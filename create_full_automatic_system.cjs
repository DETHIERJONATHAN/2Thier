const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

async function createFullAutomaticSystem() {
  try {
    console.log('🚀 CRÉATION DU SYSTÈME 100% AUTOMATIQUE\n');
    console.log('='.repeat(60));
    
    console.log('1️⃣ SUPPRESSION ANCIEN TRIGGER...');
    await prisma.$executeRaw`
      DROP TRIGGER IF EXISTS auto_create_variables_trigger ON "TreeBranchLeafSubmission";
    `;
    
    console.log('2️⃣ CRÉATION FONCTION COMPLÈTE D\'AUTO-POPULATION...');
    
    await prisma.$executeRaw`
      CREATE OR REPLACE FUNCTION auto_populate_complete_submission()
      RETURNS TRIGGER AS $$
      BEGIN
          -- 1. Créer TOUTES les variables existantes
          INSERT INTO "TreeBranchLeafSubmissionData" (
            "id",
            "submissionId", 
            "nodeId",
            "value",
            "isVariable",
            "variableKey",
            "variableDisplayName", 
            "variableUnit",
            "fieldLabel",
            "sourceRef",
            "operationDetail",
            "createdAt"
          )
          SELECT 
            var."nodeId",
            NEW.id,
            var."nodeId",
            CASE 
              WHEN node.type = 'branch' THEN
                -- Pour les SELECT, utiliser la résolution intelligente
                resolve_select_with_options(var."nodeId", NEW.id)
              ELSE
                -- Pour les champs normaux, utiliser le label
                COALESCE(node."label", 'Variable ' || var."exposedKey")
            END,
            true,
            var."exposedKey",
            var."displayName",
            var."unit",
            node."label",
            var."sourceRef",
            CASE 
              WHEN node.type = 'branch' THEN
                json_build_object(
                  'translatedValue', resolve_select_with_options(var."nodeId", NEW.id),
                  'method', 'select_intelligent',
                  'autoGenerated', true
                )
              ELSE
                json_build_object(
                  'translatedValue', '"' || var."displayName" || '" (' || COALESCE(node."label", '0') || ')',
                  'method', 'standard',
                  'autoGenerated', true
                )
            END,
            NOW()
          FROM "TreeBranchLeafNodeVariable" var
          JOIN "TreeBranchLeafNode" node ON var."nodeId" = node.id
          ON CONFLICT ("id") DO UPDATE SET
            "value" = EXCLUDED."value",
            "operationDetail" = EXCLUDED."operationDetail",
            "isVariable" = true,
            "variableKey" = EXCLUDED."variableKey",
            "variableDisplayName" = EXCLUDED."variableDisplayName";
          
          -- 2. Créer les données pour TOUS les champs avec données réelles
          INSERT INTO "TreeBranchLeafSubmissionData" (
            "id",
            "submissionId",
            "nodeId", 
            "value",
            "isVariable",
            "fieldLabel",
            "createdAt"
          )
          SELECT 
            COALESCE(existing_data."nodeId", new_data.node_id),
            NEW.id,
            COALESCE(existing_data."nodeId", new_data.node_id),
            COALESCE(existing_data."value", new_data.default_value),
            false,
            new_data.node_label,
            NOW()
          FROM (
            SELECT 
              n.id as node_id,
              n.label as node_label,
              COALESCE(n."defaultValue", '') as default_value
            FROM "TreeBranchLeafNode" n
            WHERE n."isActive" = true 
              AND n."isVisible" = true
              AND n.id NOT IN (
                SELECT "nodeId" FROM "TreeBranchLeafSubmissionData" 
                WHERE "submissionId" = NEW.id
              )
          ) new_data
          LEFT JOIN "TreeBranchLeafSubmissionData" existing_data 
            ON existing_data."nodeId" = new_data.node_id 
            AND existing_data."submissionId" = NEW.id
          ON CONFLICT ("id") DO NOTHING;
          
          RAISE NOTICE 'Auto-population complète terminée pour devis %', NEW.id;
          
          RETURN NEW;
      END;
      $$ LANGUAGE plpgsql;
    `;
    
    console.log('3️⃣ CRÉATION NOUVEAU TRIGGER COMPLET...');
    
    await prisma.$executeRaw`
      CREATE TRIGGER auto_populate_complete_trigger
          AFTER INSERT ON "TreeBranchLeafSubmission"
          FOR EACH ROW
          EXECUTE FUNCTION auto_populate_complete_submission();
    `;
    
    console.log('4️⃣ AMÉLIORATION TRIGGER DE TRADUCTION...');
    
    await prisma.$executeRaw`
      CREATE OR REPLACE FUNCTION auto_resolve_tree_branch_leaf_operations()
      RETURNS TRIGGER AS $$
      DECLARE
        node_label TEXT;
        node_type TEXT;
        var_key TEXT;
        var_display_name TEXT;
        var_unit TEXT;
        var_exists BOOLEAN := FALSE;
        resolved_value TEXT;
      BEGIN
        -- Auto-remplir fieldLabel si nodeId fourni
        IF NEW."nodeId" IS NOT NULL AND NEW."fieldLabel" IS NULL THEN
          SELECT label, type INTO node_label, node_type
          FROM "TreeBranchLeafNode"
          WHERE "id" = NEW."nodeId";
          
          IF node_label IS NOT NULL THEN
            NEW."fieldLabel" := node_label;
          END IF;
        END IF;
        
        -- Auto-remplir les informations de variables si nodeId fourni
        IF NEW."nodeId" IS NOT NULL AND (NEW."variableKey" IS NULL OR NEW."isVariable" IS NULL) THEN
          SELECT 
            v."exposedKey",
            v."displayName", 
            v."unit",
            TRUE
          INTO var_key, var_display_name, var_unit, var_exists
          FROM "TreeBranchLeafNodeVariable" v
          WHERE v."nodeId" = NEW."nodeId";
          
          IF var_exists THEN
            NEW."variableKey" := var_key;
            NEW."variableDisplayName" := var_display_name;
            NEW."variableUnit" := var_unit;
            NEW."isVariable" := TRUE;
          ELSE
            NEW."isVariable" := FALSE;
          END IF;
        END IF;
        
        -- TRADUCTION INTELLIGENTE AUTOMATIQUE
        IF NEW."isVariable" = TRUE AND (NEW."operationDetail" IS NULL OR NEW."lastResolved" IS NULL) THEN
          -- Vérifier le type de champ pour traitement spécialisé
          SELECT type INTO node_type FROM "TreeBranchLeafNode" WHERE id = NEW."nodeId";
          
          IF node_type = 'branch' THEN
            -- Champ SELECT avec options
            resolved_value := resolve_select_with_options(NEW."nodeId", NEW."submissionId");
            NEW."operationDetail" := json_build_object(
              'translatedValue', resolved_value,
              'originalValue', NEW."value",
              'method', 'select_intelligent',
              'timestamp', NOW()
            );
          ELSE
            -- Champ standard
            resolved_value := '"' || COALESCE(var_display_name, node_label) || '" (' || COALESCE(NEW."value", '0') || ')';
            NEW."operationDetail" := json_build_object(
              'translatedValue', resolved_value,
              'originalValue', NEW."value", 
              'method', 'standard',
              'timestamp', NOW()
            );
          END IF;
          
          NEW."lastResolved" := NOW();
        END IF;
        
        RETURN NEW;
      END;
      $$ LANGUAGE plpgsql;
    `;
    
    console.log('5️⃣ FONCTION DE MISE À JOUR GLOBALE...');
    
    await prisma.$executeRaw`
      CREATE OR REPLACE FUNCTION refresh_all_submissions()
      RETURNS INTEGER AS $$
      DECLARE
        submission_record RECORD;
        updated_count INTEGER := 0;
      BEGIN
        -- Mettre à jour toutes les soumissions existantes
        FOR submission_record IN 
          SELECT DISTINCT "submissionId" FROM "TreeBranchLeafSubmissionData"
        LOOP
          -- Marquer pour re-traduction
          UPDATE "TreeBranchLeafSubmissionData"
          SET "lastResolved" = NULL
          WHERE "submissionId" = submission_record."submissionId"
            AND "isVariable" = true;
          
          updated_count := updated_count + 1;
        END LOOP;
        
        RETURN updated_count;
      END;
      $$ LANGUAGE plpgsql;
    `;
    
    console.log('6️⃣ TEST DU SYSTÈME COMPLET...');
    
    // Créer un devis test pour vérifier que tout fonctionne
    const testTree = await prisma.treeBranchLeafTree.findFirst();
    
    if (testTree) {
      const testSubmission = await prisma.treeBranchLeafSubmission.create({
        data: {
          id: `auto_test_${Date.now()}`,
          treeId: testTree.id,
          status: 'draft',
          updatedAt: new Date()
        }
      });
      
      console.log(`   📝 Devis test créé: ${testSubmission.id}`);
      
      // Attendre le trigger
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Vérifier les créations
      const [variableEntries, dataEntries, selectEntries] = await Promise.all([
        prisma.treeBranchLeafSubmissionData.count({
          where: { submissionId: testSubmission.id, isVariable: true }
        }),
        prisma.treeBranchLeafSubmissionData.count({
          where: { submissionId: testSubmission.id }
        }),
        prisma.treeBranchLeafSubmissionData.findMany({
          where: { 
            submissionId: testSubmission.id,
            operationDetail: { path: ['method'], equals: 'select_intelligent' }
          },
          take: 3
        })
      ]);
      
      console.log(`   📊 Variables créées: ${variableEntries}`);
      console.log(`   📊 Données totales: ${dataEntries}`);
      console.log(`   🔽 SELECT intelligents: ${selectEntries.length}`);
      
      if (selectEntries.length > 0) {
        console.log('   🎯 Exemples SELECT résolus:');
        selectEntries.forEach((entry, i) => {
          const translated = entry.operationDetail?.translatedValue;
          console.log(`      ${i + 1}. ${translated}`);
        });
      }
      
      // Nettoyage
      await prisma.treeBranchLeafSubmission.delete({
        where: { id: testSubmission.id }
      });
      console.log('   🧹 Test nettoyé');
    }
    
    console.log('\n✅ SYSTÈME 100% AUTOMATIQUE CRÉÉ !');
    console.log('🎯 Reprend toutes les variables existantes');
    console.log('🎯 Résout intelligemment les SELECT avec options');
    console.log('🎯 Auto-population complète à chaque nouveau devis');
    console.log('🎯 Traduction automatique temps réel');
    
  } catch (error) {
    console.error('❌ Erreur:', error);
  } finally {
    await prisma.$disconnect();
  }
}

console.log('🚀 CRÉATION DU SYSTÈME AUTOMATIQUE COMPLET...\n');
createFullAutomaticSystem();