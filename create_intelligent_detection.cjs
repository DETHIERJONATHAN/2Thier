const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

async function createIntelligentDetectionSystem() {
  try {
    console.log('üß† SYST√àME DE D√âTECTION INTELLIGENTE DES √âL√âMENTS\n');
    console.log('='.repeat(60));
    
    // 1. D√âTECTION INTELLIGENTE DES SELECT AVEC OPTIONS
    console.log('\n1Ô∏è‚É£ D√âTECTION INTELLIGENTE DES SELECT:');
    console.log('-'.repeat(50));
    
    const selectAnalysis = await analyzeSelectFieldsIntelligent();
    
    // 2. D√âTECTION DES FORMULES COMPLEXES
    console.log('\n2Ô∏è‚É£ D√âTECTION DES FORMULES COMPLEXES:');
    console.log('-'.repeat(50));
    
    const formulaAnalysis = await analyzeFormulasIntelligent();
    
    // 3. D√âTECTION DES CONDITIONS COMPLEXES
    console.log('\n3Ô∏è‚É£ D√âTECTION DES CONDITIONS COMPLEXES:');
    console.log('-'.repeat(50));
    
    const conditionAnalysis = await analyzeConditionsIntelligent();
    
    // 4. D√âTECTION DES CHAMPS CACH√âS/D√âPENDANTS
    console.log('\n4Ô∏è‚É£ D√âTECTION DES CHAMPS CACH√âS:');
    console.log('-'.repeat(50));
    
    const hiddenFieldsAnalysis = await analyzeHiddenFieldsIntelligent();
    
    // 5. G√âN√âRATION AUTOMATIQUE DES VARIABLES INTELLIGENTES
    console.log('\n5Ô∏è‚É£ G√âN√âRATION AUTOMATIQUE DES VARIABLES:');
    console.log('-'.repeat(50));
    
    const autoGenerationPlan = generateAutoVariableCreationPlan(
      selectAnalysis,
      formulaAnalysis,
      conditionAnalysis,
      hiddenFieldsAnalysis
    );
    
    console.log('üìã PLAN DE G√âN√âRATION AUTOMATIQUE:');
    console.log(`   üìä Total d'√©l√©ments d√©tect√©s: ${autoGenerationPlan.totalElements}`);
    console.log(`   üÜï Nouvelles variables √† cr√©er: ${autoGenerationPlan.newVariables.length}`);
    console.log(`   üîó Relations √† √©tablir: ${autoGenerationPlan.relations.length}`);
    console.log(`   ‚öôÔ∏è  Configurations automatiques: ${autoGenerationPlan.configurations.length}`);
    
    return {
      selectAnalysis,
      formulaAnalysis,
      conditionAnalysis,
      hiddenFieldsAnalysis,
      autoGenerationPlan
    };
    
  } catch (error) {
    console.error('‚ùå Erreur dans la d√©tection intelligente:', error);
    throw error;
  }
}

async function analyzeSelectFieldsIntelligent() {
  console.log('üîΩ Analyse intelligente des champs SELECT...');
  
  // R√©cup√©rer tous les champs SELECT (type: branch)
  const selectFields = await prisma.treeBranchLeafNode.findMany({
    where: {
      type: 'branch',
      isActive: true,
      isVisible: true
    },
    select: {
      id: true,
      label: true,
      treeId: true,
      select_options: true,
      TreeBranchLeafNodeVariable: {
        select: { id: true, exposedKey: true }
      }
    }
  });
  
  const analysis = {
    totalSelect: selectFields.length,
    selectWithOptions: 0,
    optionsAnalyzed: 0,
    openedFields: [],
    missingVariables: [],
    recommendations: []
  };
  
  console.log(`   üìã Champs SELECT trouv√©s: ${selectFields.length}`);
  
  for (const selectField of selectFields) {
    console.log(`\n   üîç Analyse: "${selectField.label}"`);
    
    // Analyser les options SELECT
    if (selectField.select_options && Array.isArray(selectField.select_options)) {
      analysis.selectWithOptions++;
      
      console.log(`      üìù Options trouv√©es: ${selectField.select_options.length}`);
      
      for (const option of selectField.select_options) {
        analysis.optionsAnalyzed++;
        
        if (typeof option === 'object' && option.value && option.value.match(/^[a-f0-9-]{36}$/)) {
          // L'option pointe vers un node - v√©rifier si ce node existe
          const targetNode = await prisma.treeBranchLeafNode.findUnique({
            where: { id: option.value },
            select: {
              id: true,
              label: true,
              type: true,
              fieldType: true,
              TreeBranchLeafNodeVariable: {
                select: { id: true, exposedKey: true }
              }
            }
          });
          
          if (targetNode) {
            console.log(`         üîì Option "${option.label}" ouvre champ: "${targetNode.label}"`);
            
            analysis.openedFields.push({
              selectFieldId: selectField.id,
              selectLabel: selectField.label,
              optionLabel: option.label,
              openedFieldId: targetNode.id,
              openedFieldLabel: targetNode.label,
              openedFieldType: targetNode.type,
              hasVariable: !!targetNode.TreeBranchLeafNodeVariable
            });
            
            // Si le champ ouvert n'a pas de variable, le marquer pour cr√©ation
            if (!targetNode.TreeBranchLeafNodeVariable) {
              analysis.missingVariables.push({
                nodeId: targetNode.id,
                label: targetNode.label,
                type: targetNode.type,
                fieldType: targetNode.fieldType,
                context: `Champ ouvert par SELECT "${selectField.label}" ‚Üí option "${option.label}"`,
                priority: 'high', // Haute priorit√© car utilis√© dans SELECT
                suggestedExposedKey: generateSmartExposedKey(targetNode.label, 'select_opened'),
                sourceType: 'select_option',
                sourceRef: `select:${selectField.id}:option:${option.value}`
              });
            }
          }
        }
      }
    }
    
    // Si le SELECT lui-m√™me n'a pas de variable
    if (!selectField.TreeBranchLeafNodeVariable) {
      analysis.missingVariables.push({
        nodeId: selectField.id,
        label: selectField.label,
        type: 'branch',
        fieldType: 'select',
        context: `Champ SELECT principal`,
        priority: 'medium',
        suggestedExposedKey: generateSmartExposedKey(selectField.label, 'select'),
        sourceType: 'select_field',
        sourceRef: `select:${selectField.id}`
      });
    }
  }
  
  console.log(`\n   üìä R√âSULTATS SELECT:`);
  console.log(`      - SELECT avec options: ${analysis.selectWithOptions}`);
  console.log(`      - Options analys√©es: ${analysis.optionsAnalyzed}`);
  console.log(`      - Champs ouverts d√©tect√©s: ${analysis.openedFields.length}`);
  console.log(`      - Variables manquantes: ${analysis.missingVariables.length}`);
  
  return analysis;
}

async function analyzeFormulasIntelligent() {
  console.log('üßÆ Analyse intelligente des formules...');
  
  // R√©cup√©rer toutes les formules
  const formulas = await prisma.treeBranchLeafNodeFormula.findMany({
    include: {
      node: {
        select: {
          id: true,
          label: true,
          type: true,
          TreeBranchLeafNodeVariable: {
            select: { id: true, exposedKey: true }
          }
        }
      }
    }
  });
  
  const analysis = {
    totalFormulas: formulas.length,
    formulasWithVariables: 0,
    formulasWithoutVariables: 0,
    referencedNodes: new Set(),
    missingVariables: [],
    dependencies: []
  };
  
  console.log(`   üìã Formules trouv√©es: ${formulas.length}`);
  
  for (const formula of formulas) {
    console.log(`\n   üîç Analyse formule: "${formula.name}" sur "${formula.node.label}"`);
    
    if (formula.node.TreeBranchLeafNodeVariable) {
      analysis.formulasWithVariables++;
      console.log(`      ‚úÖ Node avec variable: ${formula.node.TreeBranchLeafNodeVariable.exposedKey}`);
    } else {
      analysis.formulasWithoutVariables++;
      console.log(`      ‚ùå Node SANS variable`);
      
      analysis.missingVariables.push({
        nodeId: formula.nodeId,
        label: formula.node.label,
        type: formula.node.type,
        context: `Champ avec formule "${formula.name}"`,
        priority: 'high',
        suggestedExposedKey: generateSmartExposedKey(formula.node.label, 'formula'),
        sourceType: 'formula',
        sourceRef: `formula:${formula.id}`,
        formulaTokens: formula.tokens
      });
    }
    
    // Analyser les tokens de la formule pour d√©tecter les d√©pendances
    if (formula.tokens && Array.isArray(formula.tokens)) {
      for (const token of formula.tokens) {
        if (typeof token === 'string' && token.startsWith('@value.')) {
          const referencedNodeId = token.replace('@value.', '');
          analysis.referencedNodes.add(referencedNodeId);
          
          // V√©rifier si le node r√©f√©renc√© a une variable
          const referencedNode = await prisma.treeBranchLeafNode.findUnique({
            where: { id: referencedNodeId },
            select: {
              id: true,
              label: true,
              TreeBranchLeafNodeVariable: {
                select: { exposedKey: true }
              }
            }
          });
          
          if (referencedNode && !referencedNode.TreeBranchLeafNodeVariable) {
            console.log(`      üîó R√©f√©rence node SANS variable: "${referencedNode.label}"`);
            
            analysis.missingVariables.push({
              nodeId: referencedNodeId,
              label: referencedNode.label,
              type: 'referenced',
              context: `Node r√©f√©renc√© par formule "${formula.name}"`,
              priority: 'high',
              suggestedExposedKey: generateSmartExposedKey(referencedNode.label, 'formula_ref'),
              sourceType: 'formula_reference',
              sourceRef: `formula_ref:${formula.id}:${referencedNodeId}`
            });
          }
          
          analysis.dependencies.push({
            formulaId: formula.id,
            formulaName: formula.name,
            referencedNodeId: referencedNodeId,
            referencedNodeLabel: referencedNode?.label || 'Node non trouv√©'
          });
        }
      }
    }
  }
  
  console.log(`\n   üìä R√âSULTATS FORMULES:`);
  console.log(`      - Formules avec variables: ${analysis.formulasWithVariables}`);
  console.log(`      - Formules sans variables: ${analysis.formulasWithoutVariables}`);
  console.log(`      - Nodes r√©f√©renc√©s: ${analysis.referencedNodes.size}`);
  console.log(`      - Variables manquantes: ${analysis.missingVariables.length}`);
  console.log(`      - D√©pendances d√©tect√©es: ${analysis.dependencies.length}`);
  
  return analysis;
}

async function analyzeConditionsIntelligent() {
  console.log('üîÄ Analyse intelligente des conditions...');
  
  const conditions = await prisma.treeBranchLeafNodeCondition.findMany({
    include: {
      node: {
        select: {
          id: true,
          label: true,
          type: true,
          TreeBranchLeafNodeVariable: {
            select: { id: true, exposedKey: true }
          }
        }
      }
    }
  });
  
  const analysis = {
    totalConditions: conditions.length,
    conditionsWithVariables: 0,
    conditionsWithoutVariables: 0,
    missingVariables: []
  };
  
  console.log(`   üìã Conditions trouv√©es: ${conditions.length}`);
  
  for (const condition of conditions) {
    console.log(`\n   üîç Analyse condition: "${condition.name}" sur "${condition.node.label}"`);
    
    if (condition.node.TreeBranchLeafNodeVariable) {
      analysis.conditionsWithVariables++;
      console.log(`      ‚úÖ Node avec variable: ${condition.node.TreeBranchLeafNodeVariable.exposedKey}`);
    } else {
      analysis.conditionsWithoutVariables++;
      console.log(`      ‚ùå Node SANS variable`);
      
      analysis.missingVariables.push({
        nodeId: condition.nodeId,
        label: condition.node.label,
        type: condition.node.type,
        context: `Champ avec condition "${condition.name}"`,
        priority: 'high',
        suggestedExposedKey: generateSmartExposedKey(condition.node.label, 'condition'),
        sourceType: 'condition',
        sourceRef: `condition:${condition.id}`,
        conditionSet: condition.conditionSet
      });
    }
  }
  
  console.log(`\n   üìä R√âSULTATS CONDITIONS:`);
  console.log(`      - Conditions avec variables: ${analysis.conditionsWithVariables}`);
  console.log(`      - Conditions sans variables: ${analysis.conditionsWithoutVariables}`);
  console.log(`      - Variables manquantes: ${analysis.missingVariables.length}`);
  
  return analysis;
}

async function analyzeHiddenFieldsIntelligent() {
  console.log('üîç Analyse intelligente des champs cach√©s...');
  
  // D√©tecter les champs qui pourraient √™tre masqu√©s ou d√©pendants
  const hiddenFields = await prisma.treeBranchLeafNode.findMany({
    where: {
      OR: [
        { isVisible: false },
        { isActive: false },
        { type: 'leaf_option_field' }, // Champs d'options souvent cach√©s
        { type: 'leaf_option' }
      ]
    },
    select: {
      id: true,
      label: true,
      type: true,
      subType: true,
      isVisible: true,
      isActive: true,
      parentId: true,
      TreeBranchLeafNodeVariable: {
        select: { id: true, exposedKey: true }
      }
    }
  });
  
  const analysis = {
    totalHiddenFields: hiddenFields.length,
    invisibleFields: 0,
    inactiveFields: 0,
    optionFields: 0,
    missingVariables: []
  };
  
  console.log(`   üìã Champs cach√©s/d√©pendants trouv√©s: ${hiddenFields.length}`);
  
  for (const field of hiddenFields) {
    if (!field.isVisible) analysis.invisibleFields++;
    if (!field.isActive) analysis.inactiveFields++;
    if (field.type.includes('option')) analysis.optionFields++;
    
    if (!field.TreeBranchLeafNodeVariable) {
      analysis.missingVariables.push({
        nodeId: field.id,
        label: field.label,
        type: field.type,
        context: `Champ cach√©/d√©pendant (visible: ${field.isVisible}, actif: ${field.isActive})`,
        priority: 'low', // Priorit√© plus basse pour les champs cach√©s
        suggestedExposedKey: generateSmartExposedKey(field.label, 'hidden'),
        sourceType: 'hidden_field',
        sourceRef: `hidden:${field.id}`,
        isVisible: field.isVisible,
        isActive: field.isActive
      });
    }
  }
  
  console.log(`\n   üìä R√âSULTATS CHAMPS CACH√âS:`);
  console.log(`      - Champs invisibles: ${analysis.invisibleFields}`);
  console.log(`      - Champs inactifs: ${analysis.inactiveFields}`);
  console.log(`      - Champs d'options: ${analysis.optionFields}`);
  console.log(`      - Variables manquantes: ${analysis.missingVariables.length}`);
  
  return analysis;
}

function generateSmartExposedKey(label, context) {
  // Nettoyer le label
  const cleanLabel = label
    .replace(/[^a-zA-Z0-9\s]/g, '') // Supprimer caract√®res sp√©ciaux
    .replace(/\s+/g, '_')           // Remplacer espaces par underscore
    .toUpperCase();
  
  // G√©n√©rer un pr√©fixe bas√© sur le contexte
  const prefixes = {
    'select': 'SEL',
    'select_opened': 'OPEN',
    'formula': 'CALC',
    'formula_ref': 'REF',
    'condition': 'COND',
    'hidden': 'HIDE'
  };
  
  const prefix = prefixes[context] || 'VAR';
  
  // Tronquer le label si trop long
  const truncatedLabel = cleanLabel.length > 20 ? cleanLabel.substring(0, 20) : cleanLabel;
  
  // Ajouter un suffixe unique bas√© sur le timestamp
  const suffix = Date.now().toString().slice(-4);
  
  return `${prefix}_${truncatedLabel}_${suffix}`;
}

function generateAutoVariableCreationPlan(selectAnalysis, formulaAnalysis, conditionAnalysis, hiddenFieldsAnalysis) {
  const plan = {
    totalElements: 0,
    newVariables: [],
    relations: [],
    configurations: []
  };
  
  // Collecter toutes les variables manquantes
  const allMissingVariables = [
    ...selectAnalysis.missingVariables,
    ...formulaAnalysis.missingVariables,
    ...conditionAnalysis.missingVariables,
    ...hiddenFieldsAnalysis.missingVariables
  ];
  
  // D√©duplication par nodeId
  const uniqueVariables = {};
  for (const variable of allMissingVariables) {
    if (!uniqueVariables[variable.nodeId]) {
      uniqueVariables[variable.nodeId] = variable;
    } else {
      // Garder la variable avec la priorit√© la plus √©lev√©e
      if (getPriorityValue(variable.priority) > getPriorityValue(uniqueVariables[variable.nodeId].priority)) {
        uniqueVariables[variable.nodeId] = variable;
      }
    }
  }
  
  plan.newVariables = Object.values(uniqueVariables);
  plan.totalElements = plan.newVariables.length;
  
  // G√©n√©rer les relations
  plan.relations = [
    ...formulaAnalysis.dependencies.map(dep => ({
      type: 'formula_dependency',
      source: dep.formulaId,
      target: dep.referencedNodeId,
      description: `Formule "${dep.formulaName}" r√©f√©rence "${dep.referencedNodeLabel}"`
    })),
    ...selectAnalysis.openedFields.map(field => ({
      type: 'select_opens_field',
      source: field.selectFieldId,
      target: field.openedFieldId,
      description: `SELECT "${field.selectLabel}" ouvre "${field.openedFieldLabel}"`
    }))
  ];
  
  // G√©n√©rer les configurations automatiques
  plan.configurations = plan.newVariables.map(variable => ({
    nodeId: variable.nodeId,
    exposedKey: variable.suggestedExposedKey,
    displayName: variable.label,
    sourceType: variable.sourceType,
    sourceRef: variable.sourceRef,
    priority: variable.priority,
    autoGenerated: true
  }));
  
  return plan;
}

function getPriorityValue(priority) {
  const values = { 'high': 3, 'medium': 2, 'low': 1 };
  return values[priority] || 1;
}

console.log('üöÄ LANCEMENT DE LA D√âTECTION INTELLIGENTE...\n');

createIntelligentDetectionSystem()
  .catch(error => {
    console.error('üí• Erreur fatale:', error);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });