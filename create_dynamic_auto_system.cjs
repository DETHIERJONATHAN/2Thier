const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

async function createDynamicAutoVariableSystem() {
  try {
    console.log('‚öôÔ∏è  SYST√àME D\'AUTO-CR√âATION DYNAMIQUE DES VARIABLES\n');
    console.log('='.repeat(60));
    
    // 1. CR√âER LA FONCTION DE D√âCOUVERTE DYNAMIQUE
    console.log('\n1Ô∏è‚É£ CR√âATION FONCTION DE D√âCOUVERTE DYNAMIQUE:');
    console.log('-'.repeat(50));
    
    await createDynamicDiscoveryFunction();
    
    // 2. CR√âER LA FONCTION D'AUTO-CR√âATION INTELLIGENTE
    console.log('\n2Ô∏è‚É£ CR√âATION FONCTION D\'AUTO-CR√âATION INTELLIGENTE:');
    console.log('-'.repeat(50));
    
    await createIntelligentAutoCreationFunction();
    
    // 3. CR√âER LE TRIGGER √âTENDU
    console.log('\n3Ô∏è‚É£ CR√âATION TRIGGER √âTENDU:');
    console.log('-'.repeat(50));
    
    await createExtendedTrigger();
    
    // 4. TESTER LE SYST√àME
    console.log('\n4Ô∏è‚É£ TEST DU SYST√àME:');
    console.log('-'.repeat(50));
    
    await testDynamicSystem();
    
    console.log('\n‚úÖ SYST√àME DYNAMIQUE CR√â√â AVEC SUCC√àS !');
    
  } catch (error) {
    console.error('‚ùå Erreur:', error);
    throw error;
  }
}

async function createDynamicDiscoveryFunction() {
  console.log('üìú Cr√©ation de la fonction de d√©couverte dynamique...');
  
  await prisma.$executeRaw`
    CREATE OR REPLACE FUNCTION discover_missing_variables()
    RETURNS TABLE(
      node_id TEXT,
      node_label TEXT,
      node_type TEXT,
      field_type TEXT,
      suggested_key TEXT,
      source_type TEXT,
      source_ref TEXT,
      priority TEXT,
      context TEXT
    ) AS $$
    DECLARE
      node_record RECORD;
      suggested_key TEXT;
      context_info TEXT;
      source_type_val TEXT;
      source_ref_val TEXT;
      priority_val TEXT;
    BEGIN
      -- D√âCOUVRIR TOUS LES CHAMPS SANS VARIABLES
      FOR node_record IN 
        SELECT n.id, n.label, n.type, n."fieldType", n."hasFormula", n."hasCondition", n."isVisible", n."isActive"
        FROM "TreeBranchLeafNode" n
        LEFT JOIN "TreeBranchLeafNodeVariable" v ON n.id = v."nodeId"
        WHERE v."nodeId" IS NULL 
          AND n."isActive" = true
          AND n."isVisible" = true
      LOOP
        -- G√âN√âRER EXPOSEDKEY INTELLIGENT
        suggested_key := 'AUTO_' || UPPER(REGEXP_REPLACE(COALESCE(node_record.label, 'VAR'), '[^a-zA-Z0-9]', '_', 'g'));
        suggested_key := LEFT(suggested_key, 40) || '_' || EXTRACT(epoch FROM NOW())::TEXT;
        
        -- D√âTERMINER LE TYPE DE SOURCE ET PRIORIT√â
        IF node_record.type = 'branch' THEN
          source_type_val := 'select_field';
          source_ref_val := 'select:' || node_record.id;
          priority_val := 'medium';
          context_info := 'Champ SELECT principal';
        ELSIF node_record."hasFormula" = true THEN
          source_type_val := 'formula_field';
          source_ref_val := 'formula_field:' || node_record.id;
          priority_val := 'high';
          context_info := 'Champ avec formules attach√©es';
        ELSIF node_record."hasCondition" = true THEN
          source_type_val := 'condition_field';
          source_ref_val := 'condition_field:' || node_record.id;
          priority_val := 'high';
          context_info := 'Champ avec conditions attach√©es';
        ELSIF node_record.type LIKE '%option%' THEN
          source_type_val := 'option_field';
          source_ref_val := 'option:' || node_record.id;
          priority_val := 'low';
          context_info := 'Champ d''option';
        ELSE
          source_type_val := 'standard_field';
          source_ref_val := 'field:' || node_record.id;
          priority_val := 'medium';
          context_info := 'Champ standard';
        END IF;
        
        -- RETOURNER LA D√âCOUVERTE
        node_id := node_record.id;
        node_label := node_record.label;
        node_type := node_record.type;
        field_type := node_record."fieldType";
        suggested_key := suggested_key;
        source_type := source_type_val;
        source_ref := source_ref_val;
        priority := priority_val;
        context := context_info;
        
        RETURN NEXT;
      END LOOP;
      
      RETURN;
    END;
    $$ LANGUAGE plpgsql;
  `;
  
  console.log('‚úÖ Fonction de d√©couverte cr√©√©e');
}

async function createIntelligentAutoCreationFunction() {
  console.log('üìú Cr√©ation de la fonction d\'auto-cr√©ation intelligente...');
  
  await prisma.$executeRaw`
    CREATE OR REPLACE FUNCTION auto_create_all_missing_variables(submission_id TEXT)
    RETURNS INTEGER AS $$
    DECLARE
      discovery_record RECORD;
      created_count INTEGER := 0;
      unique_key TEXT;
      counter INTEGER := 1;
    BEGIN
      -- UTILISER LA FONCTION DE D√âCOUVERTE
      FOR discovery_record IN 
        SELECT * FROM discover_missing_variables()
      LOOP
        -- G√âN√âRER UN EXPOSEDKEY UNIQUE
        unique_key := discovery_record.suggested_key;
        
        -- V√âRIFIER L'UNICIT√â ET AJUSTER SI N√âCESSAIRE
        WHILE EXISTS (SELECT 1 FROM "TreeBranchLeafNodeVariable" WHERE "exposedKey" = unique_key) LOOP
          unique_key := discovery_record.suggested_key || '_' || counter;
          counter := counter + 1;
        END LOOP;
        
        BEGIN
          -- CR√âER LA VARIABLE
          INSERT INTO "TreeBranchLeafNodeVariable" (
            "id",
            "nodeId",
            "exposedKey",
            "displayName",
            "displayFormat",
            "unit",
            "precision",
            "visibleToUser",
            "isReadonly",
            "sourceType",
            "sourceRef",
            "createdAt",
            "updatedAt"
          ) VALUES (
            'auto_' || discovery_record.node_id || '_' || EXTRACT(epoch FROM NOW())::TEXT,
            discovery_record.node_id,
            unique_key,
            COALESCE(discovery_record.node_label, 'Variable auto-g√©n√©r√©e'),
            CASE 
              WHEN discovery_record.field_type = 'number' THEN 'number'
              ELSE 'text'
            END,
            CASE 
              WHEN discovery_record.field_type = 'number' THEN 'unit√©'
              ELSE NULL
            END,
            CASE 
              WHEN discovery_record.field_type = 'number' THEN 2
              ELSE NULL
            END,
            true,
            false,
            discovery_record.source_type,
            discovery_record.source_ref,
            NOW(),
            NOW()
          );
          
          -- CR√âER L'ENREGISTREMENT DANS SUBMISSIONDATA
          INSERT INTO "TreeBranchLeafSubmissionData" (
            "id",
            "submissionId",
            "nodeId",
            "value",
            "isVariable",
            "variableKey",
            "variableDisplayName",
            "variableUnit",
            "fieldLabel",
            "sourceRef",
            "operationSource",
            "createdAt"
          ) VALUES (
            discovery_record.node_id,
            submission_id,
            discovery_record.node_id,
            COALESCE(discovery_record.node_label, 'Auto-g√©n√©r√©'),
            true,
            unique_key,
            COALESCE(discovery_record.node_label, 'Variable auto-g√©n√©r√©e'),
            CASE 
              WHEN discovery_record.field_type = 'number' THEN 'unit√©'
              ELSE NULL
            END,
            discovery_record.node_label,
            discovery_record.source_ref,
            CASE 
              WHEN discovery_record.source_type LIKE '%formula%' THEN 'formula'::OperationSource
              WHEN discovery_record.source_type LIKE '%condition%' THEN 'condition'::OperationSource
              ELSE NULL
            END,
            NOW()
          ) ON CONFLICT ("id") DO UPDATE SET
            "isVariable" = true,
            "variableKey" = unique_key,
            "variableDisplayName" = COALESCE(discovery_record.node_label, 'Variable auto-g√©n√©r√©e'),
            "sourceRef" = discovery_record.source_ref;
          
          created_count := created_count + 1;
          
          RAISE NOTICE 'Auto-cr√©√© variable % pour node % (%), type: %', 
            unique_key, discovery_record.node_id, discovery_record.node_label, discovery_record.source_type;
            
        EXCEPTION 
          WHEN OTHERS THEN
            RAISE NOTICE 'Erreur cr√©ation variable pour %: %', discovery_record.node_id, SQLERRM;
        END;
      END LOOP;
      
      RETURN created_count;
    END;
    $$ LANGUAGE plpgsql;
  `;
  
  console.log('‚úÖ Fonction d\'auto-cr√©ation intelligente cr√©√©e');
}

async function createExtendedTrigger() {
  console.log('üìú Cr√©ation du trigger √©tendu...');
  
  // Supprimer l'ancien trigger
  await prisma.$executeRaw`
    DROP TRIGGER IF EXISTS auto_create_variables_trigger ON "TreeBranchLeafSubmission";
  `;
  
  // Cr√©er la nouvelle fonction de trigger
  await prisma.$executeRaw`
    CREATE OR REPLACE FUNCTION auto_create_variables_then_translate()
    RETURNS TRIGGER AS $$
    DECLARE
      created_count INTEGER;
      existing_count INTEGER;
    BEGIN
      RAISE NOTICE 'TRIGGER √âTENDU: Nouveau devis cr√©√© %', NEW.id;
      
      -- 1. COMPTER LES VARIABLES EXISTANTES
      SELECT COUNT(*) INTO existing_count
      FROM "TreeBranchLeafNodeVariable";
      
      RAISE NOTICE 'Variables existantes dans le syst√®me: %', existing_count;
      
      -- 2. AUTO-D√âCOUVRIR ET CR√âER LES VARIABLES MANQUANTES
      SELECT auto_create_all_missing_variables(NEW.id) INTO created_count;
      
      RAISE NOTICE 'Variables auto-cr√©√©es: %', created_count;
      
      -- 3. CR√âER LES ENREGISTREMENTS POUR TOUTES LES VARIABLES (EXISTANTES + NOUVELLES)
      INSERT INTO "TreeBranchLeafSubmissionData" (
        "id",
        "submissionId", 
        "nodeId",
        "value",
        "isVariable",
        "variableKey",
        "variableDisplayName", 
        "variableUnit",
        "fieldLabel",
        "sourceRef",
        "createdAt"
      )
      SELECT 
        var."nodeId",
        NEW.id,
        var."nodeId",
        COALESCE(node."label", 'Variable ' || var."exposedKey"),
        true,
        var."exposedKey",
        var."displayName",
        var."unit",
        node."label",
        var."sourceRef",
        NOW()
      FROM "TreeBranchLeafNodeVariable" var
      JOIN "TreeBranchLeafNode" node ON var."nodeId" = node.id
      WHERE var."nodeId" NOT IN (
        SELECT "nodeId" 
        FROM "TreeBranchLeafSubmissionData" 
        WHERE "submissionId" = NEW.id AND "isVariable" = true
      )
      ON CONFLICT ("id") DO UPDATE SET
        "isVariable" = true,
        "variableKey" = EXCLUDED."variableKey",
        "variableDisplayName" = EXCLUDED."variableDisplayName",
        "variableUnit" = EXCLUDED."variableUnit",
        "sourceRef" = EXCLUDED."sourceRef";
      
      -- 4. MARQUER POUR TRADUCTION
      UPDATE "TreeBranchLeafSubmissionData" 
      SET "lastResolved" = NULL
      WHERE "submissionId" = NEW.id AND "isVariable" = true;
      
      RAISE NOTICE 'TRIGGER √âTENDU TERMIN√â: Devis % configur√© avec d√©couverte dynamique', NEW.id;
      
      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;
  `;
  
  // Cr√©er le nouveau trigger
  await prisma.$executeRaw`
    CREATE TRIGGER auto_create_variables_trigger
        AFTER INSERT ON "TreeBranchLeafSubmission"
        FOR EACH ROW
        EXECUTE FUNCTION auto_create_variables_then_translate();
  `;
  
  console.log('‚úÖ Trigger √©tendu cr√©√©');
}

async function testDynamicSystem() {
  console.log('üß™ Test du syst√®me dynamique...');
  
  try {
    // 1. Tester la fonction de d√©couverte
    console.log('\nüìã Test de la d√©couverte dynamique:');
    const discoveries = await prisma.$queryRaw`
      SELECT * FROM discover_missing_variables() LIMIT 10;
    `;
    
    console.log(`   üîç Variables manquantes d√©couvertes: ${discoveries.length}`);
    discoveries.forEach((discovery, i) => {
      console.log(`   ${i + 1}. ${discovery.node_label} (${discovery.node_type}) ‚Üí ${discovery.suggested_key}`);
      console.log(`      Source: ${discovery.source_type}, Priorit√©: ${discovery.priority}`);
    });
    
    // 2. Cr√©er un devis test pour d√©clencher le syst√®me
    console.log('\nüß™ Cr√©ation d\'un devis test...');
    
    const testTree = await prisma.treeBranchLeafTree.findFirst();
    if (!testTree) {
      console.log('   ‚ö†Ô∏è  Aucun arbre trouv√© pour le test');
      return;
    }
    
    const testSubmission = await prisma.treeBranchLeafSubmission.create({
      data: {
        id: `test_dynamic_${Date.now()}`,
        treeId: testTree.id,
        status: 'draft'
      }
    });
    
    console.log(`   ‚úÖ Devis test cr√©√©: ${testSubmission.id}`);
    
    // 3. V√©rifier que les variables ont √©t√© cr√©√©es
    await new Promise(resolve => setTimeout(resolve, 1000)); // Attendre le trigger
    
    const createdVariables = await prisma.treeBranchLeafSubmissionData.findMany({
      where: {
        submissionId: testSubmission.id,
        isVariable: true
      },
      select: {
        id: true,
        variableKey: true,
        variableDisplayName: true,
        sourceRef: true
      }
    });
    
    console.log(`   üìä Variables cr√©√©es automatiquement: ${createdVariables.length}`);
    createdVariables.slice(0, 5).forEach((variable, i) => {
      console.log(`   ${i + 1}. ${variable.variableKey} - "${variable.variableDisplayName}"`);
      console.log(`      Source: ${variable.sourceRef}`);
    });
    
    // 4. Nettoyer le test
    await prisma.treeBranchLeafSubmission.delete({
      where: { id: testSubmission.id }
    });
    
    console.log('   üßπ Test nettoy√©');
    
  } catch (error) {
    console.log(`   ‚ùå Erreur test: ${error.message}`);
  }
}

console.log('üöÄ CR√âATION DU SYST√àME DYNAMIQUE COMPLET...\n');

createDynamicAutoVariableSystem()
  .catch(error => {
    console.error('üí• Erreur fatale:', error);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });