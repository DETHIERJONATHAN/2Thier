/**
 * Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
 * Ã°Å¸Å½Â¯ SYSTÃƒË†ME UNIVERSEL D'INTERPRÃƒâ€°TATION DES OPÃƒâ€°RATIONS TBL
 * Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
 * 
 * Ce module permet de LIRE, COMPRENDRE, et RETRANSCRIRE n'importe quelle
 * opÃƒÂ©ration TBL (Condition, Formule, Table) de maniÃƒÂ¨re rÃƒÂ©cursive.
 * 
 * PRINCIPES FONDAMENTAUX :
 * ------------------------
 * 1. TOUT peut se mÃƒÂ©langer : Condition Ã¢â€ â€™ Formule Ã¢â€ â€™ Table Ã¢â€ â€™ Condition...
 * 2. Chaque opÃƒÂ©ration est interprÃƒÂ©tÃƒÂ©e RÃƒâ€°CURSIVEMENT
 * 3. Les donnÃƒÂ©es sont rÃƒÂ©cupÃƒÂ©rÃƒÂ©es depuis SubmissionData
 * 4. Le rÃƒÂ©sultat est retranscrit en texte humain
 * 
 * ARCHITECTURE :
 * --------------
 * - identifyReferenceType()    : Identifie le type d'une rÃƒÂ©fÃƒÂ©rence
 * - interpretReference()        : Point d'entrÃƒÂ©e rÃƒÂ©cursif universel
 * - interpretCondition()        : InterprÃƒÂ¨te une condition
 * - interpretFormula()          : InterprÃƒÂ¨te une formule
 * - interpretTable()            : InterprÃƒÂ¨te un lookup de table
 * - interpretField()            : InterprÃƒÂ¨te un champ simple
 * - evaluateVariableOperation() : Point d'entrÃƒÂ©e principal depuis l'API
 * 
 * @author System TBL
 * @version 1.0.0
 * @date 2025-01-06
 */

import { PrismaClient } from '@prisma/client';
import { evaluateExpression } from './formulaEngine.js';

function formatDebugValue(value: unknown): string {
  if (value === null || value === undefined) return 'Ã¢Ë†â€¦';
  if (typeof value === 'string') {
    return value.length > 120 ? `${value.slice(0, 117)}...` : value;
  }
  if (typeof value === 'number' || typeof value === 'boolean') {
    return String(value);
  }
  try {
    const serialized = JSON.stringify(value);
    return serialized.length > 120 ? `${serialized.slice(0, 117)}...` : serialized;
  } catch {
    return '[unserializable]';
  }
}

// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
// Ã°Å¸â€œâ€¹ TYPES ET INTERFACES
// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â

/**
 * Ã°Å¸â€œÂ¤ Structure de retour standard pour toutes les interprÃƒÂ©tations
 * 
 * Cette interface unifie le format de retour de toutes les fonctions
 * d'interprÃƒÂ©tation, garantissant cohÃƒÂ©rence et traÃƒÂ§abilitÃƒÂ©.
 */
export interface InterpretResult {
  /** Valeur calculÃƒÂ©e finale (ex: "73", "1450", "0.35") */
  result: string;
  
  /** Texte explicatif en langage humain (ex: "Si Prix > 10 Alors...") */
  humanText: string;
  
  /** Structure dÃƒÂ©taillÃƒÂ©e de l'opÃƒÂ©ration pour traÃƒÂ§abilitÃƒÂ© complÃƒÂ¨te */
  details: {
    /** Type d'opÃƒÂ©ration (condition, formula, table, field) */
    type: string;
    /** Autres propriÃƒÂ©tÃƒÂ©s spÃƒÂ©cifiques au type */
    [key: string]: any;
  };
}

/**
 * Ã°Å¸Å½Â¯ Types de rÃƒÂ©fÃƒÂ©rences possibles dans le systÃƒÂ¨me TBL
 */
type ReferenceType = 'field' | 'formula' | 'condition' | 'table' | 'value';

// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
// Ã°Å¸â€Â MODULE 1 : IDENTIFICATION DU TYPE DE RÃƒâ€°FÃƒâ€°RENCE
// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â

/**
 * Ã°Å¸â€Â Identifie le type d'une rÃƒÂ©fÃƒÂ©rence TBL
 * 
 * Cette fonction analyse une chaÃƒÂ®ne de rÃƒÂ©fÃƒÂ©rence et dÃƒÂ©termine si elle
 * pointe vers un champ, une formule, une condition ou une table.
 * 
 * FORMATS RECONNUS :
 * ------------------
 * - Formule     : "node-formula:xxx" ou "@value.node-formula:xxx"
 * - Condition   : "condition:xxx" ou "@value.condition:xxx"
 * - Table       : "node-table:xxx" ou "@table.xxx"
 * - Champ UUID  : "702d1b09-abc9-4096-9aaa-77155ac5294f"
 * - Champ gÃƒÂ©nÃƒÂ©rÃƒÂ©: "node_1757366229534_x6jxzmvmu"
 * 
 * @param ref - RÃƒÂ©fÃƒÂ©rence brute ÃƒÂ  analyser
 * @returns Type de rÃƒÂ©fÃƒÂ©rence identifiÃƒÂ©
 * 
 * @example
 * identifyReferenceType("@value.702d1b09...") Ã¢â€ â€™ 'field'
 * identifyReferenceType("node-formula:4e352467...") Ã¢â€ â€™ 'formula'
 * identifyReferenceType("condition:ff05cc48...") Ã¢â€ â€™ 'condition'
 * identifyReferenceType("@table.cmgbfpc7t...") Ã¢â€ â€™ 'table'
 */
function identifyReferenceType(ref: string): ReferenceType {
  // Ã°Å¸â€ â€¢ DÃƒâ€°TECTION RAPIDE - VÃƒÂ©rifier les prÃƒÂ©fixes AVANT de nettoyer
  // Car @value. et @table. sont des indices cruciaux du type rÃƒÂ©el
  if (ref.startsWith('@value.condition:') || ref.startsWith('@value.node-condition:')) {
    return 'condition';
  }
  if (ref.startsWith('@value.node-formula:')) {
    return 'formula';
  }
  if (ref.startsWith('@value.node-table:')) {
    return 'table';
  }
  if (ref.startsWith('@value.')) {
    return 'value'; // Ã°Å¸â€ â€¢ ReconnaÃƒÂ®tre explicitement le type 'value'
  }
  if (ref.startsWith('@table.')) {
    return 'table';
  }
  
  // Nettoyer les prÃƒÂ©fixes courants pour analyse
  const cleaned = ref
    .replace('@value.', '')
    .replace('@table.', '')
    .trim();
  
  // Ã°Å¸Â§Â® VÃƒÂ©rifier si c'est une FORMULE
  if (cleaned.startsWith('node-formula:')) {
    return 'formula';
  }
  
  // Ã°Å¸â€â‚¬ VÃƒÂ©rifier si c'est une CONDITION
  if (cleaned.startsWith('condition:') || cleaned.startsWith('node-condition:')) {
    return 'condition';
  }
  
  // Ã°Å¸â€œÅ  VÃƒÂ©rifier si c'est une TABLE
  if (cleaned.startsWith('node-table:')) {
    return 'table';
  }
  
  // Ã°Å¸â€œÂ VÃƒÂ©rifier si c'est un champ gÃƒÂ©nÃƒÂ©rÃƒÂ© automatiquement
  if (cleaned.startsWith('node_')) {
    return 'field';
  }
  
  // Ã°Å¸â€œÂ VÃƒÂ©rifier si c'est une rÃƒÂ©fÃƒÂ©rence partagÃƒÂ©e
  if (cleaned.startsWith('shared-ref-')) {
    return 'field';
  }
  
  // Ã¢Å¡Â Ã¯Â¸Â IMPORTANT: Les UUIDs nus sont ambigus - peuvent ÃƒÂªtre des fields, tables, ou conditions
  // On retourne 'field' comme dÃƒÂ©faut, mais le systÃƒÂ¨me devrait vÃƒÂ©rifier en base de donnÃƒÂ©es
  // si c'est vraiment un champ ou une table
  const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i;
  if (uuidRegex.test(cleaned)) {
    // AMÃƒâ€°LIORATION FUTURE: VÃƒÂ©rifier le type du nÃ…â€œud en base de donnÃƒÂ©es
    // Pour l'instant, retourner 'field' comme dÃƒÂ©faut
    return 'field';
  }
  
  // Par dÃƒÂ©faut, considÃƒÂ©rer comme un champ
  return 'field';
}

/**
 * Ã°Å¸â€Â Identifie le type d'un UUID ambigu en interrogeant la base de donnÃƒÂ©es
 * 
 * Cette fonction vÃƒÂ©rifie si un UUID est une condition, formule, table, ou champ
 * en interrogeant Prisma.
 * 
 * @param id - UUID ÃƒÂ  vÃƒÂ©rifier
 * @param prisma - Client Prisma
 * @returns Type de rÃƒÂ©fÃƒÂ©rence trouvÃƒÂ© ('condition' | 'formula' | 'table' | 'field')
 */
async function identifyReferenceTypeFromDB(id: string, prisma: PrismaClient): Promise<ReferenceType> {
  try {
    // Ã¢Å“â€¦ VÃƒÂ©rifier si c'est une condition
    const conditionNode = await prisma.treeBranchLeafNode.findUnique({
      where: { id },
      select: { type: true }
    });
    
    if (conditionNode) {
      if (conditionNode.type === 'condition') {
        return 'condition';
      }
      if (conditionNode.type === 'node_formula') {
        return 'formula';
      }
      if (conditionNode.type === 'node_table') {
        return 'table';
      }
      return 'field';
    }
    
    return 'field';
  } catch (error) {
    console.error(`[IDENTIFY] Ã¢ÂÅ’ Erreur lors de l'identification en BD:`, error);
    return 'field'; // DÃƒÂ©faut : considÃƒÂ©rer comme champ
  }
}

/**
 * Ã°Å¸Â§Â¹ Normalise une rÃƒÂ©fÃƒÂ©rence en enlevant les prÃƒÂ©fixes
 * 
 * Cette fonction nettoie une rÃƒÂ©fÃƒÂ©rence pour obtenir l'ID pur utilisable
 * dans les requÃƒÂªtes Prisma.
 * 
 * @param ref - RÃƒÂ©fÃƒÂ©rence ÃƒÂ  normaliser
 * @returns ID normalisÃƒÂ©
 * 
 * @example
 * normalizeRef("@value.702d1b09...") Ã¢â€ â€™ "702d1b09..."
 * normalizeRef("node-formula:4e352467...") Ã¢â€ â€™ "4e352467..."
 * normalizeRef("condition:ff05cc48...") Ã¢â€ â€™ "ff05cc48..."
 */
function normalizeRef(ref: string): string {
  return ref
    .replace('@value.', '')
    .replace('@table.', '')
    .replace('node-formula:', '')
    .replace('node-table:', '')
    .replace('node-condition:', '')
    .replace('condition:', '')
    .trim();
}

// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
// Ã°Å¸â€œÅ  MODULE 2 : RÃƒâ€°CUPÃƒâ€°RATION DES DONNÃƒâ€°ES
// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â

/**
 * Ã°Å¸â€œÅ  ENRICHISSEMENT MASSIF - Charge TOUTES les valeurs et labels d'une soumission
 * 
 * Cette fonction effectue une rÃƒÂ©cupÃƒÂ©ration massive depuis la base de donnÃƒÂ©es :
 * 1. RÃƒÂ©cupÃƒÂ¨re TOUTES les valeurs depuis TreeBranchLeafSubmissionData
 * 2. RÃƒÂ©cupÃƒÂ¨re TOUS les labels depuis TreeBranchLeafNode (pour tout l'arbre)
 * 3. Remplit les Maps valueMap et labelMap pour accÃƒÂ¨s rapide
 * 
 * IMPORTANT : Cette fonction ENRICHIT les Maps existantes (ne les remplace pas)
 * 
 * @param submissionId - ID de la soumission
 * @param prisma - Instance Prisma Client
 * @param valueMap - Map des valeurs ÃƒÂ  enrichir
 * @param labelMap - Map des labels ÃƒÂ  enrichir
 * @param treeId - ID de l'arbre (optionnel, sera dÃƒÂ©tectÃƒÂ© automatiquement)
 */
async function enrichDataFromSubmission(
  submissionId: string,
  prisma: PrismaClient,
  valueMap: Map<string, unknown>,
  labelMap: Map<string, string>,
  treeId?: string
): Promise<void> {
  
  try {
    // 1. RÃƒÂ©cupÃƒÂ©rer les VALEURS depuis TreeBranchLeafSubmissionData
    const submissionData = await prisma.treeBranchLeafSubmissionData.findMany({
      where: { submissionId },
      select: { 
        nodeId: true, 
        value: true
      }
    });
    
    
    // 2. Trouver l'arbre de cette soumission si pas fourni
    if (!treeId) {
      const firstSubmissionNode = await prisma.treeBranchLeafSubmissionData.findFirst({
        where: { submissionId },
        include: { TreeBranchLeafNode: { select: { treeId: true } } }
      });
      treeId = firstSubmissionNode?.TreeBranchLeafNode?.treeId;
    }
    
    if (treeId) {
      // 3. RÃƒÂ©cupÃƒÂ©rer TOUS les labels ET calculatedValue de l'arbre
      // Ã°Å¸â€Â¥ AJOUT: calculatedValue pour les variables calculÃƒÂ©es (ex: Rampant toiture-1)
      const allNodes = await prisma.treeBranchLeafNode.findMany({
        where: { treeId },
        select: { 
          id: true, 
          label: true,
          sharedReferenceName: true,
          field_label: true,
          calculatedValue: true  // Ã°Å¸â€ â€¢ RÃƒÂ©cupÃƒÂ©rer les valeurs calculÃƒÂ©es
        }
      });
      
      
      // 4. ENRICHIR LABELMAP avec prioritÃƒÂ© pour cohÃƒÂ©rence
      // Ã°Å¸â€Â¥ ORDRE DE PRIORITÃƒâ€°: sharedReferenceName > field_label > label (mÃƒÂªme logique que getNodeLabel)
      for (const node of allNodes) {
        if (!labelMap.has(node.id)) {
          const canonicalLabel = node.sharedReferenceName || node.field_label || node.label;
          labelMap.set(node.id, canonicalLabel);
        }
        
        // Ã°Å¸â€ â€¢ ENRICHIR VALUEMAP avec calculatedValue si prÃƒÂ©sent et pas dÃƒÂ©jÃƒÂ  dans valueMap
        // Ceci permet aux formules copiÃƒÂ©es (ex: MAX paysage-1) d'accÃƒÂ©der aux valeurs 
        // des variables calculÃƒÂ©es (ex: Rampant toiture-1)
        if (!valueMap.has(node.id) && node.calculatedValue !== null && node.calculatedValue !== undefined && node.calculatedValue !== '') {
          valueMap.set(node.id, node.calculatedValue);
        }
      }
    } else {
      // Mode preview - pas d'avertissement
    }
    
    // 5. ENRICHIR VALUEMAP avec SubmissionData (prioritÃƒÂ© sur calculatedValue)
    for (const data of submissionData) {
      if (data.nodeId && data.value !== null) {
        // Ãƒâ€°craser calculatedValue avec la valeur soumise si prÃƒÂ©sente
        let parsedValue: unknown;
        try {
          parsedValue = typeof data.value === 'string' ? JSON.parse(data.value) : data.value;
        } catch {
          parsedValue = data.value;
        }
        valueMap.set(data.nodeId, parsedValue);
      }
    }
    
    
  } catch (error) {
    console.error(`[ENRICHMENT] Ã¢ÂÅ’ Erreur enrichissement:`, error);
  }
}

/**
 * Ã°Å¸â€œÅ  RÃƒÂ©cupÃƒÂ¨re la valeur d'un nÃ…â€œud depuis valueMap (avec fallback DB)
 * 
 * Cette fonction interroge d'abord le valueMap (mode preview ou cache enrichi),
 * puis fait un fallback vers TreeBranchLeafSubmissionData si nÃƒÂ©cessaire.
 * 
 * Ã¢Å¡â„¢Ã¯Â¸Â OPTIONS :
 * - `preserveEmpty=true` Ã¢â€ â€™ retourne `null` si aucune donnÃƒÂ©e rÃƒÂ©elle n'existe
 *   (utile pour les opÃƒÂ©rateurs `isEmpty` / `isNotEmpty`).
 * - Par dÃƒÂ©faut, la fonction continue de retourner "0" pour ÃƒÂ©viter de casser
 *   les formules numÃƒÂ©riques lorsqu'une valeur manque.
 * 
 * @param nodeId - ID du nÃ…â€œud ÃƒÂ  rÃƒÂ©cupÃƒÂ©rer
 * @param submissionId - ID de la soumission en cours
 * @param prisma - Instance Prisma Client
 * @param valueMap - Map des valeurs (dÃƒÂ©jÃƒÂ  enrichie par enrichDataFromSubmission)
 * @returns Valeur du nÃ…â€œud ou "0" si non trouvÃƒÂ©e
 * 
 * @example
 * await getNodeValue("702d1b09...", "tbl-1759750447813...", prisma, valueMap)
 * Ã¢â€ â€™ "1450" (si prÃƒÂ©sent) ou "0" (si absent)
 */
interface GetNodeValueOptions {
  /**
   * Lorsque true, la fonction retournera null/undefined si aucune donnÃƒÂ©e n'existe
   * rÃƒÂ©ellement, au lieu de forcer la valeur de secours "0".
   */
  preserveEmpty?: boolean;
}

async function getNodeValue(
  nodeId: string,
  submissionId: string,
  prisma: PrismaClient,
  valueMap?: Map<string, unknown>,
  options?: GetNodeValueOptions
): Promise<string | null> {
  // Ã°Å¸Å½Â¯ PRIORITÃƒâ€° 1: VÃƒÂ©rifier dans valueMap si fourni
  if (valueMap && valueMap.has(nodeId)) {
    const val = valueMap.get(nodeId);
    if (val === null || val === undefined) {
      return options?.preserveEmpty ? null : "0";
    }
    return String(val);
  }

  
  // Ã°Å¸Å½Â¯ PRIORITÃƒâ€° 2: RequÃƒÂªte Prisma pour rÃƒÂ©cupÃƒÂ©rer depuis TreeBranchLeafSubmissionData
  const data = await prisma.treeBranchLeafSubmissionData.findFirst({
    where: {
      nodeId,
      submissionId
    },
    select: {
      value: true
    }
  });

  if (data?.value !== null && data?.value !== undefined) {
    return String(data.value);
  }
  
  // Ã°Å¸Å½Â¯ PRIORITÃƒâ€° 3 (NOUVEAU): RÃƒÂ©cupÃƒÂ©rer depuis TreeBranchLeafNode.calculatedValue
  // Ceci permet de rÃƒÂ©cupÃƒÂ©rer les valeurs calculÃƒÂ©es d'autres formules (ex: Mur, Mur-1)
  // mÃƒÂªme si elles ne sont pas dans le valueMap ou SubmissionData
  const node = await prisma.treeBranchLeafNode.findUnique({
    where: { id: nodeId },
    select: { calculatedValue: true, label: true }
  });

  if (node?.calculatedValue !== null && node?.calculatedValue !== undefined && node?.calculatedValue !== '') {
    return String(node.calculatedValue);
  }

  
  // Retourner "0" par dÃƒÂ©faut si aucune valeur trouvÃƒÂ©e
  return options?.preserveEmpty ? null : "0";
}

/**
 * Ã°Å¸ÂÂ·Ã¯Â¸Â RÃƒÂ©cupÃƒÂ¨re le label depuis labelMap (avec fallback DB)
 * 
 * Cette fonction rÃƒÂ©cupÃƒÂ¨re d'abord le label depuis labelMap (cache enrichi),
 * puis fait un fallback vers TreeBranchLeafNode si nÃƒÂ©cessaire.
 * 
 * Ã°Å¸â€Â¥ COHÃƒâ€°RENCE: Utilise sharedReferenceName > label > field_label pour 
 * garantir que les variables utilisent exactement le mÃƒÂªme libellÃƒÂ© que l'original.
 * 
 * @param nodeId - ID du nÃ…â€œud
 * @param prisma - Instance Prisma Client
 * @param labelMap - Map des labels (dÃƒÂ©jÃƒÂ  enrichie par enrichDataFromSubmission)
 * @returns Label du nÃ…â€œud ou "Inconnu" si non trouvÃƒÂ©
 * 
 * @example
 * await getNodeLabel("702d1b09...", prisma, labelMap) Ã¢â€ â€™ "Prix Kw/h"
 */
async function getNodeLabel(
  nodeId: string,
  prisma: PrismaClient,
  labelMap?: Map<string, string>
): Promise<string> {
  // Ã°Å¸Å½Â¯ PRIORITÃƒâ€° 1: VÃƒÂ©rifier dans labelMap si fourni
  if (labelMap && labelMap.has(nodeId)) {
    const label = labelMap.get(nodeId);
    return label || 'Inconnu';
  }
  
  // Ã°Å¸Å½Â¯ PRIORITÃƒâ€° 2: RequÃƒÂªte Prisma (fallback) avec plus de champs pour cohÃƒÂ©rence
  // Ã°Å¸â€Â¥ COHÃƒâ€°RENCE: RÃƒÂ©cupÃƒÂ©rer sharedReferenceName et field_label pour utiliser le mÃƒÂªme libellÃƒÂ© que l'original
  const node = await prisma.treeBranchLeafNode.findUnique({
    where: { id: nodeId },
    select: { 
      label: true,
      sharedReferenceName: true,
      field_label: true
    }
  });
  
  // Ã°Å¸â€Â¥ ORDRE DE PRIORITÃƒâ€° pour cohÃƒÂ©rence avec les champs originaux:
  // 1. sharedReferenceName (si dÃƒÂ©fini, c'est le nom canonique de la rÃƒÂ©fÃƒÂ©rence)
  // 2. field_label (libellÃƒÂ© personnalisÃƒÂ© du champ)
  // 3. label (libellÃƒÂ© standard)
  return node?.sharedReferenceName || node?.field_label || node?.label || 'Inconnu';
}

// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
// Ã°Å¸â€â€ž MODULE 3 : INTERPRÃƒâ€°TATION RÃƒâ€°CURSIVE UNIVERSELLE
// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â

/**
 * Ã°Å¸â€â€ž FONCTION RÃƒâ€°CURSIVE UNIVERSELLE - CÃ…â€™UR DU SYSTÃƒË†ME
 * 
 * C'est LA fonction centrale qui interprÃƒÂ¨te n'importe quelle rÃƒÂ©fÃƒÂ©rence TBL.
 * Elle agit comme un dispatcher intelligent qui :
 * 
 * 1. Ã°Å¸â€Â Identifie le type de la rÃƒÂ©fÃƒÂ©rence
 * 2. Ã°Å¸Å½Â¯ VÃƒÂ©rifie si dÃƒÂ©jÃƒÂ  calculÃƒÂ©e (cache)
 * 3. Ã°Å¸Å½Â¬ DÃƒÂ©lÃƒÂ¨gue ÃƒÂ  l'interprÃƒÂ©teur appropriÃƒÂ©
 * 4. Ã°Å¸â€™Â¾ Met en cache le rÃƒÂ©sultat
 * 5. Ã°Å¸â€œÂ¤ Retourne le rÃƒÂ©sultat structurÃƒÂ©
 * 
 * RÃƒâ€°CURSIVITÃƒâ€° :
 * -------------
 * Cette fonction s'appelle elle-mÃƒÂªme indirectement via les interprÃƒÂ©teurs
 * spÃƒÂ©cifiques (interpretCondition, interpretFormula, etc.), permettant
 * de rÃƒÂ©soudre des structures imbriquÃƒÂ©es infiniment complexes.
 * 
 * PROTECTION :
 * ------------
 * - Limite de profondeur (depth > 10) pour ÃƒÂ©viter boucles infinies
 * - Cache (valuesCache) pour ÃƒÂ©viter recalculs multiples
 * 
 * @param ref - RÃƒÂ©fÃƒÂ©rence ÃƒÂ  interprÃƒÂ©ter (peut ÃƒÂªtre n'importe quel format)
 * @param submissionId - ID de la soumission en cours
 * @param prisma - Instance Prisma Client
 * @param valuesCache - Cache des valeurs dÃƒÂ©jÃƒÂ  calculÃƒÂ©es (ÃƒÂ©vite boucles)
 * @param depth - Profondeur de rÃƒÂ©cursion actuelle (protection)
 * @param valueMap - Map des valeurs (mode preview ou enrichie)
 * @param labelMap - Map des labels (enrichie automatiquement)
 * @returns RÃƒÂ©sultat interprÃƒÂ©tÃƒÂ© avec valeur, texte et dÃƒÂ©tails
 * 
 * @example
 * // Cas simple : champ
 * await interpretReference("702d1b09...", "tbl-xxx", prisma)
 * Ã¢â€ â€™ { result: "1450", humanText: "Prix Kw/h(1450)", details: {...} }
 * 
 * // Cas complexe : condition qui contient une formule
 * await interpretReference("condition:ff05cc48...", "tbl-xxx", prisma)
 * Ã¢â€ â€™ RÃƒÂ©sout rÃƒÂ©cursivement toute la structure
 */
async function interpretReference(
  ref: string,
  submissionId: string,
  prisma: PrismaClient,
  valuesCache: Map<string, InterpretResult> = new Map(),
  depth: number = 0,
  valueMap?: Map<string, unknown>,
  labelMap?: Map<string, string>,
  knownType?: ReferenceType  // Ã°Å¸â€ â€¢ Type connu du contexte (p.ex. 'table' depuis @table.xxx)
): Promise<InterpretResult> {
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€ºÂ¡Ã¯Â¸Â Ãƒâ€°TAPE 1 : Protection contre rÃƒÂ©cursion infinie
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  if (depth > 10) {
    console.error(`[INTERPRÃƒâ€°TATION] Ã¢ÂÅ’ RÃƒÂ©cursion trop profonde (depth=${depth}) pour ref:`, ref);
    return {
      result: 'Ã¢Ë†â€¦',
      humanText: 'Ã¢Å¡Â Ã¯Â¸Â RÃƒÂ©cursion trop profonde',
      details: {
        type: 'error',
        error: 'Max depth exceeded',
        depth
      }
    };
  }
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸Å½Â¯ Ãƒâ€°TAPE 2 : VÃƒÂ©rifier le cache
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const cleanRef = normalizeRef(ref);
  
  if (valuesCache.has(cleanRef)) {
    return valuesCache.get(cleanRef)!;
  }
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€Â Ãƒâ€°TAPE 3 : Identifier le type de rÃƒÂ©fÃƒÂ©rence
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€ â€¢ Si le type est connu du contexte (p.ex. @table.xxx), l'utiliser en prioritÃƒÂ©
  let type = knownType || identifyReferenceType(ref);
  
  // Ã°Å¸â€Â Si c'est un UUID ambigu (pas de prÃƒÂ©fixe), vÃƒÂ©rifier en BD
  const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i;
  
  if (type === 'field' && uuidRegex.test(cleanRef)) {
    type = await identifyReferenceTypeFromDB(cleanRef, prisma);
  }
  
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸Å½Â¬ Ãƒâ€°TAPE 4 : DÃƒÂ©lÃƒÂ©guer ÃƒÂ  l'interprÃƒÂ©teur appropriÃƒÂ©
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  let result: InterpretResult;
  
  try {
    switch (type) {
      case 'condition':
        result = await interpretCondition(cleanRef, submissionId, prisma, valuesCache, depth, valueMap, labelMap);
        break;
      
      case 'formula':
        result = await interpretFormula(cleanRef, submissionId, prisma, valuesCache, depth, valueMap, labelMap);
        break;
      
      case 'table':
        result = await interpretTable(cleanRef, submissionId, prisma, valuesCache, depth, valueMap, labelMap);
        break;
      
      case 'value':
      case 'field':
        result = await interpretField(cleanRef, submissionId, prisma, valueMap, labelMap);
        break;
      
      default:
        console.error(`[INTERPRÃƒâ€°TATION] Ã¢ÂÅ’ Type inconnu: ${type}`);
        result = {
          result: 'Ã¢Ë†â€¦',
          humanText: `Type inconnu: ${type}`,
          details: { type: 'error', error: 'Unknown type' }
        };
    }
  } catch (error) {
    // Gestion des erreurs d'interprÃƒÂ©tation
    console.error(`[INTERPRÃƒâ€°TATION] Ã¢ÂÅ’ Erreur lors de l'interprÃƒÂ©tation:`, error);
    result = {
      result: 'Ã¢Ë†â€¦',
      humanText: `Erreur: ${error instanceof Error ? error.message : 'Inconnue'}`,
      details: {
        type: 'error',
        error: error instanceof Error ? error.message : String(error)
      }
    };
  }
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€™Â¾ Ãƒâ€°TAPE 5 : Mettre en cache le rÃƒÂ©sultat
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  valuesCache.set(cleanRef, result);
  
  return result;
}

// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
// Ã°Å¸â€â‚¬ MODULE 4 : INTERPRÃƒâ€°TATION DES CONDITIONS
// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â

/**
 * Ã°Å¸â€â‚¬ INTERPRÃƒË†TE UNE CONDITION (Si...Alors...Sinon)
 * 
 * Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
 * Ã°Å¸Å½Â¯ FONCTIONNEMENT CLÃƒâ€°S :
 * Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
 * Cette fonction ÃƒÂ©value une condition logique ET INTERPRÃƒË†TE LES DEUX BRANCHES
 * (ALORS + SINON) pour fournir un rÃƒÂ©sultat complet et transparent.
 * 
 * Ã¢Å¡Â Ã¯Â¸Â DIFFÃƒâ€°RENCE AVEC L'ANCIENNE VERSION :
 * ----------------------------------------
 * AVANT : On interprÃƒÂ©tait SEULEMENT la branche sÃƒÂ©lectionnÃƒÂ©e
 *         Ã¢â€ â€™ Texte incomplet : "Si X; ALORS: Y = result"
 * 
 * MAINTENANT : On interprÃƒÂ¨te LES DEUX branches systÃƒÂ©matiquement
 *              Ã¢â€ â€™ Texte complet : "Si X; ALORS: Y = result1; SINON: Z = result2 Ã¢â€ â€™ [ALORS SÃƒâ€°LECTIONNÃƒâ€°]"
 * 
 * Ã°Å¸â€œÅ  EXEMPLE CONCRET :
 * --------------------
 * Condition : Si "Prix Kw/h" est vide
 * ALORS : Calcul automatique = 1250 / 5000 = 0.25
 * SINON : Utiliser la valeur saisie = Prix Kw/h
 * 
 * RÃƒÂ©sultat affichÃƒÂ© :
 * "Si Prix Kw/h(Ã¢Ë†â€¦) est vide; 
 *  ALORS: Calcul du prix Kw/h(1250)/Consommation(5000) = 0.25; 
 *  SINON: Prix Kw/h(150) = 150 
 *  Ã¢â€ â€™ [ALORS SÃƒâ€°LECTIONNÃƒâ€°] Result = 0.25"
 * 
 * Ã°Å¸â€â€ž PROCESSUS DÃƒâ€°TAILLÃƒâ€° :
 * -----------------------
 * 1. Ã°Å¸â€œÂ¥ RÃƒÂ©cupÃƒÂ©rer la condition depuis TreeBranchLeafNodeCondition
 * 2. Ã°Å¸â€Â Extraire le WHEN (left op right)
 * 3. Ã°Å¸â€œÅ  RÃƒÂ©cupÃƒÂ©rer les valeurs LEFT et RIGHT
 *    - LEFT : Valeur du champ testÃƒÂ© (ex: Prix Kw/h)
 *    - RIGHT : Valeur de comparaison (fixe ou rÃƒÂ©fÃƒÂ©rence)
 * 4. Ã¢Å¡â€“Ã¯Â¸Â Ãƒâ€°valuer l'opÃƒÂ©rateur (isEmpty, eq, gt, etc.)
 * 5. Ã°Å¸Å½Â¯ DÃƒÂ©terminer quelle branche est vraie (ALORS ou SINON)
 * 6. Ã°Å¸â€â€ž **INTERPRÃƒâ€°TER LES DEUX BRANCHES** (nouvelle logique)
 *    - InterprÃƒÂ©ter la branche ALORS (peut ÃƒÂªtre formule/table/champ/condition)
 *    - InterprÃƒÂ©ter la branche SINON (idem)
 * 7. Ã°Å¸â€œÂ Construire le texte humain COMPLET avec les deux rÃƒÂ©sultats
 * 8. Ã°Å¸â€œÂ¤ Retourner le rÃƒÂ©sultat de la branche sÃƒÂ©lectionnÃƒÂ©e + texte explicatif
 * 
 * Ã°Å¸Ââ€”Ã¯Â¸Â STRUCTURE D'UNE CONDITION :
 * -------------------------------
 * {
 *   branches: [{
 *     when: { 
 *       op: "isEmpty",               // OpÃƒÂ©rateur : isEmpty, eq, gt, etc.
 *       left: {ref: "@value.xxx"}    // RÃƒÂ©fÃƒÂ©rence au champ testÃƒÂ©
 *     },
 *     actions: [{ 
 *       type: "SHOW", 
 *       nodeIds: ["node-formula:yyy"] // Action si condition VRAIE
 *     }]
 *   }],
 *   fallback: {
 *     actions: [{ 
 *       type: "SHOW", 
 *       nodeIds: ["zzz"]              // Action si condition FAUSSE
 *     }]
 *   }
 * }
 * 
 * Ã°Å¸Å½Â¨ FORMAT DU TEXTE GÃƒâ€°NÃƒâ€°RÃƒâ€° :
 * ---------------------------
 * "Si {condition}; ALORS: {texte_alors}; SINON: {texte_sinon} Ã¢â€ â€™ [{branche} SÃƒâ€°LECTIONNÃƒâ€°] Result = {rÃƒÂ©sultat}"
 * 
 * Note: Les humanText des branches contiennent dÃƒÂ©jÃƒÂ  leur rÃƒÂ©sultat
 *       (ex: "expression = 0.25"), donc on ne rajoute PAS "= result" aprÃƒÂ¨s !
 * 
 * Ã°Å¸â€œÂ¦ RETOUR :
 * -----------
 * {
 *   result: "0.25",                    // RÃƒÂ©sultat de la branche sÃƒÂ©lectionnÃƒÂ©e
 *   humanText: "Si ... ALORS: ... SINON: ... Ã¢â€ â€™ [ALORS SÃƒâ€°LECTIONNÃƒâ€°]",
 *   details: {
 *     type: 'condition',
 *     conditionId: "...",
 *     branchUsed: "ALORS",             // Branche qui a ÃƒÂ©tÃƒÂ© utilisÃƒÂ©e
 *     alorsResult: {...},              // DÃƒÂ©tails du rÃƒÂ©sultat ALORS
 *     sinonResult: {...},              // DÃƒÂ©tails du rÃƒÂ©sultat SINON
 *     selectedResult: {...}            // DÃƒÂ©tails du rÃƒÂ©sultat sÃƒÂ©lectionnÃƒÂ©
 *   }
 * }
 * 
 * @param conditionId - ID de la condition (avec ou sans prÃƒÂ©fixe "condition:")
 * @param submissionId - ID de la soumission (ou "preview-xxx" en mode aperÃƒÂ§u)
 * @param prisma - Instance Prisma Client pour accÃƒÂ¨s BDD
 * @param valuesCache - Cache des valeurs dÃƒÂ©jÃƒÂ  calculÃƒÂ©es (ÃƒÂ©vite recalculs)
 * @param depth - Profondeur de rÃƒÂ©cursion (protection contre boucles infinies)
 * @param valueMap - Map optionnelle des valeurs en preview (clÃƒÂ©=nodeId, valeur=valeur)
 * @param labelMap - Map optionnelle des labels (clÃƒÂ©=nodeId, valeur=label)
 * @returns RÃƒÂ©sultat interprÃƒÂ©tÃƒÂ© avec les deux branches ÃƒÂ©valuÃƒÂ©es
 */
async function interpretCondition(
  conditionId: string,
  submissionId: string,
  prisma: PrismaClient,
  valuesCache: Map<string, InterpretResult>,
  depth: number,
  valueMap?: Map<string, unknown>,
  labelMap?: Map<string, string>
): Promise<InterpretResult> {
  
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€œÂ¥ Ãƒâ€°TAPE 1 : RÃƒÂ©cupÃƒÂ©rer la condition depuis la base de donnÃƒÂ©es
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const cleanId = conditionId.replace('condition:', '');
  
  const condition = await prisma.treeBranchLeafNodeCondition.findUnique({
    where: { id: cleanId },
    select: {
      id: true,
      name: true,
      conditionSet: true,
      nodeId: true
    }
  });
  
  if (!condition) {
    // Log supprim
    return {
      result: 'Ã¢Ë†â€¦',
      humanText: `Condition introuvable: ${conditionId}`,
      details: { type: 'condition', error: 'Not found' }
    };
  }
  
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€Â Ãƒâ€°TAPE 2 : Extraire la structure WHEN et les branches
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const condSet = condition.conditionSet as any;
  const branch = condSet.branches?.[0];
  const when = branch?.when;
  
  if (!when) {
    // Log supprim
    return {
      result: 'Ã¢Ë†â€¦',
      humanText: 'Structure condition invalide',
      details: { type: 'condition', error: 'Missing WHEN' }
    };
  }
  
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€œÅ  Ãƒâ€°TAPE 3 : RÃƒÂ©cupÃƒÂ©rer la valeur LEFT (cÃƒÂ´tÃƒÂ© gauche de la condition)
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const resolveOperandReference = async (ref: string | undefined): Promise<{ value: string | null; label: string }> => {
    if (!ref) {
      return { value: null, label: 'Inconnu' };
    }

    // Ã°Å¸â€ â€¢ GESTION SPÃƒâ€°CIALE pour @select.xxx
    // Pour les options de select, on veut rÃƒÂ©cupÃƒÂ©rer le LABEL de l'option (ex: "Portrait")
    // pas sa valeur (qui est souvent null ou l'ID)
    if (ref.startsWith('@select.')) {
      const optionNodeId = ref.slice('@select.'.length).split('.')[0];
      
      // RÃƒÂ©cupÃƒÂ©rer le noeud d'option pour obtenir son label
      const optionNode = await prisma.treeBranchLeafNode.findUnique({
        where: { id: optionNodeId },
        select: { id: true, label: true, parentId: true }
      });
      
      if (optionNode) {
        // Pour une option, la "valeur" ÃƒÂ  comparer est son ID (car c'est ce qui est stockÃƒÂ© dans la soumission)
        // et le label est le texte affichÃƒÂ©
        return { value: optionNode.id, label: optionNode.label };
      }
      
      // Log supprim
      return { value: optionNodeId, label: 'Option inconnue' };
    }

    const operandType = identifyReferenceType(ref);
    if (operandType === 'field' || operandType === 'value') {
      const operandId = normalizeRef(ref);
      const value = await getNodeValue(operandId, submissionId, prisma, valueMap, { preserveEmpty: true });
      const label = await getNodeLabel(operandId, prisma, labelMap);
      return { value, label };
    }

    const interpreted = await interpretReference(
      ref,
      submissionId,
      prisma,
      valuesCache,
      depth + 1,
      valueMap,
      labelMap,
      operandType
    );

    const labelFromDetails = interpreted.details?.conditionName
      || interpreted.details?.formulaName
      || interpreted.details?.tableName
      || interpreted.details?.label
      || interpreted.details?.name
      || `RÃƒÂ©fÃƒÂ©rence ${operandType}`;

    return {
      value: interpreted.result,
      label: labelFromDetails
    };
  };

  const leftRef = when.left?.ref;
  let leftValue: string | null = null;
  let leftLabel = 'Inconnu';

  if (leftRef) {
    const leftInfo = await resolveOperandReference(leftRef);
    leftValue = leftInfo.value;
    leftLabel = leftInfo.label;
  }
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€œÅ  Ãƒâ€°TAPE 4 : RÃƒÂ©cupÃƒÂ©rer la valeur RIGHT (cÃƒÂ´tÃƒÂ© droit de la condition)
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const rightRef = when.right?.ref;
  let rightValue: string | null = null;
  let rightLabel = 'Inconnu';
  
  if (rightRef) {
    const rightInfo = await resolveOperandReference(rightRef);
    rightValue = rightInfo.value;
    rightLabel = rightInfo.label;
  } else if (when.right?.value !== undefined) {
    // C'est une valeur fixe
    rightValue = String(when.right.value);
    rightLabel = rightValue;
  }
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã¢Å¡â€“Ã¯Â¸Â Ãƒâ€°TAPE 5 : Ãƒâ€°valuer l'opÃƒÂ©rateur
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const operator = when.op;
  const conditionMet = evaluateOperator(operator, leftValue, rightValue);
  
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸Å½Â¯ Ãƒâ€°TAPE 6 : DÃƒÂ©terminer quelle branche est vraie
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const _selectedBranch = conditionMet ? branch : condSet.fallback;
  const branchName = conditionMet ? 'ALORS' : 'SINON';
  
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€â€ž Ãƒâ€°TAPE 7 : InterprÃƒÂ©ter LES DEUX BRANCHES (ALORS + SINON)
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  
  // Ã°Å¸â€œÅ’ InterprÃƒÂ©ter la branche ALORS
  let alorsResult: InterpretResult = { result: 'Ã¢Ë†â€¦', humanText: 'Aucune action' };
  
  if (branch && branch.actions && branch.actions.length > 0) {
    const alorsAction = branch.actions[0];
    const alorsNodeId = alorsAction.nodeIds?.[0];
    
    if (alorsNodeId) {
      alorsResult = await interpretReference(
        alorsNodeId,
        submissionId,
        prisma,
        valuesCache,
        depth + 1,
        valueMap,
        labelMap
      );
    }
  }
  
  // Ã°Å¸â€œÅ’ InterprÃƒÂ©ter la branche SINON
  let sinonResult: InterpretResult = { result: 'Ã¢Ë†â€¦', humanText: 'Aucune action' };
  
  if (condSet.fallback && condSet.fallback.actions && condSet.fallback.actions.length > 0) {
    const sinonAction = condSet.fallback.actions[0];
    const sinonNodeId = sinonAction.nodeIds?.[0];
    
    if (sinonNodeId) {
      sinonResult = await interpretReference(
        sinonNodeId,
        submissionId,
        prisma,
        valuesCache,
        depth + 1,
        valueMap,
        labelMap
      );
    }
  }
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€œÂ Ãƒâ€°TAPE 8 : Construire le texte humain COMPLET (les 2 branches)
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const operatorText = getOperatorText(operator);
  const leftDisplay = `${leftLabel}(${leftValue || 'Ã¢Ë†â€¦'})`;
  const rightDisplay = rightLabel !== 'Inconnu' ? `${rightLabel}` : '';
  
  // Construction de la condition
  const conditionText = rightDisplay 
    ? `Si ${leftDisplay} ${operatorText} ${rightDisplay}`
    : `Si ${leftDisplay} ${operatorText}`;
  
  // Construction du texte avec les DEUX branches + indication de la branche sÃƒÂ©lectionnÃƒÂ©e
  // Note: alorsResult.humanText et sinonResult.humanText contiennent dÃƒÂ©jÃƒÂ  le rÃƒÂ©sultat (ex: "expression = 0.25")
  const humanText = `${conditionText}; ` +
    `ALORS: ${alorsResult.humanText}; ` +
    `SINON: ${sinonResult.humanText} ` +
    `Ã¢â€ â€™ [${branchName} SÃƒâ€°LECTIONNÃƒâ€°] Result = ${conditionMet ? alorsResult.result : sinonResult.result}`;
  
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€œÂ¤ Ãƒâ€°TAPE 9 : Retourner le rÃƒÂ©sultat structurÃƒÂ© avec le rÃƒÂ©sultat de la branche sÃƒÂ©lectionnÃƒÂ©e
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const finalResult = conditionMet ? alorsResult.result : sinonResult.result;
  
  return {
    result: finalResult,
    humanText,
    details: {
      type: 'condition',
      conditionId: condition.id,
      conditionName: condition.name,
      when: {
        left: { ref: leftRef, label: leftLabel, value: leftValue },
        operator: operator,
        right: { ref: rightRef, label: rightLabel, value: rightValue },
        evaluated: conditionMet
      },
      branchUsed: branchName,
      alorsResult: alorsResult.details,
      sinonResult: sinonResult.details,
      selectedResult: conditionMet ? alorsResult.details : sinonResult.details
    }
  };
}

/**
 * Ã¢Å¡â€“Ã¯Â¸Â Ãƒâ€°value un opÃƒÂ©rateur de condition
 * 
 * OPÃƒâ€°RATEURS SUPPORTÃƒâ€°S :
 * ----------------------
 * - isEmpty      : VÃƒÂ©rifie si vide (null, undefined, '')
 * - isNotEmpty   : VÃƒÂ©rifie si non vide
 * - eq (==)      : Ãƒâ€°galitÃƒÂ© stricte
 * - ne (!=)      : DiffÃƒÂ©rent
 * - gt (>)       : SupÃƒÂ©rieur (numÃƒÂ©rique)
 * - gte (>=)     : SupÃƒÂ©rieur ou ÃƒÂ©gal
 * - lt (<)       : InfÃƒÂ©rieur
 * - lte (<=)     : InfÃƒÂ©rieur ou ÃƒÂ©gal
 * 
 * @param op - OpÃƒÂ©rateur ÃƒÂ  ÃƒÂ©valuer
 * @param left - Valeur de gauche
 * @param right - Valeur de droite
 * @returns true si condition vraie, false sinon
 */
function evaluateOperator(op: string, left: any, right: any): boolean {
  switch (op) {
    case 'isEmpty':
      return left === null || left === undefined || left === '';
    
    case 'isNotEmpty':
      return left !== null && left !== undefined && left !== '';
    
    case 'eq':
    case '==':
      return left === right;
    
    case 'ne':
    case '!=':
      return left !== right;
    
    // Ã°Å¸â€Â¥ NOUVEAU: OpÃƒÂ©rateur 'contains' pour vÃƒÂ©rifier si une chaÃƒÂ®ne contient une autre
    case 'contains':
      if (left === null || left === undefined) return false;
      if (right === null || right === undefined) return false;
      return String(left).toLowerCase().includes(String(right).toLowerCase());
    
    // Ã°Å¸â€Â¥ NOUVEAU: OpÃƒÂ©rateur 'startsWith' pour vÃƒÂ©rifier si une chaÃƒÂ®ne commence par une autre
    case 'startsWith':
    case 'commence par':
      if (left === null || left === undefined) return false;
      if (right === null || right === undefined) return false;
      return String(left).toLowerCase().startsWith(String(right).toLowerCase());
    
    case 'gt':
    case '>':
      return Number(left) > Number(right);
    
    case 'gte':
    case '>=':
      return Number(left) >= Number(right);
    
    case 'lt':
    case '<':
      return Number(left) < Number(right);
    
    case 'lte':
    case '<=':
      return Number(left) <= Number(right);
    
    default:
      // Log supprim
      return false;
  }
}

function compareValuesByOperator(op: string | undefined | null, cellValue: any, targetValue: any): boolean {
  if (!op) return false;
  switch (op) {
    case 'equals':
    case '==':
      return String(cellValue) === String(targetValue);
    case 'notEquals':
    case '!=':
      return String(cellValue) !== String(targetValue);
    case 'greaterThan':
    case '>':
      return Number(cellValue) > Number(targetValue);
    case 'greaterOrEqual':
    case '>=':
      return Number(cellValue) >= Number(targetValue);
    case 'lessThan':
    case '<':
      return Number(cellValue) < Number(targetValue);
    case 'lessOrEqual':
    case '<=':
      return Number(cellValue) <= Number(targetValue);
    case 'contains':
      return String(cellValue).includes(String(targetValue));
    case 'notContains':
      return !String(cellValue).includes(String(targetValue));
    default:
      return false;
  }
}

// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
// Ã°Å¸Â§Â° UTILITAIRES COMMUNS POUR LES LOOKUP (normalisation + recherche numÃƒÂ©rique)
// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â

const normalizeLookupValue = (value: unknown): string => String(value ?? '').trim().toLowerCase();

const parseNumericLookupValue = (value: unknown): number => {
  if (typeof value === 'number') return value;
  const raw = String(value ?? '').trim();
  if (!raw) return NaN;
  const sanitized = raw.replace(/,/g, '.').replace(/[^0-9+\-\.]/g, '');
  if (!sanitized) return NaN;
  return Number(sanitized);
};

function findClosestIndexInLabels(
  targetValue: unknown,
  labels: Array<unknown>,
  allowedIndices?: number[]
): { index: number; matchType: 'text' | 'numeric'; matchedValue?: unknown } | null {
  const indices = allowedIndices && allowedIndices.length ? allowedIndices : labels.map((_, idx) => idx);
  const normalizedTarget = normalizeLookupValue(targetValue);

  for (const idx of indices) {
    const label = labels[idx];
    if (normalizeLookupValue(label) === normalizedTarget || label === targetValue) {
      return { index: idx, matchType: 'text', matchedValue: label };
    }
  }

  const numericTarget = parseNumericLookupValue(targetValue);
  if (isNaN(numericTarget)) {
    return null;
  }

  let exactIndex = -1;
  let upperIndex = -1;
  let upperValue = Infinity;
  let lowerIndex = -1;
  let lowerValue = -Infinity;

  for (const idx of indices) {
    const labelValue = parseNumericLookupValue(labels[idx]);
    if (isNaN(labelValue)) continue;

    if (labelValue === numericTarget) {
      exactIndex = idx;
      break;
    }

    if (labelValue >= numericTarget && labelValue < upperValue) {
      upperValue = labelValue;
      upperIndex = idx;
    }

    if (labelValue <= numericTarget && labelValue > lowerValue) {
      lowerValue = labelValue;
      lowerIndex = idx;
    }
  }

  if (exactIndex !== -1) {
    return { index: exactIndex, matchType: 'numeric', matchedValue: numericTarget };
  }

  if (upperIndex !== -1) {
    return { index: upperIndex, matchType: 'numeric', matchedValue: upperValue };
  }

  if (lowerIndex !== -1) {
    return { index: lowerIndex, matchType: 'numeric', matchedValue: lowerValue };
  }

  return null;
}

/**
 * Ã°Å¸â€œÂ Traduit un opÃƒÂ©rateur en texte humain franÃƒÂ§ais
 * 
 * @param op - OpÃƒÂ©rateur technique
 * @returns Texte en franÃƒÂ§ais
 */
function getOperatorText(op: string): string {
  const texts: Record<string, string> = {
    'isEmpty': 'est vide',
    'isNotEmpty': "n'est pas vide",
    'eq': '=',
    'ne': 'Ã¢â€°Â ',
    'gt': '>',
    'gte': 'Ã¢â€°Â¥',
    'lt': '<',
    'lte': 'Ã¢â€°Â¤',
    '==': '=',
    '!=': 'Ã¢â€°Â '
  };
  
  return texts[op] || op;
}

type FormulaExpressionPart =
  | { type: 'literal'; value: string }
  | { type: 'placeholder'; encoded: string };

interface FormulaReferenceMeta {
  refId: string;
  refType: ReferenceType;
  rawToken: string;
}

interface FormulaExpressionBuildResult {
  expression: string;
  parts: FormulaExpressionPart[];
  roleToEncoded: Record<string, string>;
  encodedMeta: Record<string, FormulaReferenceMeta>;
}

const RE_NODE_FORMULA = /node-formula:[a-z0-9-]+/i;
const RE_LEGACY_FORMULA = /formula:[a-z0-9-]+/i;
const UUID_REGEX = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i;

function encodeRef(refType: ReferenceType, refId: string): string {
  return `${refType}::${refId}`;
}

function tryParseTokenReference(token?: string | null): FormulaReferenceMeta | null {
  if (!token || typeof token !== 'string') return null;

  const rawToken = token;
  let normalizedToken = token.trim();
  const wrapperMatch = normalizedToken.match(/^\{\{\s*(.+?)\s*\}\}$/);
  if (wrapperMatch && wrapperMatch[1]) {
    normalizedToken = wrapperMatch[1];
  }

  const createMeta = (refType: ReferenceType, refId: string): FormulaReferenceMeta => ({ refType, refId, rawToken });

  // Ã°Å¸â€Â¥ NOUVEAU: Support des tokens @calculated.xxx (champs avec valeur calculÃƒÂ©e)
  // Ces tokens rÃƒÂ©fÃƒÂ©rencent un nodeId qui a une formule associÃƒÂ©e
  if (normalizedToken.startsWith('@calculated.')) {
    const nodeId = normalizedToken.slice('@calculated.'.length);
    // Un @calculated.xxx est essentiellement une rÃƒÂ©fÃƒÂ©rence ÃƒÂ  un champ (value) 
    // dont la valeur sera rÃƒÂ©cupÃƒÂ©rÃƒÂ©e ou calculÃƒÂ©e
    return createMeta('value', nodeId);
  }

  if (normalizedToken.startsWith('@value.condition:')) {
    return createMeta('condition', normalizedToken.slice('@value.condition:'.length));
  }
  if (normalizedToken.startsWith('@value.node-condition:')) {
    return createMeta('condition', normalizedToken.slice('@value.node-condition:'.length));
  }
  if (normalizedToken.startsWith('@value.')) {
    return createMeta('value', normalizedToken.slice('@value.'.length));
  }
  if (normalizedToken.startsWith('@table.')) {
    return createMeta('table', normalizedToken.slice('@table.'.length));
  }
  if (normalizedToken.startsWith('@condition.')) {
    return createMeta('condition', normalizedToken.slice('@condition.'.length));
  }
  if (normalizedToken.startsWith('@select.')) {
    const cleaned = normalizedToken.slice('@select.'.length).split('.')[0];
    return cleaned ? createMeta('value', cleaned) : null;
  }

  const formulaMatch = normalizedToken.match(RE_NODE_FORMULA) || normalizedToken.match(RE_LEGACY_FORMULA);
  if (formulaMatch && formulaMatch[0]) {
    const normalized = formulaMatch[0].startsWith('node-formula:')
      ? formulaMatch[0].slice('node-formula:'.length)
      : formulaMatch[0].slice('formula:'.length);
    return createMeta('formula', normalized);
  }

  if (normalizedToken.startsWith('node-formula:')) {
    return createMeta('formula', normalizedToken.slice('node-formula:'.length));
  }
  // Support aussi "formula:" sans prÃƒÂ©fixe "node-"
  if (normalizedToken.startsWith('formula:') && !normalizedToken.startsWith('formula:node-')) {
    return createMeta('formula', normalizedToken.slice('formula:'.length));
  }
  if (normalizedToken.startsWith('node-table:')) {
    return createMeta('table', normalizedToken.slice('node-table:'.length));
  }
  // Support aussi "table:" sans prÃƒÂ©fixe "node-"
  if (normalizedToken.startsWith('table:') && !normalizedToken.startsWith('table:node-')) {
    return createMeta('table', normalizedToken.slice('table:'.length));
  }
  if (normalizedToken.startsWith('node-condition:')) {
    return createMeta('condition', normalizedToken.slice('node-condition:'.length));
  }
  // Support aussi "condition:" sans prÃƒÂ©fixe "node-"
  if (normalizedToken.startsWith('condition:') && !normalizedToken.startsWith('condition:node-')) {
    return createMeta('condition', normalizedToken.slice('condition:'.length));
  }

  if (normalizedToken.startsWith('shared-ref-') || normalizedToken.startsWith('node_') || UUID_REGEX.test(normalizedToken)) {
    return createMeta('field', normalizedToken);
  }

  return null;
}

function buildFormulaExpression(tokens: any[]): FormulaExpressionBuildResult {
  const parts: FormulaExpressionPart[] = [];
  const roleToEncoded: Record<string, string> = {};
  const encodedMeta: Record<string, FormulaReferenceMeta> = {};
  const exprSegments: string[] = [];
  let varIndex = 0;

  const appendLiteral = (value: string) => {
    exprSegments.push(value);
    parts.push({ type: 'literal', value });
  };

  const registerReference = (meta: FormulaReferenceMeta) => {
    const encoded = encodeRef(meta.refType, meta.refId);
    if (!encodedMeta[encoded]) encodedMeta[encoded] = meta;
    const role = `var_${varIndex++}`;
    roleToEncoded[role] = encoded;
    const placeholder = `{{${role}}}`;
    exprSegments.push(placeholder);
    parts.push({ type: 'placeholder', encoded });
  };

  for (const rawToken of tokens) {
    if (typeof rawToken === 'string') {
      const refMeta = tryParseTokenReference(rawToken);
      if (refMeta) {
        registerReference(refMeta);
        continue;
      }
      if (rawToken === 'CONCAT') {
        appendLiteral('&');
        continue;
      }
      appendLiteral(rawToken);
    } else if (rawToken && typeof rawToken === 'object') {
      const refStr = typeof rawToken.ref === 'string'
        ? rawToken.ref
        : typeof rawToken.value === 'string'
          ? rawToken.value
          : typeof rawToken.nodeId === 'string'
            ? rawToken.nodeId
            : '';
      if (refStr) {
        const refMeta = tryParseTokenReference(refStr) || { refType: 'field', refId: refStr, rawToken: refStr };
        registerReference(refMeta);
      }
    }
  }

  const expression = exprSegments.join(' ');
  return { expression, parts, roleToEncoded, encodedMeta };
}

// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
// Ã°Å¸Â§Â® MODULE 5 : INTERPRÃƒâ€°TATION DES FORMULES
// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â

/**
 * Ã°Å¸Â§Â® INTERPRÃƒË†TE UNE FORMULE (Calcul mathÃƒÂ©matique)
 * 
 * Cette fonction ÃƒÂ©value une formule mathÃƒÂ©matique en rÃƒÂ©solvant tous ses tokens.
 * 
 * PROCESSUS :
 * -----------
 * 1. Ã°Å¸â€œÂ¥ RÃƒÂ©cupÃƒÂ©rer la formule depuis TreeBranchLeafNodeFormula
 * 2. Ã°Å¸â€Â Parcourir les tokens un par un
 * 3. Ã°Å¸â€â€ž Pour chaque @value.xxx, interprÃƒÂ©ter rÃƒÂ©cursivement
 * 4. Ã°Å¸Â§Â® Construire l'expression mathÃƒÂ©matique
 * 5. Ã¢Å¡Â¡ Calculer le rÃƒÂ©sultat final
 * 6. Ã°Å¸â€œÂ GÃƒÂ©nÃƒÂ©rer le texte explicatif
 * 
 * FORMAT DES TOKENS :
 * -------------------
 * ["@value.xxx", "/", "@value.yyy"] Ã¢â€ â€™ Champ1 / Champ2
 * [{ type: "ref", ref: "@value.xxx" }, "+", "100"] Ã¢â€ â€™ Champ + 100
 * 
 * @param formulaId - ID de la formule
 * @param submissionId - ID de la soumission
 * @param prisma - Instance Prisma Client
 * @param valuesCache - Cache des valeurs
 * @param depth - Profondeur de rÃƒÂ©cursion
 * @returns RÃƒÂ©sultat interprÃƒÂ©tÃƒÂ©
 */
async function interpretFormula(
  formulaId: string,
  submissionId: string,
  prisma: PrismaClient,
  valuesCache: Map<string, InterpretResult>,
  depth: number,
  valueMap?: Map<string, unknown>,
  labelMap?: Map<string, string>
): Promise<InterpretResult> {
  
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€œÂ¥ Ãƒâ€°TAPE 1 : RÃƒÂ©cupÃƒÂ©rer la formule depuis la base de donnÃƒÂ©es
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const cleanId = formulaId.replace('node-formula:', '');
  
  let formula = await prisma.treeBranchLeafNodeFormula.findUnique({
    where: { id: cleanId },
    select: {
      id: true,
      name: true,
      tokens: true,
      nodeId: true
    }
  });
  
  // Ã°Å¸â€Â RÃƒâ€°SOLUTION IMPLICITE : Si pas trouvÃƒÂ© par ID, chercher par nodeId (formule par dÃƒÂ©faut)
  if (!formula) {
    try {
      const byNode = await prisma.treeBranchLeafNodeFormula.findFirst({
        where: { nodeId: cleanId },
        select: { id: true, name: true, tokens: true, nodeId: true },
        orderBy: { isDefault: 'desc' }
      });
      if (byNode) {
        formula = byNode;
      }
    } catch (e) {
      console.warn('[FORMULE] Ã¢Å¡Â Ã¯Â¸Â RÃƒÂ©solution implicite ÃƒÂ©chouÃƒÂ©e:', e instanceof Error ? e.message : e);
    }
  }
  
  if (!formula) {
    // Formule introuvable - silencieux en preview
    return {
      result: 'Ã¢Ë†â€¦',
      humanText: `Formule introuvable: ${formulaId}`,
      details: { type: 'formula', error: 'Not found' }
    };
  }
  
  
  const tokens = Array.isArray(formula.tokens) ? formula.tokens : [];

  const buildResult = buildFormulaExpression(tokens);
  if (!buildResult.expression.trim()) {
    console.warn('[FORMULE] Ã¢Å¡Â Ã¯Â¸Â Expression vide, retour 0');
    return {
      result: '0',
      humanText: '0',
      details: {
        type: 'formula',
        formulaId: formula.id,
        formulaName: formula.name,
        tokens: [],
        expression: '',
        humanExpression: '',
        calculatedResult: 0
      }
    };
  }

  const valueCacheByEncoded = new Map<string, number>();
  const labelCacheByEncoded = new Map<string, string>();
  const detailCacheByEncoded = new Map<string, InterpretResult>();

  const resolveVariable = async (encoded: string): Promise<number> => {
    if (valueCacheByEncoded.has(encoded)) {
      return valueCacheByEncoded.get(encoded)!;
    }
    const meta = buildResult.encodedMeta[encoded];
    if (!meta || !meta.refId) {
      valueCacheByEncoded.set(encoded, 0);
      labelCacheByEncoded.set(encoded, meta?.rawToken || encoded);
      return 0;
    }

    try {
      const refResult = await interpretReference(
        meta.refId,
        submissionId,
        prisma,
        valuesCache,
        depth + 1,
        valueMap,
        labelMap,
        meta.refType
      );
      detailCacheByEncoded.set(encoded, refResult);
      const numeric = Number(refResult.result);
      const safeValue = Number.isFinite(numeric) ? numeric : 0;
      valueCacheByEncoded.set(encoded, safeValue);

      if (meta.refType === 'formula') {
        const label = refResult.details?.formulaName || refResult.details?.label || `Formule ${meta.refId}`;
        labelCacheByEncoded.set(encoded, label);
      } else {
        const label = await getNodeLabel(meta.refId, prisma, labelMap).catch(() => meta.refId);
        labelCacheByEncoded.set(encoded, label || meta.refId);
      }

      return safeValue;
    } catch (error) {
      console.error('[FORMULE] Ã¢ÂÅ’ Erreur rÃƒÂ©solution variable:', { encoded, error });
      valueCacheByEncoded.set(encoded, 0);
      labelCacheByEncoded.set(encoded, meta?.rawToken || encoded);
      return 0;
    }
  };

  let evaluation: { value: number; errors: string[] };
  try {
    evaluation = await evaluateExpression(buildResult.expression, buildResult.roleToEncoded, {
      resolveVariable,
      divisionByZeroValue: 0,
      strictVariables: false
    });
  } catch (error) {
    console.error('[FORMULE] Ã¢ÂÅ’ Erreur evaluateExpression:', error);
    return {
      result: 'Ã¢Ë†â€¦',
      humanText: 'Erreur de calcul de la formule',
      details: {
        type: 'formula',
        formulaId: formula.id,
        formulaName: formula.name,
        tokens: tokens.map(token => ({ type: 'raw', value: token })),
        expression: buildResult.expression,
        humanExpression: buildResult.expression,
        calculatedResult: 0,
        error: error instanceof Error ? error.message : String(error)
      }
    };
  }

  const humanExpression = buildResult.parts
    .map(part => {
      if (part.type === 'literal') return part.value;
      const label = labelCacheByEncoded.get(part.encoded) || buildResult.encodedMeta[part.encoded]?.refId || part.encoded;
      const value = valueCacheByEncoded.get(part.encoded) ?? 0;
      return `${label}(${value})`;
    })
    .join(' ')
    .replace(/\s+/g, ' ')
    .trim();

  const calculatedResult = evaluation.value;
  const humanText = `${humanExpression} = ${calculatedResult}`;

  const tokenDetails = buildResult.parts.map(part => {
    if (part.type === 'literal') {
      return { type: 'literal', value: part.value };
    }
    const meta = buildResult.encodedMeta[part.encoded];
    return {
      type: 'reference',
      ref: meta?.refId,
      refType: meta?.refType,
      label: labelCacheByEncoded.get(part.encoded) || meta?.refId,
      value: valueCacheByEncoded.get(part.encoded) ?? 0,
      details: detailCacheByEncoded.get(part.encoded)?.details || null
    };
  });

  return {
    result: String(calculatedResult),
    humanText,
    details: {
      type: 'formula',
      formulaId: formula.id,
      formulaName: formula.name,
      tokens: tokenDetails,
      expression: buildResult.expression,
      humanExpression,
      calculatedResult,
      evaluationErrors: evaluation.errors
    }
  };
}

// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
// Ã°Å¸â€œÅ  MODULE 6 : INTERPRÃƒâ€°TATION DES TABLES (LOOKUP)
// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â

/**
 * Ã°Å¸â€œÅ  INTERPRÃƒË†TE UNE TABLE (Lookup croisÃƒÂ©)
 * 
 * Cette fonction effectue un lookup dans une table en croisant ligne Ãƒâ€” colonne.
 * 
 * PROCESSUS :
 * -----------
 * 1. Ã°Å¸â€œÂ¥ RÃƒÂ©cupÃƒÂ©rer la table depuis TreeBranchLeafNodeTable
 * 2. Ã°Å¸â€Â Extraire la config de lookup (selectors)
 * 3. Ã°Å¸â€œÅ  RÃƒÂ©cupÃƒÂ©rer les valeurs sÃƒÂ©lectionnÃƒÂ©es (rowFieldId, columnFieldId)
 * 4. Ã°Å¸Å½Â¯ Trouver les index dans rows[] et columns[]
 * 5. Ã°Å¸â€œÂ Faire le lookup dans data[rowIndex][colIndex]
 * 6. Ã°Å¸â€œÂ GÃƒÂ©nÃƒÂ©rer le texte explicatif
 * 
 * STRUCTURE D'UNE TABLE :
 * -----------------------
 * columns: ["Orientation", "0", "5", "15", "25", ...]
 * rows: ["Orientation", "Nord", "Nord-Est", ...]
 * data: [[86, 82, 73, ...], [86, 83, 74, ...], ...]
 * meta.lookup.selectors: { rowFieldId, columnFieldId }
 * 
 * @param tableId - ID de la table
 * @param submissionId - ID de la soumission
 * @param prisma - Instance Prisma Client
 * @param valuesCache - Cache des valeurs
 * @param depth - Profondeur de rÃƒÂ©cursion
 * @returns RÃƒÂ©sultat interprÃƒÂ©tÃƒÂ©
 */
// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
// Ã°Å¸â€Â¥ NOUVEAU: Gestion des 3 options de source (SELECT/CHAMP/CAPACITÃƒâ€°)
// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â

/**
 * Ã°Å¸â€Â¥ RÃƒÂ©cupÃƒÂ¨re la valeur source selon le type configurÃƒÂ©
 * 
 * Supporte les 3 options :
 * 1. SELECT (columnSourceOption?.type === 'select'): Utilise le champ configurÃƒÂ©
 * 2. CHAMP (columnSourceOption?.type === 'field'): RÃƒÂ©cupÃƒÂ¨re la valeur d'un autre champ
 * 3. CAPACITÃƒâ€° (columnSourceOption?.type === 'capacity'): ExÃƒÂ©cute une capacitÃƒÂ©
 * 
 * @param sourceOption - Configuration de la source (columnSourceOption ou rowSourceOption)
 * @param lookupConfig - Configuration lookup complÃƒÂ¨te (fallback pour mode SELECT)
 * @param fieldId - ID du champ pour le mode SELECT (fallback)
 * @param submissionId - ID de la soumission
 * @param prisma - Instance Prisma
 * @param valuesCache - Cache des interprÃƒÂ©tations
 * @param depth - Profondeur de rÃƒÂ©cursion
 * @param valueMap - Map des valeurs
 * @param labelMap - Map des labels
 * @returns Valeur source | null
 */
async function getSourceValue(
  sourceOption: any,
  lookupConfig: any,
  fieldId: string | null | undefined,
  submissionId: string,
  prisma: PrismaClient,
  valuesCache: Map<string, InterpretResult>,
  depth: number,
  valueMap?: Map<string, unknown>,
  labelMap?: Map<string, string>
): Promise<string | null> {
  // Par dÃƒÂ©faut (ou option SELECT): utiliser le fieldId configurÃƒÂ©
  if (!sourceOption || sourceOption.type === 'select') {
    return fieldId ? await getNodeValue(fieldId, submissionId, prisma, valueMap) : null;
  }
  
  // Option 2 (CHAMP): rÃƒÂ©cupÃƒÂ©rer la valeur du champ source
  if (sourceOption.type === 'field' && sourceOption.sourceField) {
    
    const result = await getNodeValue(sourceOption.sourceField, submissionId, prisma, valueMap);
    return result;
  }
  
  // Option 3 (CAPACITÃƒâ€°): exÃƒÂ©cuter la capacitÃƒÂ© et rÃƒÂ©cupÃƒÂ©rer son rÃƒÂ©sultat
  if (sourceOption.type === 'capacity' && sourceOption.capacityRef) {
    try {
      const capacityResult = await interpretReference(
        sourceOption.capacityRef,
        submissionId,
        prisma,
        valuesCache,
        depth + 1,
        valueMap,
        labelMap
      );
      return capacityResult.result;
    } catch (error) {
      console.error(`[TABLE] Ã¢ÂÅ’ Erreur exÃƒÂ©cution capacitÃƒÂ© ${sourceOption.capacityRef}:`, error);
      return null;
    }
  }
  
  return null;
}

/**
 * Ã°Å¸ÂÂ·Ã¯Â¸Â RÃƒÂ©cupÃƒÂ¨re le label de la source selon le type configurÃƒÂ©
 * 
 * @param sourceOption - Configuration de la source
 * @param lookupConfig - Configuration lookup complÃƒÂ¨te (fallback)
 * @param fieldId - ID du champ pour fallback
 * @param prisma - Instance Prisma
 * @param labelMap - Map des labels
 * @returns Label de la source
 */
async function getSourceLabel(
  sourceOption: any,
  lookupConfig: any,
  fieldId: string | null | undefined,
  prisma: PrismaClient,
  labelMap?: Map<string, string>
): Promise<string> {
  // Option SELECT: label du champ sÃƒÂ©lectionnÃƒÂ©
  if (!sourceOption || sourceOption.type === 'select') {
    return fieldId ? await getNodeLabel(fieldId, prisma, labelMap) : 'Source';
  }
  
  // Option CHAMP: label du champ source
  if (sourceOption.type === 'field' && sourceOption.sourceField) {
    return await getNodeLabel(sourceOption.sourceField, prisma, labelMap);
  }
  
  // Option CAPACITÃƒâ€°: label de la capacitÃƒÂ©
  if (sourceOption.type === 'capacity' && sourceOption.capacityRef) {
    // Essayer de rÃƒÂ©cupÃƒÂ©rer le label depuis labelMap ou retourner la rÃƒÂ©fÃƒÂ©rence
    const capacityId = sourceOption.capacityRef.replace('@value.', '').replace('formula:', '').replace('condition:', '').replace('table:', '');
    if (labelMap && labelMap.has(capacityId)) {
      return labelMap.get(capacityId) || capacityId;
    }
    return `CapacitÃƒÂ©: ${sourceOption.capacityRef}`;
  }
  
  return 'Source';
}

// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â

async function interpretTable(
  tableId: string,
  submissionId: string,
  prisma: PrismaClient,
  valuesCache: Map<string, InterpretResult>,
  depth: number,
  valueMap?: Map<string, unknown>,
  labelMap?: Map<string, string>
): Promise<InterpretResult> {
  
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€œÂ¥ Ãƒâ€°TAPE 1 : RÃƒÂ©cupÃƒÂ©rer la table depuis la base de donnÃƒÂ©es
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const cleanId = tableId.replace('@table.', '').replace('node-table:', '');
  
  let table = await prisma.treeBranchLeafNodeTable.findUnique({
    where: { id: cleanId },
    select: {
      id: true,
      name: true,
      type: true,
      rowCount: true,
      columnCount: true,
      meta: true,
      nodeId: true,
      tableColumns: {
        orderBy: { columnIndex: 'asc' },
        select: {
          id: true,
          columnIndex: true,
          name: true,
          type: true,
          width: true,
          format: true,
          metadata: true
        }
      },
      tableRows: {
        orderBy: { rowIndex: 'asc' },
        select: {
          id: true,
          rowIndex: true,
          cells: true
        }
      }
    }
  });
  
  // Ã°Å¸â€Â RÃƒâ€°SOLUTION IMPLICITE : Si pas trouvÃƒÂ© par ID, chercher par nodeId (table par dÃƒÂ©faut)
  if (!table) {
    try {
      const byNode = await prisma.treeBranchLeafNodeTable.findFirst({
        where: { nodeId: cleanId },
        select: {
          id: true,
          name: true,
          type: true,
          rowCount: true,
          columnCount: true,
          meta: true,
          nodeId: true,
          tableColumns: {
            orderBy: { columnIndex: 'asc' },
            select: { id: true, columnIndex: true, name: true, type: true, width: true, format: true, metadata: true }
          },
          tableRows: {
            orderBy: { rowIndex: 'asc' },
            select: { id: true, rowIndex: true, cells: true }
          }
        },
        orderBy: [{ isDefault: 'desc' }, { updatedAt: 'desc' }]
      });
      if (byNode) {
        table = byNode;
      } else {
      }
    } catch (e) {
      console.warn('[TABLE] Ã¢Å¡Â Ã¯Â¸Â RÃƒÂ©solution implicite ÃƒÂ©chouÃƒÂ©e:', e instanceof Error ? e.message : e);
    }
  }
  
  if (!table) {
    // Valeur introuvable - silencieux
    return {
      result: 'Ã¢Ë†â€¦',
      humanText: `Table introuvable: ${tableId}`,
      details: { type: 'table', error: 'Not found' }
    };
  }
  
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã¯Â¿Â½ RECONSTRUCTION DES DONNÃƒâ€°ES depuis la structure normalisÃƒÂ©e
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Reconstituer columns, rows, data depuis les relations
  const columns = table.tableColumns.map(col => col.name);
  const rows: string[] = [];
  const data: any[][] = [];
  
  // Ã°Å¸â€â€ž Parser cells avec support hybride (JSON array OU plain string)
  table.tableRows.forEach(row => {
    try {
      let cellsData: any;
      
      // Ã°Å¸â€Â Tentative 1: Parse JSON si c'est une string
      if (typeof row.cells === 'string') {
        try {
          cellsData = JSON.parse(row.cells);
        } catch {
          // Ã°Å¸â€Â§ Fallback: Si ce n'est PAS du JSON, c'est juste une valeur simple (premiÃƒÂ¨re colonne uniquement)
          // Cela arrive pour les anciennes donnÃƒÂ©es oÃƒÂ¹ cells = "Orientation" au lieu de ["Orientation", ...]
          cellsData = [row.cells]; // Envelopper dans un array
        }
      } else {
        cellsData = row.cells || [];
      }
      
      // Ã¢Å¡Â Ã¯Â¸Â IMPORTANT: IGNORER rowIndex=0 car c'est la ligne HEADER (noms de colonnes)
      // Dans le nouveau systÃƒÂ¨me normalisÃƒÂ©, rowIndex=0 contient ["Orientation", "0Ã‚Â°", "5Ã‚Â°", ...]
      // qui sont dÃƒÂ©jÃƒÂ  extraits dans tableColumns
      if (row.rowIndex === 0) {
        return; // Skip cette ligne
      }
      
      if (Array.isArray(cellsData) && cellsData.length > 0) {
        // Ã°Å¸â€â€˜ cellsData[0] = label de ligne (colonne A) : "Nord", "Sud", etc.
        // Ã°Å¸â€œÅ  cellsData[1...] = donnÃƒÂ©es (colonnes B, C, D...) : [86, 82, 73, ...]
        const rowLabel = String(cellsData[0] || '');
        const rowData = cellsData.slice(1); // DonnÃƒÂ©es sans le label
        
        rows.push(rowLabel);
        data.push(rowData);
      } else {
        rows.push(`Row ${row.rowIndex}`);
        data.push([]);
      }
    } catch (error) {
      console.error('[TABLE] Ã¢Å¡Â Ã¯Â¸Â Erreur parsing cells:', error);
      rows.push(`Row ${row.rowIndex}`);
      data.push([]);
    }
  });
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã¯Â¿Â½Ã°Å¸â€Â Ãƒâ€°TAPE 2 : Extraire la configuration de lookup
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const meta = table.meta as any;
  const lookup = meta?.lookup;
  
  // Ã°Å¸â€Â¥ FIX: lookup.enabled peut ÃƒÂªtre undefined si seulement columnLookupEnabled/rowLookupEnabled sont dÃƒÂ©finis
  const isLookupActive = lookup && (lookup.enabled === true || lookup.columnLookupEnabled === true || lookup.rowLookupEnabled === true);
  
  if (!isLookupActive) {
    console.error(`[TABLE] Ã¢ÂÅ’ Lookup non configurÃƒÂ© ou dÃƒÂ©sactivÃƒÂ©`);
    return {
      result: 'Ã¢Ë†â€¦',
      humanText: `Lookup non configurÃƒÂ© pour table ${table.name}`,
      details: { type: 'table', error: 'Lookup not enabled' }
    };
  }
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€œÅ  Ãƒâ€°TAPE 3 : RÃƒÂ©cupÃƒÂ©rer les selectors (champs de sÃƒÂ©lection) et les toggles
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const rowFieldId = lookup.selectors?.rowFieldId;
  const colFieldId = lookup.selectors?.columnFieldId;
  const rowEnabled = lookup.rowLookupEnabled === true;
  const colEnabled = lookup.columnLookupEnabled === true;
  const rowSourceOption = lookup.rowSourceOption;
  const colSourceOption = lookup.columnSourceOption;

  const hasRowSelector = Boolean(rowFieldId || (rowSourceOption && rowSourceOption.type && rowSourceOption.type !== 'select'));
  const hasColSelector = Boolean(colFieldId || (colSourceOption && colSourceOption.type && colSourceOption.type !== 'select'));
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸Å½Â¯ DÃƒâ€°TECTION DU MODE (3 modes possibles)
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  
  // MODE 3 : Les DEUX toggles activÃƒÂ©s ET les deux fieldIds configurÃƒÂ©s (croisement dynamique complet)
  if (rowEnabled && colEnabled && hasRowSelector && hasColSelector) {
    // Le code existant continue ici (rÃƒÂ©cupÃƒÂ©ration des deux valeurs + croisement)
  }
  
  // MODE 1 : COLONNE activÃƒÂ©e avec displayColumn (peut avoir ligne activÃƒÂ©e mais sans rowFieldId)
  else if (colEnabled && (colFieldId || colSourceOption) && lookup.displayColumn && !(rowEnabled && colEnabled && hasRowSelector && hasColSelector)) {
    
    // Ã°Å¸â€Â¥ NOUVEAU: Support des 3 options de source (SELECT/CHAMP/CAPACITÃƒâ€°)
    const colSelectorValue = await getSourceValue(
      colSourceOption,
      lookup,
      colFieldId,
      submissionId,
      prisma,
      valuesCache,
      depth,
      valueMap,
      labelMap
    );
    const colLabel = await getSourceLabel(colSourceOption, lookup, colFieldId, prisma, labelMap);
    
    // displayColumn peut ÃƒÂªtre un string OU un array
    const displayColumns = Array.isArray(lookup.displayColumn) 
      ? lookup.displayColumn 
      : [lookup.displayColumn];
    
    if (!colSelectorValue) {
      return {
        result: 'Ã¢Ë†â€¦',
        humanText: `Table "${table.name}" - Aucune sÃƒÂ©lection colonne`,
        details: { type: 'table', mode: 1, error: 'No column selection' }
      };
    }
    
    // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
    // Ã°Å¸â€Â¥ Ãƒâ€°TAPE 2.5 : FILTRAGE DES LIGNES (si configurÃƒÂ©)
    // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
    let validRowIndices: number[] = Array.from({ length: rows.length }, (_, i) => i); // Tous les indices au dÃƒÂ©part
    
    if (colSourceOption?.filterColumn && colSourceOption?.filterOperator && colSourceOption?.filterValueRef) {
      
      // 1Ã¯Â¸ÂÃ¢Æ’Â£ RÃƒÂ©cupÃƒÂ©rer la valeur de comparaison (celle ÃƒÂ  droite de l'opÃƒÂ©rateur)
      const filterRefResult = await interpretReference(
        colSourceOption.filterValueRef,
        submissionId,
        prisma,
        valuesCache,
        depth + 1,
        valueMap,
        labelMap
      );
      const filterComparisonValue = filterRefResult.result;
      
      // 2Ã¯Â¸ÂÃ¢Æ’Â£ Trouver l'index de la colonne ÃƒÂ  filtrer
      const normalizedFilterColName = String(colSourceOption.filterColumn).trim().toLowerCase();
      const filterColInCols = columns.findIndex(c => String(c).trim().toLowerCase() === normalizedFilterColName);
      const filterColInRows = rows.findIndex(r => String(r).trim().toLowerCase() === normalizedFilterColName);
      
      let filterColIndex = -1;
      if (filterColInCols !== -1) filterColIndex = filterColInCols;
      else if (filterColInRows !== -1) filterColIndex = filterColInRows;
      
      if (filterColIndex !== -1) {
        // 3Ã¯Â¸ÂÃ¢Æ’Â£ Filtrer les lignes basÃƒÂ©es sur l'opÃƒÂ©rateur
        const dataColIndexForFilter = filterColIndex - 1;
        validRowIndices = validRowIndices.filter((rowIdx) => {
          // RÃƒÂ©cupÃƒÂ©rer la valeur de la cellule ÃƒÂ  filtrer
          const cellValue = filterColIndex === 0 ? rows[rowIdx] : data[rowIdx]?.[dataColIndexForFilter];
          
          // Appliquer l'opÃƒÂ©rateur de comparaison
          const matches = compareValuesByOperator(colSourceOption.filterOperator, cellValue, filterComparisonValue);
          
          if (matches) {
          } else {
          }
          
          return matches;
        });
        
      } else {
        console.warn(`[TABLE] Ã¢Å¡Â Ã¯Â¸Â Ãƒâ€°TAPE 2.5 - Colonne de filtrage non trouvÃƒÂ©e: "${colSourceOption.filterColumn}"`);
      }
    }
    
    // Faire le lookup avec colSelectorValue et CHAQUE displayColumn
    // columns, rows, data dÃƒÂ©jÃƒÂ  reconstruits plus haut
    // validRowIndices contient les indices des lignes ÃƒÂ  traiter (filtrÃƒÂ©es ou toutes)
    
    const results: Array<{ row: string; value: any }> = [];
    
    // Mode extract: si lookup.extractValueRef est configurÃƒÂ©, on cherche la premiÃƒÂ¨re ligne
    // qui satisfait l'opÃƒÂ©rateur pour la colonne sÃƒÂ©lectionnÃƒÂ©e
    if (lookup.extractValueRef) {
      const refResult = await interpretReference(lookup.extractValueRef, submissionId, prisma, valuesCache, depth + 1, valueMap, labelMap);
      const targetValue = refResult.result;
      // DÃƒÂ©terminer la colonne cible (colIndex) ÃƒÂ  partir du colSelectorValue
      const normalizedColSelector = String(colSelectorValue || '').trim().toLowerCase();
      const colSelectorInCols = columns.findIndex(c => String(c).trim().toLowerCase() === normalizedColSelector);
      const colSelectorInRows = rows.findIndex(r => String(r).trim().toLowerCase() === normalizedColSelector);
      let finalColIndex = -1;
      if (colSelectorInCols !== -1) finalColIndex = colSelectorInCols; else finalColIndex = colSelectorInRows;
      if (finalColIndex === -1) {
        console.warn(`[TABLE] Ã¢Å¡Â Ã¯Â¸Â MODE 1 extract - colonne non trouvÃƒÂ©e pour selector ${colSelectorValue}`);
      } else {
        const dataColIndex = finalColIndex - 1;
        // Chercher la premiÃƒÂ¨re ligne oÃƒÂ¹ data[row][dataColIndex] match l'opÃƒÂ©rateur
        // Ã°Å¸â€Â¥ Ãƒâ€°TAPE 2.5: Boucler SEULEMENT sur les indices filtrÃƒÂ©s
        let foundRowIndex = -1;
        for (const rIdx of validRowIndices) {
          // dataRowIndex = rIdx (rows includes headers)
          const potentialVal = data[rIdx]?.[dataColIndex];
          if (compareValuesByOperator(lookup.extractOperator, potentialVal, targetValue)) {
            foundRowIndex = rIdx;
            break;
          }
        }
        if (foundRowIndex !== -1) {
          // Construire results ÃƒÂ  partir de displayColumns pour la ligne trouvÃƒÂ©e
          for (const fixedRowValue of displayColumns) {
            const normalizedFixedRow = String(fixedRowValue).trim().toLowerCase();
            const fixedRowInRows = rows.findIndex(r => String(r).trim().toLowerCase() === normalizedFixedRow);
            const fixedRowInCols = columns.findIndex(c => String(c).trim().toLowerCase() === normalizedFixedRow);
            let rowIndex = -1;
            if (fixedRowInRows !== -1) rowIndex = fixedRowInRows;
            else if (fixedRowInCols !== -1) rowIndex = fixedRowInCols; // fallback
            if (rowIndex !== -1) {
              const dataRowIndex = rowIndex;
              const dataColIndexForDisplay = finalColIndex - 1;
              const result = data[dataRowIndex]?.[dataColIndexForDisplay];
              results.push({ row: fixedRowValue, value: result });
            }
          }
          const resultText = results.map(r => `${r.row}=${r.value}`).join(', ');
          const resultValues = results.map(r => r.value);
          const humanText = `Table "${table.name}"[extract ${lookup.extractValueRef} ${lookup.extractOperator} -> row=${rows[foundRowIndex]}] = ${resultText}`;
          return {
            result: resultValues.length === 1 ? String(resultValues[0]) : JSON.stringify(resultValues),
            humanText,
            details: {
              type: 'table',
              mode: 1,
              tableId: table.id,
              tableName: table.name,
              lookup: {
                column: { field: colLabel, value: colSelectorValue },
                rows: results,
                multiple: results.length > 1,
                extract: { ref: lookup.extractValueRef, operator: lookup.extractOperator, target: targetValue }
              }
            }
          };
        }
      }
    }

    // Ã°Å¸â€Â¥ NOUVEAU: Pour Option 2 (CHAMP) et Option 3 (CAPACITÃƒâ€°) avec opÃƒÂ©rateur, chercher la ligne qui match l'opÃƒÂ©rateur
    let targetColIndex = -1;
    if ((colSourceOption?.type === 'field' || colSourceOption?.type === 'capacity') && colSourceOption?.operator && colSourceOption?.comparisonColumn) {
      
      // Utiliser directement comparisonColumn au lieu de deviner
      const comparisonColName = colSourceOption.comparisonColumn;
      const normalizedComparisonCol = String(comparisonColName).trim().toLowerCase();
      const colSelectorInCols = columns.findIndex(c => String(c).trim().toLowerCase() === normalizedComparisonCol);
      const colSelectorInRows = rows.findIndex(r => String(r).trim().toLowerCase() === normalizedComparisonCol);
      
      let colSelectorIndex = -1;
      if (colSelectorInCols !== -1) colSelectorIndex = colSelectorInCols;
      else if (colSelectorInRows !== -1) colSelectorIndex = colSelectorInRows;
      
      if (colSelectorIndex !== -1) {
        // Ã°Å¸â€Â¥ FIX: Si colSelectorIndex = 0 (premiÃƒÂ¨re colonne), les valeurs sont dans rows[], pas data[]
        const dataColIndex = colSelectorIndex - 1;
        let foundRowIndex = -1;
        // Ã°Å¸â€Â¥ Ãƒâ€°TAPE 2.5: Boucler SEULEMENT sur les indices filtrÃƒÂ©s
        for (const rIdx of validRowIndices) {
          // Si on compare la premiÃƒÂ¨re colonne (index 0), prendre la valeur depuis rows[]
          const cellValue = colSelectorIndex === 0 ? rows[rIdx] : data[rIdx]?.[dataColIndex];
          if (compareValuesByOperator(colSourceOption.operator, cellValue, colSelectorValue)) {
            foundRowIndex = rIdx;
            break;
          }
        }
        
        if (foundRowIndex !== -1) {
          // On a trouvÃƒÂ© la ligne avec l'opÃƒÂ©rateur, rÃƒÂ©cupÃƒÂ©rer la valeur depuis cette ligne pour chaque colonne ÃƒÂ  afficher
          for (const fixedColValue of displayColumns) {
            const normalizedFixedCol = String(fixedColValue).trim().toLowerCase();
            const fixedColInCols = columns.findIndex(c => String(c).trim().toLowerCase() === normalizedFixedCol);
            const fixedColInRows = rows.findIndex(r => String(r).trim().toLowerCase() === normalizedFixedCol);
            let colIndexForDisplay = -1;
            if (fixedColInCols !== -1) colIndexForDisplay = fixedColInCols;
            else if (fixedColInRows !== -1) colIndexForDisplay = fixedColInRows;
            
            if (colIndexForDisplay !== -1) {
              // Utiliser foundRowIndex (la ligne trouvÃƒÂ©e par l'opÃƒÂ©rateur) et colIndexForDisplay
              const dataColIndexForDisplay = colIndexForDisplay - 1;
              const result = data[foundRowIndex]?.[dataColIndexForDisplay];
              results.push({ row: fixedColValue, value: result });
            }
          }
          targetColIndex = colSelectorIndex; // Marquer qu'on a traitÃƒÂ© avec l'opÃƒÂ©rateur
        }
      } else {
        console.warn(`[TABLE] Ã¢Å¡Â Ã¯Â¸Â MODE 1 - Colonne de comparaison non trouvÃƒÂ©e: ${comparisonColName}`);
      }
    }

    // Boucle sur CHAQUE ligne ÃƒÂ  afficher (UNIQUEMENT si Option 2 n'a pas trouvÃƒÂ© de match)
    if (targetColIndex === -1) {
      // Ã°Å¸â€Â¥ NOUVEAU: Pour les options CHAMP / CAPACITÃƒâ€° sans opÃƒÂ©rateur, lire la valeur numÃƒÂ©rique et trouver la ligne la plus proche (prioritÃƒÂ© au supÃƒÂ©rieur)
      const hasOperatorConfig = Boolean(colSourceOption?.operator && colSourceOption?.comparisonColumn);
      const isNumericSourceWithoutOperator = (colSourceOption?.type === 'capacity' || colSourceOption?.type === 'field') && !hasOperatorConfig;
      if (isNumericSourceWithoutOperator) {
        const optionLabel = colSourceOption?.type === 'field' ? 'Option 2' : 'Option 3';

        const match = findClosestIndexInLabels(colSelectorValue, rows, validRowIndices);
        if (match) {
          const foundRowIndex = match.index;

          for (const fixedColValue of displayColumns) {
            const normalizedFixedCol = normalizeLookupValue(fixedColValue);
            const fixedColInCols = columns.findIndex(c => normalizeLookupValue(c) === normalizedFixedCol);
            const fixedColInRows = rows.findIndex(r => normalizeLookupValue(r) === normalizedFixedCol);
            let colIndexForDisplay = -1;
            if (fixedColInCols !== -1) colIndexForDisplay = fixedColInCols;
            else if (fixedColInRows !== -1) colIndexForDisplay = fixedColInRows;

            if (colIndexForDisplay !== -1) {
              const dataColIndexForDisplay = colIndexForDisplay - 1;
              const result = data[foundRowIndex]?.[dataColIndexForDisplay];
              results.push({ row: fixedColValue, value: result });
            }
          }
          targetColIndex = 0;
        } else {
          console.warn(`[TABLE] Ã¢Å¡Â Ã¯Â¸Â MODE 1 ${optionLabel} - Impossible de trouver une ligne pour ${colSelectorValue}`);
        }
      }
      
      // Cas standard: Option 1/2 oÃƒÂ¹ colSelectorValue est un nom de colonne
      if (targetColIndex === -1) {
        for (const fixedRowValue of displayColumns) {
          // Normalisation pour matching robuste
          // Ã°Å¸â€Â§ FIX: Enlever le suffixe (-1, -2, etc.) pour les champs copiÃƒÂ©s dans les repeaters
          const colSelectorWithoutSuffix = String(colSelectorValue).replace(/-\d+$/, '');
          const normalizedColSelector = colSelectorWithoutSuffix.trim().toLowerCase();
          const normalizedFixedRow = String(fixedRowValue).trim().toLowerCase();
          
          // Chercher dans colonnes ET lignes (auto-dÃƒÂ©tection)
          const colSelectorInCols = columns.findIndex(c => String(c).trim().toLowerCase() === normalizedColSelector);
          const colSelectorInRows = rows.findIndex(r => String(r).trim().toLowerCase() === normalizedColSelector);
          const fixedRowInRows = rows.findIndex(r => String(r).trim().toLowerCase() === normalizedFixedRow);
          const fixedRowInCols = columns.findIndex(c => String(c).trim().toLowerCase() === normalizedFixedRow);
          
          // DÃƒÂ©terminer les index finaux (privilÃƒÂ©gier le matching naturel)
          let colIndex = -1;
          let rowIndex = -1;
          
          if (colSelectorInCols !== -1 && fixedRowInRows !== -1) {
            // Configuration normale
            colIndex = colSelectorInCols;
            rowIndex = fixedRowInRows;
          } else if (colSelectorInRows !== -1 && fixedRowInCols !== -1) {
            // Configuration inversÃƒÂ©e (auto-correction)
            colIndex = fixedRowInCols;
            rowIndex = colSelectorInRows;
          } else {
            // Matching partiel
            colIndex = colSelectorInCols !== -1 ? colSelectorInCols : colSelectorInRows;
            rowIndex = fixedRowInRows !== -1 ? fixedRowInRows : fixedRowInCols;
          }
          
          if (colIndex !== -1 && rowIndex !== -1) {
            // Lookup dans data (avec dÃƒÂ©calage header)
            const dataRowIndex = rowIndex;
            const dataColIndex = colIndex - 1;
            const result = data[dataRowIndex]?.[dataColIndex];
            
            results.push({ row: fixedRowValue, value: result });
          }
        }
      }
    }
    
    // Construire le rÃƒÂ©sultat final
    const resultText = results.map(r => `${r.row}=${r.value}`).join(', ');
    const resultValues = results.map(r => r.value);
    const humanText = `Table "${table.name}"[${colLabel}=${colSelectorValue}, ${displayColumns.join('+')}(fixes)] = ${resultText}`;
    
    return {
      result: resultValues.length === 1 ? String(resultValues[0]) : JSON.stringify(resultValues),
      humanText,
      details: {
        type: 'table',
        mode: 1,
        tableId: table.id,
        tableName: table.name,
        lookup: {
          column: { field: colLabel, value: colSelectorValue },
          rows: results,
          multiple: results.length > 1
        }
      }
    };
  }
  
  // MODE 2 : Seulement LIGNE activÃƒÂ©e (croisement avec displayRow fixe)
  else if (rowEnabled && !colEnabled && hasRowSelector && lookup.displayRow) {
    
    // Ã°Å¸â€Â¥ NOUVEAU: Support des 3 options de source (SELECT/CHAMP/CAPACITÃƒâ€°)
    const rowSelectorValue = await getSourceValue(
      rowSourceOption,
      lookup,
      rowFieldId,
      submissionId,
      prisma,
      valuesCache,
      depth,
      valueMap,
      labelMap
    );
    const rowLabel = await getSourceLabel(rowSourceOption, lookup, rowFieldId, prisma, labelMap);
    
    // displayRow peut ÃƒÂªtre un string OU un array
    const displayRows = Array.isArray(lookup.displayRow) 
      ? lookup.displayRow 
      : [lookup.displayRow];
    
    
    if (!rowSelectorValue) {
      return {
        result: 'Ã¢Ë†â€¦',
        humanText: `Table "${table.name}" - Aucune sÃƒÂ©lection ligne`,
        details: { type: 'table', mode: 2, error: 'No row selection' }
      };
    }
    
    // Faire le lookup avec rowSelectorValue et CHAQUE displayRow
    // columns, rows, data dÃƒÂ©jÃƒÂ  reconstruits plus haut
    
    const results: Array<{ column: string; value: any }> = [];
    
    // Mode extract : si lookup.extractValueRef est configurÃƒÂ©, chercher la premiÃƒÂ¨re colonne qui match dans la ligne choisie
    if (lookup.extractValueRef) {
      const refResult = await interpretReference(lookup.extractValueRef, submissionId, prisma, valuesCache, depth + 1, valueMap, labelMap);
      const targetValue = refResult.result;
      // Determining row index from rowSelectorValue
      const normalizedRowSelector = String(rowSelectorValue || '').trim().toLowerCase();
      const rowSelectorInRows = rows.findIndex(r => String(r).trim().toLowerCase() === normalizedRowSelector);
      const rowSelectorInCols = columns.findIndex(c => String(c).trim().toLowerCase() === normalizedRowSelector);
      let finalRowIndex = -1;
      if (rowSelectorInRows !== -1) finalRowIndex = rowSelectorInRows; else finalRowIndex = rowSelectorInCols;
      if (finalRowIndex === -1) {
        console.warn(`[TABLE] Ã¢Å¡Â Ã¯Â¸Â MODE 2 extract - ligne non trouvÃƒÂ©e pour selector ${rowSelectorValue}`);
      } else {
        const dataRowIndex = finalRowIndex;
        // iterate across columns
        let foundColIndex = -1;
        for (let cIdx = 0; cIdx < columns.length; cIdx++) {
          const valueAt = data[dataRowIndex]?.[cIdx - 1];
          if (compareValuesByOperator(lookup.extractOperator, valueAt, targetValue)) {
            foundColIndex = cIdx;
            break;
          }
        }
        if (foundColIndex !== -1) {
          // now build results: for each fixedColValue, get value from data[dataRowIndex][foundColIndex-1]
          for (const fixedColValue of displayRows) {
            const normalizedFixedCol = String(fixedColValue).trim().toLowerCase();
            const fixedColInCols = columns.findIndex(c => String(c).trim().toLowerCase() === normalizedFixedCol);
            const fixedColInRows = rows.findIndex(r => String(r).trim().toLowerCase() === normalizedFixedCol);
            let colIndex = -1;
            if (fixedColInCols !== -1) colIndex = fixedColInCols;
            else if (fixedColInRows !== -1) colIndex = fixedColInRows; // fallback if reversed
            if (colIndex !== -1) {
              const dataColIndex = colIndex - 1;
              const result = data[dataRowIndex]?.[dataColIndex];
              results.push({ column: fixedColValue, value: result });
            }
          }
          const resultText = results.map(r => `${r.column}=${r.value}`).join(', ');
          const resultValues = results.map(r => r.value);
          const humanText = `Table "${table.name}"[extract ${lookup.extractValueRef} ${lookup.extractOperator} -> col=${columns[foundColIndex]}] = ${resultText}`;
          return {
            result: resultValues.length === 1 ? String(resultValues[0]) : JSON.stringify(resultValues),
            humanText,
            details: {
              type: 'table',
              mode: 2,
              tableId: table.id,
              tableName: table.name,
              lookup: {
                row: { field: rowLabel, value: rowSelectorValue },
                columns: results,
                multiple: results.length > 1,
                extract: { ref: lookup.extractValueRef, operator: lookup.extractOperator, target: targetValue }
              }
            }
          };
        }
      }
    }

    // Ã°Å¸â€Â¥ NOUVEAU: Pour Option 2 (CHAMP) et Option 3 (CAPACITÃƒâ€°) avec opÃƒÂ©rateur, chercher la colonne qui match l'opÃƒÂ©rateur
    let targetRowIndex = -1;
    if ((rowSourceOption?.type === 'field' || rowSourceOption?.type === 'capacity') && rowSourceOption?.operator && rowSourceOption?.comparisonColumn) {
      
      // Utiliser directement comparisonColumn au lieu de deviner
      const comparisonRowName = rowSourceOption.comparisonColumn;
      const normalizedComparisonRow = String(comparisonRowName).trim().toLowerCase();
      const rowSelectorInRows = rows.findIndex(r => String(r).trim().toLowerCase() === normalizedComparisonRow);
      const rowSelectorInCols = columns.findIndex(c => String(c).trim().toLowerCase() === normalizedComparisonRow);
      
      let rowSelectorIndex = -1;
      if (rowSelectorInRows !== -1) rowSelectorIndex = rowSelectorInRows;
      else if (rowSelectorInCols !== -1) rowSelectorIndex = rowSelectorInCols;
      
      if (rowSelectorIndex !== -1) {
        // Ã°Å¸â€Â¥ FIX: Si rowSelectorIndex = 0 (premiÃƒÂ¨re ligne), les valeurs sont dans rows[], pas data[]
        // Pour data[], on doit mapper l'index correctement
        let foundColIndex = -1;
        for (let cIdx = 0; cIdx < columns.length; cIdx++) {
          // Si on compare la premiÃƒÂ¨re ligne (index 0), prendre la valeur depuis columns[], pas data[]
          const cellValue = rowSelectorIndex === 0 ? columns[cIdx] : data[rowSelectorIndex - 1]?.[cIdx - 1];
          if (compareValuesByOperator(rowSourceOption.operator, cellValue, rowSelectorValue)) {
            foundColIndex = cIdx;
            break;
          }
        }
        
        if (foundColIndex !== -1) {
          // On a trouvÃƒÂ© la colonne avec l'opÃƒÂ©rateur, rÃƒÂ©cupÃƒÂ©rer la valeur depuis chaque ligne pour cette colonne
          const dataColIndexForFound = foundColIndex - 1;
          for (const fixedRowValue of displayRows) {
            const normalizedFixedRow = String(fixedRowValue).trim().toLowerCase();
            const fixedRowInRows = rows.findIndex(r => String(r).trim().toLowerCase() === normalizedFixedRow);
            const fixedRowInCols = columns.findIndex(c => String(c).trim().toLowerCase() === normalizedFixedRow);
            let rowIndexForDisplay = -1;
            if (fixedRowInRows !== -1) rowIndexForDisplay = fixedRowInRows;
            else if (fixedRowInCols !== -1) rowIndexForDisplay = fixedRowInCols;
            
            if (rowIndexForDisplay !== -1) {
              // Utiliser rowIndexForDisplay (la ligne ÃƒÂ  afficher) et la colonne trouvÃƒÂ©e par l'opÃƒÂ©rateur
              // Ã°Å¸â€Â¥ FIX: GÃƒÂ©rer le cas oÃƒÂ¹ rowIndexForDisplay === 0
              const result = rowIndexForDisplay === 0 ? columns[foundColIndex] : data[rowIndexForDisplay - 1]?.[dataColIndexForFound];
              results.push({ column: fixedRowValue, value: result });
            }
          }
          targetRowIndex = rowSelectorIndex; // Marquer qu'on a traitÃƒÂ© avec l'opÃƒÂ©rateur
        }
      } else {
        console.warn(`[TABLE] Ã¢Å¡Â Ã¯Â¸Â MODE 2 - Ligne de comparaison non trouvÃƒÂ©e: ${comparisonRowName}`);
      }
    }

    // Boucle sur CHAQUE colonne ÃƒÂ  afficher (UNIQUEMENT si Option 2 n'a pas trouvÃƒÂ© de match)
    if (targetRowIndex === -1) {
      const hasRowOperatorConfig = Boolean(rowSourceOption?.operator && rowSourceOption?.comparisonColumn);
      const isRowNumericSource = (rowSourceOption?.type === 'field' || rowSourceOption?.type === 'capacity') && !hasRowOperatorConfig;

      if (isRowNumericSource) {
        const optionLabel = rowSourceOption?.type === 'field' ? 'Option 2' : 'Option 3';

        const match = findClosestIndexInLabels(rowSelectorValue, rows);
        if (match) {
          const foundRowIndex = match.index;

          for (const fixedColValue of displayRows) {
            const normalizedFixedCol = normalizeLookupValue(fixedColValue);
            const fixedColInCols = columns.findIndex(c => normalizeLookupValue(c) === normalizedFixedCol);
            const fixedColInRows = rows.findIndex(r => normalizeLookupValue(r) === normalizedFixedCol);
            let colIndexForDisplay = -1;
            if (fixedColInCols !== -1) colIndexForDisplay = fixedColInCols;
            else if (fixedColInRows !== -1) colIndexForDisplay = fixedColInRows;

            if (colIndexForDisplay !== -1) {
              const dataColIndexForDisplay = colIndexForDisplay - 1;
              const result = data[foundRowIndex]?.[dataColIndexForDisplay];
              results.push({ column: fixedColValue, value: result });
            }
          }

          const resultText = results.map(r => `${r.column}=${r.value}`).join(', ');
          const resultValues = results.map(r => r.value);
          const humanText = `Table "${table.name}"[${rowLabel}=${rowSelectorValue}, ${displayRows.join('+')}(fixes)] = ${resultText}`;

          return {
            result: resultValues.length === 1 ? String(resultValues[0]) : JSON.stringify(resultValues),
            humanText,
            details: {
              type: 'table',
              mode: 2,
              tableId: table.id,
              tableName: table.name,
              lookup: {
                row: { field: rowLabel, value: rowSelectorValue },
                columns: results,
                multiple: results.length > 1
              }
            }
          };
        } else {
          console.warn(`[TABLE] Ã¢Å¡Â Ã¯Â¸Â MODE 2 ${optionLabel} - Impossible de trouver une ligne pour ${rowSelectorValue}`);
        }
      }

      for (const fixedColValue of displayRows) {
        // Normalisation
        const normalizedRowSelector = String(rowSelectorValue).trim().toLowerCase();
        const normalizedFixedCol = String(fixedColValue).trim().toLowerCase();
        
        // Chercher dans colonnes ET lignes (auto-dÃƒÂ©tection)
        const rowSelectorInRows = rows.findIndex(r => String(r).trim().toLowerCase() === normalizedRowSelector);
        const rowSelectorInCols = columns.findIndex(c => String(c).trim().toLowerCase() === normalizedRowSelector);
        const fixedColInCols = columns.findIndex(c => String(c).trim().toLowerCase() === normalizedFixedCol);
        const fixedColInRows = rows.findIndex(r => String(r).trim().toLowerCase() === normalizedFixedCol);
        
        // DÃƒÂ©terminer les index finaux (privilÃƒÂ©gier le matching naturel)
        let rowIndex = -1;
        let colIndex = -1;
        
        if (rowSelectorInRows !== -1 && fixedColInCols !== -1) {
          // Configuration normale
          rowIndex = rowSelectorInRows;
          colIndex = fixedColInCols;
        } else if (rowSelectorInCols !== -1 && fixedColInRows !== -1) {
          // Configuration inversÃƒÂ©e (auto-correction)
          rowIndex = fixedColInRows;
          colIndex = rowSelectorInCols;
        } else {
          // Matching partiel
          rowIndex = rowSelectorInRows !== -1 ? rowSelectorInRows : rowSelectorInCols;
          colIndex = fixedColInCols !== -1 ? fixedColInCols : fixedColInRows;
        }
        
        if (rowIndex !== -1 && colIndex !== -1) {
          // Lookup dans data
          const dataRowIndex = rowIndex;
          const dataColIndex = colIndex - 1;
          const result = data[dataRowIndex]?.[dataColIndex];
          
          results.push({ column: fixedColValue, value: result });
        }
      }
    }
    
    // Construire le rÃƒÂ©sultat final
    const resultText = results.map(r => `${r.column}=${r.value}`).join(', ');
    const resultValues = results.map(r => r.value);
    const humanText = `Table "${table.name}"[${rowLabel}=${rowSelectorValue}, ${displayRows.join('+')}(fixes)] = ${resultText}`;
    
    return {
      result: resultValues.length === 1 ? String(resultValues[0]) : JSON.stringify(resultValues),
      humanText,
      details: {
        type: 'table',
        mode: 2,
        tableId: table.id,
        tableName: table.name,
        lookup: {
          row: { field: rowLabel, value: rowSelectorValue },
          columns: results,
          multiple: results.length > 1
        }
      }
    };
  }
  

  
  // Ã¢ÂÅ’ Configuration invalide
  else {
    console.error(`[TABLE] Ã¢ÂÅ’ Configuration lookup invalide`);
    return {
      result: 'Ã¢Ë†â€¦',
      humanText: `Configuration lookup invalide pour table ${table.name}`,
      details: { type: 'table', error: 'Invalid configuration' }
    };
  }
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€œÅ  MODE 3 : Code existant (croisement dynamique colonne Ãƒâ€” ligne)
  // Ce code s'exÃƒÂ©cute SEULEMENT si on est en MODE 3
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€œÅ  Ãƒâ€°TAPE 4 : RÃƒÂ©cupÃƒÂ©rer les valeurs sÃƒÂ©lectionnÃƒÂ©es par l'utilisateur
  // Ã°Å¸â€Â¥ NOUVEAU: Support des 3 options de source (SELECT/CHAMP/CAPACITÃƒâ€°)
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  let rowSelectorValue = await getSourceValue(
    rowSourceOption,
    lookup,
    rowFieldId,
    submissionId,
    prisma,
    valuesCache,
    depth,
    valueMap,
    labelMap
  );
  let colSelectorValue = await getSourceValue(
    colSourceOption,
    lookup,
    colFieldId,
    submissionId,
    prisma,
    valuesCache,
    depth,
    valueMap,
    labelMap
  );
  const rowLabel = await getSourceLabel(rowSourceOption, lookup, rowFieldId, prisma, labelMap);
  const colLabel = await getSourceLabel(colSourceOption, lookup, colFieldId, prisma, labelMap);
  const rowSourceType = rowSourceOption?.type || (rowFieldId ? 'select' : undefined);
  const colSourceType = colSourceOption?.type || (colFieldId ? 'select' : undefined);
  
  
  if (!rowSelectorValue || !colSelectorValue) {
    return {
      result: 'Ã¢Ë†â€¦',
      humanText: `Table "${table.name}"[${rowLabel}(${rowSelectorValue || '?'}), ${colLabel}(${colSelectorValue || '?'})] = aucune sÃƒÂ©lection`,
      details: { type: 'table', error: 'Missing selection' }
    };
  }
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸Å½Â¯ Ãƒâ€°TAPE 5 : Trouver les index dans rows[] et columns[]
  // Ã¯Â¿Â½ AUTO-DÃƒâ€°TECTION : On cherche chaque valeur dans rows ET columns pour dÃƒÂ©terminer
  //    automatiquement oÃƒÂ¹ elle se trouve (inversion automatique si nÃƒÂ©cessaire)
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // columns, rows, data dÃƒÂ©jÃƒÂ  reconstruits plus haut
  
  // Ã¯Â¿Â½Ã°Å¸Ââ€º DEBUG : Afficher toutes les valeurs AVANT la normalisation
  
  // Ã°Å¸Â§Â¹ NORMALISATION : Trim + lowercase pour matching robuste
  const normalizedRowSelector = String(rowSelectorValue).trim().toLowerCase();
  const normalizedColSelector = String(colSelectorValue).trim().toLowerCase();
  
  
  // Ã°Å¸â€Â Chercher rowSelectorValue dans rows ET columns
  let rowSelectorInRows = rows.findIndex(r => String(r).trim().toLowerCase() === normalizedRowSelector);
  let rowSelectorInCols = columns.findIndex(c => String(c).trim().toLowerCase() === normalizedRowSelector);
  
  // Ã°Å¸â€Â Chercher colSelectorValue dans rows ET columns
  let colSelectorInRows = rows.findIndex(r => String(r).trim().toLowerCase() === normalizedColSelector);
  let colSelectorInCols = columns.findIndex(c => String(c).trim().toLowerCase() === normalizedColSelector);

  if (rowSelectorInRows === -1 && rowSelectorInCols === -1 && (rowSourceType === 'field' || rowSourceType === 'capacity')) {
    const rowMatch = findClosestIndexInLabels(rowSelectorValue, rows);
    if (rowMatch) {
      rowSelectorInRows = rowMatch.index;
      rowSelectorValue = String(rows[rowMatch.index]);
    } else {
      const columnIndices = columns.map((_, idx) => idx).filter(idx => idx > 0);
      const colMatch = findClosestIndexInLabels(rowSelectorValue, columns, columnIndices);
      if (colMatch) {
        rowSelectorInCols = colMatch.index;
        rowSelectorValue = String(columns[colMatch.index]);
      }
    }
  }

  if (colSelectorInCols === -1 && colSelectorInRows === -1 && (colSourceType === 'field' || colSourceType === 'capacity')) {
    const columnIndices = columns.map((_, idx) => idx).filter(idx => idx > 0);
    const colMatch = findClosestIndexInLabels(colSelectorValue, columns, columnIndices);
    if (colMatch) {
      colSelectorInCols = colMatch.index;
      colSelectorValue = String(columns[colMatch.index]);
    } else {
      const rowMatch = findClosestIndexInLabels(colSelectorValue, rows);
      if (rowMatch) {
        colSelectorInRows = rowMatch.index;
        colSelectorValue = String(rows[rowMatch.index]);
      }
    }
  }
  
  
  // Ã°Å¸Å½Â¯ DÃƒÂ©terminer les index finaux (avec auto-correction de l'inversion)
  let finalRowIndex = -1;
  let finalColIndex = -1;
  let actualRowValue = '';
  let actualColValue = '';
  
  // StratÃƒÂ©gie : PrivilÃƒÂ©gier le matching le plus "naturel"
  // Si rowSelector est dans rows ET colSelector est dans columns Ã¢â€ â€™ OK
  // Si rowSelector est dans columns ET colSelector est dans rows Ã¢â€ â€™ INVERSION
  
  if (rowSelectorInRows !== -1 && colSelectorInCols !== -1) {
    // Ã¢Å“â€¦ CAS NORMAL : pas d'inversion
    finalRowIndex = rowSelectorInRows;
    finalColIndex = colSelectorInCols;
    actualRowValue = String(rowSelectorValue);
    actualColValue = String(colSelectorValue);
  } else if (rowSelectorInCols !== -1 && colSelectorInRows !== -1) {
    // Ã°Å¸â€â€ž CAS INVERSÃƒâ€° : on utilise directement les bons index
    finalRowIndex = colSelectorInRows;
    finalColIndex = rowSelectorInCols;
    actualRowValue = String(colSelectorValue);
    actualColValue = String(rowSelectorValue);
  } else {
    // Ã¢ÂÅ’ Aucun matching trouvÃƒÂ© (ou matching partiel)
    finalRowIndex = rowSelectorInRows !== -1 ? rowSelectorInRows : colSelectorInRows;
    finalColIndex = rowSelectorInCols !== -1 ? rowSelectorInCols : colSelectorInCols;
    actualRowValue = String(rowSelectorValue);
    actualColValue = String(colSelectorValue);
  }
  
  // Ã°Å¸Ââ€º DEBUG : Afficher toutes les lignes/colonnes disponibles
  
  
  if (finalRowIndex === -1 || finalColIndex === -1) {
    // Valeur introuvable - silencieux
    return {
      result: 'Ã¢Ë†â€¦',
      humanText: `Table "${table.name}"[${actualRowValue}, ${actualColValue}] = valeur introuvable`,
      details: { type: 'table', error: 'Value not found in rows/columns' }
    };
  }
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€œÂ Ãƒâ€°TAPE 6 : Faire le lookup dans data[][]
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // IMPORTANT : rows[] a ÃƒÂ©tÃƒÂ© construit en SKIPPANT rowIndex=0 (header) Ã¢â€ â€™ pas de dÃƒÂ©calage
  // MAIS columns[] contient TOUTES les colonnes y compris columns[0]="Orientation" (label)
  // alors que data[][] a ÃƒÂ©tÃƒÂ© construit avec cellsData.slice(1) Ã¢â€ â€™ dÃƒÂ©calage de -1 sur les colonnes
  // Exemple : "25" trouvÃƒÂ© ÃƒÂ  columns[4] Ã¢â€ â€™ data[x][3] car data ne contient pas la colonne de labels
  const dataRowIndex = finalRowIndex;
  const dataColIndex = finalColIndex - 1;
  
  
  if (dataRowIndex < 0 || dataColIndex < 0 || !data[dataRowIndex]) {
    console.error(`[TABLE] Ã¢ÂÅ’ Index hors limites`);
    return {
      result: 'Ã¢Ë†â€¦',
      humanText: `Table "${table.name}"[${actualRowValue}, ${actualColValue}] = hors limites`,
      details: { type: 'table', error: 'Index out of bounds' }
    };
  }
  
  const result = data[dataRowIndex][dataColIndex];
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€œÂ Ãƒâ€°TAPE 7 : Construire le texte humain
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const humanText = `Table "${table.name}"[${rowLabel}=${actualRowValue}, ${colLabel}=${actualColValue}] = ${result}`;
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€œÂ¤ Ãƒâ€°TAPE 8 : Retourner le rÃƒÂ©sultat structurÃƒÂ©
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  return {
    result: String(result),
    humanText,
    details: {
      type: 'table',
      tableId: table.id,
      tableName: table.name,
      lookup: {
        row: {
          field: rowLabel,
          fieldId: rowFieldId,
          value: actualRowValue,
          index: finalRowIndex
        },
        column: {
          field: colLabel,
          fieldId: colFieldId,
          value: actualColValue,
          index: finalColIndex
        },
        result
      }
    }
  };
}

// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
// Ã°Å¸â€œÂ MODULE 7 : INTERPRÃƒâ€°TATION DES CHAMPS SIMPLES
// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â

/**
 * Ã°Å¸â€œÂ INTERPRÃƒË†TE UN CHAMP SIMPLE
 * 
 * Cette fonction rÃƒÂ©cupÃƒÂ¨re simplement la valeur d'un champ saisi par l'utilisateur.
 * C'est le cas le plus simple (pas de calcul, juste rÃƒÂ©cupÃƒÂ©ration).
 * 
 * @param fieldId - ID du champ
 * @param submissionId - ID de la soumission
 * @param prisma - Instance Prisma Client
 * @returns RÃƒÂ©sultat interprÃƒÂ©tÃƒÂ©
 */
async function interpretField(
  fieldId: string,
  submissionId: string,
  prisma: PrismaClient,
  valueMap?: Map<string, unknown>,
  labelMap?: Map<string, string>
): Promise<InterpretResult> {
  
  
  // Ã¢Å¡Â Ã¯Â¸Â FALLBACK: Si l'UUID nu n'est pas un champ valide, vÃƒÂ©rifier si c'est une table
  const node = await prisma.treeBranchLeafNode.findUnique({
    where: { id: fieldId },
    select: { type: true, label: true }
  });
  
  
  // Si c'est une table (identifiÃƒÂ©e comme table en base), rediriger vers interpretTable
  if (node && node.type) {
    if (node.type.startsWith('leaf_table_')) {
      return await interpretTable(fieldId, submissionId, prisma, new Map(), 0, valueMap, labelMap);
    }
    
    // VÃƒÂ©rifier aussi les autres prefixes de table
    if (node.type.includes('table')) {
      return await interpretTable(fieldId, submissionId, prisma, new Map(), 0, valueMap, labelMap);
    }
  }
  
  // RÃƒÂ©cupÃƒÂ©rer la valeur et le label (prioritÃƒÂ© valueMap pour mode preview)
  const value = await getNodeValue(fieldId, submissionId, prisma, valueMap);
  const label = await getNodeLabel(fieldId, prisma, labelMap);
  
  // Ã°Å¸â€œÅ’ NOUVEAU: value ne peut jamais ÃƒÂªtre null/undefined car getNodeValue retourne "0" par dÃƒÂ©faut
  
  const humanText = `${label}(${value})`;
  
  return {
    result: value || '0',
    humanText,
    details: {
      type: 'field',
      fieldId,
      label,
      value
    }
  };
}

// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
// Ã°Å¸Å¡â‚¬ MODULE 8 : POINT D'ENTRÃƒâ€°E PRINCIPAL (API)
// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â

/**
 * Ã°Å¸Å½Â¯ FONCTION PRINCIPALE : Ãƒâ€°value une variable et toutes ses opÃƒÂ©rations
 * 
 * C'est LA fonction ÃƒÂ  appeler depuis les routes API pour ÃƒÂ©valuer une variable.
 * Elle gÃƒÂ¨re automatiquement toute la rÃƒÂ©cursion et retourne un rÃƒÂ©sultat complet.
 * 
 * PROCESSUS :
 * -----------
 * 1. Ã°Å¸â€œÂ¥ RÃƒÂ©cupÃƒÂ©rer la variable depuis TreeBranchLeafNodeVariable
 * 2. Ã°Å¸â€Â VÃƒÂ©rifier le sourceType (fixed, tree, api, etc.)
 * 3. Ã°Å¸â€â€ž Si tree, interprÃƒÂ©ter rÃƒÂ©cursivement la sourceRef
 * 4. Ã°Å¸â€œÂ¤ Retourner le rÃƒÂ©sultat complet (value, detail, humanText)
 * 
 * UTILISATION DANS L'API :
 * ------------------------
 * ```typescript
 * const result = await evaluateVariableOperation(
 *   "10bfb6d2-67ae-49a8-8d49-fc6dafa3f74e",  // nodeId de la variable
 *   "tbl-1759750447813-5n5y6oup4",            // submissionId
 *   prisma
 * );
 * 
 * // Stocker dans SubmissionData
 * await prisma.treeBranchLeafSubmissionData.upsert({
 *   where: { submissionId_nodeId: { submissionId, nodeId } },
 *   update: {
 *     value: result.value,
 *     operationDetail: result.operationDetail,
 *     operationResult: result.operationResult
 *   },
 *   create: { ... }
 * });
 * ```
 * 
 * @param variableNodeId - ID du nÃ…â€œud variable ÃƒÂ  ÃƒÂ©valuer
 * @param submissionId - ID de la soumission en cours
 * @param prisma - Instance Prisma Client
 * @returns RÃƒÂ©sultat complet avec value, detail et humanText
 * 
 * @throws Error si variable introuvable
 */
export async function evaluateVariableOperation(
  variableNodeId: string,
  submissionId: string,
  prisma: PrismaClient,
  valueMap?: Map<string, unknown>
): Promise<{
  value: string;
  operationDetail: any;
  operationResult: string;
  operationSource: 'condition' | 'formula' | 'table' | 'field' | 'fixed';
  sourceRef: string;
}> {
  
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€œÂ¥ Ãƒâ€°TAPE 0 : RÃƒÂ©cupÃƒÂ©rer d'abord le nÃ…â€œud pour avoir le treeId
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const variableNode = await prisma.treeBranchLeafNode.findUnique({
    where: { id: variableNodeId },
    select: { treeId: true }
  });
  const treeId = variableNode?.treeId;
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€œÂ¥ Ãƒâ€°TAPE 0b : Initialiser et enrichir les Maps avec le treeId
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const localValueMap = valueMap || new Map<string, unknown>();
  const labelMap = new Map<string, string>();
  
  // Enrichir automatiquement les donnÃƒÂ©es depuis la base AVEC le treeId
  await enrichDataFromSubmission(submissionId, prisma, localValueMap, labelMap, treeId);
  
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€œÂ¥ Ãƒâ€°TAPE 1 : RÃƒÂ©cupÃƒÂ©rer la variable
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  const variable = await prisma.treeBranchLeafNodeVariable.findUnique({
    where: { nodeId: variableNodeId },
    select: {
      id: true,
      nodeId: true,
      exposedKey: true,
      displayName: true,
      sourceType: true,
      sourceRef: true,
      fixedValue: true,
      defaultValue: true
    }
  });
  
  if (!variable) {
    // Variable introuvable - silencieux
    throw new Error(`Variable introuvable: ${variableNodeId}`);
  }
  
  
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  // Ã°Å¸â€Â Ãƒâ€°TAPE 2 : Traiter selon le sourceType
  // Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
  
  // CAS 1 : Valeur fixe
  if (variable.sourceType === 'fixed' && variable.fixedValue) {
    return {
      value: variable.fixedValue,
      operationDetail: { type: 'fixed', value: variable.fixedValue },
      operationResult: `Valeur fixe: ${variable.fixedValue}`,
      operationSource: 'fixed',
      sourceRef: variable.sourceRef || ''
    };
  }
  
  // CAS 2 : Source depuis le tree (condition/formule/table)
  if (variable.sourceType === 'tree' && variable.sourceRef) {
    
    // Ã°Å¸â€â€ž INTERPRÃƒâ€°TATION RÃƒâ€°CURSIVE COMPLÃƒË†TE
    const valuesCache = new Map<string, InterpretResult>();
    const result = await interpretReference(
      variable.sourceRef,
      submissionId,
      prisma,
      valuesCache,
      0,  // Profondeur initiale = 0
      localValueMap,
      labelMap
    );
    
    
    // DÃƒÂ©terminer l'operationSource
    let operationSource: 'condition' | 'formula' | 'table' | 'field' | 'fixed' = 'field';
    if (variable.sourceRef.includes('condition:')) operationSource = 'condition';
    else if (variable.sourceRef.includes('node-formula:')) operationSource = 'formula';
    else if (variable.sourceRef.includes('@table.')) operationSource = 'table';
    
    return {
      value: result.result,
      operationDetail: result.details,
      operationResult: result.humanText,
      operationSource,
      sourceRef: variable.sourceRef
    };
  }
  
  // CAS 2b : Ã°Å¸â€ â€¢ Source formule directe (sourceType === 'formula')
  if (variable.sourceType === 'formula' && variable.sourceRef) {
    
    // Ã°Å¸â€â€ž INTERPRÃƒâ€°TATION DE LA FORMULE
    const valuesCache = new Map<string, InterpretResult>();
    const result = await interpretReference(
      variable.sourceRef,
      submissionId,
      prisma,
      valuesCache,
      0,  // Profondeur initiale = 0
      localValueMap,
      labelMap
    );
    
    
    return {
      value: result.result,
      operationDetail: result.details,
      operationResult: result.humanText,
      operationSource: 'formula',
      sourceRef: variable.sourceRef
    };
  }
  
  // CAS 3 : Valeur par dÃƒÂ©faut
  return {
    value: variable.defaultValue || 'Ã¢Ë†â€¦',
    operationDetail: { type: 'default', value: variable.defaultValue },
    operationResult: `Valeur par dÃƒÂ©faut: ${variable.defaultValue || 'aucune'}`,
    operationSource: 'field',
    sourceRef: variable.sourceRef || ''
  };
}

// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â
// Ã°Å¸â€œÂ¤ EXPORTS
// Ã¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢ÂÃ¢â€¢Â

export {
  interpretReference,
  interpretCondition,
  interpretFormula,
  interpretTable,
  interpretField,
  identifyReferenceType,
  normalizeRef
};
