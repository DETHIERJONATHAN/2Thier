import React, { useCallback, useMemo } from 'react';
import { useDraggable, useDroppable } from '@dnd-kit/core';
import { TreeBranchLeafNode } from '../../types';
import { getNodeIcon } from '../../utils/iconUtils';
import { TreeBranchLeafRegistry } from '../../core/registry';

interface OptimizedStructureNodeProps {
  node: TreeBranchLeafNode;
  isSelected: boolean;
  isExpanded: boolean;
  hasChildren: boolean;
  depth: number;
  readOnly?: boolean;
  allNodes?: TreeBranchLeafNode[];
  onSelect: (node: TreeBranchLeafNode) => void;
  onToggleExpanded?: (nodeId: string) => void;
  onDoubleClick?: (node: TreeBranchLeafNode) => void;
  onEditNode?: (node: TreeBranchLeafNode) => void;
  onDuplicateNode?: (node: TreeBranchLeafNode) => void;
  onDeleteNode?: (nodeId: string) => void;
  onMoveUpNode?: (nodeId: string) => void;
  onMoveDownNode?: (nodeId: string) => void;
  onToggleNodeVisibility?: (nodeId: string) => void;
  onOpenNodeSettings?: (node: TreeBranchLeafNode) => void;
}

interface NodeLegacyExtras {
  required: boolean;
  hasValidation: boolean;
  exposedKey: string;
  hidden: boolean;
}

/**
 * üöÄ OptimizedStructureNode - Composant optimis√© pour les n≈ìuds de structure
 */
const OptimizedStructureNode: React.FC<OptimizedStructureNodeProps> = ({
  node,
  isSelected,
  isExpanded,
  hasChildren,
  depth,
  readOnly = false,
  allNodes = [],
  onSelect,
  onToggleExpanded,
  onDoubleClick,
  onEditNode,
  onDuplicateNode,
  onDeleteNode,
  onMoveUpNode,
  onMoveDownNode,
  onToggleNodeVisibility,
  onOpenNodeSettings
}) => {
  // D√©tecter si ce champ est dans une section
  const isFieldInSection = useMemo(() => {
    try {
      // Seulement pour les n≈ìuds feuilles (champs)
      if (!node?.type?.startsWith('leaf_')) return false;
      if (!allNodes || !Array.isArray(allNodes)) return false;
      
      return TreeBranchLeafRegistry.isFieldInSection(node, allNodes);
    } catch (error) {
      console.error('Error in isFieldInSection:', error);
      return false;
    }
  }, [node, allNodes]);

  // Configuration sp√©ciale pour les champs dans les sections
  const sectionConfig = useMemo(() => {
    try {
      if (!isFieldInSection || !node) return null;
      return TreeBranchLeafRegistry.getSectionDisplayConfig(node);
    } catch (error) {
      console.error('Error in getSectionDisplayConfig:', error);
      return null;
    }
  }, [isFieldInSection, node]);

  // React.memo pour √©viter les re-rendus inutiles
 * et optimise les performances du drag & drop
 */

import React, { memo, useCallback, useMemo } from 'react';
import { useDraggable, useDroppable } from '@dnd-kit/core';
import type { TreeBranchLeafNode } from '../../types';
import { TreeBranchLeafRegistry } from '../../core/registry';
import { NodeActionMenu } from './NodeActionMenu';

// Fonction pour obtenir l'ic√¥ne selon le type de n≈ìud (m√™me que dans la palette)
const getNodeIcon = (nodeType: string): string => {
  // logs r√©duits
  
  // Utiliser le registry pour avoir les M√äMES ic√¥nes que dans la palette
  const nodeTypeConfig = TreeBranchLeafRegistry.getNodeType(nodeType);
  if (nodeTypeConfig?.emoji) {
    return nodeTypeConfig.emoji;
  }
  
  // Fallback si pas trouv√© dans le registry
  switch (nodeType) {
    case 'branch':
    case 'section':
    case 'groupe':
    case 'category':
      return 'üåø'; // Comme dans la palette !
    
    // Types de feuilles
    case 'leaf_option':
      return '‚óã';
    case 'leaf_option_field':
      return '‚óê';  
    case 'leaf_field':
      return '‚óè';
    
    // Types de champs (fallback)
    case 'text':
    case 'input':
      return 'üìù';
    case 'number':
    case 'numeric':
      return 'üî¢';
    case 'select':
    case 'dropdown':
      return 'üìã';
    case 'checkbox':
    case 'boolean':
      return '‚òëÔ∏è';
    case 'date':
      return 'üìÖ';
    case 'email':
      return 'üìß';
    case 'phone':
      return 'üìû';
    case 'textarea':
      return 'üìÑ';
    case 'file':
    case 'upload':
      return 'üìé';
    case 'url':
    case 'link':
      return 'üîó';
    case 'color':
      return 'üé®';
    case 'range':
      return 'üéöÔ∏è';
    
    // Par d√©faut
    default:
      return 'üìÑ';
  }
};

interface OptimizedStructureNodeProps {
  node: TreeBranchLeafNode;
  isSelected: boolean;
  isExpanded: boolean;
  hasChildren: boolean;
  depth: number;
  readOnly?: boolean;
  allNodes?: TreeBranchLeafNode[]; // Pour d√©tecter les sections parentes
  onSelect: (node: TreeBranchLeafNode) => void;
  onToggleExpanded: (nodeId: string) => void;
  onDoubleClick: (node: TreeBranchLeafNode) => void;
  // Actions du menu contextuel
  onEditNode?: (node: TreeBranchLeafNode, newLabel: string) => void;
  onDuplicateNode?: (node: TreeBranchLeafNode) => void;
  onDeleteNode?: (node: TreeBranchLeafNode) => void;
  onMoveUpNode?: (node: TreeBranchLeafNode) => void;
  onMoveDownNode?: (node: TreeBranchLeafNode) => void;
  onToggleNodeVisibility?: (node: TreeBranchLeafNode) => void;
  onOpenNodeSettings?: (node: TreeBranchLeafNode) => void;
}

const OptimizedStructureNodeComponent: React.FC<OptimizedStructureNodeProps> = ({
  node,
  isSelected,
  isExpanded,
  hasChildren,
  depth,
  readOnly = false,
  onSelect,
  onToggleExpanded,
  onDoubleClick,
  onEditNode,
  onDuplicateNode,
  onDeleteNode,
  onMoveUpNode,
  onMoveDownNode,
  onToggleNodeVisibility,
  onOpenNodeSettings
}) => {
  
  // =============================================================================
  // üéõÔ∏è DRAGGABLE - Configuration du drag
  // =============================================================================
  
  const dragData = useMemo(() => {
    const data = {
      type: 'node',
      nodeType: node.type,
      id: node.id,
      hasData: Boolean(node.value || node.defaultValue),
      exposedKey: node.exposedKey
    };
    console.log(`üèóÔ∏è Drag data pr√©par√© pour node ${node.id}:`, data);
    return data;
  }, [node.type, node.id, node.value, node.defaultValue, node.exposedKey]);

  const {
    attributes: dragAttributes,
    listeners: dragListeners,
  setNodeRef: setDragRef,
    isDragging
  } = useDraggable({
    id: `node-${node.id}`,
    data: dragData,
  disabled: readOnly,
  // Emp√™che le drag sur simple clic: il faut bouger la souris d'au moins 8px
  activationConstraint: { distance: 8 }
  });
  
  // logs r√©duits

  // =============================================================================
  // üéØ DROPPABLE - Trois zones: avant / enfant / apr√®s
  // =============================================================================
  const { setNodeRef: setDropBeforeRef, isOver: isOverBefore } = useDroppable({
    id: `drop-${node.id}-before`,
    data: { type: 'structure', nodeId: node.id, position: 'before', accepts: ['palette-item', 'node'] },
    disabled: readOnly
  });
  const { setNodeRef: setDropChildRef, isOver: isOverChild } = useDroppable({
    id: `drop-${node.id}-child`,
    data: { type: 'structure', nodeId: node.id, position: 'child', accepts: ['palette-item', 'node'] },
    disabled: readOnly
  });
  const { setNodeRef: setDropAfterRef, isOver: isOverAfter } = useDroppable({
    id: `drop-${node.id}-after`,
    data: { type: 'structure', nodeId: node.id, position: 'after', accepts: ['palette-item', 'node'] },
    disabled: readOnly
  });

  // =============================================================================
  // üé¨ HANDLERS - Gestionnaires d'√©v√©nements m√©moris√©s
  // =============================================================================
  
  const handleClick = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    onSelect(node);
    if (onOpenNodeSettings) onOpenNodeSettings(node);
  }, [node, onSelect, onOpenNodeSettings]);

  const handleDoubleClick = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
  console.log(`üëÜüëÜ [OptimizedStructureNode] Double-clic sur ${node.label} - toggle expand`);
    onDoubleClick(node);
  }, [node, onDoubleClick]);

  const handleToggle = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    onToggleExpanded(node.id);
  }, [node.id, onToggleExpanded]);

  // =============================================================================
  // üé® STYLING - Styles m√©moris√©s
  // =============================================================================
  
  const nodeStyle = useMemo(() => {
    // üîç DEBUG: Log de l'indentation
  // logs r√©duits
  const anyOver = isOverBefore || isOverChild || isOverAfter;
    
    const indent = depth * 40; // üîß Indentation r√©duite: 40px par niveau
    
    // Style de base
    const baseStyle = {
      marginLeft: `${indent}px`,
      padding: '2px 6px',
      cursor: readOnly ? 'default' : 'pointer',
      backgroundColor: isSelected 
        ? '#e6f3ff' 
    : anyOver 
          ? '#f0f8ff' 
          : 'transparent',
      border: isSelected ? '1px solid #1890ff' : '1px solid transparent',
      borderRadius: '4px',
      opacity: isDragging ? 0.5 : 1,
      fontSize: '12px',
      lineHeight: '18px',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'flex-start',
      gap: '4px',
      userSelect: 'none',
      transition: 'all 0.15s ease',
      margin: '0px 0'
    };

    // Style sp√©cial pour les champs dans les sections
    if (isFieldInSection && sectionConfig) {
      return {
        ...baseStyle,
        backgroundColor: isSelected ? '#e6f3ff' : '#fafafa',
        border: isSelected ? '1px solid #1890ff' : '1px solid #d9d9d9',
        borderRadius: '6px',
        padding: '6px 12px',
        margin: '2px 0',
        position: 'relative' as const,
        boxShadow: '0 1px 2px rgba(0,0,0,0.05)'
      };
    }

    return baseStyle;
  }, [depth, readOnly, isSelected, isDragging, isOverBefore, isOverChild, isOverAfter]);

  // =============================================================================
  // üß© NODE METADATA - M√©tadonn√©es du n≈ìud
  // =============================================================================
  
  const nodeType = useMemo(() => TreeBranchLeafRegistry.getNodeType(node.type), [node.type]);
  
  // Type d'appoint pour certaines propri√©t√©s legacy optionnelles
  type NodeLegacyExtras = { required?: boolean; hasValidation?: boolean; exposedKey?: string; hidden?: boolean; capabilities?: string[] };
  const legacy = node as unknown as NodeLegacyExtras;

  const badges = useMemo(() => {
    const badges = [];
    if (legacy.required) badges.push('R');
    if (legacy.hasValidation) badges.push('V');
    if (legacy.capabilities?.length) badges.push(`C${legacy.capabilities.length}`);
    if (legacy.exposedKey) badges.push('E');
    return badges;
  }, [legacy.required, legacy.hasValidation, legacy.capabilities, legacy.exposedKey]);

  // Badges de capacit√©s actives (√©motic√¥nes depuis le registry)
  const capabilityBadges = useMemo(() => {
    const caps: { key: string; emoji: string; title: string }[] = [];

    const pushIf = (capKey: string, enabled: boolean | undefined, extraCheck?: boolean) => {
      if (enabled || extraCheck) {
        const mod = TreeBranchLeafRegistry.getCapabilityModule(capKey);
        if (mod?.emoji) caps.push({ key: capKey, emoji: mod.emoji, title: mod.label });
      }
    };

    // D√©terminer l'√©tat √† partir des flags et/ou des configs pr√©sentes
  const isNonEmptyObject = (obj: unknown): boolean => {
    return !!(obj && typeof obj === 'object' && !Array.isArray(obj) && Object.keys(obj as Record<string, unknown>).length > 0);
  };
  const hasData = node.hasData || Boolean(node.variables?.length);
  const hasFormula = node.hasFormula || isNonEmptyObject((node as unknown as { formulaConfig?: unknown }).formulaConfig);
  const hasCondition = node.hasCondition || isNonEmptyObject((node as unknown as { conditionConfig?: unknown }).conditionConfig);
  const hasTable = node.hasTable || isNonEmptyObject((node as unknown as { tableConfig?: unknown }).tableConfig);
  const hasAPI = node.hasAPI || isNonEmptyObject((node as unknown as { apiConfig?: unknown }).apiConfig);
  const hasLink = node.hasLink || isNonEmptyObject((node as unknown as { linkConfig?: unknown }).linkConfig);
  const hasMarkers = node.hasMarkers || Boolean(node.markers?.length);

    pushIf('data', !!hasData);
    pushIf('formula', !!hasFormula);
    pushIf('condition', !!hasCondition);
    pushIf('table', !!hasTable);
    pushIf('api', !!hasAPI);
    pushIf('link', !!hasLink);
    pushIf('markers', !!hasMarkers);

    // Si node.capabilities (array) existe, ajouter ce qui manque √©ventuellement
    const capsArray: string[] | undefined = legacy.capabilities;
    if (Array.isArray(capsArray)) {
      for (const c of capsArray) {
        if (!caps.find(x => x.key === c)) {
          const mod = TreeBranchLeafRegistry.getCapabilityModule(c);
          if (mod?.emoji) caps.push({ key: c, emoji: mod.emoji, title: mod.label });
        }
      }
    }

    return caps;
  }, [node, legacy.capabilities]);

  const childCount = node.children?.length || 0;

  // =============================================================================
  // üéØ RENDER - Rendu optimis√©
  // =============================================================================
  
  return (
    <div className="node-container" style={{ position: 'relative' }}>
      {/* Zone de drop AVANT (ligne) */}
    <div
        ref={setDropBeforeRef}
        style={{
      height: '4px',
      marginLeft: `${depth * 40}px`,
          borderTop: isOverBefore ? '2px solid #52c41a' : '2px solid transparent',
          transition: 'border-color 0.1s',
        }}
      />

      {/* LIGNE PRINCIPALE DU N≈íUD (zone ENFANT) */}
      <div
        ref={setDropChildRef}
        style={{
          ...nodeStyle,
          backgroundColor: isOverChild ? '#f0f8ff' : nodeStyle.backgroundColor,
          border: isOverChild ? '1px dashed #52c41a' : nodeStyle.border,
          minHeight: '28px',
          overflow: 'visible',
        }}
        onClick={handleClick}
        onDoubleClick={handleDoubleClick}
      >
      {/* Poign√©e de d√©placement d√©di√©e pour ne pas bloquer la s√©lection au clic */}
      {!readOnly && (
        <span
          ref={setDragRef}
          {...dragAttributes}
          {...dragListeners}
          title="Glisser pour d√©placer"
          style={{
            cursor: 'grab',
            color: '#999',
            fontSize: '12px',
            lineHeight: '14px',
            padding: '0 2px',
            userSelect: 'none',
            display: 'inline-flex',
            alignItems: 'center'
          }}
          onClick={(e) => e.stopPropagation()}
        >
          ‚†ø
        </span>
      )}

      {/* Bouton expand/collapse - Style Windows Explorer */}
      {hasChildren ? (
    <span
          style={{ 
            display: 'inline-flex',
            alignItems: 'center',
            justifyContent: 'center',
      width: '14px',
      height: '14px',
      marginRight: '4px',
            cursor: 'pointer',
            color: '#666',
      fontSize: '11px',
            border: '1px solid #ccc',
            backgroundColor: '#fff',
            borderRadius: '2px',
            hover: {
              backgroundColor: '#f0f0f0'
            }
          }}
          onClick={handleToggle}
          title={isExpanded ? 'R√©duire' : 'D√©velopper'}
        >
          {isExpanded ? '‚àí' : '+'}
        </span>
      ) : (
    <span style={{ width: '18px', display: 'inline-block' }} />
      )}

      {/* 1. LOGO - Ic√¥ne du type de n≈ìud */}
      <span 
        style={{ 
          display: 'inline-block',
          marginRight: '4px',
          fontSize: '11px',
          color: nodeType?.color || '#666',
          position: 'relative'
        }}
      >
        {getNodeIcon(node.type)}
        {/* Indicateur pour champ dans section */}
        {isFieldInSection && (
          <span
            style={{
              position: 'absolute',
              top: '-2px',
              right: '-4px',
              fontSize: '8px',
              color: '#13c2c2'
            }}
            title="Champ calcul√© (section)"
          >
            üìä
          </span>
        )}
      </span>

      {/* 2. NOM - Label du n≈ìud */}
      <span style={{ 
  fontWeight: isSelected ? '500' : '400',
  color: isDragging ? '#999' : '#333'
      }}>
        {/* Indicateurs hi√©rarchiques visuels (comme Windows Explorer) */}
        {depth > 0 && (
          <>
            {/* Barres de connexion hi√©rarchique */}
            <span style={{ 
              color: '#ddd', 
              fontSize: '11px', 
              marginRight: '4px',
              fontFamily: 'monospace'
            }}>
              {'‚îÇ  '.repeat(depth - 1)}‚îî‚îÄ
            </span>
            {/* Indicateur de niveau */}
            <span style={{ 
              color: '#888', 
              fontSize: '9px', 
              marginRight: '4px',
              fontWeight: 'bold',
              backgroundColor: '#f0f0f0',
              padding: '0px 4px',
              borderRadius: '3px'
            }}>
              N{depth + 1}
            </span>
          </>
        )}
        {node.label}
      </span>

      {/* 3. COMPTEUR - Nombre d'enfants */}
      {childCount > 0 && (
        <span style={{ 
          color: '#999',
          fontSize: '10px',
          fontWeight: '500'
        }}>
          ({childCount})
        </span>
      )}

      {/* 4. IC√îNES OPTIONS - Param√®tres activ√©s (compteurs g√©n√©riques) */}
      {badges.length > 0 && (
  <span style={{ marginLeft: '4px', display: 'flex', gap: '2px' }}>
          {badges.map((badge, index) => (
            <span
              key={index}
              title={`Param√®tre: ${badge}`}
              style={{
                backgroundColor: '#e6f7ff',
                color: '#1890ff',
    fontSize: '9px',
    padding: '1px 4px',
                borderRadius: '10px',
                fontWeight: '500'
              }}
            >
              ‚öôÔ∏è{badge}
            </span>
          ))}
        </span>
      )}

      {/* 4bis. BADGES CAPACIT√âS - Affichage des capacit√©s actives avec emoji */}
      {capabilityBadges.length > 0 && (
  <span style={{ marginLeft: '4px', display: 'flex', gap: '4px' }}>
          {capabilityBadges.map(({ key, emoji, title }) => (
            <span
              key={key}
              title={title}
              style={{
                backgroundColor: '#f6ffed',
                color: '#389e0d',
    fontSize: '11px',
    padding: '0px 5px',
                borderRadius: '12px',
    lineHeight: '16px',
                display: 'inline-flex',
                alignItems: 'center',
                border: '1px solid #b7eb8f'
              }}
            >
              {emoji}
            </span>
          ))}
        </span>
      )}

      {/* 5. MENU CONTEXTUEL - Trois petits points */}
      {(() => {
  // logs r√©duits
        return (
          <div style={{ position: 'relative', zIndex: 1 }}>
            <NodeActionMenu
              node={node}
              onEdit={onEditNode}
              onDuplicate={onDuplicateNode}
              onDelete={onDeleteNode}
              onMoveUp={onMoveUpNode}
              onMoveDown={onMoveDownNode}
              onToggleVisibility={onToggleNodeVisibility}
              onOpenSettings={onOpenNodeSettings}
              readOnly={readOnly}
              size="small"
            />
          </div>
        );
      })()}
      </div>

      {/* Zone de drop APR√àS (ligne) */}
    <div
        ref={setDropAfterRef}
        style={{
      height: '4px',
      marginLeft: `${depth * 40}px`,
          borderBottom: isOverAfter ? '2px solid #52c41a' : '2px solid transparent',
          transition: 'border-color 0.1s',
        }}
      />
    </div>
  );
};

// =============================================================================
// üöÄ MEMOIZATION - Comparaison optimis√©e pour React.memo
// =============================================================================

const arePropsEqual = (
  prevProps: OptimizedStructureNodeProps,
  nextProps: OptimizedStructureNodeProps
): boolean => {
  // Comparaisons rapides des propri√©t√©s primitives
  if (
    prevProps.isSelected !== nextProps.isSelected ||
    prevProps.isExpanded !== nextProps.isExpanded ||
    prevProps.hasChildren !== nextProps.hasChildren ||
    prevProps.depth !== nextProps.depth ||
    prevProps.readOnly !== nextProps.readOnly
  ) {
    return false;
  }

  // Comparaison des callbacks du menu contextuel (par r√©f√©rence)
  if (
    prevProps.onEditNode !== nextProps.onEditNode ||
    prevProps.onDuplicateNode !== nextProps.onDuplicateNode ||
    prevProps.onDeleteNode !== nextProps.onDeleteNode ||
    prevProps.onMoveUpNode !== nextProps.onMoveUpNode ||
    prevProps.onMoveDownNode !== nextProps.onMoveDownNode ||
    prevProps.onToggleNodeVisibility !== nextProps.onToggleNodeVisibility ||
    prevProps.onOpenNodeSettings !== nextProps.onOpenNodeSettings
  ) {
    return false;
  }

  // Comparaison du n≈ìud (par r√©f√©rence d'abord, puis propri√©t√©s cl√©s)
  if (prevProps.node === nextProps.node) return true;

  const prevNode = prevProps.node;
  const nextNode = nextProps.node;

  // Comparaisons des propri√©t√©s importantes du n≈ìud
  return (
    prevNode.id === nextNode.id &&
    prevNode.label === nextNode.label &&
    prevNode.type === nextNode.type &&
    prevNode.subType === nextNode.subType &&
  (prevNode as unknown as NodeLegacyExtras).required === (nextNode as unknown as NodeLegacyExtras).required &&
  (prevNode as unknown as NodeLegacyExtras).hasValidation === (nextNode as unknown as NodeLegacyExtras).hasValidation &&
  (prevNode as unknown as NodeLegacyExtras).exposedKey === (nextNode as unknown as NodeLegacyExtras).exposedKey &&
    prevNode.value === nextNode.value &&
    prevNode.defaultValue === nextNode.defaultValue &&
  (prevNode as unknown as NodeLegacyExtras).hidden === (nextNode as unknown as NodeLegacyExtras).hidden && // Ajout√© pour la visibilit√©
  // Suivi des flags de capacit√©s pour re-rendu pr√©cis
  prevNode.hasData === nextNode.hasData &&
  prevNode.hasFormula === nextNode.hasFormula &&
  prevNode.hasCondition === nextNode.hasCondition &&
  prevNode.hasTable === nextNode.hasTable &&
  prevNode.hasAPI === nextNode.hasAPI &&
  prevNode.hasLink === nextNode.hasLink &&
  prevNode.hasMarkers === nextNode.hasMarkers &&
    (prevNode.children?.length || 0) === (nextNode.children?.length || 0) &&
  ((prevNode as unknown as NodeLegacyExtras).capabilities?.length || 0) === ((nextNode as unknown as NodeLegacyExtras).capabilities?.length || 0)
  );
};

export const OptimizedStructureNode = memo(OptimizedStructureNodeComponent, arePropsEqual);
