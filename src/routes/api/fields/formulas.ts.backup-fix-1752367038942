import express, { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { authMiddleware } from '../../../middlewares/auth.js';
import { requireRole } from '../../../middlewares/requireRole.js';
import * as mockFormulas from '../../../global-mock-formulas.js';

// Interface pour les requêtes avec paramètres fusionnés
interface MergedParamsRequest extends Request {
  params: {
    formulaId?: string;
    id?: string; // Le paramètre de la route parente /:id/formulas
    fieldId?: string;
  }
}

const router = express.Router({ mergeParams: true });
const prisma = new PrismaClient();

// Contournement du problème de mock
const mockEnabled = process.env.NODE_ENV === 'development';
console.log(`[CONFIG] Mode mock ${mockEnabled ? 'activé' : 'désactivé'}`);

// Appliquer le middleware d'authentification à toutes les routes
router.use(authMiddleware as any);

/**
 * GET toutes les formules d'un champ spécifique
 */
router.get('/', requireRole(['admin', 'super_admin']), async (req: MergedParamsRequest, res: Response) => {
  try {
    // Le fieldId est maintenant disponible via req.params.id (depuis la route parente)
    const fieldId = req.params.id;
    
    if (!fieldId) {
      return res.status(400).json({ error: "ID du champ manquant" });
    }
    
    // En mode développement, utiliser le système de mock
    if (mockEnabled) {
      console.log('[API] GET - Mode développement, récupération des formules mockées pour le champ', fieldId);
      const mockFormulasData = mockFormulas.getFormulasForField(fieldId as string);
      console.log(`[API] GET - ${mockFormulasData.length} formules mockées trouvées`);
      console.log(`[API] GET - Contenu des formules mockées:`, JSON.stringify(mockFormulasData));
      return res.json(mockFormulasData);
    }
    
    // En mode production, utiliser la base de données
    const formulas = await prisma.fieldFormula.findMany({
      where: { fieldId },
      orderBy: { order: 'asc' }
    });
    
    // On parse la séquence JSON pour chaque formule
    const processedFormulas = formulas.map(f => ({
      ...f,
      sequence: f.sequence ? JSON.parse(f.sequence as string) : [],
    }));
    
    res.json(processedFormulas);
  } catch (err: any) {
    console.error("Erreur lors de la récupération des formules:", err);
    res.status(500).json({ error: err.message });
  }
});

/**
 * PUT mise à jour d'une formule
 * Route: /api/fields/:id/formulas/:formulaId
 */
router.put('/:formulaId', requireRole(['admin', 'super_admin']), async (req: MergedParamsRequest, res: Response) => {
  try {
    const { formulaId } = req.params;
    // On récupère l'ID du champ depuis les paramètres de route fusionnés
    const fieldId = req.params.id;
    const { name, sequence, order } = req.body;

    console.log(`[API] Mise à jour formule ${formulaId} pour champ ${fieldId}`);
    console.log(`[API] Données reçues:`, { name, sequence, order });

    if (!fieldId) {
      return res.status(400).json({ error: "ID du champ manquant" });
    }

    // Si la formule n'existe pas encore, la créer d'abord
    try {
      const existingFormula = await prisma.fieldFormula.findUnique({
        where: { id: formulaId }
      });
      
      if (!existingFormula) {
        console.log(`[API] Formule ${formulaId} n'existe pas encore, création...`);
        await prisma.fieldFormula.create({
          data: {
            id: formulaId,
            fieldId: fieldId,
            name: name || 'Nouvelle formule',
            sequence: sequence ? (typeof sequence === 'string' ? sequence : JSON.stringify(sequence)) : '[]',
            order: order || 0
          }
        });
        console.log(`[API] Formule ${formulaId} créée avec succès`);
      }
    } catch (createError) {
      console.error(`[API] Erreur lors de la vérification/création de la formule:`, createError);
    }

    const dataToUpdate: any = {};

    if (name !== undefined) {
      dataToUpdate.name = name;
    }
    if (sequence !== undefined) {
      // S'assurer que la séquence est bien une chaîne JSON
      dataToUpdate.sequence = typeof sequence === 'string' ? sequence : JSON.stringify(sequence);
    }
    if (order !== undefined) {
      dataToUpdate.order = order;
    }

    let updatedFormula;
    try {
      updatedFormula = await prisma.fieldFormula.update({
        where: { id: formulaId },
        data: dataToUpdate
      });
      
      console.log(`[API] Formule mise à jour avec succès:`, { 
        id: updatedFormula.id, 
        name: updatedFormula.name
      });
    } catch (updateError) {
      console.error(`[API] Erreur lors de la mise à jour de la formule:`, updateError);
      
      // Si la mise à jour échoue, essayer de créer la formule
      updatedFormula = await prisma.fieldFormula.create({
        data: {
          id: formulaId,
          fieldId: fieldId,
          name: name || 'Nouvelle formule',
          sequence: sequence ? (typeof sequence === 'string' ? sequence : JSON.stringify(sequence)) : '[]',
          order: order || 0
        }
      });
      
      console.log(`[API] Formule créée avec succès comme alternative:`, { 
        id: updatedFormula.id, 
        name: updatedFormula.name
      });
    }

    // Après la mise à jour, on renvoie la liste complète et à jour
    const formulas = await prisma.fieldFormula.findMany({
      where: { fieldId },
      orderBy: { order: 'asc' }
    });
    
    // Transformer les formules pour le format attendu par le frontend
    const processedFormulas = formulas.map(f => ({
      ...f,
      sequence: f.sequence ? JSON.parse(f.sequence as string) : []
    }));
    
    console.log(`[API] Retour de ${processedFormulas.length} formules au client`);
    res.json(processedFormulas);

  } catch (err: any) {
    const { formulaId } = req.params;
    const fieldId = req.params.id || '';
    console.error(`Erreur API PUT /api/fields/.../formulas/${formulaId}:`, err);
    
    // En mode développement, utiliser le système de mock pour simuler la persistance
    if (mockEnabled) {
      console.log(`[API] PUT - Mode développement (catch), utilisation du système de mock pour la persistance`);
      
      // Récupérer les données de la formule depuis le body de la requête
      const { sequence, name, order } = req.body;
      
      // Utiliser le système de mock pour mettre à jour ou créer la formule
      /* eslint-disable */
      mockFormulas.updateFormula(fieldId as string, formulaId as string, {
        name,
        sequence,
        order
      });
      
      // Récupérer toutes les formules mockées pour ce champ
      const allFormulas = mockFormulas.getFormulasForField(fieldId as string);
      console.log(`[API] PUT - Formules mockées retournées (catch): ${allFormulas.length}`);
      console.log(`[API] PUT - Contenu des formules mockées (catch):`, JSON.stringify(allFormulas));
      
      return res.json(allFormulas);
    }
    
    // En production, renvoyer les erreurs normales
    if (err.code === 'P2025') {
      res.status(404).json({ error: 'Formule non trouvée' });
    } else {
      res.status(500).json({ error: 'Erreur lors de la mise à jour de la formule', details: err.message });
    }
  }
});

export default router;
