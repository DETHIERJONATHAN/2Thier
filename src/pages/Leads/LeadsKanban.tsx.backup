import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { Card, Tag, Button, Space, Typography, Row, Col, Badge, Spin, message } from 'antd';
import { 
  PhoneOutlined, 
  MailOutlined, 
  CalendarOutlined,
  ClockCircleOutlined,
  UserOutlined,
  FireOutlined,
  ExclamationCircleOutlined,
  CheckCircleOutlined,
  EyeOutlined
} from '@ant-design/icons';
import { DndProvider, useDrag, useDrop } from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import { useAuthenticatedApi } from '../../hooks/useAuthenticatedApi';
import { useAuth } from '../../auth/useAuth';
import { useLeadStatuses } from '../../hooks/useLeadStatuses';
import { 
  calculateLeadTimeline, 
  getLeadPriority, 
  getTimelineColor
} from '../../utils/leadTimeline';
import type { Lead } from '../../types/leads';

const { Title, Text } = Typography;

// Types pour le drag & drop
const ITEM_TYPE = 'LEAD_CARD';

interface DragItem {
  id: string;
  type: string;
  fromColumn: string;
}

interface LeadsKanbanProps {
  onViewLead: (leadId: string) => void;
  onCallLead: (leadId: string) => void;
  onEmailLead: (leadId: string) => void;
  onScheduleLead: (leadId: string) => void;
  refreshTrigger?: number;
  onLeadUpdated?: () => void; // üîÑ Nouveau callback pour notifier les mises √† jour
}


// üóëÔ∏è Fonction normalizeStatus supprim√©e - nous utilisons maintenant directement les UUID statusId de Prisma

// üÉè Composant Carte Lead
interface LeadCardProps {
  lead: Lead;
  onView: () => void;
  onCall: () => void;
  onEmail: () => void;
  onSchedule: () => void;
}

const LeadCard: React.FC<LeadCardProps> = ({ lead, onView, onCall, onEmail, onSchedule }) => {
  // Utilisation des utilitaires pour les couleurs et priorit√©s
  const timeline = calculateLeadTimeline(lead.createdAt, lead.source);
  const priority = getLeadPriority(lead.createdAt, lead.source, lead.lastContactDate);
  const timelineColor = getTimelineColor(timeline.status);

  const getBorderColor = () => timelineColor;

  const getPriorityIcon = () => {
    switch (priority) {
      case 'critical': return <ExclamationCircleOutlined style={{ color: '#722ed1' }} />;
      case 'high': return <FireOutlined style={{ color: '#ff4d4f' }} />;
      case 'medium': return <ClockCircleOutlined style={{ color: '#fa8c16' }} />;
      default: return <CheckCircleOutlined style={{ color: '#52c41a' }} />;
    }
  };

  console.log(`üéØ [LeadCard] Cr√©ation carte drag & drop pour lead ${lead.id}`, {
    leadId: lead.id,
    leadName: lead.firstName + ' ' + lead.lastName,
    currentStatus: lead.status,
    canDrag: true
  });

  const [{ isDragging, canDrag }, drag, dragPreview] = useDrag({
    type: ITEM_TYPE,
    item: () => {
      console.log(`üü¢ [LeadCard] ITEM function ${lead.id}:`, {
        leadId: lead.id,
        fromColumn: lead.status,
        leadName: lead.firstName + ' ' + lead.lastName
      });
      return { id: lead.id, type: ITEM_TYPE, fromColumn: lead.status };
    },
    canDrag: () => {
      const canDragResult = true; // Toujours permettre le drag pour les tests
      console.log(`üéØ [LeadCard] Can drag ${lead.id}:`, canDragResult);
      return canDragResult;
    },
    collect: (monitor) => {
      const isDragging = monitor.isDragging();
      const canDrag = monitor.canDrag();
      const item = monitor.getItem();
      
      console.log(`üöÄ [LeadCard] Drag collect ${lead.id}:`, {
        isDragging,
        canDrag,
        didDrop: monitor.didDrop(),
        item,
        monitor: monitor.getItemType()
      });
      
      return {
        isDragging,
        canDrag,
      };
    },
    end: (item, monitor) => {
      console.log(`üî¥ [LeadCard] END drag ${lead.id}:`, {
        didDrop: monitor.didDrop(),
        dropResult: monitor.getDropResult(),
        item: monitor.getItem()
      });
    }
  });

  console.log(`üîç [LeadCard] √âtat drag ${lead.id}:`, {
    isDragging,
    hasRef: !!drag,
    leadStatus: lead.status
  });

  const displayName = lead.firstName && lead.lastName 
    ? `${lead.firstName} ${lead.lastName}` 
    : lead.data?.name || `Lead ${lead.id.slice(0, 8)}`;

  // Utiliser le dragPreview pour une image personnalis√©e
  React.useEffect(() => {
    const previewElement = document.createElement('div');
    previewElement.innerHTML = `
      <div style="
        background: linear-gradient(135deg, #1890ff, #40a9ff);
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        font-size: 14px;
        font-weight: 500;
        white-space: nowrap;
        transform: rotate(3deg);
      ">
        üöÄ ${displayName}
      </div>
    `;
    previewElement.style.position = 'absolute';
    previewElement.style.top = '-1000px';
    previewElement.style.left = '-1000px';
    document.body.appendChild(previewElement);
    
    dragPreview(previewElement);
    
    return () => {
      if (document.body.contains(previewElement)) {
        document.body.removeChild(previewElement);
      }
    };
  }, [dragPreview, displayName]);

  return (
    <div 
      ref={drag} 
      style={{ 
        opacity: isDragging ? 0.5 : 1,
        cursor: canDrag ? (isDragging ? 'grabbing' : 'grab') : 'default',
        transform: isDragging ? 'rotate(5deg)' : 'none',
        transition: 'all 0.2s ease'
      }}
      draggable={true}
      className="select-none"
      onDragStart={(e) => {
        console.log(`üöÄ [LeadCard] HTML5 dragStart ${lead.id}`, e);
        e.dataTransfer.effectAllowed = 'move';
        
        // Cr√©er une image de drag personnalis√©e
        const dragImage = e.currentTarget.cloneNode(true) as HTMLElement;
        dragImage.style.transform = 'rotate(5deg)';
        dragImage.style.opacity = '0.8';
        dragImage.style.width = e.currentTarget.offsetWidth + 'px';
        dragImage.style.backgroundColor = '#f0f8ff';
        dragImage.style.border = '2px dashed #1890ff';
        dragImage.style.borderRadius = '8px';
        
        // Ajouter temporairement au DOM
        document.body.appendChild(dragImage);
        dragImage.style.position = 'absolute';
        dragImage.style.top = '-1000px';
        dragImage.style.left = '-1000px';
        
        // Utiliser comme image de drag
        e.dataTransfer.setDragImage(dragImage, e.nativeEvent.offsetX, e.nativeEvent.offsetY);
        
        // Nettoyer apr√®s un d√©lai
        setTimeout(() => {
          if (document.body.contains(dragImage)) {
            document.body.removeChild(dragImage);
          }
        }, 100);
      }}
      onDrag={(e) => {
        console.log(`üîÑ [LeadCard] HTML5 drag ${lead.id}`, e.clientX, e.clientY);
      }}
      onDragEnd={(e) => {
        console.log(`üî¥ [LeadCard] HTML5 dragEnd ${lead.id}`, e);
      }}
    >
      <Card
        size="small"
        className={`mb-3 transition-all duration-200 ${isDragging ? 'shadow-2xl border-dashed' : 'hover:shadow-md'}`}
        style={{ 
          borderLeft: `4px solid ${getBorderColor()}`,
          borderRadius: '8px',
          backgroundColor: isDragging ? '#e6f7ff' : (timeline.isOverdue ? '#faf0ff' : 'white'),
          cursor: canDrag ? (isDragging ? 'grabbing' : 'grab') : 'default',
          pointerEvents: isDragging ? 'none' : 'auto',
          border: isDragging ? '2px dashed #1890ff' : '1px solid #d9d9d9',
          transform: isDragging ? 'scale(1.02)' : 'scale(1)',
        }}
        styles={{ body: { padding: '12px' } }}
      >
        {/* Header avec priorit√© et statut temporel */}
        <Row justify="space-between" align="top" className="mb-2">
          <Col>
            <Space>
              <Text strong className="text-sm">
                {displayName}
              </Text>
              {getPriorityIcon()}
            </Space>
          </Col>
          <Col>
            <Badge 
              count={timeline.isOverdue ? 'Retard' : `${timeline.remainingHours}h`}
              style={{ 
                backgroundColor: getBorderColor(),
                fontSize: '9px',
                height: '18px',
                lineHeight: '18px'
              }}
            />
          </Col>
        </Row>

        {/* Soci√©t√© */}
        {(lead.company || lead.data?.company) && (
          <Text type="secondary" className="text-xs block mb-2">
            üè¢ {lead.company || lead.data?.company}
          </Text>
        )}

        {/* Source avec code couleur selon d√©lai */}
        <Space size="small" className="mb-2" direction="vertical">
          <Space size="small">
            <Tag color={timeline.status === 'critical' ? 'purple' : timeline.status === 'urgent' ? 'red' : timeline.status === 'important' ? 'orange' : 'green'} className="text-xs">
              {lead.source || 'direct'}
            </Tag>
            <Text className="text-xs" style={{ color: getBorderColor() }}>
              {timeline.description}
            </Text>
          </Space>
          
          {/* Recommandation IA courte */}
          {priority !== 'low' && (
            <Text className="text-xs" style={{ 
              color: priority === 'critical' ? '#722ed1' : '#666',
              fontStyle: 'italic'
            }}>
              ü§ñ Action recommand√©e bas√©e sur la priorit√© {priority}
            </Text>
          )}
        </Space>

        {/* Commercial assign√© */}
        {lead.assignedTo && (
          <div className="mb-2">
            <Text className="text-xs text-gray-500">
              <UserOutlined /> {lead.assignedTo.firstName} {lead.assignedTo.lastName}
            </Text>
          </div>
        )}

        {/* Actions avec priorit√© sur les actions urgentes */}
        <Row justify="space-between" align="middle">
          <Col>
            <Space size="small">
              {priority === 'critical' && (
                <Button 
                  size="small" 
                  type="primary" 
                  danger
                  icon={<PhoneOutlined />} 
                  onClick={(e) => { e.stopPropagation(); onCall(); }}
                  title="URGENT - Appeler"
                />
              )}
              {priority !== 'critical' && (
                <>
                  <Button 
                    size="small" 
                    type="text" 
                    icon={<PhoneOutlined />} 
                    onClick={(e) => { e.stopPropagation(); onCall(); }}
                    title="Appeler"
                  />
                  <Button 
                    size="small" 
                    type="text" 
                    icon={<MailOutlined />} 
                    onClick={(e) => { e.stopPropagation(); onEmail(); }}
                    title="Email"
                  />
                  <Button 
                    size="small" 
                    type="text" 
                    icon={<CalendarOutlined />} 
                    onClick={(e) => { e.stopPropagation(); onSchedule(); }}
                    title="RDV"
                  />
                </>
              )}
              <Button 
                size="small" 
                type="text" 
                icon={<EyeOutlined />} 
                onClick={(e) => { e.stopPropagation(); onView(); }}
                title="Voir"
              />
            </Space>
          </Col>
        </Row>
      </Card>
    </div>
  );
};

// üìã Composant Colonne
interface KanbanColumnProps {
  column: {
    id: string;
    name: string;
    color: string;
    description?: string;
  };
  leads: Lead[];
  onDropLead: (leadId: string, newStatus: string) => void;
  onViewLead: (leadId: string) => void;
  onCallLead: (leadId: string) => void;
  onEmailLead: (leadId: string) => void;
  onScheduleLead: (leadId: string) => void;
}

const KanbanColumn: React.FC<KanbanColumnProps> = ({
  column,
  leads,
  onDropLead,
  onViewLead,
  onCallLead,
  onEmailLead,
  onScheduleLead
}) => {
  console.log(`üèóÔ∏è [KanbanColumn] Initialisation colonne ${column.id}`, {
    columnId: column.id,
    columnName: column.name,
    leadsCount: leads.length,
    leadsIds: leads.map(l => l.id)
  });

  const [{ isOver }, drop] = useDrop({
    accept: ITEM_TYPE,
    drop: (item: DragItem) => {
      console.log(`üéØ [KanbanColumn] DROP dans colonne ${column.id}:`, {
        leadId: item.id,
        fromColumn: item.fromColumn,
        toColumn: column.id,
        willUpdate: item.fromColumn !== column.id
      });
      
      if (item.fromColumn !== column.id) {
        console.log(`‚úÖ [KanbanColumn] D√©clenchement onDropLead`, {
          leadId: item.id,
          newStatus: column.id
        });
        onDropLead(item.id, column.id);
      } else {
        console.log(`‚è≠Ô∏è [KanbanColumn] Pas de changement - m√™me colonne`);
      }
    },
    collect: (monitor) => {
      const isOver = monitor.isOver();
      const canDrop = monitor.canDrop();
      const item = monitor.getItem();
      
      if (item) {
        console.log(`üëÄ [KanbanColumn] Monitor colonne ${column.id}:`, {
          isOver,
          canDrop,
          draggedItemId: item.id,
          draggedFromColumn: item.fromColumn
        });
      }
      
      return {
        isOver,
      };
    },
  });

  console.log(`üîç [KanbanColumn] √âtat drop ${column.id}:`, {
    isOver,
    hasRef: !!drop,
    leadsInColumn: leads.length
  });

  // Calcul des m√©triques de la colonne avec la nouvelle logique
  const columnMetrics = useMemo(() => {
    const overdueCount = leads.filter(lead => {
      const timeline = calculateLeadTimeline(lead.createdAt, lead.source);
      return timeline.isOverdue || timeline.status === 'critical';
    }).length;

    const criticalCount = leads.filter(lead => {
      const timeline = calculateLeadTimeline(lead.createdAt, lead.source);
      return timeline.status === 'critical';
    }).length;

    const urgentCount = leads.filter(lead => {
      const priority = getLeadPriority(lead.createdAt, lead.source, lead.lastContactDate);
      return priority === 'high' || priority === 'critical';
    }).length;

    return { overdueCount, criticalCount, urgentCount };
  }, [leads]);

  return (
    <div 
      ref={drop}
      className={`bg-gray-50 rounded-lg p-3 min-h-[600px] transition-colors ${
        isOver ? 'bg-blue-50 border-2 border-blue-300 border-dashed' : ''
      }`}
    >
      {/* Header de la colonne */}
      <div className="mb-4">
        <Row justify="space-between" align="middle" className="mb-2">
          <Col>
            <Title level={5} className="mb-0" style={{ color: column.color }}>
              {column.name}
            </Title>
          </Col>
          <Col>
            <Badge 
              count={leads.length} 
              style={{ backgroundColor: column.color }}
            />
          </Col>
        </Row>
        
        <Text type="secondary" className="text-xs block mb-2">
          {column.description}
        </Text>

        {/* Indicateurs d'urgence avec nouvelle logique */}
        {(columnMetrics.overdueCount > 0 || columnMetrics.urgentCount > 0 || columnMetrics.criticalCount > 0) && (
          <Space size="small" className="mb-2">
            {columnMetrics.criticalCount > 0 && (
              <Badge 
                count={columnMetrics.criticalCount} 
                style={{ backgroundColor: '#722ed1' }}
                title={`${columnMetrics.criticalCount} leads critiques`}
              >
                <ExclamationCircleOutlined style={{ color: '#722ed1' }} />
              </Badge>
            )}
            {columnMetrics.overdueCount > 0 && (
              <Badge 
                count={columnMetrics.overdueCount} 
                style={{ backgroundColor: '#ff4d4f' }}
                title={`${columnMetrics.overdueCount} leads en retard`}
              >
                <ExclamationCircleOutlined style={{ color: '#ff4d4f' }} />
              </Badge>
            )}
            {columnMetrics.urgentCount > 0 && (
              <Badge 
                count={columnMetrics.urgentCount} 
                style={{ backgroundColor: '#fa8c16' }}
                title={`${columnMetrics.urgentCount} leads urgents`}
              >
                <FireOutlined style={{ color: '#fa8c16' }} />
              </Badge>
            )}
          </Space>
        )}
      </div>

      {/* Cartes des leads */}
      <div className="space-y-2">
        {leads.map(lead => (
          <LeadCard
            key={lead.id}
            lead={lead}
            onView={() => onViewLead(lead.id)}
            onCall={() => onCallLead(lead.id)}
            onEmail={() => onEmailLead(lead.id)}
            onSchedule={() => onScheduleLead(lead.id)}
          />
        ))}
      </div>

      {/* Zone de drop active */}
      {isOver && (
        <div className="mt-4 p-4 border-2 border-blue-300 border-dashed rounded-lg text-center">
          <Text type="secondary">
            D√©poser le lead ici pour le d√©placer vers "{column.name}"
          </Text>
        </div>
      )}
    </div>
  );
};

/**
 * Vue Kanban pour visualiser les leads par statut
 */
const LeadsKanban: React.FC<LeadsKanbanProps> = ({
  onViewLead,
  onCallLead,
  onEmailLead,
  onScheduleLead,
  refreshTrigger = 0,
  onLeadUpdated // üîÑ Nouveau prop
}) => {
  console.log('üèóÔ∏è [LeadsKanban] Composant mont√©');
  
  const { api } = useAuthenticatedApi();
  const { currentOrganization, isSuperAdmin, user } = useAuth();
  const { leadStatuses, isLoading: statusesLoading } = useLeadStatuses();
  
  const [leads, setLeads] = useState<Lead[]>([]);
  const [loading, setLoading] = useState(false);
  const [isUpdatingLead, setIsUpdatingLead] = useState(false); // Track internal updates
  const lastUpdateByKanban = useRef(false); // üö© Flag pour √©viter le refresh apr√®s nos modifications

  // üìä R√©cup√©ration des leads
  const fetchLeads = useCallback(async () => {
    if (!currentOrganization && !isSuperAdmin) {
      console.log('[LeadsKanban] ‚è≥ En attente de la d√©finition de l\'organisation...');
      return;
    }
    
    setLoading(true);
    try {
      console.log('[LeadsKanban] üìä R√©cup√©ration des leads pour Kanban...');
      
      const response = await api.get('/api/leads');
      let leadsData: Lead[] = [];
      
      if (Array.isArray(response)) {
        leadsData = response;
      } else if (response?.data && Array.isArray(response.data)) {
        leadsData = response.data;
      }
      
      console.log('[LeadsKanban] üìä Leads re√ßus pour Kanban:', leadsData.length);
      
      // Transformer les donn√©es pour le Kanban avec normalisation des statuts
      const transformedLeads = leadsData.map(lead => ({
        ...lead,
        name: lead.name || `${lead.firstName || ''} ${lead.lastName || ''}`.trim() || `Lead ${lead.id.slice(0, 8)}`,
        email: lead.email || lead.data?.email || '',
        phone: lead.phone || lead.data?.phone || '',
        company: lead.company || lead.data?.company || '',
        notes: lead.data?.notes || '',
        website: lead.data?.website || '',
        linkedin: lead.data?.linkedin || '',
        lastContact: lead.data?.lastContactDate || lead.createdAt,
        statusId: lead.statusId, // Utiliser directement statusId UUID de Prisma
      }));
      
      setLeads(transformedLeads);
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Erreur inconnue';
      console.error('Erreur lors du chargement des leads:', errorMessage);
      message.error('Erreur lors du chargement des leads');
    } finally {
      setLoading(false);
    }
  }, [api, currentOrganization, isSuperAdmin]);

  // üîÑ Chargement initial
  useEffect(() => {
    console.log('[LeadsKanban] üîÑ useEffect d√©clench√©:', { 
      isUpdatingLead, 
      refreshTrigger, 
      user: user?.email,
      hasCurrentOrg: !!currentOrganization,
      isSuperAdmin 
    });
    
    // Ne pas recharger si c'est le kanban qui vient de faire une modification
    if (isUpdatingLead) {
      console.log('[LeadsKanban] ‚è≠Ô∏è Skip refresh - modification interne en cours');
      return;
    }

    // √âviter le refresh si c'est notre propre modification qui a d√©clench√© le refreshTrigger
    if (lastUpdateByKanban.current && refreshTrigger > 0) {
      console.log('[LeadsKanban] ‚è≠Ô∏è Skip refresh - notre propre modification, pas de rechargement');
      lastUpdateByKanban.current = false; // Reset le flag
      return;
    }
    
    if (user && (currentOrganization || isSuperAdmin)) {
      console.log('[LeadsKanban] üöÄ Chargement des leads pour Kanban...', { 
        user: user.email, 
        org: currentOrganization?.name || 'Vue globale',
        isSuperAdmin,
        refreshTrigger
      });
      fetchLeads();
    } else {
      console.log('[LeadsKanban] ‚ùå Conditions non remplies pour charger les leads:', {
        hasUser: !!user,
        hasOrg: !!currentOrganization,
        isSuperAdmin
      });
    }
  }, [user, currentOrganization, isSuperAdmin, fetchLeads, refreshTrigger, isUpdatingLead]);

  // üéØ Gestion du drag & drop
  const handleDropLead = useCallback(async (leadId: string, newStatusId: string) => {
    console.log(`üöÄ [handleDropLead] D√âBUT - Tentative de d√©placement:`, {
      leadId,
      newStatusId,
      timestamp: new Date().toISOString(),
      hasApi: !!api,
      userEmail: user?.email,
      orgName: currentOrganization?.name,
      isSuperAdmin
    });

    try {
      console.log('[LeadsKanban] üéØ D√©placement lead:', leadId, 'vers statusId:', newStatusId);
      console.log('[LeadsKanban] üîß API instance:', !!api);
      console.log('[LeadsKanban] üîß User:', user?.email);
      console.log('[LeadsKanban] üîß Organization:', currentOrganization?.name);
      
      // Mise √† jour optimiste
      setLeads(prevLeads => 
        prevLeads.map(lead => 
          lead.id === leadId ? { ...lead, statusId: newStatusId } : lead
        )
      );

      // Appel API pour mise √† jour
      console.log('[LeadsKanban] üì° Appel API PUT /api/leads/' + leadId);
      const response = await api.put(`/api/leads/${leadId}`, { statusId: newStatusId });
      console.log('[LeadsKanban] ‚úÖ R√©ponse API:', response);
      
      message.success('Lead d√©plac√© avec succ√®s !');
      
      // üîÑ NOUVEAU: D√©clencher un refresh des autres vues (mais pas du kanban)
      if (onLeadUpdated) {
        console.log('[LeadsKanban] üîÑ D√©clenchement refresh des autres vues...');
        console.log('[LeadsKanban] üîß √âtat avant setIsUpdatingLead:', { isUpdatingLead, refreshTrigger });
        
        // üö© Marquer que c'est nous qui faisons la modification
        lastUpdateByKanban.current = true;
        
        setIsUpdatingLead(true); // Flag pour √©viter le refresh du kanban
        console.log('[LeadsKanban] üîß setIsUpdatingLead(true) appel√©');
        onLeadUpdated();
        console.log('[LeadsKanban] üîß onLeadUpdated() appel√©');
        
        // Reset le flag apr√®s que les autres vues aient √©t√© mises √† jour
        setTimeout(() => {
          console.log('[LeadsKanban] üîß D√©but du timeout - reset du flag...');
          setIsUpdatingLead(false);
          console.log('[LeadsKanban] üîÑ Flag isUpdatingLead reset - refresh possible √† nouveau');
        }, 2000); // 2 secondes pour laisser le temps √† toutes les vues de se mettre √† jour
      }
      
    } catch (error) {
      console.error('[LeadsKanban] ‚ùå Erreur lors du d√©placement du lead:', error);
      console.error('[LeadsKanban] ‚ùå D√©tails de l\'erreur:', {
        message: error instanceof Error ? error.message : 'Erreur inconnue',
        status: error && typeof error === 'object' && 'response' in error ? 
          (error.response as { status?: number })?.status : undefined,
        data: error && typeof error === 'object' && 'response' in error ? 
          (error.response as { data?: unknown })?.data : undefined
      });
      message.error('Erreur lors du d√©placement du lead');
      
      // Revert optimistic update
      fetchLeads();
    }
  }, [api, fetchLeads, user, currentOrganization]); // eslint-disable-line react-hooks/exhaustive-deps

  // üìã Groupement des leads par statut dynamique
  const leadsByStatus = useMemo(() => {
    console.log(`üìã [leadsByStatus] D√©but regroupement des leads:`, {
      totalLeads: leads.length,
      leadsData: leads.map(l => ({ id: l.id, name: l.firstName + ' ' + l.lastName, statusId: l.statusId }))
    });

    const grouped: Record<string, Lead[]> = {};
    
    // Initialiser toutes les colonnes avec les statuts dynamiques
    leadStatuses.forEach(status => {
      grouped[status.id] = [];
      console.log(`üìã [leadsByStatus] Colonne initialis√©e: ${status.id} (${status.name})`);
    });
    
    // Grouper les leads directement par statusId (pas de normalisation, utilisation directe des IDs Prisma)
    leads.forEach(lead => {
      const statusId = lead.statusId;
      console.log(`üìã [leadsByStatus] Lead ${lead.id}:`, {
        leadName: lead.firstName + ' ' + lead.lastName,
        statusId,
        willAddToColumn: statusId
      });
      
      // Ajouter le lead dans la colonne correspondante (ou dans une colonne par d√©faut)
      if (statusId && grouped[statusId]) {
        grouped[statusId].push(lead);
      } else {
        // Fallback: mettre dans le premier statut disponible ou cr√©er une colonne "Autre"
        const firstStatus = leadStatuses[0];
        if (firstStatus) {
          console.log(`üìã [leadsByStatus] ‚ö†Ô∏è Lead sans statut valide, ajout√© √†: ${firstStatus.id}`);
          grouped[firstStatus.id].push(lead);
        }
      }
    });
    
    console.log(`üìã [leadsByStatus] R√©sultat final du regroupement:`, {
      columnsCount: Object.keys(grouped).length,
      distribution: Object.keys(grouped).map(key => ({
        column: key,
        count: grouped[key].length,
        leadIds: grouped[key].map(l => l.id)
      }))
    });
    
    return grouped;
  }, [leads, leadStatuses]);

  // üìä M√©triques globales avec IA et syst√®me de d√©lais
  const metrics = useMemo(() => {
    const total = leads.length;
    
    const overdueLeads = leads.filter(lead => {
      const timeline = calculateLeadTimeline(lead.createdAt, lead.source);
      return timeline.isOverdue || timeline.status === 'critical';
    });
    
    const criticalLeads = leads.filter(lead => {
      const timeline = calculateLeadTimeline(lead.createdAt, lead.source);
      return timeline.status === 'critical';
    });
    
    const urgentLeads = leads.filter(lead => {
      const priority = getLeadPriority(lead.createdAt, lead.source, lead.lastContactDate);
      return priority === 'high' || priority === 'critical';
    });
    
    const won = leadsByStatus['won']?.length || 0;
    const conversionRate = total > 0 ? (won / total * 100).toFixed(1) : '0';
    
    // Score commercial global (bas√© sur les d√©lais et statuts)
    const commercialScore = leads.reduce((score, lead) => {
      const timeline = calculateLeadTimeline(lead.createdAt, lead.source);
      
      if (timeline.status === 'critical') return score - 10;
      if (timeline.isOverdue) return score - 5;
      if (timeline.status === 'urgent') return score - 1;
      if (lead.status === 'won') return score + 10;
      return score;
    }, 0);

    return { 
      total, 
      overdue: overdueLeads.length, 
      critical: criticalLeads.length,
      urgent: urgentLeads.length, 
      won, 
      conversionRate,
      commercialScore
    };
  }, [leads, leadsByStatus]);

  console.log(`üé® [LeadsKanban] RENDU PRINCIPAL:`, {
    loading,
    statusesLoading,
    leadsCount: leads.length,
    leadsByStatusKeys: Object.keys(leadsByStatus),
    hasAPI: !!api,
    hasUser: !!user,
    hasOrg: !!currentOrganization,
    dndBackend: 'HTML5Backend',
    statusesCount: leadStatuses.length
  });

  if (loading || statusesLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <Spin size="large" />
      </div>
    );
  }

  if (leadStatuses.length === 0) {
    return (
      <Alert
        message="Aucun statut de lead configur√©"
        description="Veuillez configurer les statuts de leads dans les param√®tres."
        type="warning"
        showIcon
      />
    );
  }

  return (
    <DndProvider backend={HTML5Backend}>
      <div className="p-6">
        {/* üìä Header avec m√©triques */}
        <Row justify="space-between" align="middle" className="mb-6">
          <Col>
            <Title level={2} className="mb-0">
              üèóÔ∏è Pipeline Commercial
            </Title>
          </Col>
          <Col>
            <Space size="large">
              <div className="text-center">
                <div className="text-2xl font-bold text-blue-600">{metrics.total}</div>
                <div className="text-xs text-gray-500">Total leads</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-purple-600">{metrics.critical}</div>
                <div className="text-xs text-gray-500">Critiques</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-red-600">{metrics.overdue}</div>
                <div className="text-xs text-gray-500">En retard</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-orange-600">{metrics.urgent}</div>
                <div className="text-xs text-gray-500">Urgents</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-green-600">{metrics.conversionRate}%</div>
                <div className="text-xs text-gray-500">Conversion</div>
              </div>
              <div className="text-center">
                <div className={`text-2xl font-bold ${metrics.commercialScore >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                  {metrics.commercialScore > 0 ? '+' : ''}{metrics.commercialScore}
                </div>
                <div className="text-xs text-gray-500">Score IA</div>
              </div>
            </Space>
          </Col>
        </Row>

        {/* üèóÔ∏è Colonnes Kanban Dynamiques */}
        <Row gutter={16}>
          {leadStatuses.map(status => {
            const columnLeads = leadsByStatus[status.id] || [];
            console.log(`üèóÔ∏è [Rendu] Colonne ${status.id}:`, {
              columnName: status.name,
              leadsCount: columnLeads.length,
              leadIds: columnLeads.map(l => l.id),
              hasHandleDropLead: !!handleDropLead
            });
            
            // Transformer le statut Prisma en format compatible avec KanbanColumn
            const columnData = {
              id: status.id,
              name: status.name,
              color: status.color,
              description: `Statut: ${status.name}`
            };
            
            return (
              <Col key={status.id} span={Math.floor(24 / leadStatuses.length)}>
                <KanbanColumn
                  column={columnData}
                  leads={columnLeads}
                  onDropLead={handleDropLead}
                  onViewLead={onViewLead}
                  onCallLead={onCallLead}
                  onEmailLead={onEmailLead}
                  onScheduleLead={onScheduleLead}
                />
              </Col>
            );
          })}
        </Row>
      </div>
    </DndProvider>
  );
};

export default LeadsKanban;
