import React, { useState, useEffect, useMemo, useCallback } from 'react';
import {
  Layout, List, Button, Input,
  Modal, Form, Select, message, Spin,
  Drawer, Typography, Empty, Menu
} from 'antd';
import { 
  EditOutlined, ReloadOutlined, InboxOutlined, SendOutlined, 
  FileTextOutlined, StarOutlined, DeleteOutlined, ExclamationCircleOutlined, 
  FolderOutlined, RollbackOutlined, ShareAltOutlined, StarFilled
} from '@ant-design/icons';
import { useGmailService, FormattedGmailMessage, GmailMessage, GmailLabel } from '../hooks/useGmailService';
import PageHeader from '../components/PageHeader';
import GoogleAuthError from '../components/GoogleAuthError';

const { Content, Sider } = Layout;
const { TextArea } = Input;
const { Text } = Typography;

interface ComposeFormData {
  to: string[];
  cc?: string[];
  bcc?: string[];
  subject: string;
  body: string;
}

interface GmailBodyPart {
  partId: string;
  mimeType: string;
  filename: string;
  headers: Array<{ name: string; value: string }>;
  body: {
    attachmentId?: string;
    size: number;
    data?: string;
  };
  parts?: GmailBodyPart[];
}

const GoogleMailPageFixed: React.FC = () => {
  const gmailService = useGmailService();
  const [messages, setMessages] = useState<FormattedGmailMessage[]>([]);
  const [labels, setLabels] = useState<GmailLabel[]>([]);
  const [selectedMessage, setSelectedMessage] = useState<GmailMessage | null>(null);
  const [currentLabelId, setCurrentLabelId] = useState<string>('INBOX');
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [, setPageToken] = useState<string>('');
  const [composeModalVisible, setComposeModalVisible] = useState(false);
  const [messageDetailDrawerVisible, setMessageDetailDrawerVisible] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [authError, setAuthError] = useState<boolean>(false);
  const [composeForm] = Form.useForm<ComposeFormData>();

  const systemLabels = useMemo(() => ({
    'INBOX': { name: 'Bo√Æte de r√©ception', icon: <InboxOutlined /> },
    'SENT': { name: 'Messages envoy√©s', icon: <SendOutlined /> },
    'DRAFT': { name: 'Brouillons', icon: <FileTextOutlined /> },
    'STARRED': { name: 'Messages suivis', icon: <StarOutlined /> },
    'TRASH': { name: 'Corbeille', icon: <DeleteOutlined /> },
    'SPAM': { name: 'Spam', icon: <ExclamationCircleOutlined /> },
  }), []);

  const getHeaderValue = (headers: Array<{ name: string; value: string }>, name: string) => {
    const header = headers.find(h => h.name.toLowerCase() === name.toLowerCase());
    return header ? header.value : 'N/A';
  };

  const loadMessages = useCallback(async (labelId: string, query: string, token?: string) => {
    setIsLoading(true);
    setMessages([]); // Clear previous messages
    try {
      const result = await gmailService.getMessages({
        labelIds: [labelId],
        q: query,
        maxResults: 25,
        pageToken: token,
      });

      if (result && result.data) {
        console.log('[Gmail] üìß loadMessages: Messages re√ßus:', result.data.length, 'messages');
        console.log('[Gmail] üìß loadMessages: Premier message exemple:', result.data[0]);
        // Les messages sont d√©j√† format√©s par l'API, pas besoin d'appel suppl√©mentaire
        setMessages(result.data);
        console.log('[Gmail] üìß loadMessages: setMessages appel√© avec:', result.data.length, 'messages');
        setPageToken(result.nextPageToken || '');
      } else if (gmailService.error) {
        setAuthError(true);
        setMessages([]);
      } else {
        setMessages([]);
        setPageToken('');
      }
    } catch (error) {
      console.error(`Erreur chargement messages pour ${labelId}:`, error);
      message.error('Impossible de charger les messages.');
      setAuthError(true);
    } finally {
      setIsLoading(false);
    }
  }, []); // Enlever gmailService des d√©pendances pour √©viter la boucle infinie

  const loadInitialData = useCallback(async () => {
    console.log('[Gmail] ÔøΩ Chargement des donn√©es initiales');
    setIsLoading(true);
    
    try {
      // Charger les labels
      const labelsResult = await gmailService.getLabels();
      console.log('[Gmail] üìß Labels result:', labelsResult);
      if (labelsResult && labelsResult.data) {
        setLabels(labelsResult.data);
        
        // Charger les messages INBOX directement ici
        const result = await gmailService.getMessages({
          labelIds: ['INBOX'],
          q: '',
          maxResults: 25,
        });

        console.log('[Gmail] üìß R√©ponse compl√®te result:', result);
        console.log('[Gmail] üìß result.data exist?', !!result.data);
        console.log('[Gmail] üìß result.data type:', typeof result.data);
        console.log('[Gmail] üìß result.data.length:', result.data?.length);

        if (result && result.data) {
          console.log('[Gmail] üìß Messages re√ßus:', result.data.length, 'messages');
          console.log('[Gmail] üìß Premier message exemple:', result.data[0]);
          console.log('[Gmail] üìß AVANT setMessages - √©tat actuel messages.length:', messages.length);
          setMessages(result.data);
          console.log('[Gmail] üìß APRES setMessages appel√© avec:', result.data.length, 'messages');
          setPageToken(result.nextPageToken || '');
        } else {
          console.log('[Gmail] ‚ùå Pas de donn√©es valides dans result:', { result, hasData: !!result?.data });
          setMessages([]);
          setPageToken('');
        }
        
        console.log('[Gmail] ‚úÖ Initialisation termin√©e avec succ√®s');
      } else if (gmailService.error) {
        setAuthError(true);
      }
    } catch (error) {
      console.error('Erreur chargement initial:', error);
      setAuthError(true);
    } finally {
      setIsLoading(false);
  const loadMessages = useCallback(async (labelId: string, query: string) => {
    console.log('[Gmail] üîÑ Chargement messages pour labelId:', labelId, 'query:', query);
    try {
      setIsLoading(true);
      const result = await gmailService.getMessages({
        labelIds: [labelId],
        q: query,
        maxResults: 25,
      });
      
      if (result && result.data) {
        setMessages(result.data);
        setPageToken(result.nextPageToken || '');
      }
    } catch (error) {
      console.error('Erreur lors du chargement des messages:', error);
      message.error('Erreur lors du chargement des messages');
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Initialisation des donn√©es au montage du composant
  useEffect(() => {
    const initializeData = async () => {
      console.log('[Gmail] üöÄ Chargement des donn√©es initiales - useEffect direct');
      setIsLoading(true);
      
      try {
        // Charger les labels
        const labelsResult = await gmailService.getLabels();
        console.log('[Gmail] üìß Labels result:', labelsResult);
        if (labelsResult && labelsResult.data) {
          setLabels(labelsResult.data);
          
          // Charger les messages INBOX directement ici
          const result = await gmailService.getMessages({
            labelIds: ['INBOX'],
            q: '',
            maxResults: 25,
          });

          console.log('[Gmail] üìß R√©ponse compl√®te result:', result);
          console.log('[Gmail] üìß result.data exist?', !!result.data);
          console.log('[Gmail] üìß result.data type:', typeof result.data);
          console.log('[Gmail] üìß result.data.length:', result.data?.length);

          if (result && result.data) {
            console.log('[Gmail] üìß Messages re√ßus:', result.data.length, 'messages');
            console.log('[Gmail] üìß Premier message exemple:', result.data[0]);
            console.log('[Gmail] üìß AVANT setMessages - √©tat actuel messages.length:', messages.length);
            setMessages(result.data);
            console.log('[Gmail] üìß APRES setMessages appel√© avec:', result.data.length, 'messages');
            setPageToken(result.nextPageToken || '');
          } else {
            console.log('[Gmail] ‚ùå Pas de donn√©es valides dans result:', { result, hasData: !!result?.data });
            setMessages([]);
            setPageToken('');
          }
          
          console.log('[Gmail] ‚úÖ Initialisation termin√©e avec succ√®s');
        } else if (gmailService.error) {
          setAuthError(true);
        }
      } catch (error) {
        console.error('Erreur chargement initial:', error);
        setAuthError(true);
      } finally {
        setIsLoading(false);
      }
    };

    initializeData();
  }, []); // Se d√©clenche seulement au montage du composant

  const handleLabelClick = (labelId: string) => {
    setCurrentLabelId(labelId);
    setSearchQuery('');
    loadMessages(labelId, '');
  };

  const handleSearch = (query: string) => {
    setSearchQuery(query);
    loadMessages(currentLabelId, query);
  };

  const handleOpenMessage = async (message: FormattedGmailMessage) => {
    try {
      // R√©cup√©rer le message complet avec le body pour l'affichage d√©taill√©
      const fullMessage = await gmailService.getMessage(message.id);
      if (fullMessage) {
        setSelectedMessage(fullMessage);
        setMessageDetailDrawerVisible(true);
        // Marquer comme lu en retirant le label UNREAD
        if (!message.isRead) {
          gmailService.modifyMessage(message.id, [], ['UNREAD']);
        }
      }
    } catch (error) {
      console.error('Erreur lors de l\'ouverture du message:', error);
      message.error('Impossible d\'ouvrir le message');
    }
  };

  const handleCompose = (type: 'new' | 'reply' | 'forward' = 'new', originalMessage?: GmailMessage) => {
    composeForm.resetFields();
    if (originalMessage) {
      const from = getHeaderValue(originalMessage.payload.headers, 'From');
      const subject = getHeaderValue(originalMessage.payload.headers, 'Subject');
      
      if (type === 'reply') {
        composeForm.setFieldsValue({
          to: [from],
          subject: `Re: ${subject}`,
          body: `\n\n--- Le ${new Date(parseInt(originalMessage.internalDate)).toLocaleString()}, ${from} a √©crit ---\n> ${originalMessage.snippet}`
        });
      } else if (type === 'forward') {
        composeForm.setFieldsValue({
          subject: `Fwd: ${subject}`,
          body: `\n\n--- Message transf√©r√© ---\nDe: ${from}\nDate: ${new Date(parseInt(originalMessage.internalDate)).toLocaleString()}\nSujet: ${subject}\n\n${originalMessage.snippet}`
        });
      }
    }
    setComposeModalVisible(true);
  };

  const handleSendCommand = async (values: ComposeFormData) => {
    message.loading({ content: 'Envoi en cours...', key: 'sending' });
    const result = await gmailService.sendMessage(values);
    if (result) {
      message.success({ content: 'Message envoy√© !', key: 'sending' });
      setComposeModalVisible(false);
      if (currentLabelId === 'SENT') {
        loadMessages('SENT', '');
      }
    } else {
      message.error({ content: `√âchec de l'envoi. ${gmailService.error || 'Erreur inconnue.'}`, key: 'sending' });
    }
  };

  const handleDeleteMessage = async (messageId: string) => {
    message.loading({ content: 'Suppression en cours...', key: 'deleting' });
    const result = await gmailService.trashMessage(messageId);
    if (result) {
      message.success({ content: 'Message d√©plac√© dans la corbeille.', key: 'deleting' });
      setMessageDetailDrawerVisible(false);
      setMessages(messages.filter(m => m.id !== messageId));
    } else {
      message.error({ content: 'Erreur lors de la suppression.', key: 'deleting' });
    }
  };

  const handleToggleStar = async (messageId: string, isStarred: boolean) => {
    const addLabelIds = isStarred ? [] : ['STARRED'];
    const removeLabelIds = isStarred ? ['STARRED'] : [];
    
    const result = await gmailService.modifyMessage(messageId, addLabelIds, removeLabelIds);
    if (result) {
      // Mettre √† jour l'√©tat local pour un retour visuel imm√©diat
      setMessages(messages.map(m => 
        m.id === messageId 
          ? { ...m, labelIds: isStarred ? m.labelIds?.filter(l => l !== 'STARRED') : [...(m.labelIds || []), 'STARRED'] }
          : m
      ));
      if (selectedMessage?.id === messageId) {
        setSelectedMessage({
            ...selectedMessage,
            labelIds: isStarred ? selectedMessage.labelIds?.filter(l => l !== 'STARRED') : [...(selectedMessage.labelIds || []), 'STARRED']
        });
      }
    } else {
      message.error("Impossible de modifier le statut de l'√©toile.");
    }
  };

  if (authError) {
    return <GoogleAuthError onReconnect={() => window.location.href = '/api/google-auth'} />;
  }

  const renderSidebar = () => (
    <Sider width={240} theme="light" className="border-r">
      <div className="p-4">
        <Button type="primary" icon={<EditOutlined />} block onClick={() => handleCompose('new')} size="large">
          Nouveau message
        </Button>
      </div>
      <Menu
        mode="inline"
        selectedKeys={[currentLabelId]}
        onClick={({ key }) => handleLabelClick(key)}
      >
        {Object.entries(systemLabels).map(([id, { name, icon }]) => (
          <Menu.Item key={id} icon={icon}>
            {name}
          </Menu.Item>
        ))}
        <Menu.Divider />
        <Menu.SubMenu key="sub1" title="Mes dossiers" icon={<FolderOutlined />}>
          {labels
            .filter(l => l.type === 'user')
            .map(label => (
              <Menu.Item key={label.id}>{label.name}</Menu.Item>
            ))}
        </Menu.SubMenu>
      </Menu>
    </Sider>
  );

  const renderMessageList = () => (
    <div className="flex flex-col h-full">
      <div className="p-4 border-b">
        <Input.Search
          placeholder="Rechercher dans les e-mails"
          onSearch={handleSearch}
          enterButton
          loading={isLoading}
        />
      </div>
      {isLoading ? (
        <div className="flex-grow flex items-center justify-center">
          <Spin size="large" tip="Chargement des messages..." />
        </div>
      ) : messages.length === 0 ? (
        <div className="flex-grow flex items-center justify-center">
          <Empty description="Aucun message √† afficher." />
          {console.log('[Gmail] üîç RENDU: messages.length =', messages.length, 'isLoading =', isLoading)}
        </div>
      ) : (
        <List
          itemLayout="horizontal"
          dataSource={messages}
          className="overflow-auto flex-grow"
          renderItem={item => {
            // Utiliser la structure format√©e de l'API
            const from = item.from || '';
            const subject = item.subject || '(sans objet)';
            const date = new Date(item.timestamp).toLocaleDateString();
            const isUnread = !item.isRead;
            const isStarred = item.isStarred;

            return (
              <List.Item
                key={item.id}
                onClick={() => handleOpenMessage(item)}
                className={`cursor-pointer px-4 py-3 border-b ${isUnread ? 'bg-blue-50 font-semibold' : 'hover:bg-gray-50'}`}
                actions={[
                  <Button 
                    type="text" 
                    icon={isStarred ? <StarFilled style={{ color: '#fadb14' }} /> : <StarOutlined />} 
                    onClick={(e) => {
                      e.stopPropagation(); // Emp√™che l'ouverture du message
                      handleToggleStar(item.id, isStarred);
                    }}
                  />
                ]}
              >
                <List.Item.Meta
                  title={<Text strong={isUnread}>{from}</Text>}
                  description={<Text ellipsis>{subject || '(aucun objet)'}</Text>}
                />
                <div className="text-right">
                  <Text type="secondary" className="text-xs">{date}</Text>
                </div>
              </List.Item>
            );
          }}
        />
      )}
    </div>
  );

  const renderMessageDetail = () => {
    if (!selectedMessage) return null;
    
    const from = getHeaderValue(selectedMessage.payload.headers, 'From');
    const to = getHeaderValue(selectedMessage.payload.headers, 'To');
    const subject = getHeaderValue(selectedMessage.payload.headers, 'Subject');
    const date = new Date(parseInt(selectedMessage.internalDate)).toLocaleString();
    const isStarred = selectedMessage.labelIds?.includes('STARRED');
    
    let body = '';
    const findBodyPart = (parts: GmailBodyPart[]): GmailBodyPart | null => {
        for (const part of parts) {
            if (part.mimeType === 'text/html') {
                return part;
            }
            if (part.parts) {
                const nestedPart = findBodyPart(part.parts);
                if (nestedPart) return nestedPart;
            }
        }
        return parts.find(p => p.mimeType === 'text/plain') || null;
    };

    if (selectedMessage.payload.parts) {
        const part = findBodyPart(selectedMessage.payload.parts);
        if (part && part.body.data) {
            body = atob(part.body.data.replace(/-/g, '+').replace(/_/g, '/'));
        }
    } else if (selectedMessage.payload.body.data) {
        body = atob(selectedMessage.payload.body.data.replace(/-/g, '+').replace(/_/g, '/'));
    }

    return (
      <Drawer
        title={
            <div className="flex items-center">
                <Button 
                    type="text" 
                    icon={isStarred ? <StarFilled style={{ color: '#fadb14' }} /> : <StarOutlined />} 
                    onClick={() => handleToggleStar(selectedMessage.id, isStarred)}
                    className="mr-2"
                />
                <span className="truncate">{subject || 'D√©tail du message'}</span>
            </div>
        }
        placement="right"
        width={'60%'}
        onClose={() => setMessageDetailDrawerVisible(false)}
        open={messageDetailDrawerVisible}
        extra={
          <Button.Group>
            <Button icon={<RollbackOutlined />} onClick={() => handleCompose('reply', selectedMessage)}>R√©pondre</Button>
            <Button icon={<ShareAltOutlined />} onClick={() => handleCompose('forward', selectedMessage)}>Transf√©rer</Button>
            <Button icon={<DeleteOutlined />} danger onClick={() => handleDeleteMessage(selectedMessage.id)}>Supprimer</Button>
          </Button.Group>
        }
      >
        <div className="p-2">
          <p><strong>De :</strong> {from}</p>
          <p><strong>√Ä :</strong> {to}</p>
          <p><strong>Date :</strong> {date}</p>
          <hr className="my-4"/>
          <div dangerouslySetInnerHTML={{ __html: body }} style={{ overflowWrap: 'break-word', wordWrap: 'break-word' }}/>
        </div>
      </Drawer>
    );
  };

  const renderComposeModal = () => (
    <Modal
      title="Nouveau message"
      open={composeModalVisible}
      onCancel={() => setComposeModalVisible(false)}
      width={800}
      destroyOnClose // Important pour r√©initialiser le form
      footer={[
        <Button key="back" onClick={() => setComposeModalVisible(false)}>Annuler</Button>,
        <Button key="submit" type="primary" onClick={() => composeForm.submit()}>
          Envoyer
        </Button>,
      ]}
    >
      <Form form={composeForm} layout="vertical" onFinish={handleSendCommand}>
        <Form.Item name="to" label="√Ä" rules={[{ required: true, message: 'Destinataire requis' }]}>
          <Select mode="tags" placeholder="email@example.com" />
        </Form.Item>
        <Form.Item name="subject" label="Objet">
          <Input placeholder="Objet de votre message" />
        </Form.Item>
        <Form.Item name="body" label="Message" rules={[{ required: true, message: 'Le corps du message ne peut √™tre vide' }]}>
          <TextArea rows={10} placeholder="√âcrivez votre message ici..." />
        </Form.Item>
      </Form>
    </Modal>
  );

  return (
    <Layout className="h-screen bg-white">
      <PageHeader
        title="Bo√Æte Mail Gmail"
        subtitle="Votre bo√Æte de r√©ception centralis√©e"
        extra={[
          <Button key="refresh" icon={<ReloadOutlined />} onClick={() => loadMessages(currentLabelId, searchQuery)} loading={isLoading}>
            Actualiser
          </Button>
        ]}
      />
      <Layout>
        {renderSidebar()}
        <Content className="bg-white border-l">
          {renderMessageList()}
        </Content>
      </Layout>
      {renderMessageDetail()}
      {renderComposeModal()}
    </Layout>
  );
};

export default GoogleMailPageFixed;