var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/lib/database.ts
var database_exports = {};
__export(database_exports, {
  Prisma: () => import_client.Prisma,
  checkDatabaseConnection: () => checkDatabaseConnection,
  connectDatabase: () => connectDatabase,
  db: () => db,
  disconnectDatabase: () => disconnectDatabase,
  getDatabaseInfo: () => getDatabaseInfo,
  prisma: () => prisma
});
function buildDatabaseUrl() {
  const direct = process.env.DATABASE_URL;
  if (direct && direct.trim().length > 0) {
    return direct;
  }
  const user = process.env.PGUSER || "postgres";
  const password = process.env.PGPASSWORD || "";
  const db2 = process.env.PGDATABASE || "2thier";
  const host = process.env.PGHOST || "localhost";
  const port2 = process.env.PGPORT || "5432";
  if (host.startsWith("/cloudsql/")) {
    const encodedPwd2 = encodeURIComponent(password);
    const url = `postgresql://${user}:${encodedPwd2}@localhost/${db2}?host=${encodeURIComponent(host)}`;
    console.warn("[Database] Connexion via Unix socket Cloud SQL:", {
      PGUSER: user,
      PGDATABASE: db2,
      PGHOST: host
    });
    return url;
  }
  const encodedPwd = encodeURIComponent(password);
  return `postgresql://${user}:${encodedPwd}@${host}:${port2}/${db2}`;
}
function createPrismaInstance() {
  if (globalForDb.__db_instance) {
    return globalForDb.__db_instance;
  }
  const env = process.env.NODE_ENV || "development";
  const config = DB_CONFIG[env] || DB_CONFIG.development;
  const instance = new import_client.PrismaClient({
    log: config.logLevel,
    datasources: {
      db: {
        url: buildDatabaseUrl()
      }
    }
  });
  if (process.env.NODE_ENV !== "production") {
    globalForDb.__db_instance = instance;
  }
  return instance;
}
async function connectDatabase() {
  if (globalForDb.__db_initialized) {
    console.log("[Database] \u26A1 Connexion d\xE9j\xE0 \xE9tablie (singleton)");
    return;
  }
  globalForDb.__db_initialized = true;
  try {
    console.log("[Database] \u{1F50C} Connexion en cours...");
    await db.$connect();
    console.log("[Database] \u2705 Connexion \xE9tablie avec succ\xE8s");
  } catch (err) {
    console.error("[Database] \u274C \xC9chec de connexion:", err?.message);
    throw err;
  }
}
async function disconnectDatabase() {
  try {
    await db.$disconnect();
    console.log("[Database] Connexion ferm\xE9e proprement");
  } catch (err) {
    console.error("[Database] Erreur lors de la fermeture:", err?.message);
  }
}
async function checkDatabaseConnection() {
  try {
    await db.$queryRaw`SELECT 1`;
    return true;
  } catch {
    return false;
  }
}
function getDatabaseInfo() {
  return {
    adapter: CURRENT_ADAPTER,
    environment: process.env.NODE_ENV || "development",
    connected: globalForDb.__db_initialized || false
  };
}
var import_client, CURRENT_ADAPTER, DB_CONFIG, globalForDb, db, prisma;
var init_database = __esm({
  "src/lib/database.ts"() {
    import_client = require("@prisma/client");
    CURRENT_ADAPTER = "prisma";
    DB_CONFIG = {
      development: {
        connectionLimit: 5,
        poolTimeout: 30,
        connectTimeout: 10,
        logLevel: ["warn", "error"]
      },
      production: {
        connectionLimit: 20,
        poolTimeout: 30,
        connectTimeout: 10,
        logLevel: []
      },
      test: {
        connectionLimit: 2,
        poolTimeout: 10,
        connectTimeout: 5,
        logLevel: ["error"]
      }
    };
    globalForDb = globalThis;
    db = createPrismaInstance();
    prisma = db;
    process.on("beforeExit", async () => {
      await disconnectDatabase();
    });
    console.log(`[Database] Adaptateur: ${CURRENT_ADAPTER} | Env: ${process.env.NODE_ENV || "development"}`);
  }
});

// src/lib/prisma.ts
var init_prisma = __esm({
  "src/lib/prisma.ts"() {
    init_database();
  }
});

// src/utils/crypto.ts
function encrypt(text) {
  if (!key) {
    if (process.env.NODE_ENV === "production") {
      throw new Error("ENCRYPTION_KEY absente/invalide: chiffrement indisponible. Configurez une cl\xE9 de 32 caract\xE8res.");
    }
    console.warn("[CRYPTO] encrypt() appel\xE9 sans cl\xE9 valide en environnement non-production. Retour en clair.");
    return text;
  }
  const iv = crypto2.randomBytes(IV_LENGTH);
  const cipher = crypto2.createCipheriv(ALGORITHM, key, iv);
  let encrypted = cipher.update(text, "utf8", "hex");
  encrypted += cipher.final("hex");
  return iv.toString("hex") + ":" + encrypted;
}
function decrypt(text) {
  try {
    if (!text.includes(":")) {
      return text;
    }
    if (!key) {
      console.warn("[CRYPTO] decrypt() appel\xE9 sans cl\xE9 valide. Retour du texte original.");
      return text;
    }
    const textParts = text.split(":");
    if (textParts.length < 2) {
      throw new Error("Invalid encrypted text format");
    }
    const ivHex = textParts.shift();
    if (!ivHex) {
      throw new Error("IV is missing");
    }
    const iv = Buffer.from(ivHex, "hex");
    const encryptedText = textParts.join(":");
    const decipher = crypto2.createDecipheriv(ALGORITHM, key, iv);
    let decrypted = decipher.update(encryptedText, "hex", "utf8");
    decrypted += decipher.final("utf8");
    return decrypted;
  } catch (error) {
    console.error("Decryption failed:", error);
    return text;
  }
}
var crypto2, ALGORITHM, IV_LENGTH, ENCRYPTION_KEY, key;
var init_crypto = __esm({
  "src/utils/crypto.ts"() {
    crypto2 = __toESM(require("crypto"), 1);
    ALGORITHM = "aes-256-cbc";
    IV_LENGTH = 16;
    ENCRYPTION_KEY = process.env.ENCRYPTION_KEY;
    key = null;
    (() => {
      try {
        if (ENCRYPTION_KEY && Buffer.from(ENCRYPTION_KEY, "utf8").length === 32) {
          key = Buffer.from(ENCRYPTION_KEY, "utf8");
        } else {
          console.warn("[CRYPTO] ENCRYPTION_KEY manquante ou invalide (32 chars requis). Le chiffrement est indisponible jusqu'\xE0 configuration.");
          key = null;
        }
      } catch (e) {
        console.warn("[CRYPTO] Impossible d'initialiser la cl\xE9 de chiffrement:", e?.message);
        key = null;
      }
    })();
  }
});

// src/services/UniversalNotificationService.ts
var import_events, NOTIFICATION_CONFIG, UniversalNotificationService, UniversalNotificationService_default;
var init_UniversalNotificationService = __esm({
  "src/services/UniversalNotificationService.ts"() {
    import_events = require("events");
    init_prisma();
    NOTIFICATION_CONFIG = {
      NEW_EMAIL: { icon: "\u{1F4E7}", color: "#1890ff", sound: "email.wav" },
      NEW_LEAD: { icon: "\u{1F465}", color: "#52c41a", sound: "success.wav" },
      MISSED_CALL: { icon: "\u{1F4DE}", color: "#fa8c16", sound: "alert.wav" },
      UPCOMING_MEETING: { icon: "\u{1F4C5}", color: "#722ed1", sound: "reminder.wav" },
      NEW_QUOTE: { icon: "\u{1F4B0}", color: "#13c2c2", sound: "cash.wav" },
      NEW_INVOICE: { icon: "\u{1F9FE}", color: "#eb2f96", sound: "invoice.wav" },
      OVERDUE_TASK: { icon: "\u23F0", color: "#f5222d", sound: "urgent.wav" },
      SYSTEM_ALERT: { icon: "\u{1F6A8}", color: "#ff4d4f", sound: "system.wav" },
      USER_MENTION: { icon: "@\uFE0F\u20E3", color: "#1890ff", sound: "mention.wav" },
      PROJECT_UPDATE: { icon: "\u{1F4CB}", color: "#52c41a", sound: "update.wav" },
      PAYMENT_RECEIVED: { icon: "\u{1F4B3}", color: "#52c41a", sound: "payment.wav" },
      CONTRACT_EXPIRING: { icon: "\u{1F4C4}", color: "#fa8c16", sound: "warning.wav" }
    };
    UniversalNotificationService = class _UniversalNotificationService extends import_events.EventEmitter {
      static instance;
      isRunning = false;
      checkInterval;
      constructor() {
        super();
      }
      static getInstance() {
        if (!this.instance) {
          this.instance = new _UniversalNotificationService();
        }
        return this.instance;
      }
      /**
       * üöÄ D√âMARRER LE SERVICE UNIVERSEL
       */
      start() {
        if (this.isRunning) {
          console.log("\u26A0\uFE0F [UniversalNotification] Service d\xE9j\xE0 en cours...");
          return;
        }
        console.log("\u{1F31F} [UniversalNotification] D\xE9marrage du service UNIVERSEL de notifications...");
        this.isRunning = true;
        this.startPeriodicChecks();
        this.emit("service-started");
        console.log("\u2705 [UniversalNotification] Service universel d\xE9marr\xE9 avec succ\xE8s");
      }
      /**
       * üõë ARR√äTER LE SERVICE
       */
      stop() {
        console.log("\u{1F6D1} [UniversalNotification] Arr\xEAt du service...");
        if (this.checkInterval) {
          clearInterval(this.checkInterval);
        }
        this.isRunning = false;
        this.emit("service-stopped");
        console.log("\u2705 [UniversalNotification] Service arr\xEAt\xE9");
      }
      /**
       * ÔøΩ OBTENIR L'√âTAT COURANT DU SERVICE
       */
      getStatus() {
        return {
          isRunning: this.isRunning,
          checksActive: Boolean(this.checkInterval),
          activeListeners: this.listenerCount("notification-created")
        };
      }
      /**
       * ÔøΩüîî CR√âER UNE NOTIFICATION UNIVERSELLE
       */
      async createNotification(data) {
        try {
          const config = NOTIFICATION_CONFIG[data.type];
          console.log(`\u{1F514} [UniversalNotification] Cr\xE9ation notification: ${data.type} - ${data.title}`);
          const notification = await db.notification.create({
            data: {
              organizationId: data.organizationId,
              userId: data.userId,
              type: data.type === "NEW_EMAIL" ? "NEW_MAIL_RECEIVED" : data.type,
              data: {
                title: data.title,
                message: data.message,
                priority: data.priority,
                icon: config.icon,
                color: config.color,
                sound: config.sound,
                actionUrl: data.actionUrl,
                tags: data.tags,
                timestamp: (/* @__PURE__ */ new Date()).toISOString(),
                metadata: data.metadata
              },
              status: "PENDING",
              expiresAt: data.expiresAt
            }
          });
          this.emit("notification-created", {
            id: notification.id,
            type: data.type,
            title: data.title,
            message: data.message,
            userId: data.userId,
            organizationId: data.organizationId,
            priority: data.priority,
            config
          });
          console.log(`\u2705 [UniversalNotification] Notification cr\xE9\xE9e: ${notification.id}`);
        } catch (error) {
          console.error("\u274C [UniversalNotification] Erreur cr\xE9ation notification:", error);
          throw error;
        }
      }
      /**
       * üìß NOTIFICATION EMAIL SP√âCIALIS√âE
       */
      async notifyNewEmail(emailData) {
        await this.createNotification({
          type: "NEW_EMAIL",
          title: "Nouveau message re\xE7u",
          message: emailData.summary ?? `De: ${emailData.from.substring(0, 30)}${emailData.from.length > 30 ? "..." : ""}`,
          userId: emailData.userId,
          organizationId: emailData.organizationId,
          priority: emailData.priority ?? "medium",
          metadata: {
            emailId: emailData.emailId,
            from: emailData.from,
            subject: emailData.subject,
            ...emailData.metadata
          },
          actionUrl: emailData.actionUrl ?? `/emails/${emailData.emailId}`,
          tags: emailData.tags ?? ["email", "inbox"]
        });
      }
      /**
       * üë• NOTIFICATION NOUVEAU LEAD
       */
      async notifyNewLead(leadData) {
        await this.createNotification({
          type: "NEW_LEAD",
          title: "Nouveau prospect",
          message: `${leadData.name}${leadData.source ? ` via ${leadData.source}` : ""}`,
          userId: leadData.userId,
          organizationId: leadData.organizationId,
          priority: "high",
          metadata: {
            leadId: leadData.leadId,
            name: leadData.name,
            email: leadData.email,
            phone: leadData.phone,
            source: leadData.source
          },
          actionUrl: `/leads/${leadData.leadId}`,
          tags: ["lead", "prospect", "new"]
        });
      }
      /**
       * üìû NOTIFICATION APPEL MANQU√â
       */
      async notifyMissedCall(callData) {
        await this.createNotification({
          type: "MISSED_CALL",
          title: "Appel manqu\xE9",
          message: `Appel de ${callData.from}`,
          userId: callData.userId,
          organizationId: callData.organizationId,
          priority: "high",
          metadata: {
            callId: callData.callId,
            from: callData.from,
            duration: callData.duration
          },
          actionUrl: callData.callId ? `/calls/${callData.callId}` : "/calls",
          tags: ["call", "missed", "urgent"]
        });
      }
      /**
       * üìÖ NOTIFICATION RENDEZ-VOUS PROCHE
       */
      async notifyUpcomingMeeting(meetingData) {
        const timeUntil = Math.round((meetingData.startTime.getTime() - Date.now()) / (1e3 * 60));
        await this.createNotification({
          type: "UPCOMING_MEETING",
          title: "Rendez-vous dans 15 minutes",
          message: `${meetingData.title} dans ${timeUntil} min`,
          userId: meetingData.userId,
          organizationId: meetingData.organizationId,
          priority: "high",
          metadata: {
            meetingId: meetingData.meetingId,
            title: meetingData.title,
            startTime: meetingData.startTime,
            attendees: meetingData.attendees,
            timeUntil
          },
          actionUrl: `/calendar/${meetingData.meetingId}`,
          tags: ["meeting", "calendar", "reminder"],
          expiresAt: meetingData.startTime
        });
      }
      /**
       * üí∞ NOTIFICATION NOUVEAU DEVIS
       */
      async notifyNewQuote(quoteData) {
        await this.createNotification({
          type: "NEW_QUOTE",
          title: "Nouveau devis cr\xE9\xE9",
          message: `${quoteData.clientName} - ${quoteData.amount}${quoteData.currency || "\u20AC"}`,
          userId: quoteData.userId,
          organizationId: quoteData.organizationId,
          priority: "medium",
          metadata: {
            quoteId: quoteData.quoteId,
            clientName: quoteData.clientName,
            amount: quoteData.amount,
            currency: quoteData.currency
          },
          actionUrl: `/quotes/${quoteData.quoteId}`,
          tags: ["quote", "billing", "financial"]
        });
      }
      /**
       * üîÑ V√âRIFICATIONS P√âRIODIQUES (toutes les 2 minutes)
       */
      startPeriodicChecks() {
        console.log("\u{1F504} [UniversalNotification] D\xE9marrage v\xE9rifications p\xE9riodiques...");
        this.checkInterval = setInterval(async () => {
          try {
            await this.checkForUpcomingMeetings();
            await this.checkForOverdueTasks();
            await this.checkForExpiringContracts();
            await this.cleanExpiredNotifications();
          } catch (error) {
            console.error("\u274C [UniversalNotification] Erreur v\xE9rification p\xE9riodique:", error);
          }
        }, 2 * 60 * 1e3);
      }
      /**
       * üìÖ V√âRIFIER LES RENDEZ-VOUS PROCHES
       */
      async checkForUpcomingMeetings() {
        const now = /* @__PURE__ */ new Date();
        const fifteenMinutesFromNow = new Date(now.getTime() + 15 * 60 * 1e3);
        console.log(
          `\u{1F4C5} [UniversalNotification] V\xE9rification des rendez-vous entre ${now.toISOString()} et ${fifteenMinutesFromNow.toISOString()}...`
        );
      }
      /**
       * ‚è∞ V√âRIFIER LES T√ÇCHES EN RETARD
       */
      async checkForOverdueTasks() {
        console.log("\u23F0 [UniversalNotification] V\xE9rification des t\xE2ches en retard...");
      }
      /**
       * üìÑ V√âRIFIER LES CONTRATS EXPIRANTS
       */
      async checkForExpiringContracts() {
        console.log("\u{1F4C4} [UniversalNotification] V\xE9rification des contrats expirants...");
      }
      /**
       * üßπ NETTOYER LES NOTIFICATIONS EXPIR√âES
       */
      async cleanExpiredNotifications() {
        try {
          const result = await db.notification.deleteMany({
            where: {
              expiresAt: {
                lt: /* @__PURE__ */ new Date()
              }
            }
          });
          if (result.count > 0) {
            console.log(`\u{1F9F9} [UniversalNotification] ${result.count} notifications expir\xE9es supprim\xE9es`);
          }
        } catch (error) {
          console.error("\u274C [UniversalNotification] Erreur nettoyage notifications expir\xE9es:", error);
        }
      }
      /**
       * üìä OBTENIR LES STATISTIQUES
       */
      async getStats(organizationId) {
        try {
          const stats = await db.notification.groupBy({
            by: ["type", "status"],
            where: {
              organizationId,
              createdAt: {
                gte: new Date(Date.now() - 24 * 60 * 60 * 1e3)
                // Derni√®res 24h
              }
            },
            _count: true
          });
          return {
            total: stats.reduce((sum, s) => sum + s._count, 0),
            byType: stats.reduce((acc, s) => {
              acc[s.type] = (acc[s.type] || 0) + s._count;
              return acc;
            }, {}),
            byStatus: stats.reduce((acc, s) => {
              acc[s.status] = (acc[s.status] || 0) + s._count;
              return acc;
            }, {})
          };
        } catch (error) {
          console.error("\u274C [UniversalNotification] Erreur stats:", error);
          return { total: 0, byType: {}, byStatus: {} };
        }
      }
    };
    UniversalNotificationService_default = UniversalNotificationService;
  }
});

// src/services/RealTimeEmailNotificationService.ts
var import_events2, prisma9, RealTimeEmailNotificationService2, RealTimeEmailNotificationService_default;
var init_RealTimeEmailNotificationService = __esm({
  "src/services/RealTimeEmailNotificationService.ts"() {
    init_database();
    import_events2 = require("events");
    init_UniversalNotificationService();
    prisma9 = db;
    RealTimeEmailNotificationService2 = class _RealTimeEmailNotificationService extends import_events2.EventEmitter {
      static instance;
      backupCheckInterval;
      isRunning = false;
      constructor() {
        super();
      }
      static getInstance() {
        if (!this.instance) {
          this.instance = new _RealTimeEmailNotificationService();
        }
        return this.instance;
      }
      /**
       * üöÄ D√âMARRER LE SERVICE TEMPS R√âEL
       */
      start() {
        if (this.isRunning) {
          console.log("\u26A0\uFE0F [RealTimeEmailNotification] Service d\xE9j\xE0 en cours...");
          return;
        }
        console.log("\u{1F680} [RealTimeEmailNotification] D\xE9marrage du service temps r\xE9el...");
        this.isRunning = true;
        this.setupEmailSyncListener();
        this.startBackupCheck();
        console.log("\u2705 [RealTimeEmailNotification] Service temps r\xE9el d\xE9marr\xE9 !");
      }
      /**
       * üéØ √âCOUTER LES NOUVEAUX EMAILS EN TEMPS R√âEL
       */
      setupEmailSyncListener() {
        console.log("\u{1F3A7} [RealTimeEmailNotification] Configuration de l'\xE9coute temps r\xE9el...");
        this.on("newEmailReceived", this.handleNewEmailReceived.bind(this));
        console.log("\u2705 [RealTimeEmailNotification] \xC9coute temps r\xE9el configur\xE9e");
      }
      /**
       * üìß TRAITEMENT IMM√âDIAT D'UN NOUVEL EMAIL
       */
      async handleNewEmailReceived(emailData) {
        try {
          console.log(`\u26A1 [RealTimeEmailNotification] NOUVEL EMAIL D\xC9TECT\xC9 - Traitement imm\xE9diat !`);
          console.log(`\u{1F4E7} De: ${emailData.from}, Sujet: ${emailData.subject}`);
          if (this.shouldIgnoreEmail(emailData)) {
            console.log(`\u{1F6AB} [RealTimeEmailNotification] Email ignor\xE9: ${emailData.folder}`);
            return;
          }
          await this.createInstantNotification(emailData);
        } catch (error) {
          console.error("\u274C [RealTimeEmailNotification] Erreur lors du traitement temps r\xE9el:", error);
        }
      }
      /**
       * üîî CR√âER UNE NOTIFICATION INSTANTAN√âE
       */
      async createInstantNotification(emailData) {
        try {
          const universalService = UniversalNotificationService_default.getInstance();
          await universalService.notifyNewEmail({
            emailId: emailData.emailId,
            from: emailData.from,
            subject: emailData.subject,
            userId: emailData.userId,
            organizationId: emailData.organizationId
          });
          console.log(`\u2705 [RealTimeEmailNotification] Notification UNIVERSELLE cr\xE9\xE9e pour: ${emailData.subject}`);
        } catch (error) {
          console.error("\u274C [RealTimeEmailNotification] Erreur notification instantan\xE9e:", error);
        }
      }
      /**
      * üîÑ V√âRIFICATION DE S√âCURIT√â (toutes les 5 minutes)
      * En cas o√π le temps r√©el rate quelque chose
      */
      startBackupCheck() {
        console.log("\u{1F6E1}\uFE0F [RealTimeEmailNotification] D\xE9marrage v\xE9rification de s\xE9curit\xE9...");
        this.backupCheckInterval = setInterval(async () => {
          console.log("\u{1F50D} [RealTimeEmailNotification] V\xE9rification de s\xE9curit\xE9...");
          await this.performBackupCheck();
        }, 5 * 60 * 1e3);
      }
      /**
       * üîç V√âRIFICATION DE S√âCURIT√â - RATTRAPER LES EMAILS MANQU√âS
       * M√©thode publique pour d√©clencher manuellement une v√©rification
       */
      async performBackupCheck() {
        try {
          const tenMinutesAgo = new Date(Date.now() - 10 * 60 * 1e3);
          const usersWithMail = await prisma9.emailAccount.findMany({
            where: {
              isActive: true,
              encryptedPassword: { not: null }
            },
            select: {
              userId: true
            },
            take: 10
            // Limite pour la s√©curit√©
          });
          for (const emailAccount of usersWithMail) {
            const userOrg = await prisma9.userOrganization.findFirst({
              where: { userId: emailAccount.userId },
              select: { organizationId: true }
            });
            if (!userOrg) continue;
            const organizationId = userOrg.organizationId;
            const recentEmails = await prisma9.email.findMany({
              where: {
                userId: emailAccount.userId,
                createdAt: { gte: tenMinutesAgo },
                folder: { in: ["INBOX", "inbox"] },
                // V√©rifier qu'il n'y a pas d√©j√† une notification
                NOT: {
                  id: {
                    in: await prisma9.notification.findMany({
                      where: {
                        userId: emailAccount.userId,
                        type: "NEW_MAIL_RECEIVED",
                        createdAt: { gte: tenMinutesAgo }
                      },
                      select: { id: true }
                    }).then((notifications) => notifications.map((n) => n.id))
                  }
                }
              },
              orderBy: { createdAt: "desc" },
              take: 5
            });
            for (const email of recentEmails) {
              const universalService = UniversalNotificationService_default.getInstance();
              await universalService.notifyNewEmail({
                emailId: email.id,
                from: email.from,
                subject: email.subject,
                userId: emailAccount.userId,
                organizationId
              });
            }
          }
          console.log("\u2705 [RealTimeEmailNotification] V\xE9rification de s\xE9curit\xE9 termin\xE9e");
        } catch (error) {
          console.error("\u274C [RealTimeEmailNotification] Erreur v\xE9rification de s\xE9curit\xE9:", error);
        }
      }
      /**
       * üö´ FILTRER LES EMAILS √Ä IGNORER
       */
      shouldIgnoreEmail(emailData) {
        const ignoredFolders = [
          "SPAM",
          "spam",
          "Spam",
          "JUNK",
          "junk",
          "Junk",
          "DRAFTS",
          "drafts",
          "Drafts",
          "Brouillons",
          "SENT",
          "sent",
          "Sent",
          "Envoy\xE9s"
        ];
        return ignoredFolders.includes(emailData.folder);
      }
      /**
       * üìß M√âTHODE PUBLIQUE POUR SIGNALER UN NOUVEL EMAIL
       * √Ä appeler depuis AutoMailSyncService
       */
      notifyNewEmail(emailData) {
        this.emit("newEmailReceived", emailData);
      }
      /**
       * üõë ARR√äTER LE SERVICE
       */
      stop() {
        if (!this.isRunning) return;
        console.log("\u{1F6D1} [RealTimeEmailNotification] Arr\xEAt du service...");
        if (this.backupCheckInterval) {
          clearInterval(this.backupCheckInterval);
        }
        this.removeAllListeners();
        this.isRunning = false;
        console.log("\u2705 [RealTimeEmailNotification] Service arr\xEAt\xE9");
      }
      /**
       * ‚úÇÔ∏è UTILITAIRE POUR TRONQUER LES CHA√éNES
       */
      truncateString(str, maxLength) {
        if (str.length <= maxLength) return str;
        return str.substring(0, maxLength - 3) + "...";
      }
    };
    RealTimeEmailNotificationService_default = RealTimeEmailNotificationService2;
  }
});

// src/services/AutoMailSyncService.ts
var AutoMailSyncService_exports = {};
__export(AutoMailSyncService_exports, {
  autoMailSync: () => autoMailSync,
  default: () => AutoMailSyncService_default
});
function decodeMimeHeader(header) {
  if (!header) return header;
  const mimePattern = /=\?([^?]+)\?([QqBb])\?([^?]*)\?=/g;
  return header.replace(mimePattern, (match, charset, encoding, encodedText) => {
    try {
      charset = charset.toLowerCase();
      encoding = encoding.toUpperCase();
      if (encoding === "Q" || encoding === "q") {
        let decoded = encodedText.replace(/_/g, " ");
        decoded = decoded.replace(/=([0-9A-F]{2})/gi, (_, hex) => {
          return String.fromCharCode(parseInt(hex, 16));
        });
        return decoded;
      } else if (encoding === "B" || encoding === "b") {
        return Buffer.from(encodedText, "base64").toString("utf8");
      }
      return encodedText;
    } catch (error) {
      console.warn("Erreur de d\xE9codage MIME:", error);
      return match;
    }
  });
}
function fixUtf8Encoding(text) {
  if (!text) return text;
  const utf8Fixes = {
    "\xC3\xA9": "\xE9",
    "\xC3\xA8": "\xE8",
    "\xC3 ": "\xE0",
    "\xC3\xA7": "\xE7",
    "\xC3\xA2": "\xE2",
    "\xC3\xB4": "\xF4",
    "\xC3\xB9": "\xF9",
    "\xC3\xBB": "\xFB",
    "\xC3\xAE": "\xEE",
    "\xC3\xAB": "\xEB",
    "\xC3\xAF": "\xEF",
    "\xC3\xB1": "\xF1",
    "\xC3\xAA": "\xEA",
    "\xC3\xBC": "\xFC",
    "\xC2 ": " ",
    // Espace mal encod√©
    "\xC2": ""
    // Caract√®res r√©siduels
  };
  let fixedText = text;
  for (const [bad, good] of Object.entries(utf8Fixes)) {
    fixedText = fixedText.replace(new RegExp(bad, "g"), good);
  }
  return fixedText;
}
var import_events3, import_imap_simple, AutoMailSyncService, autoMailSync, AutoMailSyncService_default;
var init_AutoMailSyncService = __esm({
  "src/services/AutoMailSyncService.ts"() {
    import_events3 = require("events");
    import_imap_simple = __toESM(require("imap-simple"), 1);
    init_crypto();
    init_RealTimeEmailNotificationService();
    init_prisma();
    AutoMailSyncService = class extends import_events3.EventEmitter {
      isRunning = false;
      syncInterval = null;
      syncFrequency = 6e4;
      // üöÄ CHANG√â : 1 minute au lieu de 10 (plus r√©actif pour notifications)
      maxRetries = 3;
      // Nombre maximum de tentatives en cas d'erreur
      retryDelay = 5e3;
      // D√©lai entre les tentatives (5 secondes)
      constructor() {
        super();
      }
      start() {
        if (this.isRunning) {
          console.log("\u{1F504} [AUTO-SYNC] Service d\xE9j\xE0 en cours d'ex\xE9cution");
          return;
        }
        this.isRunning = true;
        console.log("\u{1F680} [AUTO-SYNC] D\xE9marrage du service de synchronisation automatique (toutes les 1 minute - TEMPS R\xC9EL)");
        this.performSyncWithRetry();
        this.syncInterval = setInterval(() => {
          this.performSyncWithRetry();
        }, this.syncFrequency);
      }
      /**
       * üöÄ NOUVELLE M√âTHODE : Synchroniser un utilisateur sp√©cifique imm√©diatement
       */
      async syncForUser(userId) {
        try {
          console.log(`\u{1F3AF} [AUTO-SYNC] Synchronisation manuelle pour l'utilisateur: ${userId}`);
          const emailAccount = await db.emailAccount.findFirst({
            where: {
              userId,
              isActive: true
            }
          });
          if (!emailAccount) {
            console.log(`\u26A0\uFE0F [AUTO-SYNC] Aucun compte email actif trouv\xE9 pour l'utilisateur ${userId}`);
            return null;
          }
          const result = await this.syncUserEmails(emailAccount);
          console.log(`\u2705 [AUTO-SYNC] Sync manuelle termin\xE9e pour ${userId}: ${result.newEmails} nouveaux, ${result.updatedEmails} mis \xE0 jour`);
          return result;
        } catch (error) {
          console.error(`\u274C [AUTO-SYNC] Erreur sync manuelle pour l'utilisateur ${userId}:`, error);
          throw error;
        }
      }
      stop() {
        if (this.syncInterval) {
          clearInterval(this.syncInterval);
          this.syncInterval = null;
        }
        this.isRunning = false;
        console.log("\u23F9\uFE0F [AUTO-SYNC] Service de synchronisation automatique arr\xEAt\xE9");
      }
      // üéõÔ∏è NOUVEAU: M√©thode pour changer la fr√©quence de synchronisation
      setSyncFrequency(minutes) {
        const newFrequency = minutes * 6e4;
        console.log(`\u2699\uFE0F [AUTO-SYNC] Changement de fr\xE9quence: ${minutes} minutes (${newFrequency}ms)`);
        this.syncFrequency = newFrequency;
        if (this.isRunning) {
          console.log("\u{1F504} [AUTO-SYNC] Red\xE9marrage avec nouvelle fr\xE9quence...");
          this.stop();
          this.start();
        }
      }
      // üìä NOUVEAU: Obtenir la fr√©quence actuelle
      getSyncFrequency() {
        return this.syncFrequency / 6e4;
      }
      async performSyncWithRetry(retryCount = 0) {
        try {
          await this.performSync();
        } catch (error) {
          console.error(`\u274C [AUTO-SYNC] Erreur de synchronisation (tentative ${retryCount + 1}/${this.maxRetries}):`, error);
          if (retryCount < this.maxRetries - 1) {
            console.log(`\u{1F504} [AUTO-SYNC] Nouvelle tentative dans ${this.retryDelay}ms...`);
            await new Promise((resolve) => setTimeout(resolve, this.retryDelay));
            return this.performSyncWithRetry(retryCount + 1);
          } else {
            console.error(`\u{1F4A5} [AUTO-SYNC] \xC9chec d\xE9finitif apr\xE8s ${this.maxRetries} tentatives`);
          }
        }
      }
      async performSync() {
        try {
          console.log("\u23F0 [AUTO-SYNC] D\xE9but de la synchronisation automatique...");
          const usersWithMail = await db.emailAccount.findMany({
            where: {
              isActive: true,
              encryptedPassword: { not: null }
            },
            take: 10
            // Limite de s√©curit√©
          });
          console.log(`\u{1F465} [AUTO-SYNC] ${usersWithMail.length} utilisateurs \xE0 synchroniser`);
          const totalResults = [];
          for (const emailAccount of usersWithMail) {
            try {
              if (!emailAccount.emailAddress || !emailAccount.encryptedPassword) {
                console.warn(`\u26A0\uFE0F [AUTO-SYNC] Configuration incompl\xE8te pour l'utilisateur ${emailAccount.userId}, ignor\xE9`);
                continue;
              }
              const result = await this.syncUserEmails(emailAccount);
              totalResults.push(result);
              await new Promise((resolve) => setTimeout(resolve, 1e3));
            } catch (userError) {
              console.error(`\u274C [AUTO-SYNC] Erreur pour l'utilisateur ${emailAccount.userId}:`, userError);
            }
          }
          const totalNew = totalResults.reduce((sum, r) => sum + r.newEmails, 0);
          const totalUpdated = totalResults.reduce((sum, r) => sum + r.updatedEmails, 0);
          console.log(`\u2705 [AUTO-SYNC] Synchronisation termin\xE9e: ${totalNew} nouveaux emails, ${totalUpdated} mis \xE0 jour`);
        } catch (error) {
          console.error("\u274C [AUTO-SYNC] Erreur lors de la synchronisation automatique:", error);
          throw error;
        }
      }
      /**
       * Configuration automatique IMAP bas√©e sur le domaine email
       */
      getImapConfig(domain) {
        const configs = {
          "gmail.com": { host: "imap.gmail.com", port: 993, tls: true },
          "one.com": { host: "imap.one.com", port: 993, tls: true },
          "yandex.com": { host: "imap.yandex.com", port: 993, tls: true },
          "yandex.ru": { host: "imap.yandex.ru", port: 993, tls: true },
          "outlook.com": { host: "outlook.office365.com", port: 993, tls: true },
          "hotmail.com": { host: "outlook.office365.com", port: 993, tls: true },
          "live.com": { host: "outlook.office365.com", port: 993, tls: true },
          "yahoo.com": { host: "imap.mail.yahoo.com", port: 993, tls: true },
          "yahoo.fr": { host: "imap.mail.yahoo.com", port: 993, tls: true }
        };
        return configs[domain] || { host: `imap.${domain}`, port: 993, tls: true };
      }
      async syncUserEmails(emailAccount) {
        const startTime = Date.now();
        let newEmails = 0;
        let updatedEmails = 0;
        try {
          console.log(`\u{1F504} [AUTO-SYNC] Synchronisation pour ${emailAccount.emailAddress}...`);
          const emailDomain = emailAccount.emailAddress.split("@")[1];
          const imapConfig = this.getImapConfig(emailDomain);
          const config = {
            imap: {
              user: emailAccount.emailAddress,
              password: decrypt(emailAccount.encryptedPassword),
              host: imapConfig.host,
              port: imapConfig.port,
              tls: imapConfig.tls,
              tlsOptions: {
                rejectUnauthorized: false,
                servername: imapConfig.host
              },
              authTimeout: 1e4,
              connTimeout: 1e4,
              keepalive: false
            }
          };
          let connection;
          try {
            connection = await import_imap_simple.default.connect(config);
            const foldersToSync = [
              { imapName: "INBOX", dbName: "inbox" },
              { imapName: "INBOX.Sent", dbName: "sent" },
              { imapName: "INBOX.Drafts", dbName: "drafts" },
              { imapName: "INBOX.Trash", dbName: "trash" },
              { imapName: "INBOX.Spam", dbName: "spam" }
            ];
            for (const folder of foldersToSync) {
              try {
                await connection.openBox(folder.imapName);
                const existingEmailsCount = await db.email.count({
                  where: {
                    userId: emailAccount.userId,
                    folder: folder.dbName
                  }
                });
                console.log(`\u{1F4CA} [AUTO-SYNC] ${folder.imapName}: ${existingEmailsCount} emails existants en base`);
                let results = [];
                if (existingEmailsCount === 0) {
                  console.log(`\u{1F504} [AUTO-SYNC] Premier sync pour ${folder.imapName} - R\xE9cup\xE9ration de TOUS les emails`);
                  try {
                    results = await connection.search(["ALL"], {
                      bodies: ["HEADER.FIELDS (FROM TO SUBJECT DATE MESSAGE-ID)", "TEXT", "1.1", "1.2", "2", "1"],
                      markSeen: false,
                      struct: true
                    });
                    console.log(`\u{1F4E7} [AUTO-SYNC] ${folder.imapName}: ${results.length} emails trouv\xE9s (sync complet)`);
                  } catch (allError) {
                    console.log(`\u26A0\uFE0F [AUTO-SYNC] Erreur recherche ALL dans ${folder.imapName}:`, allError);
                  }
                } else {
                  console.log(`\u{1F504} [AUTO-SYNC] Sync normal pour ${folder.imapName} - Emails r\xE9cents seulement`);
                  const searchDate = /* @__PURE__ */ new Date();
                  const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
                  const day = String(searchDate.getDate());
                  const month = months[searchDate.getMonth()];
                  const year = searchDate.getFullYear();
                  const formattedDate = `${day}-${month}-${year}`;
                  try {
                    results = await connection.search(["SINCE", formattedDate], {
                      bodies: ["HEADER.FIELDS (FROM TO SUBJECT DATE MESSAGE-ID)", "TEXT", "1.1", "1.2", "2", "1"],
                      markSeen: false,
                      struct: true
                    });
                    console.log(`\u{1F4E7} [AUTO-SYNC] ${folder.imapName}: ${results.length} emails depuis ${formattedDate}`);
                  } catch (sinceError) {
                    console.log(`\u26A0\uFE0F [AUTO-SYNC] Erreur SINCE dans ${folder.imapName}, fallback vers r\xE9cents:`, sinceError);
                    try {
                      const allResults = await connection.search(["ALL"], {
                        bodies: ["HEADER.FIELDS (FROM TO SUBJECT DATE MESSAGE-ID)", "TEXT", "1.1", "1.2", "2", "1"],
                        markSeen: false,
                        struct: true
                      });
                      results = allResults.slice(-50);
                      console.log(`\u{1F4E7} [AUTO-SYNC] ${folder.imapName}: ${results.length} emails (fallback r\xE9cents)`);
                    } catch (fallbackError) {
                      console.log(`\u274C [AUTO-SYNC] Erreur fallback dans ${folder.imapName}:`, fallbackError);
                    }
                  }
                }
                const maxEmailsToProcess = existingEmailsCount === 0 ? 1e3 : 100;
                const emailsToProcess = results.slice(0, maxEmailsToProcess);
                if (results.length > maxEmailsToProcess) {
                  console.warn(`\u26A0\uFE0F [AUTO-SYNC] ${folder.imapName}: Limite de ${maxEmailsToProcess} emails appliqu\xE9e (${results.length} trouv\xE9s)`);
                }
                for (const item of emailsToProcess) {
                  try {
                    console.log(`\u{1F50D} [AUTO-SYNC] Traitement email dans ${folder.imapName}...`);
                    const headerPart = item.parts.find(
                      (part) => part.which && part.which.includes("HEADER")
                    );
                    let header = null;
                    if (headerPart && headerPart.body) {
                      header = headerPart.body;
                      console.log(`\u2705 [AUTO-SYNC] Headers trouv\xE9s pour email dans ${folder.imapName}`);
                    } else {
                      for (const part of item.parts || []) {
                        if (part.body && typeof part.body === "object") {
                          if (part.body.subject || part.body.from || part.body.date) {
                            header = part.body;
                            console.log(`\u2705 [AUTO-SYNC] Headers trouv\xE9s via fallback pour email dans ${folder.imapName}`);
                            break;
                          }
                        }
                      }
                    }
                    if (header) {
                      let subject = decodeMimeHeader(header.subject ? header.subject[0] : "Pas de sujet");
                      let from = decodeMimeHeader(header.from ? header.from[0] : "Exp\xE9diteur inconnu");
                      let to = decodeMimeHeader(header.to ? header.to[0] : emailAccount.emailAddress);
                      subject = fixUtf8Encoding(subject);
                      from = fixUtf8Encoding(from);
                      to = fixUtf8Encoding(to);
                      const messageId = header["message-id"] ? header["message-id"][0] : null;
                      const date = header.date ? new Date(header.date[0]) : /* @__PURE__ */ new Date();
                      const isRead = item.attributes.flags.includes("\\Seen");
                      const uid = item.attributes.uid;
                      console.log(`\u{1F4E7} [AUTO-SYNC] Email "${subject}" de ${from} - Date: ${date} - UID: ${uid}`);
                      let body2 = "Corps r\xE9cup\xE9r\xE9 en arri\xE8re-plan";
                      let contentType = "text/plain";
                      let htmlBody = null;
                      let textBody = null;
                      if (item.struct) {
                        const extractBodies = (struct, partPath = "") => {
                          if (Array.isArray(struct)) {
                            struct.forEach((part, index) => {
                              const currentPath = partPath ? `${partPath}.${index + 1}` : `${index + 1}`;
                              extractBodies(part, currentPath);
                            });
                          } else if (struct.type && struct.subtype) {
                            const mimeType = `${struct.type}/${struct.subtype}`.toLowerCase();
                            const currentPath = partPath || "1";
                            const bodyPart = item.parts.find((p) => p.which === currentPath)?.body;
                            if (bodyPart) {
                              const bodyContent = bodyPart.toString();
                              if (mimeType === "text/html" && !htmlBody) {
                                htmlBody = bodyContent;
                              } else if (mimeType === "text/plain" && !textBody) {
                                textBody = bodyContent;
                              }
                            }
                            if (struct.body) {
                              extractBodies(struct.body, currentPath);
                            }
                          }
                        };
                        extractBodies(item.struct);
                      }
                      if (!htmlBody && !textBody) {
                        const allParts = item.parts || [];
                        for (const part of allParts) {
                          if (part.which && part.body) {
                            const bodyContent = part.body.toString();
                            if (bodyContent.includes("<html") || bodyContent.includes("<HTML") || bodyContent.includes("<!DOCTYPE") || bodyContent.includes("<body") || bodyContent.includes("<div") || bodyContent.includes("<p>") || bodyContent.includes("<br") || bodyContent.includes("<a ")) {
                              htmlBody = bodyContent;
                            } else if (part.which === "TEXT" || bodyContent.length > 10) {
                              textBody = bodyContent;
                            }
                          }
                        }
                      }
                      if (htmlBody) {
                        body2 = this.cleanHtmlContent(htmlBody);
                        contentType = "text/html";
                      } else if (textBody) {
                        body2 = this.cleanTextContent(textBody);
                        contentType = "text/plain";
                      }
                      let existingEmail;
                      if (uid) {
                        existingEmail = await db.email.findFirst({
                          where: {
                            userId: emailAccount.userId,
                            uid: uid.toString(),
                            folder: folder.dbName
                          },
                          select: { id: true, isRead: true }
                        });
                      }
                      if (!existingEmail && messageId) {
                        existingEmail = await db.email.findFirst({
                          where: {
                            userId: emailAccount.userId,
                            body: { contains: messageId },
                            folder: folder.dbName
                          },
                          select: { id: true, isRead: true }
                        });
                      }
                      if (!existingEmail) {
                        const dateStart = new Date(date.getTime() - 3e4);
                        const dateEnd = new Date(date.getTime() + 3e4);
                        existingEmail = await db.email.findFirst({
                          where: {
                            userId: emailAccount.userId,
                            subject,
                            from,
                            folder: folder.dbName,
                            createdAt: {
                              gte: dateStart,
                              lte: dateEnd
                            }
                          },
                          select: { id: true, isRead: true }
                        });
                      }
                      if (!existingEmail) {
                        let isInBlacklist = false;
                        if (uid) {
                          const deletedByUID = await db.deletedEmail.findFirst({
                            where: {
                              userId: emailAccount.userId,
                              uid: uid.toString(),
                              folder: folder.dbName
                            }
                          });
                          isInBlacklist = !!deletedByUID;
                        }
                        if (!isInBlacklist && messageId) {
                          const deletedByMessageId = await db.deletedEmail.findFirst({
                            where: {
                              userId: emailAccount.userId,
                              messageId,
                              folder: folder.dbName
                            }
                          });
                          isInBlacklist = !!deletedByMessageId;
                        }
                        if (isInBlacklist) {
                          console.log(`\u{1F6AB} [AUTO-SYNC] Email en blacklist, ignor\xE9: "${subject}" (UID: ${uid})`);
                          continue;
                        }
                        console.log(`\u{1F4BE} [AUTO-SYNC] Cr\xE9ation nouvel email: "${subject}"`);
                        const cleanBody = fixUtf8Encoding(body2);
                        const finalBody = messageId ? `Message-ID: ${messageId}

${cleanBody}` : cleanBody;
                        const newEmail = await db.email.create({
                          data: {
                            userId: emailAccount.userId,
                            from,
                            to,
                            subject,
                            body: finalBody,
                            contentType,
                            isRead,
                            folder: folder.dbName,
                            uid: uid ? uid.toString() : null,
                            // ‚úÖ CORRECTION: Stocker l'UID IMAP
                            createdAt: date
                          }
                        });
                        newEmails++;
                        if (folder.dbName === "inbox" && !isRead) {
                          console.log("\u{1F514} [AUTO-SYNC] D\xE9clenchement notification temps r\xE9el !");
                          const userOrg = await db.userOrganization.findFirst({
                            where: { userId: emailAccount.userId },
                            select: { organizationId: true }
                          });
                          if (userOrg) {
                            this.emit("newEmailFound", {
                              emailId: newEmail.id,
                              from,
                              subject,
                              folder: folder.dbName,
                              receivedAt: date,
                              userId: emailAccount.userId,
                              organizationId: userOrg.organizationId
                            });
                            const notificationService = RealTimeEmailNotificationService_default.getInstance();
                            notificationService.notifyNewEmail({
                              emailId: newEmail.id,
                              from,
                              subject,
                              folder: folder.dbName,
                              receivedAt: date,
                              userId: emailAccount.userId,
                              organizationId: userOrg.organizationId
                            });
                          }
                        }
                        console.log(`\u2705 [AUTO-SYNC] Nouvel email cr\xE9\xE9: "${subject}" (UID: ${uid}, ${contentType})`);
                      } else if (existingEmail.isRead !== isRead) {
                        console.log(`\u{1F4DD} [AUTO-SYNC] Mise \xE0 jour statut email: "${subject}"`);
                        await db.email.update({
                          where: { id: existingEmail.id },
                          data: { isRead }
                        });
                        updatedEmails++;
                        console.log(`\u{1F4DD} [AUTO-SYNC] Email mis \xE0 jour: "${subject}"`);
                      } else {
                        console.log(`\u23ED\uFE0F [AUTO-SYNC] Email d\xE9j\xE0 existant: "${subject}"`);
                      }
                    } else {
                      console.warn(`\u26A0\uFE0F [AUTO-SYNC] Pas de header trouv\xE9 pour un email dans ${folder.imapName}`);
                      console.log(`\u{1F50D} [AUTO-SYNC] Debug - Parties disponibles:`, item.parts?.map((p) => ({ which: p.which, hasBody: !!p.body, bodyType: typeof p.body })));
                      console.log(`\u{1F50D} [AUTO-SYNC] Debug - Attributs:`, item.attributes);
                    }
                  } catch (emailError) {
                    console.error(`\u274C [AUTO-SYNC] Erreur traitement email dans ${folder.imapName}:`, emailError);
                  }
                }
              } catch (folderError) {
                console.log(`\u26A0\uFE0F [AUTO-SYNC] Dossier ${folder.imapName} inaccessible, ignor\xE9:`, folderError);
              }
            }
            connection.end();
            const duration = Date.now() - startTime;
            console.log(`\u26A1 [AUTO-SYNC] ${emailAccount.emailAddress}: ${newEmails} nouveaux, ${updatedEmails} mis \xE0 jour (${duration}ms)`);
          } catch (imapError) {
            if (connection) {
              try {
                connection.end();
              } catch {
              }
            }
            throw imapError;
          }
        } catch (error) {
          console.error(`\u274C [AUTO-SYNC] Erreur pour ${emailAccount.emailAddress}:`, error);
        }
        const totalEmails = await db.email.count({
          where: { userId: emailAccount.userId }
        });
        return {
          userId: emailAccount.userId,
          newEmails,
          updatedEmails,
          totalEmails
        };
      }
      async forceSync() {
        console.log("\u{1F504} [AUTO-SYNC] Synchronisation forc\xE9e demand\xE9e...");
        await this.performSyncWithRetry();
      }
      cleanHtmlContent(htmlContent) {
        try {
          let cleanContent = htmlContent;
          if (cleanContent.includes("This is a multi-part message") || cleanContent.match(/^--[a-zA-Z0-9]/m) || cleanContent.includes("------=_NextPart_") || cleanContent.includes("Content-Type:")) {
            console.log("\u{1F527} [AUTO-SYNC] Email MIME multi-part d\xE9tect\xE9, parsing avanc\xE9...");
            let parts = [];
            if (cleanContent.match(/^--[a-zA-Z0-9]/m)) {
              parts = cleanContent.split(/^--[a-zA-Z0-9][^\n]*$/m);
            } else if (cleanContent.includes("------=_NextPart_")) {
              parts = cleanContent.split(/^------=_NextPart_[^\n]*$/m);
            } else {
              parts = cleanContent.split(/^--[=a-zA-Z0-9][^\n]*$/m);
            }
            let htmlPart = null;
            let textPart = null;
            for (const part of parts) {
              if (!part.trim()) continue;
              if (part.includes("Content-Type: text/html") || part.includes("Content-Type:text/html")) {
                console.log("\u2705 [AUTO-SYNC] Partie HTML trouv\xE9e");
                const lines = part.split("\n");
                let contentStartIndex = -1;
                for (let i = 0; i < lines.length; i++) {
                  if (lines[i].trim() === "") {
                    contentStartIndex = i + 1;
                    break;
                  }
                }
                if (contentStartIndex !== -1) {
                  htmlPart = lines.slice(contentStartIndex).join("\n").trim();
                  if (part.includes("quoted-printable")) {
                    htmlPart = htmlPart.replace(/=([0-9A-F]{2})/gi, (_, hex) => {
                      return String.fromCharCode(parseInt(hex, 16));
                    });
                    htmlPart = htmlPart.replace(/=\r?\n/g, "");
                  }
                  break;
                }
              } else if (part.includes("Content-Type: text/plain") || part.includes("Content-Type:text/plain")) {
                const lines = part.split("\n");
                let contentStartIndex = -1;
                for (let i = 0; i < lines.length; i++) {
                  if (lines[i].trim() === "") {
                    contentStartIndex = i + 1;
                    break;
                  }
                }
                if (contentStartIndex !== -1) {
                  textPart = lines.slice(contentStartIndex).join("\n").trim();
                }
              }
            }
            if (htmlPart) {
              console.log("\u{1F3AF} [AUTO-SYNC] Utilisation de la partie HTML extraite");
              cleanContent = htmlPart;
            } else if (textPart) {
              console.log("\u{1F4DD} [AUTO-SYNC] Conversion texte \u2192 HTML");
              cleanContent = `<div style="white-space: pre-wrap; font-family: Arial, sans-serif; padding: 20px;">${textPart.replace(/\n/g, "<br>")}</div>`;
            } else {
              console.log("\u26A0\uFE0F [AUTO-SYNC] Aucune partie exploitable trouv\xE9e, nettoyage basique");
            }
          }
          cleanContent = cleanContent.replace(/=([0-9A-F]{2})/gi, (_, hex) => {
            return String.fromCharCode(parseInt(hex, 16));
          });
          cleanContent = cleanContent.replace(/=\r?\n/g, "");
          cleanContent = fixUtf8Encoding(cleanContent);
          cleanContent = cleanContent.replace(/^[A-Za-z-]+:\s*.*$/gm, "");
          cleanContent = cleanContent.replace(/\n\s*\n\s*\n/g, "\n\n");
          cleanContent = cleanContent.replace(/^------=_NextPart_.*$/gm, "");
          cleanContent = cleanContent.replace(/This is a multi-part message in MIME format\./g, "");
          cleanContent = cleanContent.replace(/^Content-Type:.*$/gm, "");
          cleanContent = cleanContent.replace(/^Content-Transfer-Encoding:.*$/gm, "");
          cleanContent = cleanContent.replace(/^\s*charset.*$/gm, "");
          cleanContent = cleanContent.trim();
          const htmlTagIndex = cleanContent.search(/<html|<!DOCTYPE/i);
          if (htmlTagIndex >= 0) {
            cleanContent = cleanContent.substring(htmlTagIndex);
          }
          return cleanContent;
        } catch (error) {
          console.error("\u274C [AUTO-SYNC] Erreur lors du nettoyage HTML:", error);
          return htmlContent;
        }
      }
      cleanTextContent(textContent) {
        try {
          let cleanContent = textContent;
          cleanContent = fixUtf8Encoding(cleanContent);
          const mimeHeaderPattern = /^[A-Za-z-]+:\s*.*$/gm;
          cleanContent = cleanContent.replace(mimeHeaderPattern, "");
          cleanContent = cleanContent.replace(/^------=_NextPart_.*$/gm, "");
          cleanContent = cleanContent.replace(/This is a multi-part message in MIME format\./g, "");
          cleanContent = cleanContent.trim();
          return cleanContent;
        } catch (error) {
          console.error("\u274C [AUTO-SYNC] Erreur lors du nettoyage texte:", error);
          return textContent;
        }
      }
    };
    autoMailSync = new AutoMailSyncService();
    AutoMailSyncService_default = AutoMailSyncService;
  }
});

// src/components/TreeBranchLeaf/treebranchleaf-new/api/formulaEngine.ts
function getRpnCacheStats() {
  return { entries: rpnCache.size, parseCount: rpnParseCount };
}
function clearRpnCache() {
  rpnCache.clear();
}
function getLogicMetrics() {
  return { ...logicMetrics, avgEvalMs: logicMetrics.evaluations ? logicMetrics.totalEvalMs / logicMetrics.evaluations : 0 };
}
function tokensFingerprint(tokens2) {
  return tokens2.map((t) => {
    switch (t.type) {
      case "number":
        return `n:${t.value}`;
      case "variable":
        return `v:${t.name}`;
      case "operator":
        return `o:${t.value}`;
      case "paren":
        return `p:${t.value}`;
      case "func":
        return `f:${t.name}:${t.argCount ?? "?"}`;
      case "comma":
        return "c";
    }
  }).join("|");
}
function validateExpression(expr, opts) {
  const maxLen = opts?.maxExpressionLength ?? 500;
  if (expr.length > maxLen) throw new Error("Expression trop longue");
  const allowed = opts?.allowedCharsRegex || /^[0-9A-Za-z_\s+*\-/^(),.{}:<>!=&"\\@]+$/;
  if (!allowed.test(expr)) throw new Error("Caract\xC3\u0192\xC2\xA8res non autoris\xC3\u0192\xC2\xA9s dans l'expression");
}
function parseExpression(expr, roleToNodeId, opts) {
  validateExpression(expr, opts);
  let working = expr.replace(/\{\{\s*(.+?)\s*\}\}/g, (_, v) => `__VAR__${v.trim()}__`);
  working = working.replace(/@(table|value)\.([a-zA-Z0-9_-]+)/g, (_, type, id) => `__VAR__${type}.${id}__`);
  const tokens2 = [];
  let i = 0;
  let parenBalance = 0;
  const funcParenStack = [];
  let lastToken = null;
  while (i < working.length) {
    const ch = working[i];
    if (/\s/.test(ch)) {
      i++;
      continue;
    }
    if (working.startsWith("__VAR__", i)) {
      const end = working.indexOf("__", i + 7);
      if (end === -1) throw new Error("Marqueur variable mal form\xC3\u0192\xC2\xA9");
      const role = working.substring(i + 7, end);
      const nodeId = roleToNodeId[role] || role;
      tokens2.push({ type: "variable", name: nodeId });
      i = end + 2;
      lastToken = tokens2[tokens2.length - 1];
      continue;
    }
    if (/[0-9]/.test(ch)) {
      let j = i + 1;
      while (j < working.length && /[0-9.]/.test(working[j])) j++;
      const numStr = working.slice(i, j);
      tokens2.push({ type: "number", value: parseFloat(numStr) });
      i = j;
      lastToken = tokens2[tokens2.length - 1];
      continue;
    }
    if (ch === '"') {
      let j = i + 1;
      let str = "";
      while (j < working.length) {
        const cc = working[j];
        if (cc === "\\" && j + 1 < working.length) {
          str += working[j + 1];
          j += 2;
          continue;
        }
        if (cc === '"') break;
        str += cc;
        j++;
      }
      if (j >= working.length) throw new Error("Cha\xC3\u0192\xC2\xAEne non termin\xC3\u0192\xC2\xA9e");
      tokens2.push({ type: "string", value: str });
      i = j + 1;
      lastToken = tokens2[tokens2.length - 1];
      continue;
    }
    if (/[A-Za-z_]/.test(ch)) {
      let j = i + 1;
      while (j < working.length && /[A-Za-z0-9_]/.test(working[j])) j++;
      const ident = working.slice(i, j);
      const lowerIdent = ident.toLowerCase();
      if (lowerIdent === "true" || lowerIdent === "false") {
        tokens2.push({ type: "number", value: lowerIdent === "true" ? 1 : 0 });
        i = j;
        lastToken = tokens2[tokens2.length - 1];
        continue;
      }
      const canUseAsBinary = Boolean(lastToken && (lastToken.type === "number" || lastToken.type === "variable" || lastToken.type === "paren" && lastToken.value === ")"));
      if ((lowerIdent === "and" || lowerIdent === "or") && canUseAsBinary) {
        tokens2.push({ type: "operator", value: lowerIdent });
        i = j;
        lastToken = tokens2[tokens2.length - 1];
        continue;
      }
      let k = j;
      while (k < working.length && /\s/.test(working[k])) k++;
      if (working[k] === "(") {
        tokens2.push({ type: "func", name: lowerIdent });
        i = j;
        lastToken = tokens2[tokens2.length - 1];
        continue;
      } else {
        throw new Error("Identifiant inattendu: " + ident);
      }
    }
    if (ch === "(") {
      tokens2.push({ type: "paren", value: "(" });
      const prev = lastToken;
      if (prev && prev.type === "func") {
        funcParenStack.push({ name: prev.name, argCount: 0 });
      }
      parenBalance++;
      i++;
      lastToken = tokens2[tokens2.length - 1];
      continue;
    }
    if (ch === ")") {
      tokens2.push({ type: "paren", value: ")" });
      parenBalance--;
      if (parenBalance < 0) throw new Error("Parenth\xC3\u0192\xC2\xA8ses d\xC3\u0192\xC2\xA9s\xC3\u0192\xC2\xA9quilibr\xC3\u0192\xC2\xA9es");
      if (funcParenStack.length) {
      }
      i++;
      lastToken = tokens2[tokens2.length - 1];
      continue;
    }
    if (ch === ",") {
      tokens2.push({ type: "comma" });
      if (funcParenStack.length) {
        const top = funcParenStack[funcParenStack.length - 1];
        top.argCount++;
      }
      i++;
      lastToken = tokens2[tokens2.length - 1];
      continue;
    }
    if ("+-*/^&".includes(ch)) {
      tokens2.push({ type: "operator", value: ch });
      i++;
      lastToken = tokens2[tokens2.length - 1];
      continue;
    }
    if ((ch === ">" || ch === "<" || ch === "=" || ch === "!") && i + 1 < working.length) {
      const two = working.slice(i, i + 2);
      if ([">=", "<=", "==", "!="].includes(two)) {
        tokens2.push({ type: "operator", value: two });
        i += 2;
        lastToken = tokens2[tokens2.length - 1];
        continue;
      }
    }
    if (ch === ">" || ch === "<") {
      tokens2.push({ type: "operator", value: ch });
      i++;
      lastToken = tokens2[tokens2.length - 1];
      continue;
    }
    throw new Error("Caract\xC3\u0192\xC2\xA8re inattendu: " + ch);
  }
  if (parenBalance !== 0) throw new Error("Parenth\xC3\u0192\xC2\xA8ses d\xC3\u0192\xC2\xA9s\xC3\u0192\xC2\xA9quilibr\xC3\u0192\xC2\xA9es");
  if (tokens2.some((t) => t.type === "operator" && [">", ">=", "<", "<=", "==", "!="].includes(t.value))) {
    const rewritten = [];
    for (let idx = 0; idx < tokens2.length; idx++) {
      const tk = tokens2[idx];
      if (tk.type === "operator" && [">", ">=", "<", "<=", "==", "!="].includes(tk.value)) {
        const op = tk.value;
        const left = rewritten.pop();
        const right = tokens2[idx + 1];
        if (!left || !right) throw new Error("Expression comparaison mal form\xC3\u0192\xC2\xA9e");
        idx++;
        const funcName = op === ">" ? "gt" : op === ">=" ? "gte" : op === "<" ? "lt" : op === "<=" ? "lte" : op === "==" ? "eq" : op === "!=" ? "neq" : "eq";
        rewritten.push({ type: "func", name: funcName });
        rewritten.push({ type: "paren", value: "(" });
        rewritten.push(left);
        rewritten.push({ type: "comma" });
        rewritten.push(right);
        rewritten.push({ type: "paren", value: ")" });
      } else {
        rewritten.push(tk);
      }
    }
    return rewritten;
  }
  return tokens2;
}
function toRPN(tokens2) {
  const output = [];
  const stack = [];
  const funcStack = [];
  for (let idx = 0; idx < tokens2.length; idx++) {
    const tk = tokens2[idx];
    switch (tk.type) {
      case "number":
      case "variable":
      case "string":
        output.push(tk);
        if (funcStack.length) {
        }
        break;
      case "func":
        stack.push(tk);
        break;
      case "operator": {
        while (stack.length) {
          const top = stack[stack.length - 1];
          if (top.type === "operator") {
            const pTop = OP_PRECEDENCE[top.value] || 0;
            const pCur = OP_PRECEDENCE[tk.value] || 0;
            if (OP_ASSOC[tk.value] === "L" && pCur <= pTop || OP_ASSOC[tk.value] === "R" && pCur < pTop) {
              output.push(stack.pop());
              continue;
            }
          }
          break;
        }
        stack.push(tk);
        break;
      }
      case "paren":
        if (tk.value === "(") {
          stack.push(tk);
          const prev = stack[stack.length - 2];
          if (prev && prev.type === "func") {
            funcStack.push({ name: prev.name, argCount: 1 });
          }
        } else {
          let found = false;
          while (stack.length) {
            const top = stack.pop();
            if (top.type === "paren" && top.value === "(") {
              found = true;
              break;
            }
            output.push(top);
          }
          if (!found) throw new Error("Parenth\xC3\u0192\xC2\xA8ses d\xC3\u0192\xC2\xA9s\xC3\u0192\xC2\xA9quilibr\xC3\u0192\xC2\xA9es");
          const maybeFunc = stack[stack.length - 1];
          if (maybeFunc && maybeFunc.type === "func") {
            stack.pop();
            const fMeta = funcStack.pop();
            const argCount = fMeta ? fMeta.argCount : 0;
            output.push({ type: "func", name: maybeFunc.name, argCount });
          }
        }
        break;
      case "comma":
        while (stack.length) {
          const top = stack[stack.length - 1];
          if (top.type === "paren" && top.value === "(") break;
          output.push(stack.pop());
        }
        if (funcStack.length) funcStack[funcStack.length - 1].argCount++;
        break;
    }
  }
  while (stack.length) {
    const top = stack.pop();
    if (top.type === "paren") throw new Error("Parenth\xC3\u0192\xC2\xA8ses d\xC3\u0192\xC2\xA9s\xC3\u0192\xC2\xA9quilibr\xC3\u0192\xC2\xA9es (fin)");
    output.push(top);
  }
  return output;
}
async function evaluateTokens(tokens2, opts) {
  const errors = [];
  const pushError = (c, ctx) => {
    errors.push(c);
    if (opts.onError) opts.onError(c, ctx);
    if (c === "division_by_zero") logicMetrics.divisionByZero++;
    else if (c === "unknown_variable") logicMetrics.unknownVariables++;
    else if (c === "invalid_result") logicMetrics.invalidResults++;
  };
  const t0 = Date.now();
  const useCache = opts.enableCache !== false;
  let rpn;
  if (useCache) {
    const fp = tokensFingerprint(tokens2);
    const cached = rpnCache.get(fp);
    if (cached) rpn = cached;
    else {
      rpn = toRPN(tokens2);
      rpnCache.set(fp, rpn);
      rpnParseCount++;
    }
  } else {
    rpn = toRPN(tokens2);
    rpnParseCount++;
  }
  const stack = [];
  const pushEntry = (value, hadError) => {
    stack.push({ value, hadError });
  };
  const popEntry = () => stack.pop();
  const scale = opts.precisionScale && opts.precisionScale > 1 ? Math.floor(opts.precisionScale) : null;
  const toInternal = (v) => scale ? Math.round(v * scale) : v;
  const fromInternal = (v) => scale ? v / scale : v;
  const normalizeNumber = (num) => Number.isFinite(num) ? num : 0;
  const stringToNumber = (value) => {
    if (!value) return 0;
    const normalized = value.trim().replace(/\s+/g, "").replace(",", ".");
    const parsed = Number(normalized);
    return Number.isFinite(parsed) ? parsed : 0;
  };
  const toNumber2 = (value) => {
    if (Array.isArray(value)) return normalizeNumber(value[0] ?? 0);
    if (typeof value === "number") return normalizeNumber(value);
    return stringToNumber(value);
  };
  const valueToArray = (value) => {
    if (Array.isArray(value)) return value.map(normalizeNumber);
    return [toNumber2(value)];
  };
  const normalizeArrayResult = (values) => values.length === 1 ? values[0] : values;
  const mapNumericValue = (value, mapper) => {
    const mapped = valueToArray(value).map(mapper);
    return normalizeArrayResult(mapped);
  };
  const broadcastNumericValues = (a, b, mapper) => {
    const arrA = valueToArray(a);
    const arrB = valueToArray(b);
    const lenA = arrA.length;
    const lenB = arrB.length;
    const len = Math.max(lenA, lenB);
    if (lenA > 1 && lenB > 1 && lenA !== lenB) return null;
    const result = [];
    for (let i = 0; i < len; i++) {
      const va = arrA[lenA === 1 ? 0 : i];
      const vb = arrB[lenB === 1 ? 0 : i];
      result.push(mapper(va, vb));
    }
    return normalizeArrayResult(result);
  };
  const flattenNumericArgs = (args) => args.flatMap(valueToArray);
  const valueToString = (value) => {
    if (Array.isArray(value)) return value.length === 1 ? String(value[0]) : value.join(",");
    if (typeof value === "number") return Number.isFinite(value) ? String(value) : "0";
    return value;
  };
  const sanitizeNumericResult = (value, ctx) => {
    if (Array.isArray(value)) {
      const sanitized2 = value.map((v) => {
        if (!Number.isFinite(v)) {
          pushError("invalid_result", ctx);
          return 0;
        }
        return v;
      });
      return normalizeArrayResult(sanitized2);
    }
    if (typeof value === "number" && !Number.isFinite(value)) {
      pushError("invalid_result", ctx);
      return 0;
    }
    return value;
  };
  const valueHasNumericError = (value) => {
    if (Array.isArray(value)) return value.some((v) => !Number.isFinite(v));
    if (typeof value === "number") return !Number.isFinite(value);
    return false;
  };
  for (const tk of rpn) {
    if (tk.type === "number") pushEntry(tk.value, false);
    else if (tk.type === "string") pushEntry(tk.value, false);
    else if (tk.type === "variable") {
      let v;
      const beforeErrors = errors.length;
      try {
        v = await opts.resolveVariable(tk.name);
      } catch {
        v = null;
      }
      if (v == null || !Number.isFinite(v)) {
        if (opts.strictVariables) pushError("unknown_variable", { nodeId: tk.name });
        v = 0;
      }
      const hadError = errors.length > beforeErrors;
      pushEntry(v, hadError);
    } else if (tk.type === "operator") {
      const entryB = popEntry();
      const entryA = popEntry();
      if (!entryA || !entryB) {
        pushError("stack_underflow", { op: tk.value });
        return { value: 0, errors };
      }
      const beforeErrors = errors.length;
      let resultValue = 0;
      switch (tk.value) {
        case "+": {
          const res = broadcastNumericValues(entryA.value, entryB.value, (a, b) => {
            if (scale) return fromInternal(toInternal(a) + toInternal(b));
            return a + b;
          });
          if (res === null) {
            pushError("array_length_mismatch", { op: "+" });
            resultValue = 0;
          } else {
            resultValue = sanitizeNumericResult(res, { op: "+" });
          }
          break;
        }
        case "-": {
          const res = broadcastNumericValues(entryA.value, entryB.value, (a, b) => {
            if (scale) return fromInternal(toInternal(a) - toInternal(b));
            return a - b;
          });
          if (res === null) {
            pushError("array_length_mismatch", { op: "-" });
            resultValue = 0;
          } else {
            resultValue = sanitizeNumericResult(res, { op: "-" });
          }
          break;
        }
        case "*": {
          const res = broadcastNumericValues(entryA.value, entryB.value, (a, b) => {
            if (scale) return fromInternal(Math.round(toInternal(a) * toInternal(b) / scale));
            return a * b;
          });
          if (res === null) {
            pushError("array_length_mismatch", { op: "*" });
            resultValue = 0;
          } else {
            resultValue = sanitizeNumericResult(res, { op: "*" });
          }
          break;
        }
        case "/": {
          const res = broadcastNumericValues(entryA.value, entryB.value, (a, b) => {
            if (b === 0) {
              pushError("division_by_zero", { a, b });
              return opts.divisionByZeroValue ?? 0;
            }
            if (scale) return fromInternal(Math.round(toInternal(a) * scale / toInternal(b)));
            return a / b;
          });
          if (res === null) {
            pushError("array_length_mismatch", { op: "/" });
            resultValue = 0;
          } else {
            resultValue = sanitizeNumericResult(res, { op: "/" });
          }
          break;
        }
        case "^": {
          const res = broadcastNumericValues(entryA.value, entryB.value, (a, b) => Math.pow(a, b));
          if (res === null) {
            pushError("array_length_mismatch", { op: "^" });
            resultValue = 0;
          } else {
            resultValue = sanitizeNumericResult(res, { op: "^" });
          }
          break;
        }
        case "and": {
          const res = broadcastNumericValues(entryA.value, entryB.value, (a, b) => a !== 0 && b !== 0 ? 1 : 0);
          resultValue = res === null ? 0 : res;
          if (res === null) pushError("array_length_mismatch", { op: "and" });
          break;
        }
        case "or": {
          const res = broadcastNumericValues(entryA.value, entryB.value, (a, b) => a !== 0 || b !== 0 ? 1 : 0);
          resultValue = res === null ? 0 : res;
          if (res === null) pushError("array_length_mismatch", { op: "or" });
          break;
        }
        case "&": {
          const str = valueToString(entryA.value) + valueToString(entryB.value);
          resultValue = str;
          break;
        }
        default:
          pushError("unknown_operator", { op: tk.value });
          resultValue = 0;
      }
      const hadError = entryA.hadError || entryB.hadError || errors.length > beforeErrors;
      pushEntry(resultValue, hadError);
    } else if (tk.type === "func") {
      const argc = tk.argCount ?? 0;
      if (stack.length < argc) {
        pushError("stack_underflow", { func: tk.name });
        return { value: 0, errors };
      }
      const argEntries = [];
      for (let i = 0; i < argc; i++) {
        const entry = popEntry();
        if (!entry) {
          pushError("stack_underflow", { func: tk.name });
          return { value: 0, errors };
        }
        argEntries.unshift(entry);
      }
      const args = argEntries.map((e) => e.value);
      let r = 0;
      logicMetrics.functions[tk.name] = (logicMetrics.functions[tk.name] || 0) + 1;
      const beforeErrors = errors.length;
      switch (tk.name) {
        case "min":
          r = Math.min(...flattenNumericArgs(args));
          break;
        case "max":
          r = Math.max(...flattenNumericArgs(args));
          break;
        case "eq":
          r = toNumber2(args[0] ?? 0) === toNumber2(args[1] ?? 0) ? 1 : 0;
          break;
        case "neq":
          r = toNumber2(args[0] ?? 0) !== toNumber2(args[1] ?? 0) ? 1 : 0;
          break;
        case "gt":
          r = toNumber2(args[0] ?? 0) > toNumber2(args[1] ?? 0) ? 1 : 0;
          break;
        case "gte":
          r = toNumber2(args[0] ?? 0) >= toNumber2(args[1] ?? 0) ? 1 : 0;
          break;
        case "lt":
          r = toNumber2(args[0] ?? 0) < toNumber2(args[1] ?? 0) ? 1 : 0;
          break;
        case "lte":
          r = toNumber2(args[0] ?? 0) <= toNumber2(args[1] ?? 0) ? 1 : 0;
          break;
        case "round": {
          const decimals = Math.max(0, Math.min(12, Math.floor(toNumber2(args[1] ?? 0))));
          const factor = Math.pow(10, decimals);
          r = mapNumericValue(args[0] ?? 0, (value) => {
            const rounded = Math.round(value * factor) / factor;
            return scale ? fromInternal(toInternal(rounded)) : rounded;
          });
          break;
        }
        case "abs":
          r = mapNumericValue(args[0] ?? 0, Math.abs);
          break;
        case "ceil":
          r = mapNumericValue(args[0] ?? 0, Math.ceil);
          break;
        case "floor":
          r = mapNumericValue(args[0] ?? 0, Math.floor);
          break;
        case "int":
          r = mapNumericValue(args[0] ?? 0, Math.floor);
          break;
        case "if": {
          const cond = toNumber2(args[0] ?? 0);
          const aVal = args[1] ?? 0;
          const bVal = args[2] ?? 0;
          if (argc < 2) {
            pushError("invalid_result", { func: "if", reason: "missing_args" });
            r = 0;
          } else r = cond !== 0 ? aVal : bVal;
          break;
        }
        case "and":
          r = flattenNumericArgs(args).every((v) => v !== 0) ? 1 : 0;
          break;
        case "or":
          r = flattenNumericArgs(args).some((v) => v !== 0) ? 1 : 0;
          break;
        case "not":
          r = toNumber2(args[0] ?? 0) === 0 ? 1 : 0;
          break;
        case "present":
          r = toNumber2(args[0] ?? 0) !== 0 ? 1 : 0;
          break;
        case "empty":
          r = toNumber2(args[0] ?? 0) === 0 ? 1 : 0;
          break;
        case "sum":
          r = flattenNumericArgs(args).reduce((acc, v) => acc + (Number.isFinite(v) ? v : 0), 0);
          break;
        case "avg": {
          const flat = flattenNumericArgs(args).filter((v) => Number.isFinite(v));
          r = flat.length ? flat.reduce((a, b) => a + b, 0) / flat.length : 0;
          break;
        }
        case "ifnull":
          r = toNumber2(args[0] ?? 0) !== 0 ? args[0] ?? 0 : args[1] ?? 0;
          break;
        case "coalesce": {
          let found = 0;
          let hasFound = false;
          for (const v of args) {
            if (toNumber2(v ?? 0) !== 0) {
              found = v ?? 0;
              hasFound = true;
              break;
            }
          }
          r = hasFound ? found : 0;
          break;
        }
        case "safediv": {
          const aVal = toNumber2(args[0] ?? 0);
          const bVal = toNumber2(args[1] ?? 0);
          const fb = toNumber2(args[2] ?? 0);
          r = bVal === 0 ? fb : aVal / bVal;
          break;
        }
        case "percentage": {
          const part = toNumber2(args[0] ?? 0);
          const total = toNumber2(args[1] ?? 0);
          r = total === 0 ? 0 : part / total * 100;
          break;
        }
        case "ratio": {
          const aVal = toNumber2(args[0] ?? 0);
          const bVal = toNumber2(args[1] ?? 0);
          r = bVal === 0 ? 0 : aVal / bVal;
          break;
        }
        case "radians":
        case "rad":
          r = mapNumericValue(args[0] ?? 0, (angle) => angle * (Math.PI / 180));
          break;
        case "sqrt":
        case "racine":
          r = mapNumericValue(args[0] ?? 0, (value) => {
            if (value < 0) {
              pushError("invalid_result", { func: tk.name, value });
              return 0;
            }
            return Math.sqrt(value);
          });
          break;
        case "cos":
        case "cosinus":
          r = mapNumericValue(args[0] ?? 0, Math.cos);
          break;
        case "atan":
        case "arctan":
          r = mapNumericValue(args[0] ?? 0, Math.atan);
          break;
        case "pi": {
          const factor = argc >= 1 ? toNumber2(args[0]) : 1;
          r = Math.PI * factor;
          break;
        }
        case "row": {
          if (!args.length) {
            pushError("invalid_result", { func: "row", reason: "missing_args" });
            r = 0;
            break;
          }
          const target = args[0];
          if (Array.isArray(target)) r = target;
          else r = mapNumericValue(target, (value) => value);
          break;
        }
        case "indirect": {
          const source = valueToString(args[0] ?? "");
          const match = source.match(/^(-?\d+)\s*:\s*(-?\d+)$/);
          if (match) {
            const start = parseInt(match[1], 10);
            const end = parseInt(match[2], 10);
            const step = start <= end ? 1 : -1;
            const length = Math.min(1e3, Math.abs(end - start) + 1);
            const seq = [];
            for (let i = 0; i < length; i++) seq.push(start + i * step);
            if (length < Math.abs(end - start) + 1) {
              pushError("range_truncated", { func: "indirect", start, end });
            }
            r = seq;
          } else {
            r = stringToNumber(source);
          }
          break;
        }
        case "sumproduct":
        case "sumprod": {
          if (!args.length) {
            r = 0;
            break;
          }
          const arrays = args.map(valueToArray);
          const maxLen = Math.max(...arrays.map((arr) => arr.length));
          if (maxLen === 0) {
            r = 0;
            break;
          }
          const variableArrays = arrays.filter((arr) => arr.length > 1);
          if (variableArrays.some((arr) => arr.length !== maxLen)) {
            pushError("array_length_mismatch", { func: tk.name });
            r = 0;
            break;
          }
          if (arrays.length === 1) {
            r = arrays[0].reduce((acc, val) => acc + val, 0);
            break;
          }
          let total = 0;
          for (let i = 0; i < maxLen; i++) {
            let product = 1;
            for (const arr of arrays) {
              const val = arr.length === 1 ? arr[0] : arr[i] ?? 0;
              product *= val;
            }
            total += product;
          }
          r = total;
          break;
        }
        case "sierreur":
        case "iferror": {
          const primary = argEntries[0];
          const fallback = argEntries[1];
          const fallbackValue = fallback?.value ?? 0;
          const primaryValue = primary?.value;
          const usedFallback = !primary || primary.hadError || valueHasNumericError(primaryValue ?? 0);
          r = usedFallback ? fallbackValue ?? 0 : primaryValue ?? 0;
          break;
        }
        // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√¢‚Ç¨≈æ ARRONDIS
        case "arrondi":
        case "round": {
          const val = toNumber2(args[0] ?? 0);
          const decimals = Math.floor(toNumber2(args[1] ?? 0));
          const factor = Math.pow(10, decimals);
          r = Math.round(val * factor) / factor;
          break;
        }
        case "arrondi.sup":
        case "roundup": {
          const val = toNumber2(args[0] ?? 0);
          const decimals = Math.floor(toNumber2(args[1] ?? 0));
          const factor = Math.pow(10, decimals);
          r = Math.ceil(val * factor) / factor;
          break;
        }
        case "arrondi.inf":
        case "rounddown": {
          const val = toNumber2(args[0] ?? 0);
          const decimals = Math.floor(toNumber2(args[1] ?? 0));
          const factor = Math.pow(10, decimals);
          r = Math.floor(val * factor) / factor;
          break;
        }
        case "ent":
          r = mapNumericValue(args[0] ?? 0, Math.floor);
          break;
        case "tronque":
        case "trunc": {
          const val = toNumber2(args[0] ?? 0);
          const decimals = Math.floor(toNumber2(args[1] ?? 0));
          const factor = Math.pow(10, decimals);
          r = Math.trunc(val * factor) / factor;
          break;
        }
        case "plafond":
        case "ceiling": {
          const val = toNumber2(args[0] ?? 0);
          const multiple = toNumber2(args[1] ?? 1);
          r = multiple === 0 ? val : Math.ceil(val / multiple) * multiple;
          break;
        }
        case "plancher": {
          const val = toNumber2(args[0] ?? 0);
          const multiple = toNumber2(args[1] ?? 1);
          r = multiple === 0 ? val : Math.floor(val / multiple) * multiple;
          break;
        }
        // √É¬∞√Ö¬∏√¢‚Ç¨≈ì√Ç¬ê TRIGONOM√É∆í√¢‚Ç¨¬∞TRIE (compl√É∆í√Ç¬©ments)
        case "degres":
        case "degrees":
          r = mapNumericValue(args[0] ?? 0, (rad) => rad * (180 / Math.PI));
          break;
        case "sin":
        case "sinus":
          r = mapNumericValue(args[0] ?? 0, Math.sin);
          break;
        case "tan":
        case "tangente":
          r = mapNumericValue(args[0] ?? 0, Math.tan);
          break;
        case "asin":
        case "arcsin":
          r = mapNumericValue(args[0] ?? 0, Math.asin);
          break;
        case "acos":
        case "arccos":
          r = mapNumericValue(args[0] ?? 0, Math.acos);
          break;
        case "atan2": {
          const x = toNumber2(args[0] ?? 0);
          const y = toNumber2(args[1] ?? 0);
          r = Math.atan2(y, x);
          break;
        }
        // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬¢ MATH√É∆í√¢‚Ç¨¬∞MATIQUES (compl√É∆í√Ç¬©ments)
        case "puissance":
        case "power": {
          const base = toNumber2(args[0] ?? 0);
          const exp = toNumber2(args[1] ?? 1);
          r = Math.pow(base, exp);
          break;
        }
        case "exp":
          r = mapNumericValue(args[0] ?? 0, Math.exp);
          break;
        case "ln":
          r = mapNumericValue(args[0] ?? 0, (val) => val <= 0 ? 0 : Math.log(val));
          break;
        case "log": {
          const val = toNumber2(args[0] ?? 0);
          const base = toNumber2(args[1] ?? 10);
          r = val <= 0 ? 0 : Math.log(val) / Math.log(base);
          break;
        }
        case "log10":
          r = mapNumericValue(args[0] ?? 0, (val) => val <= 0 ? 0 : Math.log10(val));
          break;
        // case 'abs': // D√©j√† d√©fini plus haut
        //   r = mapNumericValue(args[0] ?? 0, Math.abs);
        //   break;
        case "signe":
        case "sign":
          r = mapNumericValue(args[0] ?? 0, Math.sign);
          break;
        case "mod": {
          const val = toNumber2(args[0] ?? 0);
          const divisor = toNumber2(args[1] ?? 1);
          r = divisor === 0 ? 0 : val % divisor;
          break;
        }
        // üìä STATISTIQUES (compl√©ments) - min/max d√©finis plus haut
        case "moyenne":
        case "average": {
          const vals = args.flatMap((a) => Array.isArray(a) ? a : [toNumber2(a ?? 0)]);
          r = vals.length ? vals.reduce((s, v) => s + v, 0) / vals.length : 0;
          break;
        }
        case "somme":
        case "sum": {
          const vals = args.flatMap((a) => Array.isArray(a) ? a : [toNumber2(a ?? 0)]);
          r = vals.reduce((s, v) => s + v, 0);
          break;
        }
        case "sommeprod": {
          if (!args.length) {
            r = 0;
            break;
          }
          const arraysF = args.map(valueToArray);
          const maxLenF = Math.max(...arraysF.map((arr) => arr.length));
          if (maxLenF === 0) {
            r = 0;
            break;
          }
          if (arraysF.length === 1) {
            r = arraysF[0].reduce((acc, val) => acc + val, 0);
            break;
          }
          let totalF = 0;
          for (let i = 0; i < maxLenF; i++) {
            let product = 1;
            for (const arr of arraysF) {
              const val = arr.length === 1 ? arr[0] : arr[i] ?? 0;
              product *= val;
            }
            totalF += product;
          }
          r = totalF;
          break;
        }
        case "nb":
        case "count": {
          const vals = args.flatMap((a) => Array.isArray(a) ? a : [a]);
          r = vals.filter((v) => typeof v === "number" && !isNaN(v)).length;
          break;
        }
        // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√¢‚Äö¬¨ LOGIQUE & CONDITIONS
        case "si":
        case "if": {
          const cond = toNumber2(args[0] ?? 0) !== 0;
          r = cond ? args[1] ?? 0 : args[2] ?? 0;
          break;
        }
        case "et":
        case "and": {
          r = args.every((a) => toNumber2(a ?? 0) !== 0) ? 1 : 0;
          break;
        }
        case "ou":
        case "or": {
          r = args.some((a) => toNumber2(a ?? 0) !== 0) ? 1 : 0;
          break;
        }
        case "non":
        case "not":
          r = toNumber2(args[0] ?? 0) === 0 ? 1 : 0;
          break;
        default:
          pushError("unknown_function", { func: tk.name });
          r = 0;
      }
      if (typeof r === "number" || Array.isArray(r)) {
        r = sanitizeNumericResult(r, { func: tk.name });
      }
      const funcIntroducedErrors = errors.length > beforeErrors;
      let hadError;
      if (tk.name === "sierreur" || tk.name === "iferror") {
        const primary = argEntries[0];
        const fallback = argEntries[1];
        const usedFallback = !primary || primary.hadError || valueHasNumericError(primary?.value ?? 0);
        const sourceEntry = usedFallback ? fallback : primary;
        hadError = funcIntroducedErrors || Boolean(sourceEntry?.hadError);
      } else {
        hadError = funcIntroducedErrors || argEntries.some((e) => e.hadError);
      }
      pushEntry(r, hadError);
    }
  }
  const out = popEntry();
  if (stack.length || !out) {
    pushError("invalid_result");
    const dt2 = Date.now() - t0;
    logicMetrics.evaluations++;
    logicMetrics.totalEvalMs += dt2;
    return { value: 0, errors };
  }
  let finalValue = out.value;
  if (typeof finalValue === "string") {
    finalValue = stringToNumber(finalValue);
  } else if (Array.isArray(finalValue)) {
    finalValue = finalValue[0] ?? 0;
  }
  if (typeof finalValue !== "number" || !Number.isFinite(finalValue)) {
    pushError("invalid_result");
    const dt2 = Date.now() - t0;
    logicMetrics.evaluations++;
    logicMetrics.totalEvalMs += dt2;
    return { value: 0, errors };
  }
  const dt = Date.now() - t0;
  logicMetrics.evaluations++;
  logicMetrics.totalEvalMs += dt;
  return { value: finalValue, errors };
}
async function evaluateExpression(expr, roleToNodeId, opts) {
  try {
    const tokens2 = parseExpression(expr, roleToNodeId, opts);
    return evaluateTokens(tokens2, opts);
  } catch (e) {
    logicMetrics.parseErrors++;
    throw e;
  }
}
var OP_PRECEDENCE, OP_ASSOC, rpnCache, rpnParseCount, logicMetrics;
var init_formulaEngine = __esm({
  "src/components/TreeBranchLeaf/treebranchleaf-new/api/formulaEngine.ts"() {
    OP_PRECEDENCE = {
      "+": 1,
      "-": 1,
      "*": 2,
      "/": 2,
      "^": 3,
      "&": 1,
      and: 0,
      or: 0
    };
    OP_ASSOC = {
      "+": "L",
      "-": "L",
      "*": "L",
      "/": "L",
      "^": "R",
      "&": "L",
      and: "L",
      or: "L"
    };
    rpnCache = /* @__PURE__ */ new Map();
    rpnParseCount = 0;
    logicMetrics = {
      evaluations: 0,
      totalEvalMs: 0,
      functions: {},
      divisionByZero: 0,
      unknownVariables: 0,
      parseErrors: 0,
      invalidResults: 0
    };
  }
});

// src/components/TreeBranchLeaf/treebranchleaf-new/api/operation-interpreter.ts
var operation_interpreter_exports = {};
__export(operation_interpreter_exports, {
  evaluateVariableOperation: () => evaluateVariableOperation,
  identifyReferenceType: () => identifyReferenceType,
  interpretCondition: () => interpretCondition,
  interpretField: () => interpretField,
  interpretFormula: () => interpretFormula,
  interpretReference: () => interpretReference,
  interpretTable: () => interpretTable,
  normalizeRef: () => normalizeRef
});
function identifyReferenceType(ref) {
  if (ref.startsWith("@value.condition:") || ref.startsWith("@value.node-condition:")) {
    return "condition";
  }
  if (ref.startsWith("@value.node-formula:")) {
    return "formula";
  }
  if (ref.startsWith("@value.node-table:")) {
    return "table";
  }
  if (ref.startsWith("@value.")) {
    return "value";
  }
  if (ref.startsWith("@table.")) {
    return "table";
  }
  const cleaned = ref.replace("@value.", "").replace("@table.", "").trim();
  if (cleaned.startsWith("node-formula:")) {
    return "formula";
  }
  if (cleaned.startsWith("condition:") || cleaned.startsWith("node-condition:")) {
    return "condition";
  }
  if (cleaned.startsWith("node-table:")) {
    return "table";
  }
  if (cleaned.startsWith("node_")) {
    return "field";
  }
  if (cleaned.startsWith("shared-ref-")) {
    return "field";
  }
  const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i;
  if (uuidRegex.test(cleaned)) {
    return "field";
  }
  return "field";
}
async function identifyReferenceTypeFromDB(id, prisma51) {
  try {
    const conditionNode = await prisma51.treeBranchLeafNode.findUnique({
      where: { id },
      select: { type: true }
    });
    if (conditionNode) {
      if (conditionNode.type === "condition") {
        return "condition";
      }
      if (conditionNode.type === "node_formula") {
        return "formula";
      }
      if (conditionNode.type === "node_table") {
        return "table";
      }
      return "field";
    }
    return "field";
  } catch (error) {
    console.error(`[IDENTIFY] \xC3\xA2\xC2\x9D\xC5\u2019 Erreur lors de l'identification en BD:`, error);
    return "field";
  }
}
function normalizeRef(ref) {
  return ref.replace("@value.", "").replace("@table.", "").replace("node-formula:", "").replace("node-table:", "").replace("node-condition:", "").replace("condition:", "").trim();
}
async function enrichDataFromSubmission(submissionId, prisma51, valueMap, labelMap, treeId) {
  try {
    const submissionData = await prisma51.treeBranchLeafSubmissionData.findMany({
      where: { submissionId },
      select: {
        nodeId: true,
        value: true
      }
    });
    if (!treeId) {
      const firstSubmissionData = await prisma51.treeBranchLeafSubmissionData.findFirst({
        where: { submissionId },
        select: { nodeId: true }
      });
      if (firstSubmissionData?.nodeId) {
        const node = await prisma51.treeBranchLeafNode.findUnique({
          where: { id: firstSubmissionData.nodeId },
          select: { treeId: true }
        });
        treeId = node?.treeId;
      }
    }
    let leadId = null;
    const submission = await prisma51.treeBranchLeafSubmission.findUnique({
      where: { id: submissionId },
      select: { leadId: true }
    });
    if (submission?.leadId) {
      leadId = submission.leadId;
    }
    if (!leadId) {
      const leadNode = await prisma51.treeBranchLeafSubmissionData.findFirst({
        where: {
          submissionId,
          fieldLabel: { contains: "ID Lead" }
        },
        select: { value: true }
      });
      if (leadNode?.value) {
        try {
          leadId = typeof leadNode.value === "string" ? JSON.parse(leadNode.value) : leadNode.value;
        } catch {
          leadId = leadNode.value;
        }
      }
    }
    if (leadId && typeof leadId === "string") {
      const lead = await prisma51.lead.findUnique({
        where: { id: leadId },
        select: {
          firstName: true,
          lastName: true,
          email: true,
          phone: true,
          company: true,
          leadNumber: true,
          linkedin: true,
          website: true,
          status: true,
          notes: true,
          data: true
        }
      });
      if (lead) {
        valueMap.set("lead.firstName", lead.firstName);
        valueMap.set("lead.lastName", lead.lastName);
        valueMap.set("lead.email", lead.email);
        valueMap.set("lead.phone", lead.phone);
        valueMap.set("lead.company", lead.company);
        valueMap.set("lead.leadNumber", lead.leadNumber);
        valueMap.set("lead.linkedin", lead.linkedin);
        valueMap.set("lead.website", lead.website);
        valueMap.set("lead.status", lead.status);
        valueMap.set("lead.notes", lead.notes);
        if (lead.data && typeof lead.data === "object") {
          const leadData = lead.data;
          if (leadData.postalCode) {
            valueMap.set("lead.postalCode", leadData.postalCode);
          } else if (leadData.address && typeof leadData.address === "string") {
            const postalCodeMatch = leadData.address.match(/\b(\d{4})\b/);
            if (postalCodeMatch) {
              const extractedPostalCode = postalCodeMatch[1];
              valueMap.set("lead.postalCode", extractedPostalCode);
            }
          }
          if (leadData.address) {
            valueMap.set("lead.address", leadData.address);
          }
          if (leadData.city) {
            valueMap.set("lead.city", leadData.city);
          }
          if (leadData.country) {
            valueMap.set("lead.country", leadData.country);
          }
          if (leadData.locality) {
            valueMap.set("lead.locality", leadData.locality);
          }
          if (leadData.streetName) {
            valueMap.set("lead.streetName", leadData.streetName);
          }
          if (leadData.streetNumber) {
            valueMap.set("lead.streetNumber", leadData.streetNumber);
          }
        }
      }
    }
    if (treeId) {
      const allNodes = await prisma51.treeBranchLeafNode.findMany({
        where: { treeId },
        select: {
          id: true,
          label: true,
          sharedReferenceName: true,
          field_label: true,
          calculatedValue: true
          // √É¬∞√Ö¬∏√¢‚Ç¨¬†√¢‚Ç¨¬¢ R√É∆í√Ç¬©cup√É∆í√Ç¬©rer les valeurs calcul√É∆í√Ç¬©es
        }
      });
      for (const node of allNodes) {
        if (!labelMap.has(node.id)) {
          const canonicalLabel = node.sharedReferenceName || node.field_label || node.label;
          labelMap.set(node.id, canonicalLabel);
        }
      }
    } else {
    }
    for (const data of submissionData) {
      if (data.nodeId && data.value !== null) {
        if (valueMap.has(data.nodeId)) {
          if (data.nodeId === "d6212e5e-3fe9-4cce-b380-e6745524d011") {
            console.log(`\u{1F50D} [enrichDataFromSubmission] SKIP Facture annuelle - valueMap a d\xE9j\xE0: ${valueMap.get(data.nodeId)}, DB a: ${data.value}`);
          }
          continue;
        }
        let parsedValue;
        try {
          parsedValue = typeof data.value === "string" ? JSON.parse(data.value) : data.value;
        } catch {
          parsedValue = data.value;
        }
        if (data.nodeId === "d6212e5e-3fe9-4cce-b380-e6745524d011") {
          console.log(`\u{1F50D} [enrichDataFromSubmission] SET Facture annuelle depuis DB: ${parsedValue}`);
        }
        valueMap.set(data.nodeId, parsedValue);
      }
    }
  } catch (error) {
    console.error(`[ENRICHMENT] \xC3\xA2\xC2\x9D\xC5\u2019 Erreur enrichissement:`, error);
  }
}
async function getNodeValue(nodeId, submissionId, prisma51, valueMap, options) {
  if (nodeId && (nodeId.startsWith("lead.") || nodeId.includes("."))) {
    if (valueMap && valueMap.has(nodeId)) {
      const val = valueMap.get(nodeId);
      if (val === null || val === void 0) {
        return options?.preserveEmpty ? null : "0";
      }
      return String(val);
    }
    return options?.preserveEmpty ? null : "0";
  }
  if (valueMap && valueMap.has(nodeId)) {
    const val = valueMap.get(nodeId);
    if (val === null || val === void 0) {
      return options?.preserveEmpty ? null : "0";
    }
    return String(val);
  }
  const data = await prisma51.treeBranchLeafSubmissionData.findFirst({
    where: {
      nodeId,
      submissionId
    },
    select: {
      value: true
    }
  });
  if (data?.value !== null && data?.value !== void 0) {
    return String(data.value);
  }
  return options?.preserveEmpty ? null : "0";
}
async function getNodeLabel(nodeId, prisma51, labelMap) {
  if (labelMap && labelMap.has(nodeId)) {
    const label = labelMap.get(nodeId);
    return label || "Inconnu";
  }
  const node = await prisma51.treeBranchLeafNode.findUnique({
    where: { id: nodeId },
    select: {
      label: true,
      sharedReferenceName: true,
      field_label: true
    }
  });
  return node?.sharedReferenceName || node?.field_label || node?.label || "Inconnu";
}
async function interpretReference(ref, submissionId, prisma51, valuesCache = /* @__PURE__ */ new Map(), depth = 0, valueMap, labelMap, knownType) {
  if (depth > 10) {
    console.error(`[INTERPR\xC3\u0192\xE2\u20AC\xB0TATION] \xC3\xA2\xC2\x9D\xC5\u2019 R\xC3\u0192\xC2\xA9cursion trop profonde (depth=${depth}) pour ref:`, ref);
    return {
      result: "\u2205",
      humanText: "\xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F R\xC3\u0192\xC2\xA9cursion trop profonde",
      details: {
        type: "error",
        error: "Max depth exceeded",
        depth
      }
    };
  }
  const cleanRef = normalizeRef(ref);
  if (valuesCache.has(cleanRef)) {
    return valuesCache.get(cleanRef);
  }
  let type = knownType || identifyReferenceType(ref);
  const uuidRegex = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i;
  if (type === "field" && uuidRegex.test(cleanRef)) {
    type = await identifyReferenceTypeFromDB(cleanRef, prisma51);
  }
  let result;
  try {
    switch (type) {
      case "condition":
        result = await interpretCondition(cleanRef, submissionId, prisma51, valuesCache, depth, valueMap, labelMap);
        break;
      case "formula":
        result = await interpretFormula(cleanRef, submissionId, prisma51, valuesCache, depth, valueMap, labelMap);
        break;
      case "table":
        result = await interpretTable(cleanRef, submissionId, prisma51, valuesCache, depth, valueMap, labelMap);
        break;
      case "value":
      case "field":
        result = await interpretField(cleanRef, submissionId, prisma51, valueMap, labelMap);
        break;
      default:
        console.error(`[INTERPR\xC3\u0192\xE2\u20AC\xB0TATION] \xC3\xA2\xC2\x9D\xC5\u2019 Type inconnu: ${type}`);
        result = {
          result: "\u2205",
          humanText: `Type inconnu: ${type}`,
          details: { type: "error", error: "Unknown type" }
        };
    }
  } catch (error) {
    console.error(`[INTERPR\xC3\u0192\xE2\u20AC\xB0TATION] \xC3\xA2\xC2\x9D\xC5\u2019 Erreur lors de l'interpr\xC3\u0192\xC2\xA9tation:`, error);
    result = {
      result: "\u2205",
      humanText: `Erreur: ${error instanceof Error ? error.message : "Inconnue"}`,
      details: {
        type: "error",
        error: error instanceof Error ? error.message : String(error)
      }
    };
  }
  valuesCache.set(cleanRef, result);
  return result;
}
async function interpretCondition(conditionId, submissionId, prisma51, valuesCache, depth, valueMap, labelMap) {
  const cleanId = conditionId.replace("condition:", "");
  const condition = await prisma51.treeBranchLeafNodeCondition.findUnique({
    where: { id: cleanId },
    select: {
      id: true,
      name: true,
      conditionSet: true,
      nodeId: true
    }
  });
  if (!condition) {
    return {
      result: "\u2205",
      humanText: `Condition introuvable: ${conditionId}`,
      details: { type: "condition", error: "Not found" }
    };
  }
  const condSet = condition.conditionSet;
  const branch = condSet.branches?.[0];
  const when = branch?.when;
  if (!when) {
    return {
      result: "\u2205",
      humanText: "Structure condition invalide",
      details: { type: "condition", error: "Missing WHEN" }
    };
  }
  const resolveOperandReference = async (ref) => {
    if (!ref) {
      return { value: null, label: "Inconnu" };
    }
    const stripUuidNumericSuffix = (id) => {
      const m = id.match(/^([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})-\d+$/i);
      return m ? m[1] : id;
    };
    if (ref.startsWith("@select.")) {
      const optionNodeId = ref.slice("@select.".length).split(".")[0];
      let optionNode = await prisma51.treeBranchLeafNode.findUnique({
        where: { id: optionNodeId },
        select: { id: true, label: true, parentId: true }
      });
      if (!optionNode) {
        const baseOptionId = stripUuidNumericSuffix(optionNodeId);
        if (baseOptionId !== optionNodeId) {
          optionNode = await prisma51.treeBranchLeafNode.findUnique({
            where: { id: baseOptionId },
            select: { id: true, label: true, parentId: true }
          });
        }
      }
      if (optionNode) {
        return { value: optionNode.id, label: optionNode.label };
      }
      return { value: optionNodeId, label: "Option inconnue" };
    }
    const operandType = identifyReferenceType(ref);
    if (operandType === "field" || operandType === "value") {
      const operandId = normalizeRef(ref);
      const value = await getNodeValue(operandId, submissionId, prisma51, valueMap, { preserveEmpty: true });
      const label = await getNodeLabel(operandId, prisma51, labelMap);
      return { value, label };
    }
    const interpreted = await interpretReference(
      ref,
      submissionId,
      prisma51,
      valuesCache,
      depth + 1,
      valueMap,
      labelMap,
      operandType
    );
    const labelFromDetails = interpreted.details?.conditionName || interpreted.details?.formulaName || interpreted.details?.tableName || interpreted.details?.label || interpreted.details?.name || `R\xC3\u0192\xC2\xA9f\xC3\u0192\xC2\xA9rence ${operandType}`;
    return {
      value: interpreted.result,
      label: labelFromDetails
    };
  };
  const leftRef = when.left?.ref;
  let leftValue = null;
  let leftLabel = "Inconnu";
  if (leftRef) {
    const leftInfo = await resolveOperandReference(leftRef);
    leftValue = leftInfo.value;
    leftLabel = leftInfo.label;
  }
  const rightRef = when.right?.ref;
  let rightValue = null;
  let rightLabel = "Inconnu";
  if (rightRef) {
    const rightInfo = await resolveOperandReference(rightRef);
    rightValue = rightInfo.value;
    rightLabel = rightInfo.label;
  } else if (when.right?.value !== void 0) {
    rightValue = String(when.right.value);
    rightLabel = rightValue;
  }
  const operator = when.op;
  const conditionMet = evaluateOperator(operator, leftValue, rightValue);
  const _selectedBranch = conditionMet ? branch : condSet.fallback;
  const branchName = conditionMet ? "ALORS" : "SINON";
  let alorsResult = { result: "\u2205", humanText: "Aucune action" };
  if (branch && branch.actions && branch.actions.length > 0) {
    const alorsAction = branch.actions[0];
    const alorsNodeId = alorsAction.nodeIds?.[0];
    if (alorsNodeId) {
      alorsResult = await interpretReference(
        alorsNodeId,
        submissionId,
        prisma51,
        valuesCache,
        depth + 1,
        valueMap,
        labelMap
      );
    }
  }
  let sinonResult = { result: "\u2205", humanText: "Aucune action" };
  if (condSet.fallback && condSet.fallback.actions && condSet.fallback.actions.length > 0) {
    const sinonAction = condSet.fallback.actions[0];
    const sinonNodeId = sinonAction.nodeIds?.[0];
    if (sinonNodeId) {
      sinonResult = await interpretReference(
        sinonNodeId,
        submissionId,
        prisma51,
        valuesCache,
        depth + 1,
        valueMap,
        labelMap
      );
    }
  }
  const operatorText = getOperatorText(operator);
  const leftDisplay = `${leftLabel}(${leftValue || "\u2205"})`;
  const rightDisplay = rightLabel !== "Inconnu" ? `${rightLabel}` : "";
  const conditionText = rightDisplay ? `Si ${leftDisplay} ${operatorText} ${rightDisplay}` : `Si ${leftDisplay} ${operatorText}`;
  const humanText = `${conditionText}; ALORS: ${alorsResult.humanText}; SINON: ${sinonResult.humanText} \xC3\xA2\xE2\u20AC\xA0\xE2\u20AC\u2122 [${branchName} S\xC3\u0192\xE2\u20AC\xB0LECTIONN\xC3\u0192\xE2\u20AC\xB0] Result = ${conditionMet ? alorsResult.result : sinonResult.result}`;
  const finalResult = conditionMet ? alorsResult.result : sinonResult.result;
  return {
    result: finalResult,
    humanText,
    details: {
      type: "condition",
      conditionId: condition.id,
      conditionName: condition.name,
      when: {
        left: { ref: leftRef, label: leftLabel, value: leftValue },
        operator,
        right: { ref: rightRef, label: rightLabel, value: rightValue },
        evaluated: conditionMet
      },
      branchUsed: branchName,
      alorsResult: alorsResult.details,
      sinonResult: sinonResult.details,
      selectedResult: conditionMet ? alorsResult.details : sinonResult.details
    }
  };
}
function evaluateOperator(op, left, right) {
  const normalizeUuidWithNumericSuffix = (value) => {
    if (typeof value !== "string") return value;
    const m = value.match(/^([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})(-\d+)?$/i);
    if (!m) return value;
    return m[1];
  };
  const isUuidLike = (value) => {
    if (typeof value !== "string") return false;
    const normalized = normalizeUuidWithNumericSuffix(value);
    if (typeof normalized !== "string") return false;
    return /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i.test(normalized);
  };
  const normalizeComparable = (value) => {
    if (Array.isArray(value)) return value.map(normalizeComparable);
    return normalizeUuidWithNumericSuffix(value);
  };
  const equalsWithCopySuffixSupport = (a, b) => {
    const na = normalizeComparable(a);
    const nb = normalizeComparable(b);
    if (Array.isArray(na) && Array.isArray(nb)) {
      if (na.length !== nb.length) return false;
      for (let i = 0; i < na.length; i++) {
        if (na[i] !== nb[i]) return false;
      }
      return true;
    }
    if (Array.isArray(na)) return na.includes(nb);
    if (Array.isArray(nb)) return nb.includes(na);
    return na === nb;
  };
  switch (op) {
    case "isEmpty":
      return left === null || left === void 0 || left === "";
    case "isNotEmpty":
      return left !== null && left !== void 0 && left !== "";
    case "eq":
    case "==":
      return equalsWithCopySuffixSupport(left, right);
    case "ne":
    case "!=":
      return !equalsWithCopySuffixSupport(left, right);
    // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬• NOUVEAU: Op√É∆í√Ç¬©rateur 'contains' pour v√É∆í√Ç¬©rifier si une cha√É∆í√Ç¬Æne contient une autre
    case "contains":
      if (left === null || left === void 0) return false;
      if (right === null || right === void 0) return false;
      {
        const nl = normalizeComparable(left);
        const nr = normalizeComparable(right);
        if (Array.isArray(nl) && Array.isArray(nr)) {
          return nr.every((v) => nl.includes(v));
        }
        if (Array.isArray(nl) && !Array.isArray(nr)) {
          return nl.includes(nr);
        }
        if (!Array.isArray(nl) && Array.isArray(nr)) {
          return nr.includes(nl);
        }
        if (isUuidLike(nl) || isUuidLike(nr)) {
          return equalsWithCopySuffixSupport(nl, nr);
        }
        return String(nl).toLowerCase().includes(String(nr).toLowerCase());
      }
    // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬• NOUVEAU: Op√É∆í√Ç¬©rateur 'startsWith' pour v√É∆í√Ç¬©rifier si une cha√É∆í√Ç¬Æne commence par une autre
    case "startsWith":
    case "commence par":
      if (left === null || left === void 0) return false;
      if (right === null || right === void 0) return false;
      return String(left).toLowerCase().startsWith(String(right).toLowerCase());
    case "gt":
    case ">":
      return Number(left) > Number(right);
    case "gte":
    case ">=":
      return Number(left) >= Number(right);
    case "lt":
    case "<":
      return Number(left) < Number(right);
    case "lte":
    case "<=":
      return Number(left) <= Number(right);
    default:
      return false;
  }
}
function compareValuesByOperator(op, cellValue, targetValue) {
  if (!op) return false;
  const normalizeUuidWithNumericSuffix = (value) => {
    if (typeof value !== "string") return value;
    const m = value.match(/^([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})(-\d+)?$/i);
    if (!m) return value;
    return m[1];
  };
  const normalizedCell = normalizeUuidWithNumericSuffix(cellValue);
  const normalizedTarget = normalizeUuidWithNumericSuffix(targetValue);
  switch (op) {
    case "equals":
    case "==":
      return String(normalizedCell) === String(normalizedTarget);
    case "notEquals":
    case "!=":
      return String(normalizedCell) !== String(normalizedTarget);
    case "greaterThan":
    case ">":
      return Number(cellValue) > Number(targetValue);
    case "greaterOrEqual":
    case ">=":
      return Number(cellValue) >= Number(targetValue);
    case "lessThan":
    case "<":
      return Number(cellValue) < Number(targetValue);
    case "lessOrEqual":
    case "<=":
      return Number(cellValue) <= Number(targetValue);
    case "contains":
      return String(cellValue).includes(String(targetValue));
    case "notContains":
      return !String(cellValue).includes(String(targetValue));
    default:
      return false;
  }
}
function findClosestIndexInLabels(targetValue, labels, allowedIndices) {
  const indices = allowedIndices && allowedIndices.length ? allowedIndices : labels.map((_, idx) => idx);
  const normalizedTarget = normalizeLookupValue(targetValue);
  const strictTarget = String(targetValue ?? "").trim().toLowerCase();
  for (const idx of indices) {
    const label = labels[idx];
    const strictLabel = String(label ?? "").trim().toLowerCase();
    if (label === targetValue || strictLabel === strictTarget || normalizeLookupValue(label) === normalizedTarget) {
      return { index: idx, matchType: "text", matchedValue: label };
    }
  }
  const numericTarget = parseNumericLookupValue(targetValue);
  if (isNaN(numericTarget)) {
    return null;
  }
  let exactIndex = -1;
  let upperIndex = -1;
  let upperValue = Infinity;
  let lowerIndex = -1;
  let lowerValue = -Infinity;
  for (const idx of indices) {
    const labelValue = parseNumericLookupValue(labels[idx]);
    if (isNaN(labelValue)) continue;
    if (labelValue === numericTarget) {
      exactIndex = idx;
      break;
    }
    if (labelValue >= numericTarget && labelValue < upperValue) {
      upperValue = labelValue;
      upperIndex = idx;
    }
    if (labelValue <= numericTarget && labelValue > lowerValue) {
      lowerValue = labelValue;
      lowerIndex = idx;
    }
  }
  if (exactIndex !== -1) {
    return { index: exactIndex, matchType: "numeric", matchedValue: numericTarget };
  }
  if (upperIndex !== -1) {
    return { index: upperIndex, matchType: "numeric", matchedValue: upperValue };
  }
  if (lowerIndex !== -1) {
    return { index: lowerIndex, matchType: "numeric", matchedValue: lowerValue };
  }
  return null;
}
function getOperatorText(op) {
  const texts = {
    "isEmpty": "est vide",
    "isNotEmpty": "n'est pas vide",
    "eq": "=",
    "ne": "\xC3\xA2\xE2\u20AC\xB0\xC2\xA0",
    "gt": ">",
    "gte": "\xC3\xA2\xE2\u20AC\xB0\xC2\xA5",
    "lt": "<",
    "lte": "\xC3\xA2\xE2\u20AC\xB0\xC2\xA4",
    "==": "=",
    "!=": "\xC3\xA2\xE2\u20AC\xB0\xC2\xA0"
  };
  return texts[op] || op;
}
function encodeRef(refType, refId) {
  return `${refType}::${refId}`;
}
function tryParseTokenReference(token) {
  if (!token || typeof token !== "string") return null;
  const rawToken = token;
  let normalizedToken = token.trim();
  const wrapperMatch = normalizedToken.match(/^\{\{\s*(.+?)\s*\}\}$/);
  if (wrapperMatch && wrapperMatch[1]) {
    normalizedToken = wrapperMatch[1];
  }
  const createMeta = (refType, refId) => ({ refType, refId, rawToken });
  if (normalizedToken.startsWith("@calculated.")) {
    const nodeId = normalizedToken.slice("@calculated.".length);
    return createMeta("value", nodeId);
  }
  if (normalizedToken.startsWith("@value.condition:")) {
    return createMeta("condition", normalizedToken.slice("@value.condition:".length));
  }
  if (normalizedToken.startsWith("@value.node-condition:")) {
    return createMeta("condition", normalizedToken.slice("@value.node-condition:".length));
  }
  if (normalizedToken.startsWith("@value.")) {
    return createMeta("value", normalizedToken.slice("@value.".length));
  }
  if (normalizedToken.startsWith("@table.")) {
    return createMeta("table", normalizedToken.slice("@table.".length));
  }
  if (normalizedToken.startsWith("@condition.")) {
    return createMeta("condition", normalizedToken.slice("@condition.".length));
  }
  if (normalizedToken.startsWith("@select.")) {
    const cleaned = normalizedToken.slice("@select.".length).split(".")[0];
    return cleaned ? createMeta("value", cleaned) : null;
  }
  const formulaMatch = normalizedToken.match(RE_NODE_FORMULA) || normalizedToken.match(RE_LEGACY_FORMULA);
  if (formulaMatch && formulaMatch[0]) {
    const normalized = formulaMatch[0].startsWith("node-formula:") ? formulaMatch[0].slice("node-formula:".length) : formulaMatch[0].slice("formula:".length);
    return createMeta("formula", normalized);
  }
  if (normalizedToken.startsWith("node-formula:")) {
    return createMeta("formula", normalizedToken.slice("node-formula:".length));
  }
  if (normalizedToken.startsWith("formula:") && !normalizedToken.startsWith("formula:node-")) {
    return createMeta("formula", normalizedToken.slice("formula:".length));
  }
  if (normalizedToken.startsWith("node-table:")) {
    return createMeta("table", normalizedToken.slice("node-table:".length));
  }
  if (normalizedToken.startsWith("table:") && !normalizedToken.startsWith("table:node-")) {
    return createMeta("table", normalizedToken.slice("table:".length));
  }
  if (normalizedToken.startsWith("node-condition:")) {
    return createMeta("condition", normalizedToken.slice("node-condition:".length));
  }
  if (normalizedToken.startsWith("condition:") && !normalizedToken.startsWith("condition:node-")) {
    return createMeta("condition", normalizedToken.slice("condition:".length));
  }
  if (normalizedToken.startsWith("shared-ref-") || normalizedToken.startsWith("node_") || UUID_REGEX.test(normalizedToken)) {
    return createMeta("field", normalizedToken);
  }
  return null;
}
function buildFormulaExpression(tokens2) {
  const parts = [];
  const roleToEncoded = {};
  const encodedMeta = {};
  const exprSegments = [];
  let varIndex = 0;
  const appendLiteral = (value) => {
    exprSegments.push(value);
    parts.push({ type: "literal", value });
  };
  const registerReference = (meta) => {
    const encoded = encodeRef(meta.refType, meta.refId);
    if (!encodedMeta[encoded]) encodedMeta[encoded] = meta;
    const role = `var_${varIndex++}`;
    roleToEncoded[role] = encoded;
    const placeholder = `{{${role}}}`;
    exprSegments.push(placeholder);
    parts.push({ type: "placeholder", encoded });
  };
  for (const rawToken of tokens2) {
    if (typeof rawToken === "string") {
      const refMeta = tryParseTokenReference(rawToken);
      if (refMeta) {
        registerReference(refMeta);
        continue;
      }
      if (rawToken === "CONCAT") {
        appendLiteral("&");
        continue;
      }
      appendLiteral(rawToken);
    } else if (rawToken && typeof rawToken === "object") {
      const refStr = typeof rawToken.ref === "string" ? rawToken.ref : typeof rawToken.value === "string" ? rawToken.value : typeof rawToken.nodeId === "string" ? rawToken.nodeId : "";
      if (refStr) {
        const refMeta = tryParseTokenReference(refStr) || { refType: "field", refId: refStr, rawToken: refStr };
        registerReference(refMeta);
      }
    }
  }
  const expression = exprSegments.join(" ");
  return { expression, parts, roleToEncoded, encodedMeta };
}
async function interpretFormula(formulaId, submissionId, prisma51, valuesCache, depth, valueMap, labelMap) {
  const cleanId = formulaId.replace("node-formula:", "");
  let formula = await prisma51.treeBranchLeafNodeFormula.findUnique({
    where: { id: cleanId },
    select: {
      id: true,
      name: true,
      tokens: true,
      nodeId: true
    }
  });
  if (!formula) {
    try {
      const byNode = await prisma51.treeBranchLeafNodeFormula.findFirst({
        where: { nodeId: cleanId },
        select: { id: true, name: true, tokens: true, nodeId: true },
        orderBy: { isDefault: "desc" }
      });
      if (byNode) {
        formula = byNode;
      }
    } catch (e) {
      console.warn("[FORMULE] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F R\xC3\u0192\xC2\xA9solution implicite \xC3\u0192\xC2\xA9chou\xC3\u0192\xC2\xA9e:", e instanceof Error ? e.message : e);
    }
  }
  if (!formula) {
    return {
      result: "\u2205",
      humanText: `Formule introuvable: ${formulaId}`,
      details: { type: "formula", error: "Not found" }
    };
  }
  const tokens2 = Array.isArray(formula.tokens) ? formula.tokens : [];
  const buildResult = buildFormulaExpression(tokens2);
  if (!buildResult.expression.trim()) {
    console.warn("[FORMULE] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F Expression vide, retour 0");
    return {
      result: "0",
      humanText: "0",
      details: {
        type: "formula",
        formulaId: formula.id,
        formulaName: formula.name,
        tokens: [],
        expression: "",
        humanExpression: "",
        calculatedResult: 0
      }
    };
  }
  const valueCacheByEncoded = /* @__PURE__ */ new Map();
  const labelCacheByEncoded = /* @__PURE__ */ new Map();
  const detailCacheByEncoded = /* @__PURE__ */ new Map();
  const resolveVariable = async (encoded) => {
    if (valueCacheByEncoded.has(encoded)) {
      return valueCacheByEncoded.get(encoded);
    }
    const meta = buildResult.encodedMeta[encoded];
    if (!meta || !meta.refId) {
      valueCacheByEncoded.set(encoded, 0);
      labelCacheByEncoded.set(encoded, meta?.rawToken || encoded);
      return 0;
    }
    try {
      const refResult = await interpretReference(
        meta.refId,
        submissionId,
        prisma51,
        valuesCache,
        depth + 1,
        valueMap,
        labelMap,
        meta.refType
      );
      detailCacheByEncoded.set(encoded, refResult);
      const numeric = parseNumericLookupValue(refResult.result);
      const safeValue = Number.isFinite(numeric) ? numeric : 0;
      valueCacheByEncoded.set(encoded, safeValue);
      if (meta.refType === "formula") {
        const label = refResult.details?.formulaName || refResult.details?.label || `Formule ${meta.refId}`;
        labelCacheByEncoded.set(encoded, label);
      } else {
        const label = await getNodeLabel(meta.refId, prisma51, labelMap).catch(() => meta.refId);
        labelCacheByEncoded.set(encoded, label || meta.refId);
      }
      return safeValue;
    } catch (error) {
      console.error("[FORMULE] \xC3\xA2\xC2\x9D\xC5\u2019 Erreur r\xC3\u0192\xC2\xA9solution variable:", { encoded, error });
      valueCacheByEncoded.set(encoded, 0);
      labelCacheByEncoded.set(encoded, meta?.rawToken || encoded);
      return 0;
    }
  };
  let evaluation;
  try {
    evaluation = await evaluateExpression(buildResult.expression, buildResult.roleToEncoded, {
      resolveVariable,
      divisionByZeroValue: 0,
      strictVariables: false
    });
  } catch (error) {
    console.error("[FORMULE] \xC3\xA2\xC2\x9D\xC5\u2019 Erreur evaluateExpression:", error);
    return {
      result: "\u2205",
      humanText: "Erreur de calcul de la formule",
      details: {
        type: "formula",
        formulaId: formula.id,
        formulaName: formula.name,
        tokens: tokens2.map((token) => ({ type: "raw", value: token })),
        expression: buildResult.expression,
        humanExpression: buildResult.expression,
        calculatedResult: 0,
        error: error instanceof Error ? error.message : String(error)
      }
    };
  }
  const humanExpression = buildResult.parts.map((part) => {
    if (part.type === "literal") return part.value;
    const label = labelCacheByEncoded.get(part.encoded) || buildResult.encodedMeta[part.encoded]?.refId || part.encoded;
    const value = valueCacheByEncoded.get(part.encoded) ?? 0;
    return `${label}(${value})`;
  }).join(" ").replace(/\s+/g, " ").trim();
  const calculatedResult = evaluation.value;
  const humanText = `${humanExpression} = ${calculatedResult}`;
  const tokenDetails = buildResult.parts.map((part) => {
    if (part.type === "literal") {
      return { type: "literal", value: part.value };
    }
    const meta = buildResult.encodedMeta[part.encoded];
    return {
      type: "reference",
      ref: meta?.refId,
      refType: meta?.refType,
      label: labelCacheByEncoded.get(part.encoded) || meta?.refId,
      value: valueCacheByEncoded.get(part.encoded) ?? 0,
      details: detailCacheByEncoded.get(part.encoded)?.details || null
    };
  });
  return {
    result: String(calculatedResult),
    humanText,
    details: {
      type: "formula",
      formulaId: formula.id,
      formulaName: formula.name,
      tokens: tokenDetails,
      expression: buildResult.expression,
      humanExpression,
      calculatedResult,
      evaluationErrors: evaluation.errors
    }
  };
}
async function getSourceValue(sourceOption, lookupConfig, fieldId, submissionId, prisma51, valuesCache, depth, valueMap, labelMap) {
  if (!sourceOption || sourceOption.type === "select") {
    return fieldId ? await getNodeValue(fieldId, submissionId, prisma51, valueMap) : null;
  }
  if (sourceOption.type === "field" && sourceOption.sourceField) {
    const result = await getNodeValue(sourceOption.sourceField, submissionId, prisma51, valueMap);
    return result;
  }
  if (sourceOption.type === "capacity" && sourceOption.capacityRef) {
    try {
      const capacityResult = await interpretReference(
        sourceOption.capacityRef,
        submissionId,
        prisma51,
        valuesCache,
        depth + 1,
        valueMap,
        labelMap
      );
      return capacityResult.result;
    } catch (error) {
      console.error(`[TABLE] \xC3\xA2\xC2\x9D\xC5\u2019 Erreur ex\xC3\u0192\xC2\xA9cution capacit\xC3\u0192\xC2\xA9 ${sourceOption.capacityRef}:`, error);
      return null;
    }
  }
  return null;
}
async function getSourceLabel(sourceOption, lookupConfig, fieldId, prisma51, labelMap) {
  if (!sourceOption || sourceOption.type === "select") {
    return fieldId ? await getNodeLabel(fieldId, prisma51, labelMap) : "Source";
  }
  if (sourceOption.type === "field" && sourceOption.sourceField) {
    return await getNodeLabel(sourceOption.sourceField, prisma51, labelMap);
  }
  if (sourceOption.type === "capacity" && sourceOption.capacityRef) {
    const capacityId = sourceOption.capacityRef.replace("@value.", "").replace("formula:", "").replace("condition:", "").replace("table:", "");
    if (labelMap && labelMap.has(capacityId)) {
      return labelMap.get(capacityId) || capacityId;
    }
    return `Capacit\xC3\u0192\xC2\xA9: ${sourceOption.capacityRef}`;
  }
  return "Source";
}
async function interpretTable(tableId, submissionId, prisma51, valuesCache, depth, valueMap, labelMap) {
  const cleanId = tableId.replace("@table.", "").replace("node-table:", "");
  const stripUuidNumericSuffix = (id) => {
    const m = id.match(/^([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})-\d+$/i);
    return m ? m[1] : id;
  };
  const stripCopySuffix = (value) => {
    return String(value ?? "").replace(/-\d+$/, "");
  };
  const baseId = stripUuidNumericSuffix(cleanId);
  let table = await prisma51.treeBranchLeafNodeTable.findUnique({
    where: { id: cleanId },
    select: {
      id: true,
      name: true,
      type: true,
      rowCount: true,
      columnCount: true,
      meta: true,
      nodeId: true,
      tableColumns: {
        orderBy: { columnIndex: "asc" },
        select: {
          id: true,
          columnIndex: true,
          name: true,
          type: true,
          width: true,
          format: true,
          metadata: true
        }
      },
      tableRows: {
        orderBy: { rowIndex: "asc" },
        select: {
          id: true,
          rowIndex: true,
          cells: true
        }
      }
    }
  });
  if (!table && baseId !== cleanId) {
    table = await prisma51.treeBranchLeafNodeTable.findUnique({
      where: { id: baseId },
      select: {
        id: true,
        name: true,
        type: true,
        rowCount: true,
        columnCount: true,
        meta: true,
        nodeId: true,
        tableColumns: {
          orderBy: { columnIndex: "asc" },
          select: { id: true, columnIndex: true, name: true, type: true, width: true, format: true, metadata: true }
        },
        tableRows: {
          orderBy: { rowIndex: "asc" },
          select: { id: true, rowIndex: true, cells: true }
        }
      }
    });
  }
  if (!table) {
    try {
      const byNode = await prisma51.treeBranchLeafNodeTable.findFirst({
        where: { nodeId: cleanId },
        select: {
          id: true,
          name: true,
          type: true,
          rowCount: true,
          columnCount: true,
          meta: true,
          nodeId: true,
          tableColumns: {
            orderBy: { columnIndex: "asc" },
            select: { id: true, columnIndex: true, name: true, type: true, width: true, format: true, metadata: true }
          },
          tableRows: {
            orderBy: { rowIndex: "asc" },
            select: { id: true, rowIndex: true, cells: true }
          }
        },
        orderBy: [{ isDefault: "desc" }, { updatedAt: "desc" }]
      });
      if (byNode) {
        table = byNode;
      }
    } catch (e) {
      console.warn("[TABLE] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F R\xC3\u0192\xC2\xA9solution implicite \xC3\u0192\xC2\xA9chou\xC3\u0192\xC2\xA9e:", e instanceof Error ? e.message : e);
    }
  }
  if (!table && baseId !== cleanId) {
    try {
      const byNode = await prisma51.treeBranchLeafNodeTable.findFirst({
        where: { nodeId: baseId },
        select: {
          id: true,
          name: true,
          type: true,
          rowCount: true,
          columnCount: true,
          meta: true,
          nodeId: true,
          tableColumns: {
            orderBy: { columnIndex: "asc" },
            select: { id: true, columnIndex: true, name: true, type: true, width: true, format: true, metadata: true }
          },
          tableRows: {
            orderBy: { rowIndex: "asc" },
            select: { id: true, rowIndex: true, cells: true }
          }
        },
        orderBy: [{ isDefault: "desc" }, { updatedAt: "desc" }]
      });
      if (byNode) {
        table = byNode;
      }
    } catch (e) {
      console.warn("[TABLE] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F R\xC3\u0192\xC2\xA9solution implicite (baseId) \xC3\u0192\xC2\xA9chou\xC3\u0192\xC2\xA9e:", e instanceof Error ? e.message : e);
    }
  }
  if (!table) {
    return {
      result: "\u2205",
      humanText: `Table introuvable: ${tableId}`,
      details: { type: "table", error: "Not found" }
    };
  }
  const columns = table.tableColumns.map((col) => col.name);
  const rows = [];
  const data = [];
  table.tableRows.forEach((row) => {
    try {
      let cellsData;
      if (typeof row.cells === "string") {
        try {
          cellsData = JSON.parse(row.cells);
        } catch {
          cellsData = [row.cells];
        }
      } else {
        cellsData = row.cells || [];
      }
      if (row.rowIndex === 0) {
        return;
      }
      if (Array.isArray(cellsData) && cellsData.length > 0) {
        const rowLabel2 = String(cellsData[0] || "");
        const rowData = cellsData.slice(1);
        rows.push(rowLabel2);
        data.push(rowData);
      } else {
        rows.push(`Row ${row.rowIndex}`);
        data.push([]);
      }
    } catch (error) {
      console.error("[TABLE] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F Erreur parsing cells:", error);
      rows.push(`Row ${row.rowIndex}`);
      data.push([]);
    }
  });
  const meta = table.meta;
  const lookup = meta?.lookup;
  const isLookupActive = lookup && (lookup.enabled === true || lookup.columnLookupEnabled === true || lookup.rowLookupEnabled === true);
  if (!isLookupActive) {
    console.error(`[TABLE] \xC3\xA2\xC2\x9D\xC5\u2019 Lookup non configur\xC3\u0192\xC2\xA9 ou d\xC3\u0192\xC2\xA9sactiv\xC3\u0192\xC2\xA9`);
    return {
      result: "\u2205",
      humanText: `Lookup non configur\xC3\u0192\xC2\xA9 pour table ${table.name}`,
      details: { type: "table", error: "Lookup not enabled" }
    };
  }
  let rowFieldId = lookup.selectors?.rowFieldId ?? lookup?.rowFieldId ?? lookup?.rowField ?? null;
  let colFieldId = lookup.selectors?.columnFieldId ?? lookup?.columnFieldId ?? lookup?.colFieldId ?? lookup?.columnField ?? null;
  if (typeof rowFieldId === "string" && rowFieldId.trim() === "") rowFieldId = null;
  if (typeof colFieldId === "string" && colFieldId.trim() === "") colFieldId = null;
  const rowEnabled = lookup.rowLookupEnabled === true;
  const colEnabled = lookup.columnLookupEnabled === true;
  const rowSourceOption = lookup.rowSourceOption;
  const colSourceOption = lookup.columnSourceOption;
  try {
    const rowNeedsFieldId = rowEnabled && (!rowSourceOption || rowSourceOption.type === "select") && !rowFieldId;
    const colNeedsFieldId = colEnabled && (!colSourceOption || colSourceOption.type === "select") && !colFieldId;
    if (rowNeedsFieldId || colNeedsFieldId) {
      const cfgs = await prisma51.treeBranchLeafSelectConfig.findMany({
        where: { tableReference: table.id },
        select: { nodeId: true }
      });
      const candidateNodeIds = cfgs.map((c) => c.nodeId).filter(Boolean);
      if (rowNeedsFieldId) {
        rowFieldId = (table.nodeId && table.nodeId !== colFieldId && candidateNodeIds.includes(table.nodeId) ? table.nodeId : null) || candidateNodeIds.find((id) => id !== colFieldId) || null;
      }
      if (colNeedsFieldId) {
        colFieldId = candidateNodeIds.find((id) => id !== rowFieldId) || null;
      }
    }
  } catch (e) {
    console.warn("[TABLE] \u26A0\uFE0F Inf\xE9rence selectors lookup \xE9chou\xE9e:", e instanceof Error ? e.message : e);
  }
  const hasRowSelector = Boolean(rowFieldId || rowSourceOption && rowSourceOption.type && rowSourceOption.type !== "select");
  const hasColSelector = Boolean(colFieldId || colSourceOption && colSourceOption.type && colSourceOption.type !== "select");
  if (rowEnabled && colEnabled && hasRowSelector && hasColSelector) {
  } else if (colEnabled && (colFieldId || colSourceOption) && lookup.displayColumn && !(rowEnabled && colEnabled && hasRowSelector && hasColSelector)) {
    const colSelectorValue2 = await getSourceValue(
      colSourceOption,
      lookup,
      colFieldId,
      submissionId,
      prisma51,
      valuesCache,
      depth,
      valueMap,
      labelMap
    );
    const colLabel2 = await getSourceLabel(colSourceOption, lookup, colFieldId, prisma51, labelMap);
    const displayColumns = Array.isArray(lookup.displayColumn) ? lookup.displayColumn : [lookup.displayColumn];
    if (!colSelectorValue2) {
      return {
        result: "\u2205",
        humanText: `Table "${table.name}" - Aucune s\xC3\u0192\xC2\xA9lection colonne`,
        details: { type: "table", mode: 1, error: "No column selection" }
      };
    }
    let validRowIndices = Array.from({ length: rows.length }, (_, i) => i);
    if (colSourceOption?.filterColumn && colSourceOption?.filterOperator && colSourceOption?.filterValueRef) {
      const filterRefResult = await interpretReference(
        colSourceOption.filterValueRef,
        submissionId,
        prisma51,
        valuesCache,
        depth + 1,
        valueMap,
        labelMap
      );
      const filterComparisonValue = filterRefResult.result;
      const normalizedFilterColName = String(colSourceOption.filterColumn).trim().toLowerCase();
      const filterColInCols = columns.findIndex((c) => String(c).trim().toLowerCase() === normalizedFilterColName);
      const filterColInRows = rows.findIndex((r) => String(r).trim().toLowerCase() === normalizedFilterColName);
      let filterColIndex = -1;
      if (filterColInCols !== -1) filterColIndex = filterColInCols;
      else if (filterColInRows !== -1) filterColIndex = filterColInRows;
      if (filterColIndex !== -1) {
        const dataColIndexForFilter = filterColIndex - 1;
        validRowIndices = validRowIndices.filter((rowIdx) => {
          const cellValue = filterColIndex === 0 ? rows[rowIdx] : data[rowIdx]?.[dataColIndexForFilter];
          const matches = compareValuesByOperator(colSourceOption.filterOperator, cellValue, filterComparisonValue);
          return matches;
        });
      } else {
        console.warn(`[TABLE] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F \xC3\u0192\xE2\u20AC\xB0TAPE 2.5 - Colonne de filtrage non trouv\xC3\u0192\xC2\xA9e: "${colSourceOption.filterColumn}"`);
      }
    }
    const results = [];
    if (lookup.extractValueRef) {
      const refResult = await interpretReference(lookup.extractValueRef, submissionId, prisma51, valuesCache, depth + 1, valueMap, labelMap);
      const targetValue = refResult.result;
      const columnIndices2 = columns.map((_, idx) => idx).filter((idx) => idx > 0);
      const colMatchInCols2 = findClosestIndexInLabels(colSelectorValue2, columns, columnIndices2);
      const colMatchInRows2 = findClosestIndexInLabels(colSelectorValue2, rows);
      let finalColIndex2 = colMatchInCols2?.index ?? colMatchInRows2?.index ?? -1;
      if (finalColIndex2 === -1) {
        console.warn(`[TABLE] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F MODE 1 extract - colonne non trouv\xC3\u0192\xC2\xA9e pour selector ${colSelectorValue2}`);
      } else {
        const dataColIndex2 = finalColIndex2 - 1;
        let foundRowIndex = -1;
        for (const rIdx of validRowIndices) {
          const potentialVal = data[rIdx]?.[dataColIndex2];
          if (compareValuesByOperator(lookup.extractOperator, potentialVal, targetValue)) {
            foundRowIndex = rIdx;
            break;
          }
        }
        if (foundRowIndex !== -1) {
          for (const fixedRowValue of displayColumns) {
            const normalizedFixedRow = stripCopySuffix(fixedRowValue).trim().toLowerCase();
            const fixedRowInRows = rows.findIndex((r) => String(r).trim().toLowerCase() === normalizedFixedRow);
            const fixedRowInCols = columns.findIndex((c) => String(c).trim().toLowerCase() === normalizedFixedRow);
            let rowIndex = -1;
            if (fixedRowInRows !== -1) rowIndex = fixedRowInRows;
            else if (fixedRowInCols !== -1) rowIndex = fixedRowInCols;
            if (rowIndex !== -1) {
              const dataRowIndex2 = rowIndex;
              const dataColIndexForDisplay = finalColIndex2 - 1;
              const result2 = data[dataRowIndex2]?.[dataColIndexForDisplay];
              results.push({ row: fixedRowValue, value: result2 });
            }
          }
          const resultText2 = results.map((r) => `${r.row}=${r.value}`).join(", ");
          const resultValues2 = results.map((r) => r.value);
          const humanText3 = `Table "${table.name}"[extract ${lookup.extractValueRef} ${lookup.extractOperator} -> row=${rows[foundRowIndex]}] = ${resultText2}`;
          return {
            result: resultValues2.length === 1 ? String(resultValues2[0]) : JSON.stringify(resultValues2),
            humanText: humanText3,
            details: {
              type: "table",
              mode: 1,
              tableId: table.id,
              tableName: table.name,
              lookup: {
                column: { field: colLabel2, value: colSelectorValue2 },
                rows: results,
                multiple: results.length > 1,
                extract: { ref: lookup.extractValueRef, operator: lookup.extractOperator, target: targetValue }
              }
            }
          };
        }
      }
    }
    let targetColIndex = -1;
    if ((colSourceOption?.type === "field" || colSourceOption?.type === "capacity") && colSourceOption?.operator && colSourceOption?.comparisonColumn) {
      const comparisonColName = colSourceOption.comparisonColumn;
      const normalizedComparisonCol = String(comparisonColName).trim().toLowerCase();
      const colSelectorInCols2 = columns.findIndex((c) => String(c).trim().toLowerCase() === normalizedComparisonCol);
      const colSelectorInRows2 = rows.findIndex((r) => String(r).trim().toLowerCase() === normalizedComparisonCol);
      let colSelectorIndex = -1;
      if (colSelectorInCols2 !== -1) colSelectorIndex = colSelectorInCols2;
      else if (colSelectorInRows2 !== -1) colSelectorIndex = colSelectorInRows2;
      if (colSelectorIndex !== -1) {
        const dataColIndex2 = colSelectorIndex - 1;
        let foundRowIndex = -1;
        for (const rIdx of validRowIndices) {
          const cellValue = colSelectorIndex === 0 ? rows[rIdx] : data[rIdx]?.[dataColIndex2];
          if (compareValuesByOperator(colSourceOption.operator, cellValue, colSelectorValue2)) {
            foundRowIndex = rIdx;
            break;
          }
        }
        if (foundRowIndex !== -1) {
          for (const fixedColValue of displayColumns) {
            const normalizedFixedCol = stripCopySuffix(fixedColValue).trim().toLowerCase();
            const fixedColInCols = columns.findIndex((c) => String(c).trim().toLowerCase() === normalizedFixedCol);
            const fixedColInRows = rows.findIndex((r) => String(r).trim().toLowerCase() === normalizedFixedCol);
            let colIndexForDisplay = -1;
            if (fixedColInCols !== -1) colIndexForDisplay = fixedColInCols;
            else if (fixedColInRows !== -1) colIndexForDisplay = fixedColInRows;
            if (colIndexForDisplay !== -1) {
              const dataColIndexForDisplay = colIndexForDisplay - 1;
              const result2 = data[foundRowIndex]?.[dataColIndexForDisplay];
              results.push({ row: fixedColValue, value: result2 });
            }
          }
          targetColIndex = colSelectorIndex;
        }
      } else {
        console.warn(`[TABLE] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F MODE 1 - Colonne de comparaison non trouv\xC3\u0192\xC2\xA9e: ${comparisonColName}`);
      }
    }
    if (targetColIndex === -1) {
      const hasOperatorConfig = Boolean(colSourceOption?.operator && colSourceOption?.comparisonColumn);
      const isNumericSourceWithoutOperator = (colSourceOption?.type === "capacity" || colSourceOption?.type === "field") && !hasOperatorConfig;
      if (isNumericSourceWithoutOperator) {
        const optionLabel = colSourceOption?.type === "field" ? "Option 2" : "Option 3";
        const match = findClosestIndexInLabels(colSelectorValue2, rows, validRowIndices);
        if (match) {
          const foundRowIndex = match.index;
          for (const fixedColValue of displayColumns) {
            const normalizedFixedCol = normalizeLookupValue(stripCopySuffix(fixedColValue));
            const fixedColInCols = columns.findIndex((c) => normalizeLookupValue(stripCopySuffix(c)) === normalizedFixedCol);
            const fixedColInRows = rows.findIndex((r) => normalizeLookupValue(stripCopySuffix(r)) === normalizedFixedCol);
            let colIndexForDisplay = -1;
            if (fixedColInCols !== -1) colIndexForDisplay = fixedColInCols;
            else if (fixedColInRows !== -1) colIndexForDisplay = fixedColInRows;
            if (colIndexForDisplay !== -1) {
              const dataColIndexForDisplay = colIndexForDisplay - 1;
              const result2 = data[foundRowIndex]?.[dataColIndexForDisplay];
              results.push({ row: fixedColValue, value: result2 });
            }
          }
          targetColIndex = 0;
        } else {
          console.warn(`[TABLE] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F MODE 1 ${optionLabel} - Impossible de trouver une ligne pour ${colSelectorValue2}`);
        }
      }
      if (targetColIndex === -1) {
        for (const fixedRowValue of displayColumns) {
          const colSelectorWithoutSuffix = String(colSelectorValue2).replace(/-\d+$/, "");
          const normalizedColSelector = normalizeLookupValue(colSelectorWithoutSuffix);
          const normalizedFixedRow = normalizeLookupValue(stripCopySuffix(fixedRowValue));
          const colSelectorInCols2 = columns.findIndex((c) => normalizeLookupValue(stripCopySuffix(c)) === normalizedColSelector);
          const colSelectorInRows2 = rows.findIndex((r) => normalizeLookupValue(stripCopySuffix(r)) === normalizedColSelector);
          const fixedRowInRows = rows.findIndex((r) => normalizeLookupValue(stripCopySuffix(r)) === normalizedFixedRow);
          const fixedRowInCols = columns.findIndex((c) => normalizeLookupValue(stripCopySuffix(c)) === normalizedFixedRow);
          let colIndex = -1;
          let rowIndex = -1;
          if (colSelectorInCols2 !== -1 && fixedRowInRows !== -1) {
            colIndex = colSelectorInCols2;
            rowIndex = fixedRowInRows;
          } else if (colSelectorInRows2 !== -1 && fixedRowInCols !== -1) {
            colIndex = fixedRowInCols;
            rowIndex = colSelectorInRows2;
          } else {
            colIndex = colSelectorInCols2 !== -1 ? colSelectorInCols2 : colSelectorInRows2;
            rowIndex = fixedRowInRows !== -1 ? fixedRowInRows : fixedRowInCols;
          }
          if (colIndex !== -1 && rowIndex !== -1) {
            const dataRowIndex2 = rowIndex;
            const dataColIndex2 = colIndex - 1;
            const result2 = data[dataRowIndex2]?.[dataColIndex2];
            results.push({ row: fixedRowValue, value: result2 });
          }
        }
      }
    }
    const resultText = results.map((r) => `${r.row}=${r.value}`).join(", ");
    const resultValues = results.map((r) => r.value);
    const humanText2 = `Table "${table.name}"[${colLabel2}=${colSelectorValue2}, ${displayColumns.join("+")}(fixes)] = ${resultText}`;
    return {
      result: resultValues.length === 1 ? String(resultValues[0]) : JSON.stringify(resultValues),
      humanText: humanText2,
      details: {
        type: "table",
        mode: 1,
        tableId: table.id,
        tableName: table.name,
        lookup: {
          column: { field: colLabel2, value: colSelectorValue2 },
          rows: results,
          multiple: results.length > 1
        }
      }
    };
  } else if (rowEnabled && !colEnabled && hasRowSelector && lookup.displayRow) {
    const rowSelectorValue2 = await getSourceValue(
      rowSourceOption,
      lookup,
      rowFieldId,
      submissionId,
      prisma51,
      valuesCache,
      depth,
      valueMap,
      labelMap
    );
    const rowLabel2 = await getSourceLabel(rowSourceOption, lookup, rowFieldId, prisma51, labelMap);
    const displayRows = Array.isArray(lookup.displayRow) ? lookup.displayRow : [lookup.displayRow];
    if (!rowSelectorValue2) {
      return {
        result: "\u2205",
        humanText: `Table "${table.name}" - Aucune s\xC3\u0192\xC2\xA9lection ligne`,
        details: { type: "table", mode: 2, error: "No row selection" }
      };
    }
    const results = [];
    if (lookup.extractValueRef) {
      const refResult = await interpretReference(lookup.extractValueRef, submissionId, prisma51, valuesCache, depth + 1, valueMap, labelMap);
      const targetValue = refResult.result;
      const columnIndices2 = columns.map((_, idx) => idx).filter((idx) => idx > 0);
      const rowMatchInRows2 = findClosestIndexInLabels(rowSelectorValue2, rows);
      const rowMatchInCols2 = findClosestIndexInLabels(rowSelectorValue2, columns, columnIndices2);
      let finalRowIndex2 = rowMatchInRows2?.index ?? rowMatchInCols2?.index ?? -1;
      if (finalRowIndex2 === -1) {
        console.warn(`[TABLE] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F MODE 2 extract - ligne non trouv\xC3\u0192\xC2\xA9e pour selector ${rowSelectorValue2}`);
      } else {
        const dataRowIndex2 = finalRowIndex2;
        let foundColIndex = -1;
        for (let cIdx = 0; cIdx < columns.length; cIdx++) {
          const valueAt = data[dataRowIndex2]?.[cIdx - 1];
          if (compareValuesByOperator(lookup.extractOperator, valueAt, targetValue)) {
            foundColIndex = cIdx;
            break;
          }
        }
        if (foundColIndex !== -1) {
          for (const fixedColValue of displayRows) {
            const normalizedFixedCol = normalizeLookupValue(fixedColValue);
            const fixedColInCols = columns.findIndex((c) => normalizeLookupValue(c) === normalizedFixedCol);
            const fixedColInRows = rows.findIndex((r) => normalizeLookupValue(r) === normalizedFixedCol);
            let colIndex = -1;
            if (fixedColInCols !== -1) colIndex = fixedColInCols;
            else if (fixedColInRows !== -1) colIndex = fixedColInRows;
            if (colIndex !== -1) {
              const dataColIndex2 = colIndex - 1;
              const result2 = data[dataRowIndex2]?.[dataColIndex2];
              results.push({ column: fixedColValue, value: result2 });
            }
          }
          const resultText2 = results.map((r) => `${r.column}=${r.value}`).join(", ");
          const resultValues2 = results.map((r) => r.value);
          const humanText3 = `Table "${table.name}"[extract ${lookup.extractValueRef} ${lookup.extractOperator} -> col=${columns[foundColIndex]}] = ${resultText2}`;
          return {
            result: resultValues2.length === 1 ? String(resultValues2[0]) : JSON.stringify(resultValues2),
            humanText: humanText3,
            details: {
              type: "table",
              mode: 2,
              tableId: table.id,
              tableName: table.name,
              lookup: {
                row: { field: rowLabel2, value: rowSelectorValue2 },
                columns: results,
                multiple: results.length > 1,
                extract: { ref: lookup.extractValueRef, operator: lookup.extractOperator, target: targetValue }
              }
            }
          };
        }
      }
    }
    let targetRowIndex = -1;
    if ((rowSourceOption?.type === "field" || rowSourceOption?.type === "capacity") && rowSourceOption?.operator && rowSourceOption?.comparisonColumn) {
      const comparisonRowName = rowSourceOption.comparisonColumn;
      const normalizedComparisonRow = String(comparisonRowName).trim().toLowerCase();
      const rowSelectorInRows2 = rows.findIndex((r) => String(r).trim().toLowerCase() === normalizedComparisonRow);
      const rowSelectorInCols2 = columns.findIndex((c) => String(c).trim().toLowerCase() === normalizedComparisonRow);
      let rowSelectorIndex = -1;
      if (rowSelectorInRows2 !== -1) rowSelectorIndex = rowSelectorInRows2;
      else if (rowSelectorInCols2 !== -1) rowSelectorIndex = rowSelectorInCols2;
      if (rowSelectorIndex !== -1) {
        let foundColIndex = -1;
        for (let cIdx = 0; cIdx < columns.length; cIdx++) {
          const cellValue = rowSelectorIndex === 0 ? columns[cIdx] : data[rowSelectorIndex - 1]?.[cIdx - 1];
          if (compareValuesByOperator(rowSourceOption.operator, cellValue, rowSelectorValue2)) {
            foundColIndex = cIdx;
            break;
          }
        }
        if (foundColIndex !== -1) {
          const dataColIndexForFound = foundColIndex - 1;
          for (const fixedRowValue of displayRows) {
            const normalizedFixedRow = String(fixedRowValue).trim().toLowerCase();
            const fixedRowInRows = rows.findIndex((r) => String(r).trim().toLowerCase() === normalizedFixedRow);
            const fixedRowInCols = columns.findIndex((c) => String(c).trim().toLowerCase() === normalizedFixedRow);
            let rowIndexForDisplay = -1;
            if (fixedRowInRows !== -1) rowIndexForDisplay = fixedRowInRows;
            else if (fixedRowInCols !== -1) rowIndexForDisplay = fixedRowInCols;
            if (rowIndexForDisplay !== -1) {
              const result2 = rowIndexForDisplay === 0 ? columns[foundColIndex] : data[rowIndexForDisplay - 1]?.[dataColIndexForFound];
              results.push({ column: fixedRowValue, value: result2 });
            }
          }
          targetRowIndex = rowSelectorIndex;
        }
      } else {
        console.warn(`[TABLE] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F MODE 2 - Ligne de comparaison non trouv\xC3\u0192\xC2\xA9e: ${comparisonRowName}`);
      }
    }
    if (targetRowIndex === -1) {
      const hasRowOperatorConfig = Boolean(rowSourceOption?.operator && rowSourceOption?.comparisonColumn);
      const isRowNumericSource = (rowSourceOption?.type === "field" || rowSourceOption?.type === "capacity") && !hasRowOperatorConfig;
      if (isRowNumericSource) {
        const optionLabel = rowSourceOption?.type === "field" ? "Option 2" : "Option 3";
        const match = findClosestIndexInLabels(rowSelectorValue2, rows);
        if (match) {
          const foundRowIndex = match.index;
          for (const fixedColValue of displayRows) {
            const normalizedFixedCol = normalizeLookupValue(fixedColValue);
            const fixedColInCols = columns.findIndex((c) => normalizeLookupValue(c) === normalizedFixedCol);
            const fixedColInRows = rows.findIndex((r) => normalizeLookupValue(r) === normalizedFixedCol);
            let colIndexForDisplay = -1;
            if (fixedColInCols !== -1) colIndexForDisplay = fixedColInCols;
            else if (fixedColInRows !== -1) colIndexForDisplay = fixedColInRows;
            if (colIndexForDisplay !== -1) {
              const dataColIndexForDisplay = colIndexForDisplay - 1;
              const result2 = data[foundRowIndex]?.[dataColIndexForDisplay];
              results.push({ column: fixedColValue, value: result2 });
            }
          }
          const resultText2 = results.map((r) => `${r.column}=${r.value}`).join(", ");
          const resultValues2 = results.map((r) => r.value);
          const humanText3 = `Table "${table.name}"[${rowLabel2}=${rowSelectorValue2}, ${displayRows.join("+")}(fixes)] = ${resultText2}`;
          return {
            result: resultValues2.length === 1 ? String(resultValues2[0]) : JSON.stringify(resultValues2),
            humanText: humanText3,
            details: {
              type: "table",
              mode: 2,
              tableId: table.id,
              tableName: table.name,
              lookup: {
                row: { field: rowLabel2, value: rowSelectorValue2 },
                columns: results,
                multiple: results.length > 1
              }
            }
          };
        } else {
          console.warn(`[TABLE] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F MODE 2 ${optionLabel} - Impossible de trouver une ligne pour ${rowSelectorValue2}`);
        }
      }
      for (const fixedColValue of displayRows) {
        const normalizedRowSelector = normalizeLookupValue(rowSelectorValue2);
        const normalizedFixedCol = normalizeLookupValue(fixedColValue);
        const rowSelectorInRows2 = rows.findIndex((r) => normalizeLookupValue(r) === normalizedRowSelector);
        const rowSelectorInCols2 = columns.findIndex((c) => normalizeLookupValue(c) === normalizedRowSelector);
        const fixedColInCols = columns.findIndex((c) => normalizeLookupValue(c) === normalizedFixedCol);
        const fixedColInRows = rows.findIndex((r) => normalizeLookupValue(r) === normalizedFixedCol);
        let rowIndex = -1;
        let colIndex = -1;
        if (rowSelectorInRows2 !== -1 && fixedColInCols !== -1) {
          rowIndex = rowSelectorInRows2;
          colIndex = fixedColInCols;
        } else if (rowSelectorInCols2 !== -1 && fixedColInRows !== -1) {
          rowIndex = fixedColInRows;
          colIndex = rowSelectorInCols2;
        } else {
          rowIndex = rowSelectorInRows2 !== -1 ? rowSelectorInRows2 : rowSelectorInCols2;
          colIndex = fixedColInCols !== -1 ? fixedColInCols : fixedColInRows;
        }
        if (rowIndex !== -1 && colIndex !== -1) {
          const dataRowIndex2 = rowIndex;
          const dataColIndex2 = colIndex - 1;
          const result2 = data[dataRowIndex2]?.[dataColIndex2];
          results.push({ column: fixedColValue, value: result2 });
        }
      }
    }
    const resultText = results.map((r) => `${r.column}=${r.value}`).join(", ");
    const resultValues = results.map((r) => r.value);
    const humanText2 = `Table "${table.name}"[${rowLabel2}=${rowSelectorValue2}, ${displayRows.join("+")}(fixes)] = ${resultText}`;
    return {
      result: resultValues.length === 1 ? String(resultValues[0]) : JSON.stringify(resultValues),
      humanText: humanText2,
      details: {
        type: "table",
        mode: 2,
        tableId: table.id,
        tableName: table.name,
        lookup: {
          row: { field: rowLabel2, value: rowSelectorValue2 },
          columns: results,
          multiple: results.length > 1
        }
      }
    };
  } else {
    console.error(`[TABLE] \xC3\xA2\xC2\x9D\xC5\u2019 Configuration lookup invalide`);
    return {
      result: "\u2205",
      humanText: `Configuration lookup invalide pour table ${table.name}`,
      details: { type: "table", error: "Invalid configuration" }
    };
  }
  let rowSelectorValue = await getSourceValue(
    rowSourceOption,
    lookup,
    rowFieldId,
    submissionId,
    prisma51,
    valuesCache,
    depth,
    valueMap,
    labelMap
  );
  let colSelectorValue = await getSourceValue(
    colSourceOption,
    lookup,
    colFieldId,
    submissionId,
    prisma51,
    valuesCache,
    depth,
    valueMap,
    labelMap
  );
  const rowLabel = await getSourceLabel(rowSourceOption, lookup, rowFieldId, prisma51, labelMap);
  const colLabel = await getSourceLabel(colSourceOption, lookup, colFieldId, prisma51, labelMap);
  if (!rowSelectorValue || !colSelectorValue) {
    return {
      result: "\u2205",
      humanText: `Table "${table.name}"[${rowLabel}(${rowSelectorValue || "?"}), ${colLabel}(${colSelectorValue || "?"})] = aucune s\xC3\u0192\xC2\xA9lection`,
      details: { type: "table", error: "Missing selection" }
    };
  }
  const columnIndices = columns.map((_, idx) => idx).filter((idx) => idx > 0);
  const rowMatchInRows = findClosestIndexInLabels(rowSelectorValue, rows);
  const rowMatchInCols = findClosestIndexInLabels(rowSelectorValue, columns, columnIndices);
  let rowSelectorInRows = rowMatchInRows?.index ?? -1;
  let rowSelectorInCols = rowMatchInCols?.index ?? -1;
  if (rowMatchInRows?.matchedValue !== void 0) {
    rowSelectorValue = String(rowMatchInRows.matchedValue);
  } else if (rowMatchInCols?.matchedValue !== void 0) {
    rowSelectorValue = String(rowMatchInCols.matchedValue);
  }
  const colMatchInCols = findClosestIndexInLabels(colSelectorValue, columns, columnIndices);
  const colMatchInRows = findClosestIndexInLabels(colSelectorValue, rows);
  let colSelectorInRows = colMatchInRows?.index ?? -1;
  let colSelectorInCols = colMatchInCols?.index ?? -1;
  if (colMatchInCols?.matchedValue !== void 0) {
    colSelectorValue = String(colMatchInCols.matchedValue);
  } else if (colMatchInRows?.matchedValue !== void 0) {
    colSelectorValue = String(colMatchInRows.matchedValue);
  }
  let finalRowIndex = -1;
  let finalColIndex = -1;
  let actualRowValue = "";
  let actualColValue = "";
  if (rowSelectorInRows !== -1 && colSelectorInCols !== -1) {
    finalRowIndex = rowSelectorInRows;
    finalColIndex = colSelectorInCols;
    actualRowValue = String(rowSelectorValue);
    actualColValue = String(colSelectorValue);
  } else if (rowSelectorInCols !== -1 && colSelectorInRows !== -1) {
    finalRowIndex = colSelectorInRows;
    finalColIndex = rowSelectorInCols;
    actualRowValue = String(colSelectorValue);
    actualColValue = String(rowSelectorValue);
  } else {
    finalRowIndex = rowSelectorInRows !== -1 ? rowSelectorInRows : colSelectorInRows;
    finalColIndex = rowSelectorInCols !== -1 ? rowSelectorInCols : colSelectorInCols;
    actualRowValue = String(rowSelectorValue);
    actualColValue = String(colSelectorValue);
  }
  if (finalRowIndex === -1 || finalColIndex === -1) {
    return {
      result: "\u2205",
      humanText: `Table "${table.name}"[${actualRowValue}, ${actualColValue}] = valeur introuvable`,
      details: { type: "table", error: "Value not found in rows/columns" }
    };
  }
  const dataRowIndex = finalRowIndex;
  const dataColIndex = finalColIndex - 1;
  if (dataRowIndex < 0 || dataColIndex < 0 || !data[dataRowIndex]) {
    console.error(`[TABLE] \xC3\xA2\xC2\x9D\xC5\u2019 Index hors limites`);
    return {
      result: "\u2205",
      humanText: `Table "${table.name}"[${actualRowValue}, ${actualColValue}] = hors limites`,
      details: { type: "table", error: "Index out of bounds" }
    };
  }
  const result = data[dataRowIndex][dataColIndex];
  const humanText = `Table "${table.name}"[${rowLabel}=${actualRowValue}, ${colLabel}=${actualColValue}] = ${result}`;
  return {
    result: String(result),
    humanText,
    details: {
      type: "table",
      tableId: table.id,
      tableName: table.name,
      lookup: {
        row: {
          field: rowLabel,
          fieldId: rowFieldId,
          value: actualRowValue,
          index: finalRowIndex
        },
        column: {
          field: colLabel,
          fieldId: colFieldId,
          value: actualColValue,
          index: finalColIndex
        },
        result
      }
    }
  };
}
async function interpretField(fieldId, submissionId, prisma51, valueMap, labelMap) {
  const node = await prisma51.treeBranchLeafNode.findUnique({
    where: { id: fieldId },
    select: { type: true, label: true }
  });
  if (node && node.type) {
    if (node.type.startsWith("leaf_table_")) {
      return await interpretTable(fieldId, submissionId, prisma51, /* @__PURE__ */ new Map(), 0, valueMap, labelMap);
    }
    if (node.type.includes("table")) {
      return await interpretTable(fieldId, submissionId, prisma51, /* @__PURE__ */ new Map(), 0, valueMap, labelMap);
    }
  }
  const value = await getNodeValue(fieldId, submissionId, prisma51, valueMap);
  const label = await getNodeLabel(fieldId, prisma51, labelMap);
  const humanText = `${label}(${value})`;
  return {
    result: value || "0",
    humanText,
    details: {
      type: "field",
      fieldId,
      label,
      value
    }
  };
}
async function evaluateVariableOperation(variableNodeId, submissionId, prisma51, valueMap) {
  const variableNode = await prisma51.treeBranchLeafNode.findUnique({
    where: { id: variableNodeId },
    select: { treeId: true }
  });
  const treeId = variableNode?.treeId;
  const localValueMap = valueMap || /* @__PURE__ */ new Map();
  const labelMap = /* @__PURE__ */ new Map();
  console.log(`\u{1F50D} [evaluateVariableOperation] AVANT enrichissement pour ${variableNodeId}:`);
  console.log(`   - valueMap.size = ${localValueMap.size}`);
  if (localValueMap.has("d6212e5e-3fe9-4cce-b380-e6745524d011")) {
    console.log(`   - Facture annuelle = ${localValueMap.get("d6212e5e-3fe9-4cce-b380-e6745524d011")}`);
  }
  await enrichDataFromSubmission(submissionId, prisma51, localValueMap, labelMap, treeId);
  console.log(`\u{1F50D} [evaluateVariableOperation] APR\xC8S enrichissement pour ${variableNodeId}:`);
  console.log(`   - valueMap.size = ${localValueMap.size}`);
  if (localValueMap.has("d6212e5e-3fe9-4cce-b380-e6745524d011")) {
    console.log(`   - Facture annuelle = ${localValueMap.get("d6212e5e-3fe9-4cce-b380-e6745524d011")}`);
  }
  const variable = await prisma51.treeBranchLeafNodeVariable.findUnique({
    where: { nodeId: variableNodeId },
    select: {
      id: true,
      nodeId: true,
      exposedKey: true,
      displayName: true,
      sourceType: true,
      sourceRef: true,
      fixedValue: true,
      defaultValue: true
    }
  });
  if (!variable) {
    console.error(`\u274C [VARIABLE MANQUANTE] nodeId: ${variableNodeId}`);
    throw new Error(`Variable introuvable: ${variableNodeId}`);
  }
  console.log(`\u2705 [VARIABLE TROUV\xC9E] ${variableNodeId} \u2192 sourceRef: ${variable.sourceRef}`);
  if (variable.sourceType === "fixed" && variable.fixedValue) {
    return {
      value: variable.fixedValue,
      operationDetail: { type: "fixed", value: variable.fixedValue },
      operationResult: `Valeur fixe: ${variable.fixedValue}`,
      operationSource: "fixed",
      sourceRef: variable.sourceRef || ""
    };
  }
  if (variable.sourceType === "tree" && variable.sourceRef) {
    const valuesCache = /* @__PURE__ */ new Map();
    const result = await interpretReference(
      variable.sourceRef,
      submissionId,
      prisma51,
      valuesCache,
      0,
      // Profondeur initiale = 0
      localValueMap,
      labelMap
    );
    let operationSource = "field";
    if (variable.sourceRef.includes("condition:")) operationSource = "condition";
    else if (variable.sourceRef.includes("node-formula:")) operationSource = "formula";
    else if (variable.sourceRef.includes("@table.")) operationSource = "table";
    return {
      value: result.result,
      operationDetail: result.details,
      operationResult: result.humanText,
      operationSource,
      sourceRef: variable.sourceRef
    };
  }
  if (variable.sourceType === "formula" && variable.sourceRef) {
    const valuesCache = /* @__PURE__ */ new Map();
    const result = await interpretReference(
      variable.sourceRef,
      submissionId,
      prisma51,
      valuesCache,
      0,
      // Profondeur initiale = 0
      localValueMap,
      labelMap
    );
    return {
      value: result.result,
      operationDetail: result.details,
      operationResult: result.humanText,
      operationSource: "formula",
      sourceRef: variable.sourceRef
    };
  }
  return {
    value: variable.defaultValue || "\u2205",
    operationDetail: { type: "default", value: variable.defaultValue },
    operationResult: `Valeur par d\xC3\u0192\xC2\xA9faut: ${variable.defaultValue || "aucune"}`,
    operationSource: "field",
    sourceRef: variable.sourceRef || ""
  };
}
var normalizeLookupValue, parseNumericLookupValue, RE_NODE_FORMULA, RE_LEGACY_FORMULA, UUID_REGEX;
var init_operation_interpreter = __esm({
  "src/components/TreeBranchLeaf/treebranchleaf-new/api/operation-interpreter.ts"() {
    init_formulaEngine();
    normalizeLookupValue = (value) => {
      const raw = String(value ?? "").trim().toLowerCase();
      if (!raw) return "";
      const withoutDiacritics = raw.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      const lettersNumbersOnly = withoutDiacritics.replace(/[^a-z0-9]+/g, " ");
      return lettersNumbersOnly.replace(/\s+/g, " ").trim();
    };
    parseNumericLookupValue = (value) => {
      if (typeof value === "number") return value;
      const raw = String(value ?? "").trim();
      if (!raw) return NaN;
      const sanitized2 = raw.replace(/,/g, ".").replace(/[^0-9+\-\.]/g, "");
      if (!sanitized2) return NaN;
      return Number(sanitized2);
    };
    RE_NODE_FORMULA = /node-formula:[a-z0-9-]+/i;
    RE_LEGACY_FORMULA = /formula:[a-z0-9-]+/i;
    UUID_REGEX = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i;
  }
});

// src/api-server-clean.ts
var api_server_clean_exports = {};
__export(api_server_clean_exports, {
  app: () => app
});
module.exports = __toCommonJS(api_server_clean_exports);
var import_dotenv = __toESM(require("dotenv"), 1);
var import_express97 = __toESM(require("express"), 1);
var import_path8 = __toESM(require("path"), 1);
var import_fs8 = __toESM(require("fs"), 1);
var import_cors = __toESM(require("cors"), 1);
var import_express_session = __toESM(require("express-session"), 1);
var import_cookie_parser = __toESM(require("cookie-parser"), 1);
var import_passport = __toESM(require("passport"), 1);
var import_helmet = __toESM(require("helmet"), 1);
var import_compression = __toESM(require("compression"), 1);
var import_express_winston = __toESM(require("express-winston"), 1);

// src/routes/index.ts
var import_express74 = require("express");

// src/routes/authRoutes.ts
var import_express = require("express");

// src/controllers/authController.ts
init_prisma();
var import_bcryptjs = __toESM(require("bcryptjs"), 1);
var import_jsonwebtoken = __toESM(require("jsonwebtoken"), 1);
var import_fs = __toESM(require("fs"), 1);
var getJWTSecret = () => {
  let secret = process.env.JWT_SECRET;
  if (secret && secret.trim()) {
    console.log("[AUTH] \u2705 JWT_SECRET trouv\xE9 dans process.env");
    return secret;
  }
  const cloudRunSecretPath = "/run/secrets/JWT_SECRET";
  if (import_fs.default.existsSync(cloudRunSecretPath)) {
    try {
      secret = import_fs.default.readFileSync(cloudRunSecretPath, "utf-8").trim();
      if (secret) {
        console.log("[AUTH] \u2705 JWT_SECRET trouv\xE9 dans /run/secrets/JWT_SECRET");
        return secret;
      }
    } catch (err) {
      console.error("[AUTH] \u274C Erreur \xE0 la lecture de /run/secrets/JWT_SECRET:", err);
    }
  }
  console.warn("[AUTH] \u26A0\uFE0F JWT_SECRET non disponible, utilisation de la cl\xE9 de d\xE9veloppement");
  return "development-secret-key";
};
var login = async (req2, res) => {
  try {
    const { email, password } = req2.body;
    console.log("[AUTH] \u{1F510} Tentative de connexion", {
      email,
      hasPassword: typeof password === "string" && password.length > 0,
      contentType: req2.headers["content-type"]
    });
    if (!email || !password) {
      console.log(`[AUTH] \u274C Email ou password manquant`);
      return res.status(400).json({ message: "Email et mot de passe requis" });
    }
    const user = await db.user.findUnique({
      where: { email },
      include: {
        UserOrganization: {
          include: {
            Organization: true,
            Role: {
              include: {
                Permission: true
              }
            }
          }
        }
      }
    });
    if (!user || !user.passwordHash) {
      console.log(`[AUTH] \u274C Utilisateur non trouv\xE9 ou pas de passwordHash pour: ${email}`);
      return res.status(401).json({ message: "Identifiants invalides" });
    }
    console.log(`[AUTH] \u{1F464} Utilisateur trouv\xE9: ${user.firstName} ${user.lastName}`);
    const isPasswordValid = await import_bcryptjs.default.compare(password, user.passwordHash);
    console.log(`[AUTH] \u{1F511} Comparaison mot de passe: ${isPasswordValid ? "\u2705 VALIDE" : "\u274C INVALIDE"}`);
    if (!isPasswordValid) {
      console.log(`[AUTH] \u274C Mot de passe incorrect pour: ${email}`);
      return res.status(401).json({ message: "Identifiants invalides" });
    }
    const { passwordHash: _passwordHash, ...userWithoutPassword } = user;
    const userRoles = user.UserOrganization.map((uo) => uo.Role);
    const allPermissions = userRoles.flatMap((role) => role.Permission || []);
    const isSuperAdmin2 = user.role === "super_admin" || userRoles.some((role) => role.name === "super_admin");
    const response = {
      currentUser: {
        ...userWithoutPassword,
        role: isSuperAdmin2 ? "super_admin" : userRoles[0]?.name || user.role || "user",
        permissions: allPermissions,
        isSuperAdmin: isSuperAdmin2,
        organizations: user.UserOrganization.map((uo) => ({
          id: uo.Organization.id,
          name: uo.Organization.name,
          status: uo.status
        }))
      },
      originalUser: null
    };
    const primaryOrganization = user.UserOrganization.find((uo) => uo.status === "active") || user.UserOrganization[0];
    const organizationId = primaryOrganization?.organizationId;
    const token = import_jsonwebtoken.default.sign(
      {
        userId: user.id,
        email: user.email,
        organizationId,
        isSuperAdmin: isSuperAdmin2,
        role: isSuperAdmin2 ? "super_admin" : userRoles[0]?.name || user.role || "user"
      },
      getJWTSecret(),
      { expiresIn: "24h" }
    );
    const isProduction4 = process.env.NODE_ENV === "production";
    const isCodespaces2 = process.env.CODESPACES === "true";
    const needsSecureCookie = isProduction4 || isCodespaces2;
    console.log(`[AUTH] \u{1F36A} Cookie config: isProduction=${isProduction4}, isCodespaces=${isCodespaces2}, needsSecure=${needsSecureCookie}`);
    res.cookie("token", token, {
      httpOnly: true,
      secure: needsSecureCookie,
      sameSite: needsSecureCookie ? "none" : "lax",
      maxAge: 24 * 60 * 60 * 1e3,
      // 24 heures
      path: "/"
    });
    console.log(`[AUTH] \u2705 Connexion r\xE9ussie pour ${email} (cookie secure=${needsSecureCookie}, sameSite=${needsSecureCookie ? "none" : "lax"})`);
    res.status(200).json(response);
  } catch (error) {
    console.error("[AUTH] Erreur lors de la connexion:", error);
    res.status(500).json({ message: "Erreur interne du serveur" });
  }
};
var getMe = async (req2, res) => {
  try {
    const token = req2.cookies.token;
    if (!token) {
      return res.status(401).json({ message: "Non authentifi\xE9" });
    }
    const decoded = import_jsonwebtoken.default.verify(token, getJWTSecret());
    const user = await db.user.findUnique({
      where: { id: decoded.userId },
      include: {
        UserOrganization: {
          include: {
            Organization: true,
            Role: {
              include: {
                Permission: true
              }
            }
          }
        }
      }
    });
    if (!user) {
      res.clearCookie("token");
      return res.status(401).json({ message: "Utilisateur introuvable" });
    }
    const { passwordHash: _passwordHash2, ...userWithoutPassword } = user;
    const organizations = user.UserOrganization.map((uo) => ({
      id: uo.Organization.id,
      name: uo.Organization.name,
      status: uo.status,
      role: uo.Role.name,
      roleLabel: uo.Role.label,
      permissions: uo.Role.Permission || []
    }));
    const currentOrganization = organizations.find((org) => org.status === "ACTIVE") || organizations[0] || null;
    const userRoles = user.UserOrganization.map((uo) => uo.Role);
    const allPermissions = userRoles.flatMap((role) => role.Permission || []);
    const isSuperAdmin2 = user.role === "super_admin" || userRoles.some((role) => role.name === "super_admin");
    const response = {
      currentUser: {
        ...userWithoutPassword,
        role: isSuperAdmin2 ? "super_admin" : userRoles[0]?.name || user.role || "user",
        permissions: allPermissions,
        isSuperAdmin: isSuperAdmin2,
        organizations,
        // Ajouter les organisations format√©es
        currentOrganization
        // Ajouter l'organisation actuelle
      },
      originalUser: null
      // Pour l'usurpation d'identit√©, null par d√©faut
    };
    res.status(200).json(response);
  } catch (error) {
    console.error("[AUTH] Erreur lors de la v\xE9rification du token:", error);
    res.clearCookie("token");
    res.status(401).json({ message: "Token invalide ou expir\xE9" });
  }
};
var logout = (_req, res) => {
  try {
    res.clearCookie("token");
    console.log("[AUTH] D\xE9connexion r\xE9ussie");
    res.status(200).json({ message: "D\xE9connexion r\xE9ussie" });
  } catch (error) {
    console.error("[AUTH] Erreur lors de la d\xE9connexion:", error);
    res.status(500).json({ message: "Erreur lors de la d\xE9connexion" });
  }
};

// src/routes/authRoutes.ts
var authRouter = (0, import_express.Router)();
console.log("[AUTH ROUTES] Chargement des routes d'authentification");
authRouter.post("/login", login);
authRouter.get("/me", getMe);
authRouter.post("/logout", logout);
console.log("[AUTH ROUTES] Routes d'authentification configur\xE9es: /login, /me, /logout");
var authRoutes_default = authRouter;

// src/routes/gmailRoutes.ts
var import_express2 = __toESM(require("express"), 1);

// src/middleware/auth.ts
var import_jsonwebtoken2 = __toESM(require("jsonwebtoken"), 1);

// src/prisma.ts
init_database();
var prisma_default = db;

// src/config.prod.ts
var JWT_SECRET = process.env.JWT_SECRET || "prod_secret_key_change_me";
var API_URL = process.env.API_URL || "https://api.crmpro.com";

// src/config.ts
var import_fs2 = __toESM(require("fs"), 1);
var isProduction = process.env.NODE_ENV === "production";
var getJWTSecretFromConfig = () => {
  let secret = process.env.JWT_SECRET;
  if (secret && secret.trim()) {
    console.log("[CONFIG] \u2705 JWT_SECRET trouv\xE9 dans process.env");
    return secret;
  }
  const cloudRunSecretPath = "/run/secrets/JWT_SECRET";
  if (import_fs2.default.existsSync(cloudRunSecretPath)) {
    try {
      secret = import_fs2.default.readFileSync(cloudRunSecretPath, "utf-8").trim();
      if (secret) {
        console.log("[CONFIG] \u2705 JWT_SECRET trouv\xE9 dans /run/secrets/JWT_SECRET");
        return secret;
      }
    } catch (err) {
      console.error("[CONFIG] \u274C Erreur \xE0 la lecture de /run/secrets/JWT_SECRET:", err);
    }
  }
  const fallbackSecret = isProduction ? "prod_secret_key" : "dev_secret_key";
  if (isProduction) {
    console.warn("[CONFIG] \u26A0\uFE0F JWT_SECRET non disponible en production, utilisateur une cl\xE9 par d\xE9faut");
  }
  return fallbackSecret;
};
var JWT_SECRET2 = getJWTSecretFromConfig();
var API_URL2 = process.env.API_URL || (isProduction ? "https://api.crmpro.com" : "");
if (isProduction) {
  console.log("Application en mode PRODUCTION");
} else {
  console.log("Application en mode D\xC9VELOPPEMENT");
}

// src/middleware/auth.ts
var JWT_SECRET3 = JWT_SECRET2;
console.log("[AUTH] \u{1F510} JWT_SECRET prefix:", typeof JWT_SECRET3 === "string" ? JWT_SECRET3.substring(0, 6) + "..." : "invalid");
var authenticateToken = (req2, res, next) => {
  console.log("[AUTH] \u{1F50D} authenticateToken - D\xE9but");
  console.log("[AUTH] \u{1F4CB} URL:", req2.originalUrl);
  console.log("[AUTH] \u{1F4CB} Method:", req2.method);
  console.log("[AUTH] \u{1F510} Using JWT_SECRET prefix:", typeof JWT_SECRET3 === "string" ? JWT_SECRET3.substring(0, 6) + "..." : "invalid");
  if (req2.headers["x-test-bypass-auth"] === "1") {
    req2.user = req2.user || {
      id: "test-user",
      email: "test@example.com",
      organizationId: "org-test",
      isSuperAdmin: true,
      role: "super_admin"
    };
    console.log("[AUTH] \u{1F6A9} Bypass auth activ\xE9 (x-test-bypass-auth)");
    return next();
  }
  const authHeader = req2.headers["authorization"];
  let token = authHeader && authHeader.split(" ")[1];
  console.log("[AUTH] \u{1F4CB} Auth header pr\xE9sent:", !!authHeader);
  if (!token && req2.cookies && req2.cookies.token) {
    token = req2.cookies.token;
    console.log("[AUTH] \u{1F36A} Token trouv\xE9 dans les cookies");
  }
  if (!token) {
    console.log("[AUTH] \u274C Aucun token trouv\xE9");
    return res.status(401).json({ error: "Token d'acc\xE8s requis" });
  }
  console.log("[AUTH] \u{1F511} Token pr\xE9sent, v\xE9rification...");
  try {
    const decoded = import_jsonwebtoken2.default.verify(token, JWT_SECRET3);
    console.log("[AUTH] \u2705 Token valide, utilisateur:", decoded.userId);
    console.log("[AUTH] \u{1F4CB} Email:", decoded.email);
    console.log("[AUTH] \u{1F4CB} OrganizationId:", decoded.organizationId);
    console.log("[AUTH] \u{1F4CB} SuperAdmin:", decoded.isSuperAdmin);
    if (!decoded.role && decoded.isSuperAdmin) {
      decoded.role = "super_admin";
      console.log("[AUTH] \u{1F451} R\xF4le super_admin assign\xE9 automatiquement");
    }
    req2.user = { ...decoded, id: decoded.userId };
    console.log("[AUTH] \u2705 req.user assign\xE9:", { id: req2.user.id, userId: req2.user.userId, email: req2.user.email });
    console.log("[AUTH] \u2705 authenticateToken termin\xE9 avec succ\xE8s");
    next();
  } catch (error) {
    console.log("[AUTH] \u274C Token invalide ou expir\xE9:", error.message);
    console.log("[AUTH] \u274C Erreur d\xE9taill\xE9e:", error);
    return res.status(401).json({ error: "Token invalide ou expir\xE9" });
  }
};
var fetchFullUser = async (req2, res, next) => {
  console.log("<<<<< [MIDDLEWARE] fetchFullUser: Ex\xE9cution. >>>>>");
  if (!req2.user || !req2.user.userId) {
    console.log("<<<<< [MIDDLEWARE] fetchFullUser: req.user ou req.user.userId manquant. Le middleware authenticateToken doit \xEAtre ex\xE9cut\xE9 avant. >>>>>");
    return res.status(401).json({ message: "Utilisateur non authentifi\xE9." });
  }
  try {
    const userFromDb = await prisma_default.user.findUnique({
      where: { id: req2.user.userId }
    });
    if (!userFromDb) {
      console.log(`<<<<< [MIDDLEWARE] fetchFullUser: Utilisateur avec ID ${req2.user.userId} non trouv\xE9 dans la DB. >>>>>`);
      return res.status(401).json({ message: "Utilisateur non valide." });
    }
    req2.user = { ...userFromDb, ...req2.user };
    console.log("<<<<< [MIDDLEWARE] fetchFullUser: req.user enrichi avec succ\xE8s. >>>>>");
    next();
  } catch (error) {
    console.error("<<<<< [MIDDLEWARE] fetchFullUser: Erreur lors de la r\xE9cup\xE9ration de l'utilisateur.", error);
    res.status(500).json({ message: "Erreur interne du serveur." });
  }
};
var extractOrganization = (req2, res, next) => {
  const orgHeader = req2.headers["x-organization-id"];
  if (orgHeader && req2.user) {
    req2.user.organizationId = orgHeader;
  }
  next();
};

// src/google-auth/core/GoogleOAuthCore.ts
var import_googleapis = require("googleapis");
var import_crypto = require("crypto");
init_database();
init_crypto();

// src/auth/googleConfig.ts
var import_meta = {};
var envCache = /* @__PURE__ */ new Map();
var DEFAULT_PROD_API_BASE = "https://app.2thier.be";
var DEFAULT_DEV_API_BASE = "http://localhost:4000";
function readEnvFromImportMeta(key2) {
  try {
    const meta = import_meta;
    const candidate = meta?.env?.[key2];
    if (typeof candidate === "string" && candidate.trim()) {
      return candidate.trim();
    }
  } catch {
  }
  return void 0;
}
function readEnv(key2) {
  if (envCache.has(key2)) {
    return envCache.get(key2);
  }
  let value;
  if (typeof process !== "undefined" && process.env && typeof process.env[key2] === "string") {
    value = process.env[key2]?.trim();
  }
  if (!value) {
    value = readEnvFromImportMeta(key2);
  }
  if (value) {
    envCache.set(key2, value);
  } else {
    envCache.set(key2, void 0);
  }
  return value;
}
function computeRedirectUri() {
  const codespaceName = readEnv("CODESPACE_NAME");
  if (codespaceName) {
    const codespaceUrl = `https://${codespaceName}-4000.app.github.dev`;
    console.log("[GoogleConfig] \u{1F680} Codespaces d\xE9tect\xE9, redirect_uri:", `${codespaceUrl}/api/google-auth/callback`);
    return `${codespaceUrl}/api/google-auth/callback`;
  }
  const explicit = readEnv("GOOGLE_REDIRECT_URI");
  if (explicit) {
    console.log("[GoogleConfig] \u{1F4CC} GOOGLE_REDIRECT_URI explicite:", explicit);
    return explicit;
  }
  const base = readEnv("API_URL") || readEnv("BACKEND_URL") || readEnv("FRONTEND_URL");
  const fallbackBase = (readEnv("NODE_ENV") || "").toLowerCase() === "production" ? DEFAULT_PROD_API_BASE : DEFAULT_DEV_API_BASE;
  const trimmedBase = (base || fallbackBase).replace(/\/$/, "");
  console.log("[GoogleConfig] \u{1F527} Redirect URI d\xE9duit:", `${trimmedBase}/api/google-auth/callback`);
  return `${trimmedBase}/api/google-auth/callback`;
}
var GOOGLE_OAUTH_SCOPES = [
  "https://www.googleapis.com/auth/userinfo.email",
  "https://www.googleapis.com/auth/userinfo.profile",
  "https://mail.google.com/",
  "https://www.googleapis.com/auth/gmail.readonly",
  "https://www.googleapis.com/auth/gmail.send",
  "https://www.googleapis.com/auth/gmail.modify",
  "https://www.googleapis.com/auth/gmail.labels",
  "https://www.googleapis.com/auth/calendar",
  "https://www.googleapis.com/auth/calendar.events",
  "https://www.googleapis.com/auth/drive",
  "https://www.googleapis.com/auth/documents",
  "https://www.googleapis.com/auth/spreadsheets",
  "https://www.googleapis.com/auth/presentations",
  "https://www.googleapis.com/auth/meetings",
  "https://www.googleapis.com/auth/contacts",
  "https://www.googleapis.com/auth/forms",
  "https://www.googleapis.com/auth/script.projects",
  "https://www.googleapis.com/auth/admin.directory.user",
  "https://www.googleapis.com/auth/admin.directory.group",
  "https://www.googleapis.com/auth/admin.directory.orgunit",
  "https://www.googleapis.com/auth/admin.directory.resource.calendar"
];
function buildOAuthOptions(clientId, clientSecret, redirectUri) {
  return {
    clientId: clientId || void 0,
    clientSecret: clientSecret || void 0,
    redirectUri
  };
}
var googleOAuthConfig = (() => {
  const clientId = readEnv("GOOGLE_CLIENT_ID") ?? "";
  const clientSecret = readEnv("GOOGLE_CLIENT_SECRET") ?? "";
  const redirectUri = computeRedirectUri();
  const projectId = readEnv("GOOGLE_PROJECT_ID") || readEnv("GOOGLE_CLOUD_PROJECT") || readEnv("GOOGLE_CLOUD_PROJECT_ID") || readEnv("GOOGLE_PROJECT_NUMBER");
  return {
    clientId,
    clientSecret,
    redirectUri,
    projectId,
    oauthOptions: buildOAuthOptions(clientId, clientSecret, redirectUri)
  };
})();
function isGoogleOAuthConfigured() {
  return Boolean(googleOAuthConfig.clientId && googleOAuthConfig.clientSecret);
}
function describeGoogleOAuthConfig() {
  return {
    clientId: googleOAuthConfig.clientId ? "[set]" : "[missing]",
    clientSecret: googleOAuthConfig.clientSecret ? "[set]" : "[missing]",
    redirectUri: googleOAuthConfig.redirectUri,
    projectId: googleOAuthConfig.projectId,
    scopes: GOOGLE_OAUTH_SCOPES.length,
    isConfigured: isGoogleOAuthConfigured()
  };
}

// src/google-auth/core/GoogleOAuthCore.ts
var { clientId: GOOGLE_CLIENT_ID, clientSecret: GOOGLE_CLIENT_SECRET, redirectUri: GOOGLE_REDIRECT_URI } = googleOAuthConfig;
var GOOGLE_SCOPES_LIST = [...GOOGLE_OAUTH_SCOPES];
var SCOPES = GOOGLE_SCOPES_LIST;
var GoogleOAuthService = class {
  oauth2Client;
  constructor() {
    if (!isGoogleOAuthConfigured()) {
      console.warn("[GoogleOAuthService] \u26A0\uFE0F Configuration Google OAuth incompl\xE8te", describeGoogleOAuthConfig());
    }
    this.oauth2Client = new import_googleapis.google.auth.OAuth2(
      GOOGLE_CLIENT_ID,
      GOOGLE_CLIENT_SECRET,
      GOOGLE_REDIRECT_URI
    );
  }
  formatOAuthError(error) {
    const asAny = error;
    const responseData = asAny?.response?.data;
    return {
      message: asAny instanceof Error ? asAny.message : String(error),
      code: asAny?.code,
      status: asAny?.response?.status ?? asAny?.status,
      error: responseData?.error,
      error_description: responseData?.error_description
    };
  }
  // G√©n√©rer l'URL d'autorisation Google
  getAuthUrl(userId, organizationId, hostHeaderOrForceConsent = false, maybeForceConsent) {
    const forceConsent = typeof hostHeaderOrForceConsent === "boolean" ? hostHeaderOrForceConsent : maybeForceConsent ?? false;
    const state = JSON.stringify({ userId, organizationId });
    const authUrl = this.oauth2Client.generateAuthUrl({
      access_type: "offline",
      // ‚úÖ ESSENTIEL : Obtenir un refresh token
      scope: SCOPES,
      state,
      // Si forceConsent ou premi√®re connexion : demander le consentement pour obtenir refresh_token
      // Sinon : juste s√©lectionner le compte (plus fluide)
      prompt: forceConsent ? "consent" : "select_account",
      include_granted_scopes: true,
      // ‚úÖ Active l'autorisation incr√©mentielle
      enable_granular_consent: true
      // ‚úÖ Protection multicompte
    });
    console.log("[GoogleOAuthService] \u{1F517} URL d'autorisation g\xE9n\xE9r\xE9e:", authUrl);
    console.log("[GoogleOAuthService] \u{1F3AF} Redirect URI configur\xE9:", GOOGLE_REDIRECT_URI);
    console.log("[GoogleOAuthService] \u{1F504} Force consent:", forceConsent);
    return authUrl;
  }
  // √âchanger le code contre des tokens
  async getTokenFromCode(code) {
    const { tokens: tokens2 } = await this.oauth2Client.getToken(code);
    return tokens2;
  }
  // Sauvegarder les tokens
  async saveUserTokens(userId, organizationId, tokens2, googleEmail) {
    if (!organizationId) {
      throw new Error("L'ID de l'organisation est requis pour sauvegarder les tokens Google.");
    }
    if (!userId) {
      throw new Error("L'ID de l'utilisateur est requis pour sauvegarder les tokens Google.");
    }
    const updateData = {
      accessToken: tokens2.access_token,
      // IMPORTANT : Toujours mettre √† jour le refresh_token s'il est fourni.
      // Google peut en envoyer un nouveau lors du 'consent'.
      refreshToken: tokens2.refresh_token,
      tokenType: tokens2.token_type || "Bearer",
      expiresAt: tokens2.expiry_date ? new Date(tokens2.expiry_date) : null,
      scope: tokens2.scope,
      updatedAt: /* @__PURE__ */ new Date()
    };
    const existingToken = await db.googleToken.findUnique({
      where: {
        userId_organizationId: { userId, organizationId }
      }
    });
    if (existingToken) {
      await db.googleToken.update({
        where: {
          userId_organizationId: { userId, organizationId }
        },
        data: {
          accessToken: updateData.accessToken,
          // Ne met √† jour le refresh token que s'il est nouveau, sinon conserve l'ancien
          refreshToken: updateData.refreshToken ?? existingToken.refreshToken,
          expiresAt: updateData.expiresAt,
          scope: updateData.scope,
          updatedAt: updateData.updatedAt,
          lastRefreshAt: /* @__PURE__ */ new Date(),
          refreshCount: { increment: 1 },
          googleEmail: googleEmail ?? existingToken.googleEmail
        }
      });
    } else {
      await db.googleToken.create({
        data: {
          id: (0, import_crypto.randomUUID)(),
          userId,
          organizationId,
          accessToken: updateData.accessToken,
          refreshToken: updateData.refreshToken,
          tokenType: updateData.tokenType,
          expiresAt: updateData.expiresAt,
          scope: updateData.scope,
          googleEmail,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    }
    console.log(`[GoogleOAuthService] Tokens sauvegard\xE9s/mis \xE0 jour pour l'utilisateur ${userId} (org: ${organizationId}, email: ${googleEmail})`);
  }
  // R√©cup√©rer les tokens par userId et organizationId
  async getUserTokens(userId, organizationId) {
    if (organizationId) {
      return await db.googleToken.findUnique({
        where: {
          userId_organizationId: { userId, organizationId }
        }
      });
    }
    const userWithOrg = await db.user.findUnique({
      where: { id: userId },
      include: {
        UserOrganization: {
          take: 1,
          orderBy: { createdAt: "desc" }
        }
      }
    });
    if (!userWithOrg || !userWithOrg.UserOrganization[0]) {
      console.log(`[GoogleOAuthService] Utilisateur ${userId} ou organisation non trouv\xE9`);
      return null;
    }
    const defaultOrgId = userWithOrg.UserOrganization[0].organizationId;
    return await db.googleToken.findUnique({
      where: {
        userId_organizationId: { userId, organizationId: defaultOrgId }
      }
    });
  }
  // Client authentifi√© avec email administrateur Google Workspace
  // Maintenant, chaque utilisateur a son propre token
  async getAuthenticatedClientForOrganization(organizationId, userId) {
    const organization = await db.organization.findUnique({
      where: { id: organizationId },
      include: {
        GoogleWorkspaceConfig: true
      }
    });
    if (!organization) {
      return null;
    }
    const googleConfig = organization.GoogleWorkspaceConfig;
    if (!googleConfig || !googleConfig.adminEmail || !googleConfig.domain) {
      return null;
    }
    const clientId = googleConfig.clientId ? decrypt(googleConfig.clientId) : null;
    const clientSecret = googleConfig.clientSecret ? decrypt(googleConfig.clientSecret) : null;
    if (!clientId || !clientSecret) {
      console.warn("[GoogleOAuthService] \u274C clientId/clientSecret manquants pour org", organizationId);
      return null;
    }
    let tokens2;
    if (userId) {
      tokens2 = await db.googleToken.findUnique({
        where: {
          userId_organizationId: { userId, organizationId: organization.id }
        }
      });
    } else {
      tokens2 = await db.googleToken.findFirst({
        where: { organizationId: organization.id }
      });
    }
    if (!tokens2) {
      return null;
    }
    const credentials = {
      access_token: tokens2.accessToken,
      refresh_token: tokens2.refreshToken,
      token_type: tokens2.tokenType,
      expiry_date: tokens2.expiresAt?.getTime()
    };
    const adminOAuth2Client = new import_googleapis.google.auth.OAuth2(clientId, clientSecret);
    adminOAuth2Client.setCredentials(credentials);
    const now = /* @__PURE__ */ new Date();
    const expiryDate = tokens2.expiresAt;
    if (expiryDate && expiryDate <= now) {
      try {
        const { credentials: newCredentials } = await adminOAuth2Client.refreshAccessToken();
        if (newCredentials.access_token && newCredentials.expiry_date) {
          await db.googleToken.update({
            where: { id: tokens2.id },
            data: {
              accessToken: newCredentials.access_token,
              // Mettre √† jour le refresh token SEULEMENT s'il est nouveau
              refreshToken: newCredentials.refresh_token ?? tokens2.refreshToken,
              tokenType: newCredentials.token_type || "Bearer",
              expiresAt: new Date(newCredentials.expiry_date),
              updatedAt: /* @__PURE__ */ new Date(),
              lastRefreshAt: /* @__PURE__ */ new Date(),
              refreshCount: { increment: 1 }
            }
          });
        }
      } catch (error) {
        console.error(`[GoogleOAuthService] \u274C \xC9chec du rafra\xEEchissement pour admin ${googleConfig.adminEmail}:`, this.formatOAuthError(error));
        return null;
      }
    }
    return adminOAuth2Client;
  }
  // Client authentifi√© pour un utilisateur sp√©cifique dans une organisation
  async getAuthenticatedClient(userId, organizationId) {
    const tokens2 = await this.getUserTokens(userId, organizationId);
    if (!tokens2) {
      console.log(`[GoogleOAuthService] \u274C Aucun token trouv\xE9 pour l'utilisateur ${userId}`);
      return null;
    }
    let orgId = organizationId;
    if (!orgId) {
      const userWithOrg = await db.user.findUnique({
        where: { id: userId },
        include: {
          UserOrganization: {
            take: 1,
            orderBy: { createdAt: "desc" }
          }
        }
      });
      orgId = userWithOrg?.UserOrganization?.[0]?.organizationId;
    }
    if (!orgId) {
      console.log(`[GoogleOAuthService] \u274C Impossible de d\xE9terminer l'organisation pour l'utilisateur ${userId}`);
      return null;
    }
    const googleConfig = await db.googleWorkspaceConfig.findUnique({ where: { organizationId: orgId } });
    const clientId = googleConfig?.clientId ? decrypt(googleConfig.clientId) : null;
    const clientSecret = googleConfig?.clientSecret ? decrypt(googleConfig.clientSecret) : null;
    if (!clientId || !clientSecret) {
      console.warn("[GoogleOAuthService] \u274C clientId/clientSecret manquants pour org", orgId);
      return null;
    }
    console.log(`[GoogleOAuthService] \u{1F50D} Tokens trouv\xE9s pour ${userId}:`);
    console.log(`[GoogleOAuthService] - Access token: ${tokens2.accessToken ? "Pr\xE9sent" : "MANQUANT"}`);
    console.log(`[GoogleOAuthService] - Refresh token: ${tokens2.refreshToken ? "Pr\xE9sent" : "MANQUANT"}`);
    console.log(`[GoogleOAuthService] - Expires at: ${tokens2.expiresAt}`);
    const credentials = {
      access_token: tokens2.accessToken,
      refresh_token: tokens2.refreshToken,
      token_type: tokens2.tokenType,
      expiry_date: tokens2.expiresAt?.getTime()
    };
    console.log(`[GoogleOAuthService] \u{1F527} Configuration credentials:`, {
      hasAccessToken: !!credentials.access_token,
      hasRefreshToken: !!credentials.refresh_token,
      tokenType: credentials.token_type,
      expiryDate: credentials.expiry_date ? new Date(credentials.expiry_date).toISOString() : "NON_D\xC9FINI"
    });
    const userOAuth2Client = new import_googleapis.google.auth.OAuth2(clientId, clientSecret);
    userOAuth2Client.setCredentials(credentials);
    console.log(`[GoogleOAuthService] \u{1F4CB} Credentials d\xE9finies sur nouveau OAuth2Client`);
    const now = /* @__PURE__ */ new Date();
    const expiryDate = tokens2.expiresAt;
    console.log(`[GoogleOAuthService] \u23F0 V\xE9rification expiration: maintenant=${now.toISOString()}, expiry=${expiryDate?.toISOString()}`);
    if (expiryDate && expiryDate <= now) {
      console.log(`[GoogleOAuthService] \u26A0\uFE0F Token expir\xE9 pour l'utilisateur ${userId}, rafra\xEEchissement...`);
      try {
        const { credentials: credentials2 } = await userOAuth2Client.refreshAccessToken();
        console.log(`[GoogleOAuthService] \u2705 Rafra\xEEchissement r\xE9ussi, nouvelles credentials:`, {
          hasAccessToken: !!credentials2.access_token,
          hasRefreshToken: !!credentials2.refresh_token,
          newExpiry: credentials2.expiry_date ? new Date(credentials2.expiry_date).toISOString() : "NON_D\xC9FINI"
        });
        if (credentials2.access_token && credentials2.expiry_date) {
          await this.updateUserTokens(userId, {
            accessToken: credentials2.access_token,
            refreshToken: credentials2.refresh_token || tokens2.refreshToken,
            // Garde l'ancien si pas de nouveau
            tokenType: credentials2.token_type || "Bearer",
            expiresAt: new Date(credentials2.expiry_date)
          });
          console.log(`[GoogleOAuthService] \u2705 Token rafra\xEEchi avec succ\xE8s pour l'utilisateur ${userId}`);
        }
      } catch (error) {
        console.error(`[GoogleOAuthService] \u274C \xC9chec du rafra\xEEchissement du token pour ${userId}:`, this.formatOAuthError(error));
        return null;
      }
    } else if (expiryDate) {
      console.log(`[GoogleOAuthService] \u2705 Token encore valide pour ${userId} (expire dans ${Math.round((expiryDate.getTime() - now.getTime()) / 1e3 / 60)} minutes)`);
    } else {
      console.log(`[GoogleOAuthService] \u26A0\uFE0F Pas de date d'expiration d\xE9finie pour ${userId}`);
    }
    console.log(`[GoogleOAuthService] \u{1F680} Retour du nouveau client OAuth2 configur\xE9 pour ${userId}`);
    return userOAuth2Client;
  }
  // M√©thode pour mettre √† jour les tokens existants
  async updateUserTokens(userId, tokenData) {
    const userWithOrg = await db.user.findUnique({
      where: { id: userId },
      include: {
        UserOrganization: {
          take: 1,
          orderBy: { createdAt: "desc" }
        }
      }
    });
    if (!userWithOrg || !userWithOrg.UserOrganization[0]) {
      throw new Error(`Utilisateur ${userId} ou organisation non trouv\xE9`);
    }
    const organizationId = userWithOrg.UserOrganization[0].organizationId;
    await db.googleToken.update({
      where: { userId_organizationId: { userId, organizationId } },
      data: {
        accessToken: tokenData.accessToken,
        refreshToken: tokenData.refreshToken,
        tokenType: tokenData.tokenType,
        expiresAt: tokenData.expiresAt
      }
    });
  }
  // V√©rifier si connect√©
  async isUserConnected(userId) {
    const tokens2 = await this.getUserTokens(userId);
    return !!tokens2;
  }
  // D√©connecter l'utilisateur
  async disconnectUser(userId) {
    try {
      const tokens2 = await this.getUserTokens(userId);
      if (tokens2?.refreshToken) {
        await this.oauth2Client.revokeToken(tokens2.refreshToken);
        console.log(`[GoogleOAuthService] Token r\xE9voqu\xE9 pour l'utilisateur ${userId}`);
      }
    } catch (error) {
      console.error(`[GoogleOAuthService] \xC9chec de la r\xE9vocation du token pour ${userId}:`, error);
    }
    const userWithOrg = await db.user.findUnique({
      where: { id: userId },
      include: {
        UserOrganization: {
          take: 1,
          // Prendre la premi√®re organisation
          orderBy: { createdAt: "desc" }
        }
      }
    });
    if (userWithOrg?.UserOrganization[0]) {
      const organizationId = userWithOrg.UserOrganization[0].organizationId;
      await db.googleToken.delete({
        where: { userId_organizationId: { userId, organizationId } }
      });
      console.log(`[GoogleOAuthService] Tokens supprim\xE9s de la DB pour l'utilisateur ${userId} (org: ${organizationId})`);
    } else {
      console.log(`[GoogleOAuthService] Impossible de trouver l'organization pour l'utilisateur ${userId}`);
    }
  }
  // Tester la connexion
  async testConnection(userId) {
    try {
      const auth = await this.getAuthenticatedClient(userId);
      if (!auth) return { success: false, error: "Non connect\xE9" };
      const oauth2 = import_googleapis.google.oauth2({ version: "v2", auth });
      const response = await oauth2.userinfo.get();
      return { success: true, userInfo: response.data };
    } catch (error) {
      console.error(`[GoogleOAuthService] Erreur lors du test de connexion pour ${userId}:`, error);
      if (error instanceof Error) {
        return { success: false, error: error.message };
      }
      return { success: false, error: "Une erreur inconnue est survenue" };
    }
  }
};
var googleOAuthService = new GoogleOAuthService();

// src/google-auth/core/GoogleAuthManager.ts
var GoogleAuthManager = class _GoogleAuthManager {
  static instance;
  constructor() {
  }
  static getInstance() {
    if (!_GoogleAuthManager.instance) {
      _GoogleAuthManager.instance = new _GoogleAuthManager();
    }
    return _GoogleAuthManager.instance;
  }
  /**
   * Obtient un client Google authentifi√© pour un utilisateur dans une organisation
   * 
   * @param organizationId - ID de l'organisation
   * @param userId - ID de l'utilisateur (optionnel pour r√©trocompatibilit√©)
   * @returns Client OAuth2 authentifi√© ou null si √©chec
   */
  async getAuthenticatedClient(organizationId, userId) {
    if (!organizationId) {
      console.error("[GoogleAuthManager] \u274C organizationId est requis");
      return null;
    }
    console.log(`[GoogleAuthManager] \u{1F510} Demande de client authentifi\xE9 pour l'organisation: ${organizationId}, utilisateur: ${userId || "non sp\xE9cifi\xE9"}`);
    try {
      return await googleOAuthService.getAuthenticatedClientForOrganization(organizationId, userId);
    } catch (error) {
      console.error("[GoogleAuthManager] \u274C Erreur lors de l'obtention du client authentifi\xE9:", error);
      return null;
    }
  }
  /**
   * G√©n√®re une URL d'autorisation Google
   * 
   * @param userId - ID de l'utilisateur
   * @param organizationId - ID de l'organisation
   * @param hostHeader - Host header du request (optionnel, utilis√© pour d√©tection d'environnement)
   * @returns URL d'autorisation
   */
  getAuthorizationUrl(userId, organizationId, hostHeader) {
    return googleOAuthService.getAuthUrl(userId, organizationId, hostHeader);
  }
  /**
   * √âchange un code d'autorisation contre des tokens
   * 
   * @param code - Code d'autorisation re√ßu de Google
   * @param userId - ID de l'utilisateur
   * @param organizationId - ID de l'organisation
   * @param googleEmail - Email du compte Google connect√© (optionnel)
   */
  async exchangeCodeForTokens(code, userId, organizationId, googleEmail) {
    const tokens2 = await googleOAuthService.getTokenFromCode(code);
    await googleOAuthService.saveUserTokens(userId, organizationId, tokens2, googleEmail);
  }
};
var googleAuthManager = GoogleAuthManager.getInstance();

// src/google-auth/services/GoogleCalendarService.ts
var import_googleapis2 = require("googleapis");
var GoogleCalendarService = class _GoogleCalendarService {
  static instance;
  constructor() {
  }
  static getInstance() {
    if (!_GoogleCalendarService.instance) {
      _GoogleCalendarService.instance = new _GoogleCalendarService();
    }
    return _GoogleCalendarService.instance;
  }
  /**
   * Obtient une instance de l'API Google Calendar pour un utilisateur dans une organisation
   */
  async getCalendarAPI(organizationId, userId) {
    console.log(`[GoogleCalendarService] \u{1F4C5} Cr\xE9ation instance API Calendar pour organisation: ${organizationId}, utilisateur: ${userId || "non sp\xE9cifi\xE9"}`);
    const authClient = await googleAuthManager.getAuthenticatedClient(organizationId, userId);
    if (!authClient) {
      throw new Error("Connexion Google non configur\xE9e.");
    }
    return import_googleapis2.google.calendar({ version: "v3", auth: authClient });
  }
  /**
   * R√©cup√®re les √©v√©nements du calendrier
   */
  async getEvents(organizationId, startDate, endDate, userId) {
    try {
      const calendar = await this.getCalendarAPI(organizationId, userId);
      const params = {
        calendarId: "primary",
        singleEvents: true,
        orderBy: "startTime",
        maxResults: 100,
        timeMin: startDate?.toISOString(),
        timeMax: endDate?.toISOString()
      };
      const response = await calendar.events.list(params);
      const events = response.data.items || [];
      return events.map((event) => ({
        id: event.id,
        summary: event.summary || "Sans titre",
        description: event.description,
        start: {
          dateTime: event.start?.dateTime || event.start?.date || "",
          timeZone: event.start?.timeZone
        },
        end: {
          dateTime: event.end?.dateTime || event.end?.date || "",
          timeZone: event.end?.timeZone
        },
        attendees: event.attendees?.map((attendee) => ({
          email: attendee.email || "",
          displayName: attendee.displayName
        }))
      }));
    } catch (error) {
      console.error("[GoogleCalendarService] \u274C Erreur lors de la r\xE9cup\xE9ration des \xE9v\xE9nements:", error);
      throw error;
    }
  }
  /**
   * Cr√©e un nouvel √©v√©nement
   */
  async createEvent(organizationId, event, userId) {
    try {
      const calendar = await this.getCalendarAPI(organizationId, userId);
      const response = await calendar.events.insert({
        calendarId: "primary",
        requestBody: {
          summary: event.summary,
          description: event.description,
          start: event.start,
          end: event.end,
          attendees: event.attendees
        }
      });
      return response.data.id;
    } catch (error) {
      console.error("[GoogleCalendarService] \u274C Erreur lors de la cr\xE9ation de l'\xE9v\xE9nement:", error);
      throw error;
    }
  }
  /**
   * Met √† jour un √©v√©nement existant
   */
  async updateEvent(organizationId, eventId, event, userId) {
    try {
      const calendar = await this.getCalendarAPI(organizationId, userId);
      await calendar.events.update({
        calendarId: "primary",
        eventId,
        requestBody: {
          summary: event.summary,
          description: event.description,
          start: event.start,
          end: event.end,
          attendees: event.attendees
        }
      });
    } catch (error) {
      console.error("[GoogleCalendarService] \u274C Erreur lors de la mise \xE0 jour de l'\xE9v\xE9nement:", error);
      throw error;
    }
  }
  /**
   * Supprime un √©v√©nement
   */
  async deleteEvent(organizationId, eventId, userId) {
    try {
      const calendar = await this.getCalendarAPI(organizationId, userId);
      await calendar.events.delete({
        calendarId: "primary",
        eventId
      });
    } catch (error) {
      console.error("[GoogleCalendarService] \u274C Erreur lors de la suppression de l'\xE9v\xE9nement:", error);
      throw error;
    }
  }
  /**
   * Synchronise les √©v√©nements avec Google Calendar
   */
  async syncEvents(organizationId, startDate, endDate, userId) {
    console.log(`[GoogleCalendarService] \u{1F504} Synchronisation des \xE9v\xE9nements pour l'organisation: ${organizationId}, utilisateur: ${userId}`);
    console.log(`[GoogleCalendarService] \u{1F4C5} P\xE9riode: ${startDate.toISOString()} -> ${endDate.toISOString()}`);
    return await this.getEvents(organizationId, startDate, endDate, userId);
  }
};
var googleCalendarService = GoogleCalendarService.getInstance();

// src/google-auth/services/GoogleGmailService.ts
var import_googleapis3 = require("googleapis");
var GoogleGmailService = class _GoogleGmailService {
  gmail;
  organizationId;
  userId = null;
  adminEmail = null;
  constructor(gmail, organizationId, userId) {
    this.gmail = gmail;
    this.organizationId = organizationId;
    this.userId = userId || null;
  }
  /**
   * Cr√©e une instance du service Gmail pour un utilisateur dans une organisation
   */
  static async create(organizationId, userId) {
    console.log(`[GoogleGmailService] Cr\xE9ation du service pour l'organisation: ${organizationId}, utilisateur: ${userId || "non sp\xE9cifi\xE9"}`);
    const authClient = await googleAuthManager.getAuthenticatedClient(organizationId, userId);
    if (!authClient) {
      console.error(`[GoogleGmailService] Impossible d'obtenir le client authentifi\xE9 pour l'organisation: ${organizationId}`);
      return null;
    }
    const gmail = import_googleapis3.google.gmail({ version: "v1", auth: authClient });
    const service = new _GoogleGmailService(gmail, organizationId, userId);
    await service.loadOrganizationInfo();
    return service;
  }
  /**
   * Charge les informations de l'organisation (email admin, etc.)
   */
  async loadOrganizationInfo() {
    try {
      const { db: db2 } = await Promise.resolve().then(() => (init_database(), database_exports));
      const organization = await db2.organization.findUnique({
        where: { id: this.organizationId },
        include: {
          GoogleWorkspaceConfig: true
        }
      });
      if (organization?.GoogleWorkspaceConfig?.adminEmail) {
        this.adminEmail = organization.GoogleWorkspaceConfig.adminEmail;
        console.log(`[GoogleGmailService] \u{1F4E7} Email admin charg\xE9: ${this.adminEmail}`);
      } else {
        console.warn(`[GoogleGmailService] \u26A0\uFE0F Email admin non trouv\xE9 pour l'organisation ${this.organizationId}`);
      }
    } catch (error) {
      console.error("[GoogleGmailService] Erreur lors du chargement des infos organisation:", error);
    }
  }
  /**
   * R√©cup√®re la liste des messages Gmail
   */
  async getMessages(options = {}) {
    console.log("[GoogleGmailService] R\xE9cup\xE9ration des messages Gmail...");
    const {
      maxResults = 10,
      pageToken,
      q,
      labelIds
    } = options;
    try {
      const messagesResponse = await this.gmail.users.messages.list({
        userId: "me",
        maxResults,
        pageToken,
        q,
        labelIds
      });
      const messages = messagesResponse.data.messages || [];
      console.log(`[GoogleGmailService] ${messages.length} messages trouv\xE9s`);
      const formattedMessages = [];
      for (const message of messages) {
        if (message.id) {
          const messageDetails = await this.getMessageDetails(message.id);
          if (messageDetails) {
            formattedMessages.push(messageDetails);
          }
        }
      }
      return {
        messages: formattedMessages,
        nextPageToken: messagesResponse.data.nextPageToken,
        totalEstimate: messagesResponse.data.resultSizeEstimate
      };
    } catch (error) {
      console.error("[GoogleGmailService] Erreur lors de la r\xE9cup\xE9ration des messages:", error);
      throw error;
    }
  }
  /**
   * R√©cup√®re les d√©tails d'un message Gmail
   */
  async getMessageDetails(messageId) {
    try {
      const response = await this.gmail.users.messages.get({
        userId: "me",
        id: messageId,
        format: "full"
      });
      const message = response.data;
      if (!message.payload || !message.payload.headers) {
        return null;
      }
      const headers = message.payload.headers;
      const getHeader = (name) => {
        const header = headers.find((h) => h.name?.toLowerCase() === name.toLowerCase());
        return header?.value || "";
      };
      let htmlBody = "";
      if (message.payload.parts) {
        htmlBody = this.extractHtmlFromParts(message.payload.parts);
      } else if (message.payload.body?.data) {
        htmlBody = Buffer.from(message.payload.body.data, "base64").toString("utf-8");
      }
      const attachments = this.extractAttachments(message.payload);
      return {
        id: message.id,
        threadId: message.threadId,
        subject: getHeader("Subject"),
        from: getHeader("From"),
        to: getHeader("To"),
        date: new Date(parseInt(message.internalDate || "0")),
        snippet: message.snippet || "",
        labels: message.labelIds || [],
        isRead: !message.labelIds?.includes("UNREAD"),
        isStarred: message.labelIds?.includes("STARRED") || false,
        hasAttachments: attachments.length > 0,
        attachments,
        htmlBody
      };
    } catch (error) {
      console.error(`[GoogleGmailService] Erreur lors de la r\xE9cup\xE9ration du message ${messageId}:`, error);
      return null;
    }
  }
  /**
   * Envoie un email - COMME GMAIL FAIT
   */
  async sendEmail(options) {
    console.log(`[GoogleGmailService] \u{1F4E7} Envoi email \xE0: ${options.to}`);
    try {
      const boundary = "----=_Part_" + Date.now();
      let messageParts = [];
      messageParts.push(`From: ${options.fromName || "2Thier CRM"} <${this.adminEmail}>`);
      messageParts.push(`To: ${options.to}`);
      messageParts.push(`Subject: ${options.subject}`);
      if (options.cc) messageParts.push(`Cc: ${options.cc}`);
      if (options.bcc) messageParts.push(`Bcc: ${options.bcc}`);
      messageParts.push(`MIME-Version: 1.0`);
      if (options.attachments && options.attachments.length > 0) {
        messageParts.push(`Content-Type: multipart/mixed; boundary="${boundary}"`);
        messageParts.push("");
        messageParts.push(`--${boundary}`);
        messageParts.push(`Content-Type: ${options.isHtml ? "text/html" : "text/plain"}; charset="UTF-8"`);
        messageParts.push("");
        messageParts.push(options.body);
        for (const att of options.attachments) {
          messageParts.push(`--${boundary}`);
          messageParts.push(`Content-Type: ${att.mimeType}; name="${att.filename}"`);
          messageParts.push(`Content-Disposition: attachment; filename="${att.filename}"`);
          messageParts.push(`Content-Transfer-Encoding: base64`);
          messageParts.push("");
          messageParts.push(att.content.toString("base64"));
        }
        messageParts.push(`--${boundary}--`);
      } else {
        messageParts.push(`Content-Type: ${options.isHtml ? "text/html" : "text/plain"}; charset="UTF-8"`);
        messageParts.push("");
        messageParts.push(options.body);
      }
      const rawMessage = messageParts.join("\r\n");
      const encodedMessage = Buffer.from(rawMessage).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
      const response = await this.gmail.users.messages.send({
        userId: "me",
        requestBody: { raw: encodedMessage }
      });
      console.log(`[GoogleGmailService] \u2705 Email envoy\xE9: ${response.data.id}`);
      return { messageId: response.data.id };
    } catch (error) {
      console.error("[GoogleGmailService] \u274C Erreur envoi:", error);
      return null;
    }
  }
  /**
   * R√©cup√®re les labels Gmail
   */
  async getLabels() {
    try {
      const response = await this.gmail.users.labels.list({
        userId: "me"
      });
      return (response.data.labels || []).map((label) => ({
        id: label.id,
        name: label.name,
        type: label.type,
        messageListVisibility: label.messageListVisibility,
        labelListVisibility: label.labelListVisibility
      }));
    } catch (error) {
      console.error("[GoogleGmailService] Erreur lors de la r\xE9cup\xE9ration des labels:", error);
      throw error;
    }
  }
  /**
   * Cr√©e un nouveau label/dossier personnalis√©
   */
  async createLabel(name) {
    try {
      const response = await this.gmail.users.labels.create({
        userId: "me",
        requestBody: {
          name,
          messageListVisibility: "show",
          labelListVisibility: "labelShow"
        }
      });
      if (response.data) {
        console.log(`[GoogleGmailService] Label "${name}" cr\xE9\xE9 avec l'ID: ${response.data.id}`);
        return {
          id: response.data.id,
          name: response.data.name,
          type: response.data.type,
          messageListVisibility: response.data.messageListVisibility,
          labelListVisibility: response.data.labelListVisibility
        };
      }
      return null;
    } catch (error) {
      console.error(`[GoogleGmailService] Erreur lors de la cr\xE9ation du label "${name}":`, error);
      return null;
    }
  }
  /**
   * Modifie un label existant
   */
  async updateLabel(labelId, name) {
    try {
      await this.gmail.users.labels.update({
        userId: "me",
        id: labelId,
        requestBody: {
          name,
          messageListVisibility: "show",
          labelListVisibility: "labelShow"
        }
      });
      console.log(`[GoogleGmailService] Label ${labelId} renomm\xE9 en "${name}"`);
      return true;
    } catch (error) {
      console.error(`[GoogleGmailService] Erreur lors de la modification du label ${labelId}:`, error);
      return false;
    }
  }
  /**
   * Supprime un label (seuls les labels personnalis√©s peuvent √™tre supprim√©s)
   */
  async deleteLabel(labelId) {
    try {
      await this.gmail.users.labels.delete({
        userId: "me",
        id: labelId
      });
      console.log(`[GoogleGmailService] Label ${labelId} supprim\xE9`);
      return true;
    } catch (error) {
      console.error(`[GoogleGmailService] Erreur lors de la suppression du label ${labelId}:`, error);
      return false;
    }
  }
  /**
   * Marque un message comme lu/non lu
   */
  async markAsRead(messageId, read = true) {
    try {
      const labelsToAdd = read ? [] : ["UNREAD"];
      const labelsToRemove = read ? ["UNREAD"] : [];
      await this.gmail.users.messages.modify({
        userId: "me",
        id: messageId,
        requestBody: {
          addLabelIds: labelsToAdd,
          removeLabelIds: labelsToRemove
        }
      });
      console.log(`[GoogleGmailService] Message ${messageId} marqu\xE9 comme ${read ? "lu" : "non lu"}`);
      return true;
    } catch (error) {
      console.error(`[GoogleGmailService] Erreur lors du marquage du message ${messageId}:`, error);
      return false;
    }
  }
  /**
   * Supprime un message
   */
  /**
   * Marque ou enl√®ve l'√©toile d'un message
   * LOGIQUE PR√âCISE : 
   * - Ajouter √©toile = SEULEMENT ajouter STARRED (ne pas toucher aux autres labels)
   * - Retirer √©toile = SEULEMENT retirer STARRED (ne pas toucher aux autres labels)
   */
  async markAsStarred(messageId, starred = true) {
    try {
      const labelChanges = {};
      if (starred) {
        labelChanges.addLabelIds = ["STARRED"];
        console.log(`[GoogleGmailService] \u2B50 Ajout STARRED uniquement (autres labels pr\xE9serv\xE9s)`);
      } else {
        labelChanges.removeLabelIds = ["STARRED"];
        console.log(`[GoogleGmailService] \u2B50 Retrait STARRED uniquement (autres labels pr\xE9serv\xE9s)`);
      }
      await this.gmail.users.messages.modify({
        userId: "me",
        id: messageId,
        requestBody: labelChanges
      });
      console.log(`[GoogleGmailService] Message ${messageId} ${starred ? "marqu\xE9 en favori" : "retir\xE9 des favoris"} - autres labels intacts`);
      return true;
    } catch (error) {
      console.error(`[GoogleGmailService] Erreur lors de la modification du favori pour ${messageId}:`, error);
      return false;
    }
  }
  /**
   * D√©place un message vers la corbeille
   * LOGIQUE SIMPLE : Ajoute SEULEMENT le label TRASH, sans retirer d'autres labels
   * Pour supprimer compl√®tement, utiliser deleteMessage
   */
  async trashMessage(messageId) {
    try {
      await this.gmail.users.messages.modify({
        userId: "me",
        id: messageId,
        requestBody: {
          addLabelIds: ["TRASH"]
          // Ne pas retirer INBOX automatiquement - gestion ind√©pendante
        }
      });
      console.log(`[GoogleGmailService] Message ${messageId} d\xE9plac\xE9 vers la corbeille (autres labels pr\xE9serv\xE9s)`);
      return true;
    } catch (error) {
      console.error(`[GoogleGmailService] Erreur lors du d\xE9placement vers la corbeille pour ${messageId}:`, error);
      return false;
    }
  }
  /**
   * Supprime un message d'un emplacement sp√©cifique (retire seulement le label demand√©)
   * Utilis√© pour supprimer de bo√Æte de r√©ception, favoris, ou dossier sans affecter les autres emplacements
   */
  async removeFromLocation(messageId, labelToRemove) {
    try {
      await this.gmail.users.messages.modify({
        userId: "me",
        id: messageId,
        requestBody: {
          removeLabelIds: [labelToRemove]
          // Ne retire QUE le label sp√©cifi√©, garde tous les autres
        }
      });
      console.log(`[GoogleGmailService] Message ${messageId} retir\xE9 de l'emplacement ${labelToRemove} (autres emplacements pr\xE9serv\xE9s)`);
      return true;
    } catch (error) {
      console.error(`[GoogleGmailService] Erreur lors de la suppression de ${labelToRemove} pour ${messageId}:`, error);
      return false;
    }
  }
  /**
   * Restaure un message de la corbeille
   * LOGIQUE SIMPLE : Retire SEULEMENT le label TRASH
   */
  async untrashMessage(messageId) {
    try {
      await this.gmail.users.messages.modify({
        userId: "me",
        id: messageId,
        requestBody: {
          removeLabelIds: ["TRASH"]
          // Ne pas ajouter INBOX automatiquement - l'utilisateur choisira o√π le remettre
        }
      });
      console.log(`[GoogleGmailService] Message ${messageId} restaur\xE9 de la corbeille`);
      return true;
    } catch (error) {
      console.error(`[GoogleGmailService] Erreur lors de la restauration de ${messageId}:`, error);
      return false;
    }
  }
  /**
   * Modifie les labels d'un message (pour gestion des dossiers)
   * LOGIQUE SIMPLE ET PR√âCISE :
   * - Suppression sp√©cifique = retire SEULEMENT le label demand√©
   * - Ajout sp√©cifique = ajoute SEULEMENT le label demand√©
   * - Chaque emplacement (INBOX, STARRED, dossier) est g√©r√© IND√âPENDAMMENT
   */
  async modifyLabels(messageId, addLabelIds = [], removeLabelIds = []) {
    try {
      const requestBody = {};
      if (addLabelIds.length > 0) {
        requestBody.addLabelIds = addLabelIds;
        console.log(`[GoogleGmailService] \u2795 Ajout des labels: ${addLabelIds.join(", ")}`);
      }
      if (removeLabelIds.length > 0) {
        requestBody.removeLabelIds = removeLabelIds;
        console.log(`[GoogleGmailService] \u2796 Suppression des labels: ${removeLabelIds.join(", ")}`);
      }
      await this.gmail.users.messages.modify({
        userId: "me",
        id: messageId,
        requestBody
      });
      console.log(`[GoogleGmailService] \u2705 Labels modifi\xE9s pour ${messageId}:`, {
        ajout\u00E9s: requestBody.addLabelIds,
        retir\u00E9s: requestBody.removeLabelIds,
        logique: "Gestion ind\xE9pendante - aucune protection automatique"
      });
      return true;
    } catch (error) {
      console.error(`[GoogleGmailService] Erreur lors de la modification des labels pour ${messageId}:`, error);
      return false;
    }
  }
  /**
   * Supprime d√©finitivement un message (suppression irr√©versible)
   */
  async deleteMessage(messageId) {
    try {
      await this.gmail.users.messages.delete({
        userId: "me",
        id: messageId
      });
      console.log(`[GoogleGmailService] Message ${messageId} supprim\xE9 d\xE9finitivement`);
      return true;
    } catch (error) {
      console.error(`[GoogleGmailService] Erreur lors de la suppression du message ${messageId}:`, error);
      return false;
    }
  }
  /**
   * Sauvegarde un email en brouillon
   * FONCTIONNALIT√â ESSENTIELLE : Auto-sauvegarde pour ne jamais perdre un email en cours
   */
  async saveDraft(options) {
    console.log(`[GoogleGmailService] \u{1F4BE} Sauvegarde en brouillon: "${options.subject}" -> ${options.to}`);
    try {
      let message = "";
      message += `To: ${options.to}\r
`;
      message += `Subject: ${options.subject}\r
`;
      if (options.cc) {
        message += `Cc: ${options.cc}\r
`;
      }
      if (options.bcc) {
        message += `Bcc: ${options.bcc}\r
`;
      }
      const contentType = options.isHtml ? "text/html" : "text/plain";
      message += `Content-Type: ${contentType}; charset=utf-8\r
`;
      message += `\r
`;
      message += options.body;
      const encodedMessage = Buffer.from(message).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
      let response;
      if (options.draftId) {
        console.log(`[GoogleGmailService] \u{1F504} Mise \xE0 jour du brouillon existant: ${options.draftId}`);
        response = await this.gmail.users.drafts.update({
          userId: "me",
          id: options.draftId,
          requestBody: {
            message: {
              raw: encodedMessage
            }
          }
        });
      } else {
        console.log(`[GoogleGmailService] \u2728 Cr\xE9ation d'un nouveau brouillon`);
        response = await this.gmail.users.drafts.create({
          userId: "me",
          requestBody: {
            message: {
              raw: encodedMessage
            }
          }
        });
      }
      const draftId = response.data.id;
      const messageId = response.data.message?.id || "";
      console.log(`[GoogleGmailService] \u2705 Brouillon sauvegard\xE9 - ID: ${draftId}, Message: ${messageId}`);
      return { draftId, messageId };
    } catch (error) {
      console.error("[GoogleGmailService] \u274C Erreur lors de la sauvegarde en brouillon:", error);
      return null;
    }
  }
  /**
   * R√©cup√®re tous les brouillons
   */
  async getDrafts() {
    console.log("[GoogleGmailService] \u{1F4C4} R\xE9cup\xE9ration des brouillons...");
    try {
      const draftsResponse = await this.gmail.users.drafts.list({
        userId: "me"
      });
      const drafts = draftsResponse.data.drafts || [];
      console.log(`[GoogleGmailService] ${drafts.length} brouillons trouv\xE9s`);
      const formattedDrafts = [];
      for (const draft of drafts) {
        if (draft.id && draft.message?.id) {
          try {
            const draftDetails = await this.gmail.users.drafts.get({
              userId: "me",
              id: draft.id,
              format: "full"
            });
            const message = draftDetails.data.message;
            if (message?.payload?.headers) {
              const headers = message.payload.headers;
              const getHeader = (name) => {
                const header = headers.find((h) => h.name?.toLowerCase() === name.toLowerCase());
                return header?.value || "";
              };
              let body2 = "";
              if (message.payload.parts) {
                body2 = this.extractTextFromParts(message.payload.parts);
              } else if (message.payload.body?.data) {
                body2 = Buffer.from(message.payload.body.data, "base64").toString("utf-8");
              }
              formattedDrafts.push({
                draftId: draft.id,
                messageId: draft.message.id,
                subject: getHeader("Subject"),
                to: getHeader("To"),
                body: body2,
                date: new Date(parseInt(message.internalDate || "0"))
              });
            }
          } catch (error) {
            console.error(`[GoogleGmailService] Erreur lors de la r\xE9cup\xE9ration du brouillon ${draft.id}:`, error);
          }
        }
      }
      console.log(`[GoogleGmailService] \u2705 ${formattedDrafts.length} brouillons format\xE9s r\xE9cup\xE9r\xE9s`);
      return { drafts: formattedDrafts };
    } catch (error) {
      console.error("[GoogleGmailService] \u274C Erreur lors de la r\xE9cup\xE9ration des brouillons:", error);
      return { drafts: [] };
    }
  }
  /**
   * Supprime un brouillon
   */
  async deleteDraft(draftId) {
    try {
      await this.gmail.users.drafts.delete({
        userId: "me",
        id: draftId
      });
      console.log(`[GoogleGmailService] \u{1F5D1}\uFE0F Brouillon ${draftId} supprim\xE9`);
      return true;
    } catch (error) {
      console.error(`[GoogleGmailService] \u274C Erreur lors de la suppression du brouillon ${draftId}:`, error);
      return false;
    }
  }
  /**
   * Envoie un brouillon (convertit le brouillon en email envoy√©)
   */
  async sendDraft(draftId) {
    console.log(`[GoogleGmailService] \u{1F4E4} Envoi du brouillon: ${draftId}`);
    try {
      const response = await this.gmail.users.drafts.send({
        userId: "me",
        requestBody: {
          id: draftId
        }
      });
      console.log(`[GoogleGmailService] \u2705 Brouillon envoy\xE9 - Message ID: ${response.data.id}`);
      return { messageId: response.data.id };
    } catch (error) {
      console.error(`[GoogleGmailService] \u274C Erreur lors de l'envoi du brouillon ${draftId}:`, error);
      return null;
    }
  }
  /**
   * Vide compl√®tement la corbeille (supprime tous les messages avec le label TRASH)
   */
  async emptyTrash() {
    try {
      console.log(`[GoogleGmailService] \u{1F525} D\xC9BUT du vidage de la corbeille...`);
      let allMessages = [];
      let pageToken = void 0;
      let totalPages = 0;
      do {
        totalPages++;
        console.log(`[GoogleGmailService] \u{1F4C4} R\xE9cup\xE9ration page ${totalPages} des messages de la corbeille...`);
        const trashMessages = await this.gmail.users.messages.list({
          userId: "me",
          labelIds: ["TRASH"],
          maxResults: 100,
          // Maximum par page
          pageToken
        });
        const pageMessages = trashMessages.data.messages || [];
        allMessages = allMessages.concat(pageMessages);
        pageToken = trashMessages.data.nextPageToken;
        console.log(`[GoogleGmailService] \u{1F4C4} Page ${totalPages}: ${pageMessages.length} messages trouv\xE9s`);
      } while (pageToken);
      console.log(`[GoogleGmailService] \u{1F4CA} TOTAL: ${allMessages.length} messages trouv\xE9s dans la corbeille sur ${totalPages} pages`);
      if (allMessages.length === 0) {
        console.log(`[GoogleGmailService] \u2705 La corbeille est d\xE9j\xE0 vide`);
        return true;
      }
      let deletedCount = 0;
      for (const message of allMessages) {
        if (message.id) {
          try {
            await this.deleteMessage(message.id);
            deletedCount++;
            if (deletedCount % 10 === 0) {
              console.log(`[GoogleGmailService] \u{1F5D1}\uFE0F Progression: ${deletedCount}/${allMessages.length} messages supprim\xE9s...`);
            }
          } catch (error) {
            console.error(`[GoogleGmailService] \u274C Erreur lors de la suppression du message ${message.id}:`, error);
          }
        }
      }
      console.log(`[GoogleGmailService] \u2705 Vidage termin\xE9: ${deletedCount}/${allMessages.length} messages supprim\xE9s de la corbeille`);
      return true;
    } catch (error) {
      console.error(`[GoogleGmailService] \u274C Erreur lors du vidage de la corbeille:`, error);
      return false;
    }
  }
  // M√©thodes utilitaires priv√©es
  extractHtmlFromParts(parts) {
    for (const part of parts) {
      if (part.mimeType === "text/html" && part.body?.data) {
        return Buffer.from(part.body.data, "base64").toString("utf-8");
      }
      if (part.parts) {
        const html = this.extractHtmlFromParts(part.parts);
        if (html) return html;
      }
    }
    return "";
  }
  extractTextFromParts(parts) {
    for (const part of parts) {
      if (part.mimeType === "text/plain" && part.body?.data) {
        return Buffer.from(part.body.data, "base64").toString("utf-8");
      }
      if (part.mimeType === "text/html" && part.body?.data) {
        return Buffer.from(part.body.data, "base64").toString("utf-8");
      }
      if (part.parts) {
        const text = this.extractTextFromParts(part.parts);
        if (text) return text;
      }
    }
    return "";
  }
  /**
   * R√©cup√®re une pi√®ce jointe d'un message Gmail
   */
  async getAttachment(messageId, attachmentId) {
    try {
      console.log(`[GoogleGmailService] \u{1F4CE} R\xE9cup\xE9ration pi\xE8ce jointe: ${attachmentId} du message: ${messageId}`);
      const messageResponse = await this.gmail.users.messages.get({
        userId: "me",
        id: messageId,
        format: "full"
      });
      let attachmentInfo = { filename: "", mimeType: "application/octet-stream" };
      const findAttachmentInfo = (parts) => {
        for (const part of parts) {
          if (part.body?.attachmentId === attachmentId) {
            attachmentInfo = {
              filename: part.filename || `attachment_${attachmentId}`,
              mimeType: part.mimeType || "application/octet-stream"
            };
            return;
          }
          if (part.parts) {
            findAttachmentInfo(part.parts);
          }
        }
      };
      if (messageResponse.data.payload?.parts) {
        findAttachmentInfo(messageResponse.data.payload.parts);
      } else if (messageResponse.data.payload?.body?.attachmentId === attachmentId) {
        attachmentInfo = {
          filename: messageResponse.data.payload.filename || `attachment_${attachmentId}`,
          mimeType: messageResponse.data.payload.mimeType || "application/octet-stream"
        };
      }
      const attachmentResponse = await this.gmail.users.messages.attachments.get({
        userId: "me",
        messageId,
        id: attachmentId
      });
      if (attachmentResponse.data.data) {
        const data = attachmentResponse.data.data.replace(/-/g, "+").replace(/_/g, "/");
        const buffer = Buffer.from(data, "base64");
        console.log(`[GoogleGmailService] \u2705 Pi\xE8ce jointe r\xE9cup\xE9r\xE9e: ${attachmentInfo.filename} (${buffer.length} bytes)`);
        return {
          data: buffer,
          filename: attachmentInfo.filename,
          mimeType: attachmentInfo.mimeType
        };
      }
      console.log(`[GoogleGmailService] \u274C Aucune donn\xE9e trouv\xE9e pour la pi\xE8ce jointe: ${attachmentId}`);
      return null;
    } catch (error) {
      console.error("[GoogleGmailService] Erreur r\xE9cup\xE9ration pi\xE8ce jointe:", error);
      throw error;
    }
  }
  extractAttachments(payload) {
    const attachments = [];
    const findAttachments = (parts) => {
      for (const part of parts) {
        if (part.filename && part.body?.attachmentId) {
          attachments.push({
            attachmentId: part.body.attachmentId,
            filename: part.filename,
            mimeType: part.mimeType || "application/octet-stream",
            size: part.body.size || 0
          });
        }
        if (part.parts) {
          findAttachments(part.parts);
        }
      }
    };
    if (payload.parts) {
      findAttachments(payload.parts);
    }
    return attachments;
  }
};

// src/google-auth/services/GoogleDriveService.ts
var import_googleapis4 = require("googleapis");
var GoogleDriveService = class _GoogleDriveService {
  static instance;
  constructor() {
  }
  static getInstance() {
    if (!_GoogleDriveService.instance) {
      _GoogleDriveService.instance = new _GoogleDriveService();
    }
    return _GoogleDriveService.instance;
  }
  /**
   * Obtient une instance de l'API Google Drive pour un utilisateur dans une organisation
   */
  async getDriveAPI(organizationId, userId) {
    console.log(`[GoogleDriveService] \u{1F4C1} Cr\xE9ation instance API Drive pour organisation: ${organizationId}, utilisateur: ${userId || "non sp\xE9cifi\xE9"}`);
    const authClient = await googleAuthManager.getAuthenticatedClient(organizationId, userId);
    if (!authClient) {
      throw new Error("Connexion Google non configur\xE9e.");
    }
    return import_googleapis4.google.drive({ version: "v3", auth: authClient });
  }
  /**
   * R√©cup√®re les fichiers et dossiers du Drive
   */
  async getFiles(organizationId, folderId = "root", pageSize = 50, pageToken, userId) {
    try {
      console.log(`[GoogleDriveService] \u{1F50D} R\xE9cup\xE9ration des fichiers pour folder: ${folderId}, userId: ${userId}`);
      const drive = await this.getDriveAPI(organizationId, userId);
      const query = folderId === "root" ? "'root' in parents and trashed = false" : `'${folderId}' in parents and trashed = false`;
      const response = await drive.files.list({
        q: query,
        pageSize,
        pageToken,
        fields: "nextPageToken, files(id, name, mimeType, size, modifiedTime, createdTime, webViewLink, webContentLink, iconLink, thumbnailLink, parents, shared, ownedByMe)",
        orderBy: "folder, name",
        supportsAllDrives: true,
        includeItemsFromAllDrives: true
      });
      const files = (response.data.files || []).map((file) => ({
        id: file.id || "",
        name: file.name || "Sans nom",
        mimeType: file.mimeType || "application/octet-stream",
        size: file.size || void 0,
        modifiedTime: file.modifiedTime || void 0,
        createdTime: file.createdTime || void 0,
        webViewLink: file.webViewLink || void 0,
        webContentLink: file.webContentLink || void 0,
        iconLink: file.iconLink || void 0,
        thumbnailLink: file.thumbnailLink || void 0,
        parents: file.parents || void 0,
        shared: file.shared || false,
        ownedByMe: file.ownedByMe || false
      }));
      console.log(`[GoogleDriveService] \u2705 ${files.length} fichiers r\xE9cup\xE9r\xE9s`);
      return {
        files,
        nextPageToken: response.data.nextPageToken || void 0
      };
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la r\xE9cup\xE9ration des fichiers:", error);
      throw error;
    }
  }
  /**
   * R√©cup√®re les fichiers partag√©s avec l'utilisateur
   */
  async getSharedFiles(organizationId, pageSize = 50, pageToken, userId) {
    try {
      console.log(`[GoogleDriveService] \u{1F50D} R\xE9cup\xE9ration des fichiers partag\xE9s`);
      const drive = await this.getDriveAPI(organizationId, userId);
      const response = await drive.files.list({
        q: "sharedWithMe = true and trashed = false",
        pageSize,
        pageToken,
        fields: "nextPageToken, files(id, name, mimeType, size, modifiedTime, createdTime, webViewLink, webContentLink, iconLink, thumbnailLink, parents, shared, ownedByMe, sharingUser)",
        orderBy: "folder, modifiedTime desc",
        supportsAllDrives: true,
        includeItemsFromAllDrives: true
      });
      const files = (response.data.files || []).map((file) => ({
        id: file.id || "",
        name: file.name || "Sans nom",
        mimeType: file.mimeType || "application/octet-stream",
        size: file.size || void 0,
        modifiedTime: file.modifiedTime || void 0,
        createdTime: file.createdTime || void 0,
        webViewLink: file.webViewLink || void 0,
        webContentLink: file.webContentLink || void 0,
        iconLink: file.iconLink || void 0,
        thumbnailLink: file.thumbnailLink || void 0,
        parents: file.parents || void 0,
        shared: true,
        ownedByMe: false
      }));
      console.log(`[GoogleDriveService] \u2705 ${files.length} fichiers partag\xE9s r\xE9cup\xE9r\xE9s`);
      return {
        files,
        nextPageToken: response.data.nextPageToken || void 0
      };
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la r\xE9cup\xE9ration des fichiers partag\xE9s:", error);
      throw error;
    }
  }
  /**
   * R√©cup√®re les drives partag√©s (Team Drives)
   */
  async getSharedDrives(organizationId, pageSize = 50, userId) {
    try {
      console.log(`[GoogleDriveService] \u{1F50D} R\xE9cup\xE9ration des drives partag\xE9s`);
      const drive = await this.getDriveAPI(organizationId, userId);
      const response = await drive.drives.list({
        pageSize,
        fields: "drives(id, name)"
      });
      const drives = (response.data.drives || []).map((d) => ({
        id: d.id || "",
        name: d.name || "Drive partag\xE9"
      }));
      console.log(`[GoogleDriveService] \u2705 ${drives.length} drives partag\xE9s r\xE9cup\xE9r\xE9s`);
      return { drives };
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la r\xE9cup\xE9ration des drives partag\xE9s:", error);
      throw error;
    }
  }
  /**
   * R√©cup√®re les fichiers d'un Drive partag√© (Team Drive)
   */
  async getSharedDriveFiles(organizationId, driveId, folderId, pageSize = 50, pageToken, userId) {
    try {
      console.log(`[GoogleDriveService] \u{1F50D} R\xE9cup\xE9ration des fichiers du drive partag\xE9: ${driveId}, folder: ${folderId || "root"}`);
      const drive = await this.getDriveAPI(organizationId, userId);
      const parentId = folderId || driveId;
      const query = `'${parentId}' in parents and trashed = false`;
      const response = await drive.files.list({
        q: query,
        pageSize,
        pageToken,
        driveId,
        corpora: "drive",
        includeItemsFromAllDrives: true,
        supportsAllDrives: true,
        fields: "nextPageToken, files(id, name, mimeType, size, modifiedTime, createdTime, webViewLink, webContentLink, iconLink, thumbnailLink, parents, shared, ownedByMe)",
        orderBy: "folder, name"
      });
      const files = (response.data.files || []).map((file) => ({
        id: file.id || "",
        name: file.name || "Sans nom",
        mimeType: file.mimeType || "application/octet-stream",
        size: file.size || void 0,
        modifiedTime: file.modifiedTime || void 0,
        createdTime: file.createdTime || void 0,
        webViewLink: file.webViewLink || void 0,
        webContentLink: file.webContentLink || void 0,
        iconLink: file.iconLink || void 0,
        thumbnailLink: file.thumbnailLink || void 0,
        parents: file.parents || void 0,
        shared: true,
        ownedByMe: false
      }));
      console.log(`[GoogleDriveService] \u2705 ${files.length} fichiers r\xE9cup\xE9r\xE9s du drive partag\xE9`);
      return {
        files,
        nextPageToken: response.data.nextPageToken || void 0
      };
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la r\xE9cup\xE9ration des fichiers du drive partag\xE9:", error);
      throw error;
    }
  }
  /**
   * Recherche des fichiers dans le Drive
   */
  async searchFiles(organizationId, searchQuery, pageSize = 50, userId) {
    try {
      console.log(`[GoogleDriveService] \u{1F50E} Recherche: "${searchQuery}"`);
      const drive = await this.getDriveAPI(organizationId, userId);
      const response = await drive.files.list({
        q: `name contains '${searchQuery}' and trashed = false`,
        pageSize,
        fields: "files(id, name, mimeType, size, modifiedTime, webViewLink, webContentLink, iconLink, thumbnailLink, parents, shared)",
        orderBy: "modifiedTime desc"
      });
      const files = (response.data.files || []).map((file) => ({
        id: file.id || "",
        name: file.name || "Sans nom",
        mimeType: file.mimeType || "application/octet-stream",
        size: file.size || void 0,
        modifiedTime: file.modifiedTime || void 0,
        webViewLink: file.webViewLink || void 0,
        webContentLink: file.webContentLink || void 0,
        iconLink: file.iconLink || void 0,
        thumbnailLink: file.thumbnailLink || void 0,
        parents: file.parents || void 0,
        shared: file.shared || false
      }));
      console.log(`[GoogleDriveService] \u2705 ${files.length} fichiers trouv\xE9s`);
      return files;
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la recherche:", error);
      throw error;
    }
  }
  /**
   * Cr√©e un nouveau dossier
   */
  async createFolder(organizationId, name, parentId = "root", userId) {
    try {
      console.log(`[GoogleDriveService] \u{1F4C2} Cr\xE9ation du dossier: "${name}"`);
      const drive = await this.getDriveAPI(organizationId, userId);
      const response = await drive.files.create({
        requestBody: {
          name,
          mimeType: "application/vnd.google-apps.folder",
          parents: [parentId]
        },
        fields: "id, name, mimeType, modifiedTime, webViewLink"
      });
      console.log(`[GoogleDriveService] \u2705 Dossier cr\xE9\xE9: ${response.data.id}`);
      return {
        id: response.data.id || "",
        name: response.data.name || name,
        mimeType: response.data.mimeType || "application/vnd.google-apps.folder",
        modifiedTime: response.data.modifiedTime || void 0,
        webViewLink: response.data.webViewLink || void 0
      };
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la cr\xE9ation du dossier:", error);
      throw error;
    }
  }
  /**
   * Supprime un fichier ou dossier (mise √† la corbeille)
   */
  async deleteFile(organizationId, fileId, userId) {
    try {
      console.log(`[GoogleDriveService] \u{1F5D1}\uFE0F Suppression du fichier: ${fileId}`);
      const drive = await this.getDriveAPI(organizationId, userId);
      await drive.files.update({
        fileId,
        supportsAllDrives: true,
        requestBody: {
          trashed: true
        }
      });
      console.log(`[GoogleDriveService] \u2705 Fichier mis \xE0 la corbeille`);
      return true;
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la suppression:", error);
      throw error;
    }
  }
  /**
   * R√©cup√®re les informations d'un fichier
   */
  async getFileInfo(organizationId, fileId, userId) {
    try {
      const drive = await this.getDriveAPI(organizationId, userId);
      const response = await drive.files.get({
        fileId,
        fields: "id, name, mimeType, size, modifiedTime, createdTime, webViewLink, webContentLink, iconLink, thumbnailLink, parents, shared, ownedByMe"
      });
      return {
        id: response.data.id || "",
        name: response.data.name || "Sans nom",
        mimeType: response.data.mimeType || "application/octet-stream",
        size: response.data.size || void 0,
        modifiedTime: response.data.modifiedTime || void 0,
        createdTime: response.data.createdTime || void 0,
        webViewLink: response.data.webViewLink || void 0,
        webContentLink: response.data.webContentLink || void 0,
        iconLink: response.data.iconLink || void 0,
        thumbnailLink: response.data.thumbnailLink || void 0,
        parents: response.data.parents || void 0,
        shared: response.data.shared || false,
        ownedByMe: response.data.ownedByMe || false
      };
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la r\xE9cup\xE9ration des infos:", error);
      throw error;
    }
  }
  /**
   * R√©cup√®re les informations de stockage
   */
  async getStorageInfo(organizationId, userId) {
    try {
      const drive = await this.getDriveAPI(organizationId, userId);
      const response = await drive.about.get({
        fields: "storageQuota"
      });
      const quota = response.data.storageQuota;
      return {
        limit: quota?.limit || "0",
        usage: quota?.usage || "0",
        usageInDrive: quota?.usageInDrive || "0",
        usageInTrash: quota?.usageInTrash || "0"
      };
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la r\xE9cup\xE9ration du stockage:", error);
      throw error;
    }
  }
  /**
   * Upload un fichier vers Google Drive
   */
  async uploadFile(organizationId, fileName, mimeType, fileBuffer, parentId = "root", userId) {
    try {
      console.log(`[GoogleDriveService] \u{1F4E4} Upload du fichier: "${fileName}"`);
      const drive = await this.getDriveAPI(organizationId, userId);
      const { Readable } = await import("stream");
      const stream = Readable.from(fileBuffer);
      const response = await drive.files.create({
        requestBody: {
          name: fileName,
          parents: [parentId]
        },
        media: {
          mimeType,
          body: stream
        },
        fields: "id, name, mimeType, size, modifiedTime, webViewLink, webContentLink, iconLink, thumbnailLink"
      });
      console.log(`[GoogleDriveService] \u2705 Fichier upload\xE9: ${response.data.id}`);
      return {
        id: response.data.id || "",
        name: response.data.name || fileName,
        mimeType: response.data.mimeType || mimeType,
        size: response.data.size || void 0,
        modifiedTime: response.data.modifiedTime || void 0,
        webViewLink: response.data.webViewLink || void 0,
        webContentLink: response.data.webContentLink || void 0,
        iconLink: response.data.iconLink || void 0,
        thumbnailLink: response.data.thumbnailLink || void 0
      };
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de l'upload:", error);
      throw error;
    }
  }
  /**
   * Renommer un fichier ou dossier
   */
  async renameFile(organizationId, fileId, newName, userId) {
    try {
      console.log(`[GoogleDriveService] \u270F\uFE0F Renommer fichier ${fileId} en "${newName}"`);
      const drive = await this.getDriveAPI(organizationId, userId);
      const response = await drive.files.update({
        fileId,
        supportsAllDrives: true,
        requestBody: {
          name: newName
        },
        fields: "id, name, mimeType, size, modifiedTime, webViewLink"
      });
      console.log(`[GoogleDriveService] \u2705 Fichier renomm\xE9`);
      return {
        id: response.data.id || "",
        name: response.data.name || newName,
        mimeType: response.data.mimeType || "",
        modifiedTime: response.data.modifiedTime || void 0,
        webViewLink: response.data.webViewLink || void 0
      };
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors du renommage:", error);
      throw error;
    }
  }
  /**
   * D√©placer un fichier vers un autre dossier
   */
  async moveFile(organizationId, fileId, newParentId, userId) {
    try {
      console.log(`[GoogleDriveService] \u{1F4E6} D\xE9placer fichier ${fileId} vers ${newParentId}`);
      const drive = await this.getDriveAPI(organizationId, userId);
      const file = await drive.files.get({
        fileId,
        supportsAllDrives: true,
        fields: "parents"
      });
      const previousParents = file.data.parents?.join(",") || "";
      const response = await drive.files.update({
        fileId,
        supportsAllDrives: true,
        addParents: newParentId,
        removeParents: previousParents,
        fields: "id, name, mimeType, parents, webViewLink"
      });
      console.log(`[GoogleDriveService] \u2705 Fichier d\xE9plac\xE9`);
      return {
        id: response.data.id || "",
        name: response.data.name || "",
        mimeType: response.data.mimeType || "",
        parents: response.data.parents || void 0,
        webViewLink: response.data.webViewLink || void 0
      };
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors du d\xE9placement:", error);
      throw error;
    }
  }
  /**
   * Copier un fichier
   */
  async copyFile(organizationId, fileId, newName, userId) {
    try {
      console.log(`[GoogleDriveService] \u{1F4CB} Copier fichier ${fileId}`);
      const drive = await this.getDriveAPI(organizationId, userId);
      const response = await drive.files.copy({
        fileId,
        supportsAllDrives: true,
        requestBody: newName ? { name: newName } : {},
        fields: "id, name, mimeType, size, modifiedTime, webViewLink"
      });
      console.log(`[GoogleDriveService] \u2705 Fichier copi\xE9: ${response.data.id}`);
      return {
        id: response.data.id || "",
        name: response.data.name || "",
        mimeType: response.data.mimeType || "",
        size: response.data.size || void 0,
        modifiedTime: response.data.modifiedTime || void 0,
        webViewLink: response.data.webViewLink || void 0
      };
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la copie:", error);
      throw error;
    }
  }
  /**
   * Obtenir le lien de partage d'un fichier
   */
  async getShareLink(organizationId, fileId, userId) {
    try {
      console.log(`[GoogleDriveService] \u{1F517} Obtenir lien de partage pour ${fileId}`);
      const drive = await this.getDriveAPI(organizationId, userId);
      const response = await drive.files.get({
        fileId,
        supportsAllDrives: true,
        fields: "webViewLink, webContentLink"
      });
      return {
        webViewLink: response.data.webViewLink || "",
        webContentLink: response.data.webContentLink || void 0
      };
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la r\xE9cup\xE9ration du lien:", error);
      throw error;
    }
  }
  /**
   * Rendre un fichier accessible √† tous avec un lien
   */
  async makePublic(organizationId, fileId, userId) {
    try {
      console.log(`[GoogleDriveService] \u{1F310} Rendre public ${fileId}`);
      const drive = await this.getDriveAPI(organizationId, userId);
      await drive.permissions.create({
        fileId,
        supportsAllDrives: true,
        requestBody: {
          type: "anyone",
          role: "reader"
        }
      });
      const response = await drive.files.get({
        fileId,
        supportsAllDrives: true,
        fields: "webViewLink"
      });
      console.log(`[GoogleDriveService] \u2705 Fichier rendu public`);
      return {
        webViewLink: response.data.webViewLink || ""
      };
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors du partage:", error);
      throw error;
    }
  }
  /**
   * R√©cup√©rer les fichiers r√©cents
   */
  async getRecentFiles(organizationId, pageSize = 50, userId) {
    try {
      console.log(`[GoogleDriveService] \u{1F550} R\xE9cup\xE9ration des fichiers r\xE9cents`);
      const drive = await this.getDriveAPI(organizationId, userId);
      const response = await drive.files.list({
        pageSize,
        orderBy: "viewedByMeTime desc",
        q: "trashed = false",
        fields: "files(id, name, mimeType, size, modifiedTime, webViewLink, webContentLink, iconLink, thumbnailLink, parents, shared, viewedByMeTime)"
      });
      const files = (response.data.files || []).map((file) => ({
        id: file.id || "",
        name: file.name || "Sans nom",
        mimeType: file.mimeType || "application/octet-stream",
        size: file.size || void 0,
        modifiedTime: file.modifiedTime || void 0,
        webViewLink: file.webViewLink || void 0,
        webContentLink: file.webContentLink || void 0,
        iconLink: file.iconLink || void 0,
        thumbnailLink: file.thumbnailLink || void 0,
        parents: file.parents || void 0,
        shared: file.shared || false
      }));
      console.log(`[GoogleDriveService] \u2705 ${files.length} fichiers r\xE9cents r\xE9cup\xE9r\xE9s`);
      return files;
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la r\xE9cup\xE9ration des fichiers r\xE9cents:", error);
      throw error;
    }
  }
  /**
   * R√©cup√©rer les fichiers favoris (√©toil√©s)
   */
  async getStarredFiles(organizationId, pageSize = 50, userId) {
    try {
      console.log(`[GoogleDriveService] \u2B50 R\xE9cup\xE9ration des fichiers favoris`);
      const drive = await this.getDriveAPI(organizationId, userId);
      const response = await drive.files.list({
        pageSize,
        q: "starred = true and trashed = false",
        fields: "files(id, name, mimeType, size, modifiedTime, webViewLink, webContentLink, iconLink, thumbnailLink, parents, shared, starred)",
        orderBy: "modifiedTime desc"
      });
      const files = (response.data.files || []).map((file) => ({
        id: file.id || "",
        name: file.name || "Sans nom",
        mimeType: file.mimeType || "application/octet-stream",
        size: file.size || void 0,
        modifiedTime: file.modifiedTime || void 0,
        webViewLink: file.webViewLink || void 0,
        webContentLink: file.webContentLink || void 0,
        iconLink: file.iconLink || void 0,
        thumbnailLink: file.thumbnailLink || void 0,
        parents: file.parents || void 0,
        shared: file.shared || false
      }));
      console.log(`[GoogleDriveService] \u2705 ${files.length} fichiers favoris r\xE9cup\xE9r\xE9s`);
      return files;
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la r\xE9cup\xE9ration des fichiers favoris:", error);
      throw error;
    }
  }
  /**
   * Ajouter/retirer un fichier des favoris
   */
  async toggleStar(organizationId, fileId, starred, userId) {
    try {
      console.log(`[GoogleDriveService] \u2B50 ${starred ? "Ajouter aux" : "Retirer des"} favoris: ${fileId}`);
      const drive = await this.getDriveAPI(organizationId, userId);
      await drive.files.update({
        fileId,
        supportsAllDrives: true,
        requestBody: {
          starred
        }
      });
      console.log(`[GoogleDriveService] \u2705 Favori mis \xE0 jour`);
      return true;
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la mise \xE0 jour du favori:", error);
      throw error;
    }
  }
  /**
   * R√©cup√©rer les fichiers dans la corbeille
   */
  async getTrash(organizationId, pageSize = 50, userId) {
    try {
      console.log(`[GoogleDriveService] \u{1F5D1}\uFE0F R\xE9cup\xE9ration de la corbeille`);
      const drive = await this.getDriveAPI(organizationId, userId);
      const response = await drive.files.list({
        pageSize,
        q: "trashed = true",
        fields: "files(id, name, mimeType, size, modifiedTime, webViewLink, iconLink, thumbnailLink, trashedTime)",
        orderBy: "modifiedTime desc"
      });
      const files = (response.data.files || []).map((file) => ({
        id: file.id || "",
        name: file.name || "Sans nom",
        mimeType: file.mimeType || "application/octet-stream",
        size: file.size || void 0,
        modifiedTime: file.modifiedTime || void 0,
        webViewLink: file.webViewLink || void 0,
        iconLink: file.iconLink || void 0,
        thumbnailLink: file.thumbnailLink || void 0
      }));
      console.log(`[GoogleDriveService] \u2705 ${files.length} fichiers dans la corbeille`);
      return files;
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la r\xE9cup\xE9ration de la corbeille:", error);
      throw error;
    }
  }
  /**
   * Restaurer un fichier de la corbeille
   */
  async restoreFile(organizationId, fileId, userId) {
    try {
      console.log(`[GoogleDriveService] \u267B\uFE0F Restaurer fichier: ${fileId}`);
      const drive = await this.getDriveAPI(organizationId, userId);
      await drive.files.update({
        fileId,
        supportsAllDrives: true,
        requestBody: {
          trashed: false
        }
      });
      console.log(`[GoogleDriveService] \u2705 Fichier restaur\xE9`);
      return true;
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la restauration:", error);
      throw error;
    }
  }
  /**
   * Supprimer d√©finitivement un fichier
   */
  async deleteFilePermanently(organizationId, fileId, userId) {
    try {
      console.log(`[GoogleDriveService] \u274C Suppression d\xE9finitive: ${fileId}`);
      const drive = await this.getDriveAPI(organizationId, userId);
      await drive.files.delete({
        fileId,
        supportsAllDrives: true
      });
      console.log(`[GoogleDriveService] \u2705 Fichier supprim\xE9 d\xE9finitivement`);
      return true;
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la suppression d\xE9finitive:", error);
      throw error;
    }
  }
  /**
   * Vider la corbeille
   */
  async emptyTrash(organizationId, userId) {
    try {
      console.log(`[GoogleDriveService] \u{1F5D1}\uFE0F Vider la corbeille`);
      const drive = await this.getDriveAPI(organizationId, userId);
      await drive.files.emptyTrash();
      console.log(`[GoogleDriveService] \u2705 Corbeille vid\xE9e`);
      return true;
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors du vidage de la corbeille:", error);
      throw error;
    }
  }
  /**
   * T√©l√©charger un fichier (obtenir l'URL de t√©l√©chargement)
   */
  async getDownloadUrl(organizationId, fileId, userId) {
    try {
      console.log(`[GoogleDriveService] \u2B07\uFE0F Obtenir URL de t\xE9l\xE9chargement: ${fileId}`);
      const drive = await this.getDriveAPI(organizationId, userId);
      const response = await drive.files.get({
        fileId,
        supportsAllDrives: true,
        fields: "name, mimeType, webContentLink"
      });
      const googleDocsMimeTypes = {
        "application/vnd.google-apps.document": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "application/vnd.google-apps.spreadsheet": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "application/vnd.google-apps.presentation": "application/vnd.openxmlformats-officedocument.presentationml.presentation"
      };
      const mimeType = response.data.mimeType || "";
      const exportMimeType = googleDocsMimeTypes[mimeType];
      if (exportMimeType) {
        return {
          downloadUrl: `https://www.googleapis.com/drive/v3/files/${fileId}/export?mimeType=${encodeURIComponent(exportMimeType)}`,
          fileName: response.data.name || "file",
          mimeType: exportMimeType
        };
      }
      return {
        downloadUrl: response.data.webContentLink || `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,
        fileName: response.data.name || "file",
        mimeType
      };
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la r\xE9cup\xE9ration de l'URL:", error);
      throw error;
    }
  }
  /**
   * Cr√©er un document Google (Docs, Sheets, Slides)
   */
  async createGoogleDoc(organizationId, name, type, parentId = "root", userId) {
    try {
      console.log(`[GoogleDriveService] \u{1F4C4} Cr\xE9er ${type}: "${name}"`);
      const drive = await this.getDriveAPI(organizationId, userId);
      const mimeTypes = {
        document: "application/vnd.google-apps.document",
        spreadsheet: "application/vnd.google-apps.spreadsheet",
        presentation: "application/vnd.google-apps.presentation"
      };
      const response = await drive.files.create({
        requestBody: {
          name,
          mimeType: mimeTypes[type],
          parents: [parentId]
        },
        fields: "id, name, mimeType, modifiedTime, webViewLink"
      });
      console.log(`[GoogleDriveService] \u2705 ${type} cr\xE9\xE9: ${response.data.id}`);
      return {
        id: response.data.id || "",
        name: response.data.name || name,
        mimeType: response.data.mimeType || mimeTypes[type],
        modifiedTime: response.data.modifiedTime || void 0,
        webViewLink: response.data.webViewLink || void 0
      };
    } catch (error) {
      console.error("[GoogleDriveService] \u274C Erreur lors de la cr\xE9ation:", error);
      throw error;
    }
  }
};
var googleDriveService = GoogleDriveService.getInstance();

// src/google-auth/controllers/GmailController.ts
var getThreads = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    const { maxResults = 10, pageToken, q } = req2.query;
    const result = await gmailService.getMessages({
      maxResults: Number(maxResults),
      pageToken,
      q
    });
    res.json(result);
  } catch (error) {
    console.error("[Gmail Controller] Erreur getThreads:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des threads" });
  }
};
var getMessages = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    const {
      maxResults = 10,
      pageToken,
      q,
      labelIds,
      mailbox
      // Frontend peut envoyer mailbox au lieu de labelIds
    } = req2.query;
    console.log("[Gmail Controller] Param\xE8tres re\xE7us:", { maxResults, pageToken, q, labelIds, mailbox });
    let finalLabelIds;
    if (labelIds) {
      finalLabelIds = Array.isArray(labelIds) ? labelIds : [labelIds];
    } else if (mailbox) {
      const mailboxStr = mailbox;
      console.log(`[Gmail Controller] \u{1F4E6} Conversion mailbox: ${mailboxStr}`);
      switch (mailboxStr.toLowerCase()) {
        case "inbox":
          finalLabelIds = ["INBOX"];
          break;
        case "sent":
          finalLabelIds = ["SENT"];
          break;
        case "drafts":
        case "draft":
          finalLabelIds = ["DRAFT"];
          break;
        case "starred":
          finalLabelIds = ["STARRED"];
          break;
        case "trash":
          finalLabelIds = ["TRASH"];
          break;
        case "spam":
          finalLabelIds = ["SPAM"];
          break;
        case "all":
          finalLabelIds = void 0;
          break;
        default:
          finalLabelIds = [mailboxStr];
      }
      console.log(`[Gmail Controller] \u2705 Label final: ${finalLabelIds}`);
    }
    const result = await gmailService.getMessages({
      maxResults: Number(maxResults),
      pageToken,
      q,
      labelIds: finalLabelIds
    });
    res.json(result);
  } catch (error) {
    console.error("[Gmail Controller] Erreur getMessages:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des messages", details: error?.message });
  }
};
var getMessage = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    const { id } = req2.params;
    if (!id) {
      return res.status(400).json({ error: "ID du message manquant" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    const message = await gmailService.getMessageDetails(id);
    if (!message) {
      return res.status(404).json({ error: "Message non trouv\xE9" });
    }
    res.json(message);
  } catch (error) {
    console.error("[Gmail Controller] Erreur getMessage:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration du message" });
  }
};
var sendMessage = async (req2, res) => {
  console.log("[Gmail Controller] \u{1F680}\u{1F680}\u{1F680} === D\xC9BUT SENDMESSAGE - CONTR\xD4LEUR ATTEINT (FORMIDABLE) ===");
  console.log("[Gmail Controller] \u{1F3AF} Timestamp:", (/* @__PURE__ */ new Date()).toISOString());
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    console.log("[Gmail Controller] \u{1F4CB} Organization ID re\xE7u:", organizationId);
    if (!organizationId) {
      console.log("[Gmail Controller] \u274C Organization ID manquant");
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    console.log("[Gmail Controller] \u{1F50D} === ANALYSE DES DONN\xC9ES RE\xC7UES (FORMIDABLE) ===");
    console.log("[Gmail Controller] \u{1F50D} RAW req.body:", JSON.stringify(req2.body, null, 2));
    console.log("[Gmail Controller] \u{1F50D} Type de req.body:", typeof req2.body);
    console.log("[Gmail Controller] \u{1F50D} Cl\xE9s dans req.body:", Object.keys(req2.body || {}));
    console.log("[Gmail Controller] \u{1F50D} RAW req.files:", req2.files);
    console.log("[Gmail Controller] \u{1F50D} Type de req.files:", typeof req2.files);
    if (req2.files && typeof req2.files === "object") {
      console.log("[Gmail Controller] \u{1F50D} Cl\xE9s dans req.files:", Object.keys(req2.files));
      if ("attachments" in req2.files) {
        const attachments2 = req2.files["attachments"];
        console.log("[Gmail Controller] \u{1F50D} Attachments trouv\xE9s:", Array.isArray(attachments2) ? attachments2.length : 1);
        if (Array.isArray(attachments2)) {
          attachments2.forEach((file, index) => {
            console.log("[Gmail Controller] \u{1F4CE} Fichier", index + 1, ":", {
              name: file.name,
              size: file.size,
              mimetype: file.mimetype
            });
          });
        } else {
          console.log("[Gmail Controller] \u{1F4CE} Fichier unique:", {
            name: attachments2.name,
            size: attachments2.size,
            mimetype: attachments2.mimetype
          });
        }
      }
    }
    const to = req2.body.to;
    const subject = req2.body.subject;
    const body2 = req2.body.body || "";
    const isHtml = req2.body.isHtml === true || req2.body.isHtml === "true";
    const cc = req2.body.cc;
    const bcc = req2.body.bcc;
    const fromName = req2.body.fromName;
    console.log("[Gmail Controller] \u{1F4E7} Donn\xE9es extraites:", {
      to,
      subject,
      body: body2?.substring(0, 100),
      isHtml,
      isHtmlRaw: req2.body.isHtml,
      cc,
      bcc,
      fromName: fromName || "Par d\xE9faut: 2Thier CRM"
    });
    if (!to || !subject) {
      console.log("[Gmail Controller] \u274C Champs obligatoires manquants:", { to, subject });
      return res.status(400).json({ error: "Destinataire et sujet requis" });
    }
    console.log("[Gmail Controller] \u{1F4E4} Envoi email avec", req2.files ? Object.keys(req2.files) : "aucun", "fichiers");
    console.log("[Gmail Controller] \u{1F4E7} Destinataire:", to, "Sujet:", subject);
    console.log("[Gmail Controller]  Cr\xE9ation du service Gmail...");
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      console.log("[Gmail Controller] \u274C Impossible de cr\xE9er le service Gmail");
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    console.log("[Gmail Controller] \u2705 Service Gmail cr\xE9\xE9 avec succ\xE8s");
    let attachments = [];
    if (req2.files && typeof req2.files === "object" && "attachments" in req2.files) {
      const files = req2.files["attachments"];
      attachments = Array.isArray(files) ? files : [files];
    }
    console.log("[Gmail Controller] \u{1F4CE} Nombre de pi\xE8ces jointes trait\xE9es:", attachments.length);
    if (attachments.length > 0) {
      console.log("[Gmail Controller] \u{1F4CE} D\xE9tails des pi\xE8ces jointes:", attachments.map((f) => ({
        filename: f.name,
        size: f.size,
        mimetype: f.mimetype
      })));
    }
    const emailData = {
      to,
      subject,
      body: body2 || "",
      isHtml: isHtml || false,
      cc,
      bcc,
      fromName: fromName || "2Thier CRM",
      // üÜï Nom professionnel par d√©faut
      attachments: attachments.length > 0 ? attachments.map((file) => ({
        filename: file.name,
        content: file.data,
        // Formidable utilise 'data' au lieu de 'buffer'
        mimeType: file.mimetype
      })) : void 0
    };
    console.log("[Gmail Controller] \u{1F4CE} Donn\xE9es email pr\xE9par\xE9es (VERSION ANTI-SPAM):", {
      to: emailData.to,
      subject: emailData.subject,
      fromName: emailData.fromName,
      attachments: emailData.attachments?.length || 0
    });
    console.log("[Gmail Controller] \u{1F680} Appel gmailService.sendEmail...");
    const result = await gmailService.sendEmail(emailData);
    if (!result) {
      console.log("[Gmail Controller] \u274C Aucun r\xE9sultat de sendEmail");
      return res.status(500).json({ error: "Erreur lors de l'envoi du message" });
    }
    console.log("[Gmail Controller] \u2705 Email envoy\xE9 avec succ\xE8s:", result);
    res.json({
      success: true,
      message: "Email envoy\xE9 avec succ\xE8s",
      data: result
    });
    console.log("[Gmail Controller] \u2705 R\xE9ponse envoy\xE9e au client");
  } catch (error) {
    console.error("[Gmail Controller] \u274C\u274C\u274C ERREUR COMPL\xC8TE sendMessage:", error);
    console.error("[Gmail Controller] \u274C Type erreur:", typeof error);
    console.error("[Gmail Controller] \u274C Message erreur:", error?.message);
    console.error("[Gmail Controller] \u274C Stack trace:", error?.stack);
    res.status(500).json({ error: "Erreur lors de l'envoi du message" });
  }
};
var modifyMessage = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    const { id } = req2.params;
    const { action: action2, addLabelIds, removeLabelIds } = req2.body;
    if (!id) {
      return res.status(400).json({ error: "ID du message manquant" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    let result = false;
    if (addLabelIds || removeLabelIds) {
      console.log("[Gmail Controller] Modification des labels:", { addLabelIds, removeLabelIds });
      if (addLabelIds && addLabelIds.includes("STARRED")) {
        result = await gmailService.markAsStarred(id, true);
      } else if (removeLabelIds && removeLabelIds.includes("STARRED")) {
        result = await gmailService.markAsStarred(id, false);
      } else {
        result = await gmailService.modifyLabels(id, addLabelIds || [], removeLabelIds || []);
      }
    } else if (action2) {
      switch (action2) {
        case "markAsRead":
          result = await gmailService.markAsRead(id, true);
          break;
        case "markAsUnread":
          result = await gmailService.markAsRead(id, false);
          break;
        default:
          return res.status(400).json({ error: "Action non support\xE9e" });
      }
    } else {
      return res.status(400).json({ error: "Action ou modification de labels requis" });
    }
    res.json({
      success: result,
      message: result ? "Message modifi\xE9 avec succ\xE8s" : "Erreur lors de la modification"
    });
  } catch (error) {
    console.error("[Gmail Controller] Erreur modifyMessage:", error);
    res.status(500).json({ error: "Erreur lors de la modification du message" });
  }
};
var deleteMessage = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    const { id } = req2.params;
    if (!id) {
      return res.status(400).json({ error: "ID du message manquant" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    const result = await gmailService.deleteMessage(id);
    res.json({
      success: result,
      message: result ? "Message supprim\xE9 avec succ\xE8s" : "Erreur lors de la suppression"
    });
  } catch (error) {
    console.error("[Gmail Controller] Erreur deleteMessage:", error);
    res.status(500).json({ error: "Erreur lors de la suppression du message" });
  }
};
var getLabels = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    const labels = await gmailService.getLabels();
    res.json(labels);
  } catch (error) {
    console.error("[Gmail Controller] Erreur getLabels:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des labels", details: error?.message });
  }
};
var trashMessage = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    const { id } = req2.params;
    if (!id) {
      return res.status(400).json({ error: "ID du message manquant" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    const result = await gmailService.trashMessage(id);
    res.json({
      success: result,
      message: result ? "Message d\xE9plac\xE9 vers la corbeille avec succ\xE8s" : "Erreur lors de la suppression"
    });
  } catch (error) {
    console.error("[Gmail Controller] Erreur trashMessage:", error);
    res.status(500).json({ error: "Erreur lors de la suppression du message" });
  }
};
var untrashMessage = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    const { id } = req2.params;
    if (!id) {
      return res.status(400).json({ error: "ID du message manquant" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    const result = await gmailService.untrashMessage(id);
    res.json({
      success: result,
      message: result ? "Message restaur\xE9 de la corbeille avec succ\xE8s" : "Erreur lors de la restauration"
    });
  } catch (error) {
    console.error("[Gmail Controller] Erreur untrashMessage:", error);
    res.status(500).json({ error: "Erreur lors de la restauration du message" });
  }
};
var emptyTrash = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    const result = await gmailService.emptyTrash();
    res.json({
      success: result,
      message: result ? "Corbeille vid\xE9e avec succ\xE8s" : "Erreur lors du vidage de la corbeille"
    });
  } catch (error) {
    console.error("[Gmail Controller] Erreur emptyTrash:", error);
    res.status(500).json({ error: "Erreur lors du vidage de la corbeille" });
  }
};
var createLabel = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    const { name } = req2.body;
    if (!name) {
      return res.status(400).json({ error: "Nom du label requis" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    const label = await gmailService.createLabel(name);
    if (!label) {
      return res.status(500).json({ error: "Erreur lors de la cr\xE9ation du label" });
    }
    res.json({
      success: true,
      data: label
    });
  } catch (error) {
    console.error("[Gmail Controller] Erreur createLabel:", error);
    res.status(500).json({ error: "Erreur lors de la cr\xE9ation du label" });
  }
};
var updateLabel = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    const { id } = req2.params;
    const { name } = req2.body;
    if (!id || !name) {
      return res.status(400).json({ error: "ID et nom du label requis" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    const result = await gmailService.updateLabel(id, name);
    res.json({
      success: result,
      message: result ? "Label modifi\xE9 avec succ\xE8s" : "Erreur lors de la modification"
    });
  } catch (error) {
    console.error("[Gmail Controller] Erreur updateLabel:", error);
    res.status(500).json({ error: "Erreur lors de la modification du label" });
  }
};
var deleteLabel = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    const { id } = req2.params;
    if (!id) {
      return res.status(400).json({ error: "ID du label manquant" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    const result = await gmailService.deleteLabel(id);
    res.json({
      success: result,
      message: result ? "Label supprim\xE9 avec succ\xE8s" : "Erreur lors de la suppression"
    });
  } catch (error) {
    console.error("[Gmail Controller] Erreur deleteLabel:", error);
    res.status(500).json({ error: "Erreur lors de la suppression du label" });
  }
};
var getAttachment = async (req2, res) => {
  try {
    let organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId && req2.user?.organizationId) {
      organizationId = req2.user.organizationId;
    }
    if (!organizationId) {
      console.log("[Gmail Controller] \u274C Aucune organisation trouv\xE9e pour l'utilisateur");
      return res.status(400).json({
        error: "Organization ID manquant",
        message: "Impossible de d\xE9terminer l'organisation de l'utilisateur"
      });
    }
    const { messageId, attachmentId } = req2.params;
    const { preview } = req2.query;
    if (!messageId || !attachmentId) {
      return res.status(400).json({ error: "Message ID et Attachment ID requis" });
    }
    console.log(`[Gmail Controller] \u{1F4CE} R\xE9cup\xE9ration pi\xE8ce jointe: ${attachmentId} du message: ${messageId}`);
    console.log(`[Gmail Controller] \u{1F3E2} Organization ID utilis\xE9: ${organizationId}`);
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    const attachment = await gmailService.getAttachment(messageId, attachmentId);
    if (!attachment) {
      return res.status(404).json({ error: "Pi\xE8ce jointe non trouv\xE9e" });
    }
    let contentType = attachment.mimeType;
    let contentDisposition = "attachment";
    const filename = attachment.filename;
    const fileExtension = filename.split(".").pop()?.toLowerCase();
    if (preview === "true") {
      contentDisposition = "inline";
      if (fileExtension === "pdf" && !contentType.includes("pdf")) {
        contentType = "application/pdf";
      } else if (["png", "jpg", "jpeg", "gif", "webp"].includes(fileExtension || "")) {
        if (fileExtension === "png") contentType = "image/png";
        else if (["jpg", "jpeg"].includes(fileExtension)) contentType = "image/jpeg";
        else if (fileExtension === "gif") contentType = "image/gif";
        else if (fileExtension === "webp") contentType = "image/webp";
      }
    }
    res.setHeader("Content-Type", contentType);
    res.setHeader("Content-Disposition", `${contentDisposition}; filename="${filename}"`);
    if (preview === "true") {
      res.setHeader("X-Frame-Options", "SAMEORIGIN");
      res.setHeader("Content-Security-Policy", "frame-ancestors 'self'");
      res.setHeader("Cache-Control", "public, max-age=3600");
      res.setHeader("Access-Control-Allow-Origin", "*");
      res.setHeader("Access-Control-Allow-Methods", "GET");
      res.setHeader("Access-Control-Allow-Headers", "Content-Type");
      if (contentType === "application/pdf") {
        res.setHeader("Accept-Ranges", "bytes");
      }
    }
    console.log(`[Gmail Controller] \u2705 Serving attachment: ${filename}, Type: ${contentType}, Disposition: ${contentDisposition}`);
    res.send(attachment.data);
  } catch (error) {
    console.error("[Gmail Controller] Erreur getAttachment:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration de la pi\xE8ce jointe",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
};
var getDrafts = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    const result = await gmailService.getDrafts();
    res.json(result);
  } catch (error) {
    console.error("[Gmail Controller] Erreur getDrafts:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des brouillons" });
  }
};
var saveDraft = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    const { to, subject, body: body2, isHtml, cc, bcc, draftId } = req2.body;
    if (!to || !subject) {
      return res.status(400).json({ error: "Destinataire et sujet requis" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    const result = await gmailService.saveDraft({
      to,
      subject,
      body: body2 || "",
      isHtml: isHtml || false,
      cc,
      bcc,
      draftId
      // Pour mise √† jour d'un brouillon existant
    });
    if (result) {
      res.json({
        success: true,
        message: draftId ? "Brouillon mis \xE0 jour avec succ\xE8s" : "Brouillon sauvegard\xE9 avec succ\xE8s",
        data: result
      });
    } else {
      res.status(500).json({
        success: false,
        error: "Erreur lors de la sauvegarde du brouillon"
      });
    }
  } catch (error) {
    console.error("[Gmail Controller] Erreur saveDraft:", error);
    res.status(500).json({ error: "Erreur lors de la sauvegarde du brouillon" });
  }
};
var deleteDraft = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    const { id } = req2.params;
    if (!id) {
      return res.status(400).json({ error: "ID du brouillon manquant" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    const result = await gmailService.deleteDraft(id);
    res.json({
      success: result,
      message: result ? "Brouillon supprim\xE9 avec succ\xE8s" : "Erreur lors de la suppression"
    });
  } catch (error) {
    console.error("[Gmail Controller] Erreur deleteDraft:", error);
    res.status(500).json({ error: "Erreur lors de la suppression du brouillon" });
  }
};
var sendDraft = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organization ID manquant dans la requ\xEAte" });
    }
    const { id } = req2.params;
    if (!id) {
      return res.status(400).json({ error: "ID du brouillon manquant" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    if (!gmailService) {
      return res.status(401).json({ error: "Google non connect\xE9 pour cette organisation" });
    }
    const result = await gmailService.sendDraft(id);
    if (result) {
      res.json({
        success: true,
        message: "Brouillon envoy\xE9 avec succ\xE8s",
        data: result
      });
    } else {
      res.status(500).json({
        success: false,
        error: "Erreur lors de l'envoi du brouillon"
      });
    }
  } catch (error) {
    console.error("[Gmail Controller] Erreur sendDraft:", error);
    res.status(500).json({ error: "Erreur lors de l'envoi du brouillon" });
  }
};
var health = async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    if (!organizationId) {
      return res.status(200).json({ ok: false, reason: "organizationId manquant" });
    }
    const gmailService = await GoogleGmailService.create(organizationId, req2.user?.id || req2.user?.userId);
    return res.status(200).json({ ok: !!gmailService });
  } catch (e) {
    return res.status(200).json({ ok: false, reason: e?.message });
  }
};

// src/routes/gmailRoutes.ts
var router = import_express2.default.Router();
console.log("<<<<< [D\xC9MARRAGE] Le fichier 'src/routes/gmailRoutes.ts' est en cours de chargement avec le nouveau contr\xF4leur centralis\xE9. >>>>>");
router.use(authenticateToken);
router.use(extractOrganization);
router.get("/threads", getThreads);
router.get("/messages", getMessages);
router.get("/messages/:id", getMessage);
router.post("/messages/send", sendMessage);
router.post("/messages/:id/modify", modifyMessage);
router.post("/messages/:id/trash", trashMessage);
router.post("/messages/:id/untrash", untrashMessage);
router.delete("/messages/:id", deleteMessage);
router.post("/trash/empty", emptyTrash);
router.get("/labels", getLabels);
router.post("/labels", createLabel);
router.put("/labels/:id", updateLabel);
router.delete("/labels/:id", deleteLabel);
router.get("/messages/:messageId/attachments/:attachmentId", getAttachment);
router.get("/health", health);
var gmailRoutes_default = router;

// src/routes/misc.ts
var import_express3 = require("express");
var import_client2 = require("@prisma/client");
var import_bcryptjs3 = __toESM(require("bcryptjs"), 1);
var import_jsonwebtoken4 = __toESM(require("jsonwebtoken"), 1);

// src/middlewares/auth.ts
var import_jsonwebtoken3 = __toESM(require("jsonwebtoken"), 1);
init_database();
var import_bcryptjs2 = __toESM(require("bcryptjs"), 1);
var prisma2 = db;
var authMiddleware = async (req2, res, next) => {
  const authHeader = req2.headers.authorization;
  const cookieToken = req2.cookies?.token;
  const orgIdFromHeader = req2.headers["x-organization-id"];
  let token;
  if (cookieToken) {
    token = cookieToken;
  } else if (authHeader && authHeader.startsWith("Bearer ")) {
    token = authHeader.split(" ")[1];
  }
  if (!token) {
    return res.status(401).json({ error: "Authentification requise" });
  }
  if (token.startsWith("dev-token-")) {
    return res.status(401).json({ error: "Token de d\xE9veloppement non autoris\xE9" });
  }
  try {
    const decoded = import_jsonwebtoken3.default.verify(token, JWT_SECRET2);
    const user = await prisma2.user.findUnique({
      where: { id: decoded.userId }
    });
    if (!user) {
      console.error("[AUTH] Utilisateur non trouv\xE9 pour l'ID:", decoded.userId);
      return res.status(401).json({ error: "Authentification invalide" });
    }
    let organizationId = decoded.organizationId || null;
    const orgIdFromQuery = req2.query?.organizationId || req2.query?.orgId;
    if (!organizationId && orgIdFromQuery) {
      organizationId = orgIdFromQuery;
    }
    if (orgIdFromHeader) {
      organizationId = orgIdFromHeader;
    }
    if (organizationId) {
      const organization = await prisma2.organization.findUnique({ where: { id: organizationId } });
      if (!organization) {
        console.error("[AUTH] Organisation non trouv\xE9e pour l'ID:", organizationId);
        return res.status(404).json({ error: "Organisation non trouv\xE9e" });
      }
    }
    req2.user = {
      userId: user.id,
      role: user.role || "user",
      organizationId,
      roles: user.role ? [user.role] : [],
      firstname: user.firstName || "",
      lastname: user.lastName || "",
      email: user.email,
      // üëë SUPER IMPORTANT: D√©finir isSuperAdmin pour que les middlewares le reconnaissent ! üëë
      isSuperAdmin: user.role === "super_admin"
    };
    return next();
  } catch (error) {
    console.error("[AUTH] Erreur de v\xE9rification du token:", error);
    return res.status(401).json({ error: "Token d'authentification invalide" });
  }
};
var requireRole = (roles) => {
  return (req2, res, next) => {
    if (!req2.user) {
      return res.status(401).json({ success: false, message: "Authentification requise." });
    }
    const userRole = req2.user.role;
    const userRoles = req2.user.roles || [];
    const hasRequiredRole = roles.includes(userRole) || userRoles.some((role) => roles.includes(role));
    if (hasRequiredRole) {
      next();
    } else {
      res.status(403).json({ success: false, message: "Acc\xE8s non autoris\xE9." });
    }
  };
};

// src/middlewares/impersonation.ts
init_database();
var prisma3 = db;
async function impersonationMiddleware(req2, res, next) {
  const authReq = req2;
  const impersonateUserId = authReq.headers["x-impersonate-user-id"];
  const impersonateOrgId = authReq.headers["x-impersonate-org-id"];
  const originalUser = authReq.user;
  if (!originalUser || originalUser.role !== "super_admin" || !impersonateUserId && !impersonateOrgId) {
    return next();
  }
  console.log(
    `[Impersonation] Middleware triggered for super_admin ${originalUser.userId}. Headers: user=${impersonateUserId}, org=${impersonateOrgId}`
  );
  try {
    if (impersonateUserId) {
      const userToImpersonate = await prisma3.user.findUnique({
        where: { id: impersonateUserId }
      });
      if (!userToImpersonate) {
        return res.status(404).json({ error: "Utilisateur \xE0 usurper non trouv\xE9." });
      }
      authReq.impersonatedUser = userToImpersonate;
      authReq.impersonatedOrganizationId = impersonateOrgId;
      console.log(
        `[Impersonation] Stored impersonatedUser: ${authReq.impersonatedUser.id}`
      );
    } else if (impersonateOrgId) {
      authReq.impersonatedOrganizationId = impersonateOrgId;
    }
    if (authReq.impersonatedOrganizationId) {
      console.log(
        `[Impersonation] Stored impersonatedOrganizationId: ${authReq.impersonatedOrganizationId}`
      );
    }
    next();
  } catch (error) {
    console.error("[Impersonation] Erreur:", error);
    res.status(500).json({ error: "Une erreur est survenue durant l'usurpation." });
  }
}

// src/routes/misc.ts
init_prisma();
var import_crypto3 = require("crypto");
var router2 = (0, import_express3.Router)();
var userWithOrgsArgs = {
  include: {
    UserOrganization: {
      include: {
        Organization: true,
        Role: {
          include: {
            Permission: true
            // CORRECTION: 'permissions' devient 'Permission'
          }
        }
      }
    }
  }
};
router2.post("/register", async (req2, res) => {
  const {
    email,
    password,
    firstName,
    lastName,
    registrationType = "freelance",
    // Par d√©faut: utilisateur libre
    organizationName,
    // Pour createOrg
    domain,
    // Pour createOrg (optionnel)
    organizationId,
    // Pour joinOrg
    message
    // Pour joinOrg (message de demande)
  } = req2.body;
  if (!email || !password || !firstName) {
    return res.status(400).json({ error: "Email, mot de passe et pr\xE9nom sont requis" });
  }
  if (registrationType === "createOrg" && !organizationName) {
    return res.status(400).json({ error: "Le nom de l'organisation est requis pour cr\xE9er une organisation" });
  }
  if (registrationType === "joinOrg" && !organizationId) {
    return res.status(400).json({ error: "L'ID de l'organisation est requis pour rejoindre une organisation" });
  }
  try {
    const hashedPassword = await import_bcryptjs3.default.hash(password, 10);
    const result = await db.$transaction(async (tx) => {
      const userId = (0, import_crypto3.randomUUID)();
      const user = await tx.user.create({
        data: {
          id: userId,
          email,
          passwordHash: hashedPassword,
          firstName,
          lastName,
          status: "active",
          role: "user"
        }
      });
      let organization = null;
      let joinRequest = null;
      if (registrationType === "createOrg") {
        const orgId = (0, import_crypto3.randomUUID)();
        organization = await tx.organization.create({
          data: {
            id: orgId,
            name: organizationName.trim(),
            description: domain ? `Domaine: ${domain}` : void 0,
            status: "active"
          }
        });
        const adminRole = await tx.role.create({
          data: {
            id: (0, import_crypto3.randomUUID)(),
            name: "admin",
            label: "Administrateur",
            organizationId: orgId
          }
        });
        await tx.role.create({
          data: {
            id: (0, import_crypto3.randomUUID)(),
            name: "user",
            label: "Utilisateur",
            organizationId: orgId
          }
        });
        await tx.userOrganization.create({
          data: {
            id: (0, import_crypto3.randomUUID)(),
            userId: user.id,
            organizationId: orgId,
            roleId: adminRole.id,
            status: import_client2.UserOrganizationStatus.ACTIVE
          }
        });
        console.log(`[Register] Utilisateur ${email} a cr\xE9\xE9 l'organisation "${organizationName}" (${orgId})`);
      } else if (registrationType === "joinOrg") {
        const targetOrg = await tx.organization.findUnique({
          where: { id: organizationId }
        });
        if (!targetOrg) {
          throw new Error("Organisation non trouv\xE9e");
        }
        joinRequest = await tx.joinRequest.create({
          data: {
            id: (0, import_crypto3.randomUUID)(),
            userId: user.id,
            organizationId,
            message: message?.trim() || null,
            status: import_client2.JoinRequestStatus.PENDING
          },
          include: {
            Organization: { select: { name: true } }
          }
        });
        console.log(`[Register] Utilisateur ${email} a envoy\xE9 une demande \xE0 "${targetOrg.name}" (${organizationId})`);
      } else {
        console.log(`[Register] Nouvel utilisateur libre: ${email}`);
      }
      return { user, organization, joinRequest };
    });
    let successMessage = "Inscription r\xE9ussie !";
    if (registrationType === "createOrg") {
      successMessage = `Organisation "${organizationName}" cr\xE9\xE9e avec succ\xE8s. Vous en \xEAtes l'administrateur.`;
    } else if (registrationType === "joinOrg") {
      successMessage = `Demande d'adh\xE9sion envoy\xE9e. En attente d'approbation de l'organisation.`;
    }
    res.status(201).json({
      success: true,
      id: result.user.id,
      email: result.user.email,
      registrationType,
      organization: result.organization ? { id: result.organization.id, name: result.organization.name } : null,
      joinRequest: result.joinRequest ? { id: result.joinRequest.id, status: result.joinRequest.status } : null,
      message: successMessage
    });
  } catch (error) {
    console.error("[API][register] Erreur lors de l'inscription:", error);
    if (error instanceof import_client2.Prisma.PrismaClientKnownRequestError && error.code === "P2002") {
      return res.status(409).json({ error: "Cette adresse email est d\xE9j\xE0 utilis\xE9e." });
    }
    if (error instanceof Error) {
      return res.status(400).json({ error: error.message });
    }
    res.status(500).json({ error: "Erreur lors de la cr\xE9ation de l'utilisateur" });
  }
});
router2.post("/login", async (req2, res) => {
  const { email, password } = req2.body;
  if (!email || !password) {
    return res.status(400).json({ error: "L'email et le mot de passe sont requis" });
  }
  try {
    const user = await db.user.findUnique({
      where: { email },
      ...userWithOrgsArgs
    });
    if (!user) {
      return res.status(401).json({ error: "Identifiants invalides" });
    }
    const isPasswordValid = await import_bcryptjs3.default.compare(password, user.passwordHash);
    if (!isPasswordValid) {
      return res.status(401).json({ error: "Identifiants invalides" });
    }
    const freshUser = await db.user.findUnique({
      where: { id: user.id },
      ...userWithOrgsArgs
    });
    if (!freshUser) {
      return res.status(404).json({ error: "Utilisateur non trouv\xE9 apr\xE8s la v\xE9rification." });
    }
    const isSuperAdmin2 = freshUser.role === "super_admin";
    const mainOrg = freshUser.UserOrganization && freshUser.UserOrganization.length > 0 ? freshUser.UserOrganization.find((uo) => uo.Organization && uo.Role && uo.status === import_client2.UserOrganizationStatus.ACTIVE) || freshUser.UserOrganization.find((uo) => uo.Organization && uo.Role) : null;
    if (!isSuperAdmin2 && !mainOrg) {
      console.log(`[API][login] Utilisateur ${user.id} se connecte sans organisation principale. C'est un utilisateur "flottant".`);
    }
    let tokenRole;
    if (isSuperAdmin2) {
      tokenRole = "super_admin";
    } else if (mainOrg && mainOrg.Role) {
      tokenRole = mainOrg.Role.name;
    } else {
      tokenRole = "user";
    }
    const token = import_jsonwebtoken4.default.sign(
      {
        userId: user.id,
        role: tokenRole,
        // L'organizationId peut √™tre null pour un super_admin sans orga principale
        organizationId: mainOrg ? mainOrg.organizationId : null
      },
      JWT_SECRET2,
      { expiresIn: "24h" }
    );
    const { passwordHash: _passwordHash, UserOrganization: userOrganizations = [], ...userInfos } = freshUser;
    const organizations = userOrganizations.filter((uo) => uo.Organization && uo.Role).map((uo) => ({
      ...uo.Organization,
      role: uo.Role.name,
      roleLabel: uo.Role.label,
      userOrganizationId: uo.id,
      // Ajout de l'ID de la relation
      status: uo.status
      // Ajout du statut de la relation
    }));
    console.log("\u{1F36A} [LOGIN] D\xE9finition du cookie d'authentification...");
    const isProduction4 = process.env.NODE_ENV === "production";
    const isCodespaces2 = process.env.CODESPACES === "true";
    const needsSecureCookie = isProduction4 || isCodespaces2;
    res.cookie("token", token, {
      httpOnly: true,
      secure: needsSecureCookie,
      sameSite: needsSecureCookie ? "none" : "lax",
      maxAge: 24 * 60 * 60 * 1e3,
      // 24 heures en millisecondes
      path: "/"
    });
    console.log("\u2705 [LOGIN] Cookie d\xE9fini avec succ\xE8s (secure:", needsSecureCookie, ")");
    res.json({
      token,
      user: userInfos,
      organizations
    });
  } catch (error) {
    console.error("[API][login] Erreur lors de la connexion:", error);
    if (!res.headersSent) {
      res.status(500).json({ error: "Erreur interne du serveur." });
    }
  }
});
router2.get(
  "/me",
  authMiddleware,
  async (req2, res) => {
    try {
      console.log("[/me] === DEBUG /me ROUTE ===");
      console.log("[/me] req.user:", req2.user);
      console.log("[/me] req.cookies:", req2.cookies);
      console.log("[/me] req.headers.authorization:", req2.headers.authorization);
      if (!req2.user || !req2.user.userId) {
        console.log("[/me] \xC9chec: req.user ou req.user.userId manquant");
        return res.status(401).json({ error: "Utilisateur non authentifi\xE9" });
      }
      const user = await db.user.findUnique({
        where: { id: req2.user.userId },
        // On peut maintenant y acc√©der en toute s√©curit√©
        ...userWithOrgsArgs
      });
      if (!user) {
        return res.status(404).json({ error: "Utilisateur non trouv\xE9" });
      }
      const isSuperAdmin2 = user.role === "super_admin";
      const mainOrg = user.UserOrganization && user.UserOrganization.length > 0 ? user.UserOrganization.find((uo) => uo.Organization && uo.Role && uo.status === import_client2.UserOrganizationStatus.ACTIVE) || user.UserOrganization.find((uo) => uo.Organization && uo.Role) : null;
      if (!isSuperAdmin2 && !mainOrg) {
        return res.status(403).json({ error: "Vous n'\xEAtes associ\xE9 \xE0 aucune organisation valide ou votre r\xF4le n'est pas correctement configur\xE9." });
      }
      let tokenRole;
      if (isSuperAdmin2) {
        tokenRole = "super_admin";
      } else {
        if (!mainOrg || !mainOrg.Role) {
          return res.status(403).json({ error: "Impossible de d\xE9terminer un r\xF4le valide pour la connexion." });
        }
        tokenRole = mainOrg.Role.name;
      }
      const token = import_jsonwebtoken4.default.sign(
        {
          userId: user.id,
          role: tokenRole,
          // L'organizationId peut √™tre null pour un super_admin sans orga principale
          organizationId: mainOrg ? mainOrg.organizationId : null
        },
        JWT_SECRET2,
        { expiresIn: "24h" }
      );
      res.cookie("token", token, {
        httpOnly: true,
        secure: false,
        sameSite: "lax",
        maxAge: 24 * 60 * 60 * 1e3,
        path: "/"
      });
      const { passwordHash: _passwordHash, UserOrganization: userOrganizations = [], ...userInfos } = user;
      const organizations = userOrganizations.filter((uo) => uo.Organization && uo.Role).map((uo) => ({
        ...uo.Organization,
        role: uo.Role.name,
        roleLabel: uo.Role.label,
        userOrganizationId: uo.id,
        // Ajout de l'ID de la relation
        status: uo.status
        // Ajout du statut de la relation
      }));
      res.json({ currentUser: { ...userInfos, organizations }, isImpersonating: !!req2.originalUser });
    } catch (err) {
      console.error(err);
      res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration de l'utilisateur." });
    }
  }
);
router2.post("/logout", (_req, res) => {
  console.log("\u{1F6AA} [LOGOUT] Demande de d\xE9connexion re\xE7ue");
  const isProduction4 = process.env.NODE_ENV === "production";
  const isCodespaces2 = process.env.CODESPACES === "true" || process.env.GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN;
  const needsSecureCookie = isProduction4 || isCodespaces2;
  res.clearCookie("token", {
    httpOnly: true,
    secure: needsSecureCookie,
    sameSite: needsSecureCookie ? "none" : "lax",
    path: "/"
  });
  const cookieOptions = [
    { path: "/" },
    { path: "/", httpOnly: true },
    { path: "/", secure: needsSecureCookie },
    { path: "/", sameSite: needsSecureCookie ? "none" : "lax" }
  ];
  cookieOptions.forEach((options) => {
    res.clearCookie("token", options);
  });
  res.header("Cache-Control", "no-cache, no-store, must-revalidate");
  console.log("\u2705 [LOGOUT] Cookie nettoy\xE9 avec succ\xE8s");
  res.json({
    success: true,
    message: "D\xE9connexion r\xE9ussie",
    clearCache: true
  });
});
router2.get(
  "/me/organizations",
  authMiddleware,
  impersonationMiddleware,
  async (req2, res) => {
    try {
      const isSuperAdmin2 = req2.user?.role === "super_admin";
      const isImpersonating = !!req2.impersonatedUser;
      const effectiveUserId = req2.impersonatedUser?.id || req2.user?.userId;
      if (!effectiveUserId) {
        return res.status(401).json({ error: "Utilisateur non authentifi\xE9." });
      }
      let organizations = [];
      if (isSuperAdmin2 && !isImpersonating) {
        const allOrgs = await db.organization.findMany({
          orderBy: { name: "asc" }
        });
        organizations = allOrgs.map((org) => ({
          ...org,
          role: "super_admin",
          roleLabel: "Super Administrateur",
          userOrganizationId: null,
          status: "ACTIVE"
          // Le statut de la relation n'existe pas ici
        }));
      } else {
        const userWithOrgs = await db.user.findUnique({
          where: { id: effectiveUserId },
          ...userWithOrgsArgs
        });
        if (userWithOrgs && userWithOrgs.UserOrganization) {
          organizations = userWithOrgs.UserOrganization.filter((uo) => uo.Organization && uo.Role).map((uo) => ({
            ...uo.Organization,
            role: uo.Role.name,
            roleLabel: uo.Role.label,
            userOrganizationId: uo.id,
            status: uo.status
          }));
        }
      }
      res.json({ success: true, data: organizations });
    } catch (error) {
      console.error("[API][me/organizations] Erreur:", error);
      res.status(500).json({ success: false, message: "Erreur interne du serveur." });
    }
  }
);
router2.get(
  "/me/role",
  authMiddleware,
  impersonationMiddleware,
  // << AJOUT DU MIDDLEWARE
  async (req2, res) => {
    const organizationId = req2.query.organizationId;
    const userId = req2.impersonatedUser?.id || req2.user?.userId;
    console.log("[API][me/role] userId:", userId, "organizationId:", organizationId, "impersonatedUser:", req2.impersonatedUser, "headers:", req2.headers);
    if (!userId) {
      res.status(401).json({ error: "Utilisateur non authentifi\xE9" });
      return;
    }
    if (!organizationId) {
      res.status(400).json({ error: "L'ID de l'organisation est requis" });
      return;
    }
    try {
      if (req2.user?.role === "super_admin" && req2.impersonatedUser) {
        const userOrg2 = await db.userOrganization.findFirst({
          where: { userId: req2.impersonatedUser.id, organizationId },
          include: { Role: true, Organization: true }
        });
        if (userOrg2 && userOrg2.Role && userOrg2.Organization) {
          res.json({
            role: userOrg2.Role.name,
            roleLabel: userOrg2.Role.label,
            orgStatus: userOrg2.Organization.status,
            organizationName: userOrg2.Organization.name
          });
          return;
        } else {
          res.status(404).json({ error: "L'utilisateur usurp\xE9 n'a pas de r\xF4le dans cette organisation." });
          return;
        }
      } else if (req2.user?.role === "super_admin" && !req2.impersonatedUser) {
        res.json({ role: "super_admin", roleLabel: "Super administrateur", orgStatus: null });
        return;
      }
      const userOrg = await db.userOrganization.findFirst({
        where: { userId, organizationId },
        include: { Role: true, Organization: true }
      });
      if (userOrg && userOrg.Role && userOrg.Organization) {
        res.json({
          role: userOrg.Role.name,
          roleLabel: userOrg.Role.label,
          orgStatus: userOrg.Organization.status,
          organizationName: userOrg.Organization.name
        });
      } else {
        res.status(404).json({ error: "R\xF4le non trouv\xE9 pour l'utilisateur dans cette organisation" });
      }
    } catch (error) {
      console.error("[API][me/role] Erreur:", error);
      res.status(500).json({ error: "Erreur interne du serveur" });
    }
  }
);
router2.post("/logout", (_req, res) => {
  res.json({ message: "D\xE9connexion r\xE9ussie" });
});
var misc_default = router2;

// src/routes/profile.ts
var import_express4 = require("express");
init_database();
var import_multer = __toESM(require("multer"), 1);
var import_path = __toESM(require("path"), 1);
var import_fs3 = __toESM(require("fs"), 1);
var prisma4 = db;
var router3 = (0, import_express4.Router)();
var buildAvatarUrl = (req2, avatarPath) => {
  if (!avatarPath) {
    return "";
  }
  if (avatarPath.startsWith("http://") || avatarPath.startsWith("https://")) {
    return avatarPath;
  }
  const host = req2.get("host");
  if (!host) {
    return avatarPath;
  }
  const normalizedPath = avatarPath.startsWith("/") ? avatarPath : `/${avatarPath}`;
  return `${req2.protocol}://${host}${normalizedPath}`;
};
var sanitizeText = (value) => {
  if (typeof value !== "string") {
    return void 0;
  }
  const trimmed = value.trim();
  return trimmed.length === 0 ? null : trimmed;
};
var storage = import_multer.default.diskStorage({
  destination: function(_req, _file, cb) {
    const dir = "public/uploads/avatars";
    if (!import_fs3.default.existsSync(dir)) {
      import_fs3.default.mkdirSync(dir, { recursive: true });
    }
    cb(null, dir);
  },
  filename: function(req2, file, cb) {
    const authReq = req2;
    const userId = authReq.user?.userId;
    cb(null, userId + import_path.default.extname(file.originalname));
  }
});
var upload = (0, import_multer.default)({ storage });
router3.use(authMiddleware, impersonationMiddleware);
router3.get("/", async (req2, res) => {
  try {
    const userId = req2.user?.userId;
    if (!userId) {
      return res.status(401).json({ error: "Utilisateur non authentifi\xE9" });
    }
    const user = await prisma4.user.findUnique({
      where: { id: userId },
      include: {
        UserOrganization: {
          include: {
            Organization: true,
            Role: true
          }
        }
      }
    });
    if (!user) {
      return res.status(404).json({ error: "Utilisateur non trouv\xE9" });
    }
    const formattedUser = {
      id: user.id,
      email: user.email,
      firstName: user.firstName || "",
      // Utiliser firstName (camelCase) pour correspondre au frontend
      lastName: user.lastName || "",
      // Utiliser lastName (camelCase) pour correspondre au frontend
      address: user.address || "",
      // Ajouter l'adresse
      vatNumber: user.vatNumber || "",
      // Ajouter le num√©ro TVA
      phoneNumber: user.phoneNumber || "",
      // Ajouter le num√©ro de t√©l√©phone
      role: user.role || "user",
      avatarUrl: buildAvatarUrl(req2, user.avatarUrl),
      createdAt: user.createdAt.toISOString(),
      updatedAt: user.updatedAt.toISOString(),
      organizationId: req2.user?.organizationId || null,
      permissions: [],
      // √Ä remplir si n√©cessaire
      organization: user.UserOrganization?.length > 0 ? {
        id: user.UserOrganization[0].Organization.id,
        name: user.UserOrganization[0].Organization.name
      } : null
    };
    return res.json(formattedUser);
  } catch (error) {
    console.error("Error fetching user profile:", error);
    return res.status(500).json({ error: "Internal server error" });
  }
});
router3.post("/avatar", upload.single("avatar"), async (req2, res) => {
  try {
    const userId = req2.user?.userId;
    if (!userId) {
      res.status(400).json({ error: "User ID not found in token" });
      return;
    }
    if (!req2.file) {
      res.status(400).json({ error: "Aucun fichier n'a \xE9t\xE9 t\xE9l\xE9vers\xE9." });
      return;
    }
    const avatarUrl = `/uploads/avatars/${req2.file.filename}`;
    const updatedUser = await prisma4.user.update({
      where: { id: userId },
      data: { avatarUrl },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        avatarUrl: true,
        address: true,
        vatNumber: true,
        phoneNumber: true,
        status: true,
        createdAt: true,
        updatedAt: true,
        UserOrganization: {
          select: {
            Organization: {
              select: {
                id: true,
                name: true,
                status: true
              }
            },
            Role: {
              select: {
                id: true,
                name: true,
                label: true,
                description: true
              }
            },
            id: true
          }
        }
      }
    });
    res.json({
      ...updatedUser,
      avatarUrl: buildAvatarUrl(req2, updatedUser.avatarUrl)
    });
  } catch (error) {
    console.error("Erreur lors du t\xE9l\xE9versement de l'avatar:", error);
    res.status(500).json({ error: "Erreur interne du serveur" });
  }
});
router3.get("/permissions", (async (req2, res) => {
  try {
    const userId = req2.user?.userId;
    const organizationId = req2.user?.organizationId;
    if (!userId) {
      return res.status(400).json({ error: "User ID not found in token" });
    }
    const user = await prisma4.user.findUnique({
      where: { id: userId },
      select: { role: true }
      // On v√©rifie le r√¥le global de l'utilisateur
    });
    if (user?.role === "super_admin") {
      return res.json({ permissions: ["manage:all"] });
    }
    if (!organizationId) {
      return res.json({ permissions: [] });
    }
    const userOrgLink = await prisma4.userOrganization.findUnique({
      where: {
        userId_organizationId: {
          userId,
          organizationId
        }
      },
      include: {
        Role: {
          include: {
            Permission: {
              where: { allowed: true }
              // On ne r√©cup√®re que les permissions actives
            }
          }
        }
      }
    });
    if (!userOrgLink || !userOrgLink.Role) {
      return res.json({ permissions: [] });
    }
    const permissions = userOrgLink.Role.Permission.map((p) => `${p.action}:${p.resource}`);
    res.json({ permissions });
  } catch (error) {
    console.error("Failed to fetch permissions:", error);
    res.status(500).json({ error: "Internal server error" });
  }
}));
router3.put("/", (async (req2, res) => {
  try {
    const userId = req2.user?.userId;
    if (!userId) {
      return res.status(400).json({ error: "User ID not found in token" });
    }
    const {
      firstName,
      lastName,
      address,
      vatNumber,
      phoneNumber,
      avatarUrl
    } = req2.body;
    let normalizedAvatarUrl = void 0;
    if (typeof avatarUrl === "string") {
      const trimmed = avatarUrl.trim();
      if (trimmed.length === 0) {
        normalizedAvatarUrl = null;
      } else {
        try {
          const parsed = new URL(trimmed);
          normalizedAvatarUrl = parsed.pathname.startsWith("/uploads/") ? parsed.pathname : trimmed;
        } catch {
          normalizedAvatarUrl = trimmed;
        }
      }
    }
    const updatedUser = await prisma4.user.update({
      where: { id: userId },
      data: {
        firstName: sanitizeText(firstName),
        lastName: sanitizeText(lastName),
        address: sanitizeText(address),
        vatNumber: sanitizeText(vatNumber),
        phoneNumber: sanitizeText(phoneNumber),
        avatarUrl: normalizedAvatarUrl
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        avatarUrl: true,
        address: true,
        vatNumber: true,
        phoneNumber: true,
        status: true,
        createdAt: true,
        updatedAt: true,
        UserOrganization: {
          select: {
            Organization: {
              select: {
                id: true,
                name: true,
                status: true
              }
            },
            Role: {
              select: {
                id: true,
                name: true,
                label: true,
                description: true
              }
            },
            id: true
          }
        }
      }
    });
    res.json({
      ...updatedUser,
      avatarUrl: buildAvatarUrl(req2, updatedUser.avatarUrl)
    });
  } catch (error) {
    console.error("Error updating profile:", error);
    res.status(500).json({ error: "Internal server error" });
  }
}));
var profile_default = router3;

// src/routes/modules.ts
var import_express5 = require("express");
init_database();
var prisma5 = db;
var router4 = (0, import_express5.Router)();
function deriveRoute(key2, provided) {
  if (!key2 && !provided) return null;
  let route = provided && provided.trim() !== "" ? provided.trim() : "";
  if (!route && key2) {
    route = key2.replace(/^google_/, "google-").replace(/_/g, "-");
  } else if (route) {
    route = route.replace(/_/g, "-");
    route = route.replace(/\/{2,}/g, "/");
    if (route.startsWith("/api/")) {
      return route;
    }
  }
  if (!route.startsWith("/")) route = "/" + route;
  return route;
}
function mapModule(m, orgStatuses, organizationId) {
  const activeGlobal = m.active !== false;
  let isActiveForOrg = void 0;
  if (organizationId) {
    if (orgStatuses && orgStatuses[m.id] !== void 0) {
      isActiveForOrg = orgStatuses[m.id];
    } else if (m.organizationId && m.organizationId === organizationId) {
      isActiveForOrg = activeGlobal;
    } else if (!m.organizationId) {
      isActiveForOrg = activeGlobal;
    } else {
      isActiveForOrg = false;
    }
  }
  return {
    id: m.id,
    key: m.key,
    label: m.label,
    feature: m.feature,
    icon: m.icon,
    route: m.route,
    description: m.description,
    page: m.page,
    order: m.order ?? 0,
    active: activeGlobal,
    parameters: m.parameters,
    // üîß Inclure les param√®tres
    organizationId: m.organizationId,
    isActiveForOrg,
    // ‚úÖ Ajouter les informations de cat√©gorie
    category: m.Category?.name || null,
    categoryIcon: m.Category?.icon || null,
    categoryColor: m.Category?.iconColor || null
  };
}
router4.get("/", async (req2, res) => {
  const { organizationId } = req2.query;
  try {
    const modules = await prisma5.module.findMany({
      orderBy: { order: "asc" },
      include: {
        Category: {
          select: {
            id: true,
            name: true,
            icon: true,
            iconColor: true
          }
        }
      }
    });
    let orgStatuses = null;
    if (organizationId) {
      const statuses = await prisma5.organizationModuleStatus.findMany({
        where: { organizationId },
        select: { moduleId: true, active: true }
      });
      orgStatuses = statuses.reduce((acc, s) => {
        acc[s.moduleId] = s.active;
        return acc;
      }, {});
    }
    const mapped = modules.map((m) => mapModule(m, orgStatuses, organizationId));
    const filtered = organizationId ? mapped.filter((m) => !m.organizationId || m.organizationId === organizationId) : mapped;
    res.json({ success: true, data: filtered });
  } catch (e) {
    console.error("[modules] GET / erreur", e);
    res.status(500).json({ success: false, message: "Erreur r\xE9cup\xE9ration modules" });
  }
});
router4.get("/all", async (_req, res) => {
  try {
    const modules = await prisma5.module.findMany({
      orderBy: { order: "asc" },
      include: {
        Category: {
          select: {
            id: true,
            name: true,
            icon: true,
            iconColor: true
          }
        }
      }
    });
    const mapped = modules.map((m) => mapModule(m, null));
    res.json({ success: true, data: mapped });
  } catch (e) {
    console.error("[modules] GET /all erreur", e);
    res.status(500).json({ success: false, message: "Erreur r\xE9cup\xE9ration modules (all)" });
  }
});
router4.patch("/status", async (req2, res) => {
  const { moduleId, organizationId, active } = req2.body;
  if (!moduleId || !organizationId || typeof active !== "boolean") {
    return res.status(400).json({ success: false, message: "Param\xE8tres invalides" });
  }
  try {
    const status = await prisma5.organizationModuleStatus.upsert({
      where: { organizationId_moduleId: { organizationId, moduleId } },
      update: { active },
      create: { organizationId, moduleId, active }
    });
    res.json({ success: true, data: status });
  } catch (e) {
    console.error("[modules] PATCH /status erreur", e);
    res.status(500).json({ success: false, message: "Erreur mise \xE0 jour statut module" });
  }
});
router4.post("/", async (req2, res) => {
  try {
    const { key: key2, label, feature, icon, route, description, page, order, active, organizationId, parameters } = req2.body;
    if (!key2 || !label) {
      return res.status(400).json({ success: false, message: "key et label requis" });
    }
    const finalRoute = deriveRoute(key2, route);
    const created = await prisma5.module.create({
      data: {
        key: key2,
        label,
        feature: feature || key2,
        // fallback
        icon: icon || null,
        route: finalRoute,
        description: description || null,
        page: page || null,
        order: typeof order === "number" ? order : 0,
        active: active !== false,
        parameters: parameters || null,
        // üîß Param√®tres JSON
        organizationId: organizationId || null
      }
    });
    res.json({ success: true, data: mapModule(created, null, organizationId) });
  } catch (e) {
    const message = e instanceof Error ? e.message : "Erreur inconnue";
    console.error("[modules] POST / erreur", e);
    res.status(500).json({ success: false, message: "Erreur cr\xE9ation module", detail: message });
  }
});
router4.put("/:id", async (req2, res) => {
  const { id } = req2.params;
  try {
    const { label, feature, icon, route, description, page, order, active, key: key2, organizationId, parameters, categoryId } = req2.body;
    let normalizedRoute;
    if (route !== void 0 || key2 !== void 0) {
      normalizedRoute = deriveRoute(key2, route);
    }
    console.log(`[modules] PUT /${id} - Mise \xE0 jour module avec categoryId:`, categoryId);
    console.log(`[modules] PUT /${id} - Body complet:`, req2.body);
    const updated = await prisma5.module.update({
      where: { id },
      data: {
        label: label !== void 0 ? label : void 0,
        feature: feature !== void 0 ? feature : void 0,
        icon: icon !== void 0 ? icon : void 0,
        route: normalizedRoute !== void 0 ? normalizedRoute : void 0,
        description: description !== void 0 ? description : void 0,
        page: page !== void 0 ? page : void 0,
        order: order !== void 0 ? order : void 0,
        active: active !== void 0 ? active : void 0,
        parameters: parameters !== void 0 ? parameters : void 0,
        // üîß Param√®tres JSON
        key: key2 !== void 0 ? key2 : void 0,
        organizationId: organizationId !== void 0 ? organizationId : void 0,
        categoryId: categoryId !== void 0 ? categoryId : void 0
      }
    });
    res.json({ success: true, data: mapModule(updated, null) });
  } catch (e) {
    console.error("[modules] PUT /:id erreur", e);
    if (e?.code === "P2002") {
      return res.status(409).json({ success: false, message: "Conflit d'unicit\xE9 (cl\xE9 ou feature d\xE9j\xE0 utilis\xE9e)" });
    }
    res.status(500).json({ success: false, message: "Erreur mise \xE0 jour module" });
  }
});
router4.delete("/:id", async (req2, res) => {
  const { id } = req2.params;
  try {
    await prisma5.organizationModuleStatus.deleteMany({ where: { moduleId: id } });
    await prisma5.permission.deleteMany({ where: { moduleId: id } }).catch(() => {
    });
    const deleted = await prisma5.module.delete({ where: { id } });
    res.json({ success: true, data: { id: deleted.id } });
  } catch (e) {
    console.error("[modules] DELETE /:id erreur", e);
    res.status(500).json({ success: false, message: "Erreur suppression module" });
  }
});
router4.get("/health", (_req, res) => res.json({ success: true, message: "modules ok" }));
var modules_default = router4;

// src/routes/admin-modules.ts
var import_express6 = require("express");

// src/middlewares/requireRole.ts
function requireRole2(roles) {
  return (req2, res, next) => {
    const authReq = req2;
    const user = authReq.user;
    if (!user) {
      res.status(403).json({ error: "Acc\xE8s refus\xE9" });
      return;
    }
    if (user.isSuperAdmin === true || user.role === "super_admin") {
      next();
      return;
    }
    if (authReq.originalUser && authReq.originalUser.role === "super_admin") {
      next();
      return;
    }
    if (!roles.includes(user.role)) {
      console.warn(`[requireRole] Acc\xE8s refus\xE9 - R\xF4le ${user.role} non autoris\xE9 pour ${roles.join(", ")}`);
      res.status(403).json({ error: "Acc\xE8s refus\xE9" });
      return;
    }
    next();
  };
}

// src/routes/admin-modules.ts
init_prisma();
var router5 = (0, import_express6.Router)();
router5.use(authMiddleware, impersonationMiddleware);
router5.get("/", async (req2, res) => {
  try {
    const organizationId = req2.query.organizationId;
    const user = req2.user;
    const isSuperAdmin2 = user?.role === "super_admin";
    console.log("[ADMIN-MODULES-V1] GET - R\xE9cup\xE9ration modules par sections (syst\xE8me hybride)");
    console.log("[ADMIN-MODULES-V1] \u{1F464} User:", user?.email, "Role:", user?.role, "IsSuperAdmin:", isSuperAdmin2);
    const fallbackIcon = "AppstoreOutlined";
    const modules = await db.module.findMany({
      where: organizationId ? {
        OR: [
          { organizationId },
          { organizationId: null }
          // Modules globaux
        ]
      } : void 0,
      orderBy: { order: "asc" },
      include: {
        Organization: true,
        Category: true,
        // ‚úÖ Inclure la nouvelle relation Category
        OrganizationModuleStatus: organizationId ? {
          where: { organizationId }
        } : true,
        Permission: true
      }
    });
    const allCategories = await db.category.findMany({
      where: {
        AND: [
          // Filtrage par organisation
          organizationId ? {
            OR: [
              { organizationId },
              { organizationId: null }
              // Cat√©gories globales
            ]
          } : {},
          // V√©rification superAdminOnly : Si pas SuperAdmin, exclure les cat√©gories SuperAdmin Only
          ...isSuperAdmin2 ? [] : [{ superAdminOnly: false }]
        ]
      },
      orderBy: { order: "asc" }
    });
    const sectionsMap = /* @__PURE__ */ new Map();
    allCategories.forEach((category) => {
      const sectionKey = `category_${category.id}`;
      sectionsMap.set(sectionKey, {
        id: category.id,
        backendCategoryId: category.id,
        // ‚úÖ identifiant r√©el BDD
        title: category.name,
        iconName: category.icon || fallbackIcon,
        iconColor: category.iconColor || "#1890ff",
        order: category.order || 999,
        active: category.active ?? true,
        superAdminOnly: category.superAdminOnly ?? false,
        isRealCategory: true,
        modules: []
      });
    });
    modules.forEach((module2) => {
      let sectionKey, sectionName, sectionIcon, sectionColor, sectionOrder, sectionId, sectionActive, sectionSuperAdminOnly;
      if (module2.Category) {
        sectionKey = `category_${module2.Category.id}`;
        sectionName = module2.Category.name;
        sectionIcon = module2.Category.icon || fallbackIcon;
        sectionColor = module2.Category.iconColor || "#1890ff";
        sectionOrder = module2.Category.order || 999;
        sectionId = module2.Category.id;
        sectionActive = module2.Category.active ?? true;
        sectionSuperAdminOnly = module2.Category.superAdminOnly ?? false;
      } else {
        const fallbackName = module2.feature ? module2.feature.charAt(0).toUpperCase() + module2.feature.slice(1) : "Non class\xE9";
        sectionKey = `feature_${fallbackName}`;
        sectionName = fallbackName;
        sectionIcon = module2.icon || fallbackIcon;
        sectionColor = "#1890ff";
        sectionOrder = module2.order ? Math.floor(module2.order / 10) * 10 : 999;
        sectionId = fallbackName;
        sectionActive = true;
        sectionSuperAdminOnly = false;
        if (!sectionsMap.has(sectionKey)) {
          sectionsMap.set(sectionKey, {
            id: sectionId,
            backendCategoryId: null,
            // ‚ùå pas de cat√©gorie BDD
            title: sectionName,
            iconName: sectionIcon,
            iconColor: sectionColor,
            order: sectionOrder,
            active: sectionActive,
            superAdminOnly: sectionSuperAdminOnly,
            isRealCategory: false,
            modules: []
          });
        }
      }
      if (sectionsMap.has(sectionKey)) {
        sectionsMap.get(sectionKey).modules.push({
          ...module2,
          // Enrichir avec les donn√©es de statut
          isActiveForOrg: module2.OrganizationModuleStatus?.[0]?.active ?? true,
          hasOrgSpecificConfig: module2.OrganizationModuleStatus?.length > 0
        });
      }
    });
    const sections = Array.from(sectionsMap.values()).sort(
      (a, b) => a.order - b.order
    );
    console.log(`[ADMIN-MODULES-V1] Sections cr\xE9\xE9es: ${sections.length} (syst\xE8me par cat\xE9gories)`);
    console.log(`[ADMIN-MODULES-V1] Total modules: ${modules.length}`);
    res.json({
      success: true,
      data: {
        sections,
        totalModules: modules.length,
        totalSections: sections.length,
        systemType: "hybrid",
        // Indicateur pour le frontend
        categorySystemAvailable: modules.some((m) => m.categoryId)
        // ‚úÖ Y a-t-il des modules avec categoryId ?
      }
    });
  } catch (error) {
    console.error("[ADMIN-MODULES-V1] Erreur GET:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la r\xE9cup\xE9ration des modules",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router5.get("/categories", async (req2, res) => {
  try {
    const organizationId = req2.query.organizationId;
    console.log("[ADMIN-MODULES] GET /categories - R\xE9cup\xE9ration des categories");
    const categories = await db.category.findMany({
      where: organizationId ? {
        OR: [
          { organizationId },
          { organizationId: null }
          // Categories globales
        ]
      } : void 0,
      orderBy: { order: "asc" },
      include: {
        _count: {
          select: {
            Module: true
            // Compter les modules dans chaque category
          }
        }
      }
    });
    console.log(`[ADMIN-MODULES] ${categories.length} categories trouv\xE9es`);
    res.json({
      success: true,
      data: categories,
      total: categories.length
    });
  } catch (error) {
    console.error("[ADMIN-MODULES] Erreur GET /categories:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la r\xE9cup\xE9ration des categories",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router5.post("/categories", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { name, description, icon, iconColor, order, organizationId } = req2.body;
    if (!name || typeof name !== "string" || !name.trim()) {
      res.status(400).json({ success: false, error: 'Le champ "name" est requis pour cr\xE9er une cat\xE9gorie.' });
      return;
    }
    console.log("[ADMIN-MODULES] POST /categories - Cr\xE9ation category:", { name, icon, organizationId });
    const { randomUUID: randomUUID12 } = await import("crypto");
    const categoryId = randomUUID12();
    const now = /* @__PURE__ */ new Date();
    const category = await db.category.create({
      data: {
        id: categoryId,
        name: name.trim(),
        description: description || null,
        icon: icon || "AppstoreOutlined",
        iconColor: iconColor || "#1890ff",
        order: typeof order === "number" ? order : 0,
        organizationId: organizationId || null,
        active: true,
        // Le sch√©ma ne d√©finit pas @updatedAt ni de default ‚Üí fournir explicitement
        updatedAt: now
      }
    });
    console.log(`[ADMIN-MODULES] Category cr\xE9\xE9e: ${category.id}`);
    res.json({
      success: true,
      data: category
    });
  } catch (error) {
    const code = error?.code;
    if (code === "P2003") {
      res.status(400).json({ success: false, error: "organizationId invalide" });
      return;
    }
    console.error("[ADMIN-MODULES] Erreur POST /categories:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la cr\xE9ation de la category",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router5.put("/categories/reorder", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { updates } = req2.body;
    console.log("[ADMIN-MODULES] PUT /categories/reorder - R\xE9organisation categories:", updates.length);
    for (const update of updates) {
      await db.category.update({
        where: { id: update.id },
        data: {
          order: update.order,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    }
    console.log(`[ADMIN-MODULES] ${updates.length} categories r\xE9organis\xE9es`);
    res.json({
      success: true,
      message: `${updates.length} categories r\xE9organis\xE9es avec succ\xE8s`
    });
  } catch (error) {
    console.error("[ADMIN-MODULES] Erreur PUT /categories/reorder:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la r\xE9organisation des categories",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router5.put("/categories/:id", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const { name, description, icon, iconColor, order, active, superAdminOnly } = req2.body;
    console.log("[ADMIN-MODULES] PUT /categories/:id - Modification category:", { id, name, active, superAdminOnly });
    const finalActive = superAdminOnly ? false : active;
    if (superAdminOnly && active) {
      console.log("[ADMIN-MODULES] SuperAdminOnly activ\xE9 - D\xE9sactivation automatique du module pour les organisations");
    }
    const category = await db.category.update({
      where: { id },
      data: {
        name,
        description,
        icon,
        iconColor,
        order,
        active: finalActive,
        superAdminOnly: superAdminOnly ?? false,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log(`[ADMIN-MODULES] Category modifi\xE9e: ${category.id}`);
    res.json({
      success: true,
      data: category
    });
  } catch (error) {
    console.error("[ADMIN-MODULES] Erreur PUT /categories/:id:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la modification de la category",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router5.delete("/categories/:id", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    console.log("[ADMIN-MODULES] DELETE /categories/:id - Suppression category:", { id });
    const moduleCount = await db.module.count({
      where: { categoryId: id }
    });
    if (moduleCount > 0) {
      res.status(400).json({
        success: false,
        error: `Cannot delete category with ${moduleCount} modules attached`
      });
      return;
    }
    await db.category.delete({
      where: { id }
    });
    console.log(`[ADMIN-MODULES] Category supprim\xE9e: ${id}`);
    res.json({
      success: true,
      message: "Category supprim\xE9e avec succ\xE8s"
    });
  } catch (error) {
    console.error("[ADMIN-MODULES] Erreur DELETE /categories/:id:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la suppression de la category",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router5.put("/modules/:id", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const { active, superAdminOnly } = req2.body;
    console.log("[ADMIN-MODULES] PUT /modules/:id - Modification module:", { id, active, superAdminOnly });
    const finalActive = superAdminOnly ? false : active;
    if (superAdminOnly && active) {
      console.log("[ADMIN-MODULES] SuperAdminOnly activ\xE9 - D\xE9sactivation automatique du module pour les organisations");
    }
    const module2 = await db.module.update({
      where: { id },
      data: {
        active: finalActive,
        superAdminOnly: superAdminOnly ?? false,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log(`[ADMIN-MODULES] Module modifi\xE9: ${module2.id}`);
    res.json({
      success: true,
      data: module2
    });
  } catch (error) {
    console.error("[ADMIN-MODULES] Erreur PUT /modules/:id:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la modification du module",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
router5.delete("/modules/:id", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    console.log("[ADMIN-MODULES] DELETE /modules/:id (alias) - Suppression module:", { id });
    await db.organizationModuleStatus.deleteMany({ where: { moduleId: id } });
    await db.permission.deleteMany({ where: { moduleId: id } }).catch(() => {
    });
    await db.module.delete({ where: { id } });
    res.json({ success: true, data: { id } });
  } catch (error) {
    console.error("[ADMIN-MODULES] Erreur DELETE /modules/:id (alias):", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la suppression du module",
      details: error instanceof Error ? error.message : "Unknown error"
    });
  }
});
var admin_modules_default = router5;

// src/routes/icons.ts
var import_express7 = require("express");
init_database();
var prisma6 = db;
var router6 = (0, import_express7.Router)();
router6.use(authMiddleware, impersonationMiddleware);
router6.get("/", async (req2, res) => {
  try {
    const { category, search } = req2.query;
    console.log("[ICONS-API] GET - R\xE9cup\xE9ration des ic\xF4nes", { category, search });
    let whereClause = {
      active: true
      // Seulement les ic√¥nes actives
    };
    if (category && category !== "all") {
      whereClause.category = category;
    }
    if (search && typeof search === "string") {
      const searchTerm = search.toLowerCase();
      whereClause.OR = [
        { name: { contains: searchTerm, mode: "insensitive" } },
        { description: { contains: searchTerm, mode: "insensitive" } },
        { tags: { hasSome: [searchTerm] } }
      ];
    }
    const icons = await prisma6.icon.findMany({
      where: whereClause,
      orderBy: [
        { category: "asc" },
        { name: "asc" }
      ]
    });
    const groupedIcons = icons.reduce((acc, icon) => {
      if (!acc[icon.category]) {
        acc[icon.category] = [];
      }
      acc[icon.category].push(icon);
      return acc;
    }, {});
    res.json({
      success: true,
      data: {
        icons,
        groupedIcons,
        totalCount: icons.length,
        categories: Object.keys(groupedIcons).sort()
      }
    });
  } catch (error) {
    console.error("[ICONS-API] Erreur lors de la r\xE9cup\xE9ration des ic\xF4nes:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la r\xE9cup\xE9ration des ic\xF4nes",
      details: error.message
    });
  }
});
router6.get("/categories", async (req2, res) => {
  try {
    console.log("[ICONS-API] GET - R\xE9cup\xE9ration des cat\xE9gories d'ic\xF4nes");
    const categories = await prisma6.icon.groupBy({
      by: ["category"],
      where: { active: true },
      _count: { id: true },
      orderBy: { category: "asc" }
    });
    res.json({
      success: true,
      data: categories.map((cat) => ({
        name: cat.category,
        count: cat._count.id
      }))
    });
  } catch (error) {
    console.error("[ICONS-API] Erreur lors de la r\xE9cup\xE9ration des cat\xE9gories:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la r\xE9cup\xE9ration des cat\xE9gories",
      details: error.message
    });
  }
});
router6.post("/", requireRole2(["super_admin"]), async (req2, res) => {
  try {
    const { name, category, description, tags, active = true } = req2.body;
    console.log("[ICONS-API] POST - Cr\xE9ation d'une nouvelle ic\xF4ne:", { name, category });
    if (!name || !category) {
      res.status(400).json({
        success: false,
        error: "Le nom et la cat\xE9gorie sont requis"
      });
      return;
    }
    const newIcon = await prisma6.icon.create({
      data: {
        name,
        category,
        description,
        tags: Array.isArray(tags) ? tags : [],
        active
      }
    });
    res.json({
      success: true,
      data: newIcon,
      message: `Ic\xF4ne "${name}" cr\xE9\xE9e avec succ\xE8s`
    });
  } catch (error) {
    console.error("[ICONS-API] Erreur lors de la cr\xE9ation de l'ic\xF4ne:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la cr\xE9ation de l'ic\xF4ne",
      details: error.message
    });
  }
});
router6.put("/:id", requireRole2(["super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const updateData = req2.body;
    console.log("[ICONS-API] PUT - Modification de l'ic\xF4ne:", { id, updateData });
    delete updateData.id;
    delete updateData.createdAt;
    delete updateData.updatedAt;
    const updatedIcon = await prisma6.icon.update({
      where: { id },
      data: updateData
    });
    res.json({
      success: true,
      data: updatedIcon,
      message: `Ic\xF4ne mise \xE0 jour avec succ\xE8s`
    });
  } catch (error) {
    console.error("[ICONS-API] Erreur lors de la modification de l'ic\xF4ne:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la modification de l'ic\xF4ne",
      details: error.message
    });
  }
});
router6.delete("/:id", requireRole2(["super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    console.log("[ICONS-API] DELETE - D\xE9sactivation de l'ic\xF4ne:", id);
    const disabledIcon = await prisma6.icon.update({
      where: { id },
      data: { active: false }
    });
    res.json({
      success: true,
      data: disabledIcon,
      message: `Ic\xF4ne d\xE9sactiv\xE9e avec succ\xE8s`
    });
  } catch (error) {
    console.error("[ICONS-API] Erreur lors de la d\xE9sactivation de l'ic\xF4ne:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la d\xE9sactivation de l'ic\xF4ne",
      details: error.message
    });
  }
});
var icons_default = router6;

// src/routes/company.ts
var import_express8 = require("express");
var router7 = (0, import_express8.Router)();
router7.use(authMiddleware);
router7.get("/", async (req2, res) => {
  try {
    const { organizationId } = req2.user;
    const companyInfo = {
      id: organizationId,
      name: "2Thier CRM",
      address: "Rue de Floreffe 37, 5150 Frani\xE8re",
      phone: "0470/29.50.77",
      email: "info@2thier.be",
      website: "https://2thier.be",
      vatNumber: "BE0123456789",
      registrationNumber: "123456789"
    };
    res.json({
      success: true,
      data: companyInfo
    });
  } catch (error) {
    console.error("\u274C [CompanyAPI] Erreur r\xE9cup\xE9ration entreprise:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration des informations de l'entreprise"
    });
  }
});
router7.put("/", requireRole(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { organizationId } = req2.user;
    const updateData = req2.body;
    console.log("\u{1F504} [CompanyAPI] Mise \xE0 jour entreprise:", { organizationId, updateData });
    res.json({
      success: true,
      message: "Informations de l'entreprise mises \xE0 jour avec succ\xE8s",
      data: updateData
    });
  } catch (error) {
    console.error("\u274C [CompanyAPI] Erreur mise \xE0 jour entreprise:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la mise \xE0 jour des informations de l'entreprise"
    });
  }
});
router7.get("/settings", requireRole(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { organizationId } = req2.user;
    const settings = {
      organizationId,
      currency: "EUR",
      timezone: "Europe/Brussels",
      language: "fr",
      dateFormat: "DD/MM/YYYY",
      invoicePrefix: "INV-",
      quotePrefix: "DEV-"
    };
    res.json({
      success: true,
      data: settings
    });
  } catch (error) {
    console.error("\u274C [CompanyAPI] Erreur param\xE8tres entreprise:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration des param\xE8tres"
    });
  }
});
var company_default = router7;

// src/routes/invitations.ts
var import_express9 = require("express");
var import_uuid = require("uuid");
var import_zod = require("zod");
var import_client3 = require("@prisma/client");
var import_bcryptjs4 = __toESM(require("bcryptjs"), 1);

// src/services/EmailService.ts
var EmailService = class {
  /**
   * Envoie un e-mail d'invitation.
   * Simule l'envoi en loggant les d√©tails dans la console.
   */
  async sendInvitationEmail(payload) {
    const { to, token, isExistingUser, organizationName, roleName } = payload;
    const frontendUrl = process.env.FRONTEND_URL || "http://localhost:5173";
    const acceptUrl = `${frontendUrl}/accept-invitation?token=${token}`;
    let subject = "";
    let body2 = "";
    if (isExistingUser) {
      subject = `Vous \xEAtes invit\xE9(e) \xE0 rejoindre ${organizationName}`;
      body2 = `
                <p>Bonjour,</p>
                <p>Vous avez \xE9t\xE9 invit\xE9(e) \xE0 rejoindre l'organisation "${organizationName}" avec le r\xF4le "${roleName}".</p>
                <p>Comme vous avez d\xE9j\xE0 un compte, il vous suffit de cliquer sur le lien ci-dessous pour accepter l'invitation :</p>
                <p><a href="${acceptUrl}">Accepter l'invitation</a></p>
                <p>Si vous n'\xEAtes pas \xE0 l'origine de cette demande, vous pouvez ignorer cet e-mail.</p>
            `;
    } else {
      subject = `Invitation \xE0 rejoindre ${organizationName}`;
      body2 = `
                <p>Bonjour,</p>
                <p>Vous avez \xE9t\xE9 invit\xE9(e) \xE0 rejoindre l'organisation "${organizationName}" avec le r\xF4le "${roleName}".</p>
                <p>Pour finaliser votre inscription et rejoindre l'\xE9quipe, veuillez cliquer sur le lien ci-dessous :</p>
                <p><a href="${acceptUrl}">Cr\xE9er votre compte et accepter l'invitation</a></p>
                <p>Ce lien est valide pendant 7 jours.</p>
            `;
    }
    console.log("--- SIMULATION D'ENVOI D'EMAIL ---");
    console.log(`\xC0: ${to}`);
    console.log(`Sujet: ${subject}`);
    console.log(`URL d'acceptation: ${acceptUrl}`);
    console.log(`Corps (HTML): ${body2.replace(/\s+/g, " ").trim()}`);
    console.log("------------------------------------");
    return Promise.resolve();
  }
  /**
   * Envoie un e-mail g√©n√©rique (simulation console).
   */
  async sendEmail(payload) {
    const { to, subject, html, text, replyTo } = payload;
    console.log("--- SIMULATION ENVOI EMAIL (g\xE9n\xE9rique) ---");
    console.log(`\xC0: ${to}`);
    console.log(`Sujet: ${subject}`);
    if (replyTo) {
      console.log(`R\xE9pondre \xE0: ${replyTo}`);
    }
    if (text) {
      console.log(`Corps (texte): ${text.replace(/\s+/g, " ").trim()}`);
    }
    console.log(`Corps (HTML): ${html.replace(/\s+/g, " ").trim()}`);
    console.log("------------------------------------------");
    return Promise.resolve();
  }
};
var emailService = new EmailService();

// src/routes/invitations.ts
init_prisma();

// src/services/GoogleWorkspaceService.ts
var import_googleapis5 = require("googleapis");
var import_google_auth_library = require("google-auth-library");
var GoogleWorkspaceService = class {
  config;
  adminClient;
  constructor(config) {
    this.config = config;
    this.initializeClient();
  }
  initializeClient() {
    try {
      const jwtClient = new import_google_auth_library.JWT({
        email: this.config.serviceAccountEmail,
        key: this.config.privateKey.replace(/\\n/g, "\n"),
        scopes: [
          "https://www.googleapis.com/auth/admin.directory.user",
          "https://www.googleapis.com/auth/admin.directory.group",
          "https://www.googleapis.com/auth/admin.directory.orgunit"
        ],
        subject: this.config.adminEmail
        // Impersonification de l'admin
      });
      this.adminClient = import_googleapis5.google.admin({ version: "directory_v1", auth: jwtClient });
    } catch (error) {
      console.error("[GoogleWorkspace] Erreur initialisation client:", error);
      throw new Error("Impossible d'initialiser le client Google Workspace");
    }
  }
  /**
   * Teste la connexion √† Google Workspace
   */
  async testConnection() {
    try {
      console.log("\u{1F9EA} [GoogleWorkspace] Test de connexion...");
      await this.adminClient.users.list({
        domain: this.config.domain,
        maxResults: 1
      });
      console.log("\u2705 [GoogleWorkspace] Test de connexion r\xE9ussi");
      return {
        success: true,
        message: `Connexion r\xE9ussie au domaine ${this.config.domain}`
      };
    } catch (error) {
      console.error("\u274C [GoogleWorkspace] Erreur test connexion:", error);
      const errorMessage = error instanceof Error ? error.message : "Erreur inconnue";
      return {
        success: false,
        message: `Erreur de connexion: ${errorMessage}`
      };
    }
  }
  /**
   * Cr√©e un nouvel utilisateur Google Workspace
   */
  async createUser(userData) {
    try {
      console.log(`\u{1F464} [GoogleWorkspace] Cr\xE9ation utilisateur ${userData.email}...`);
      const googleUser = {
        name: {
          givenName: userData.firstName,
          familyName: userData.lastName
        },
        primaryEmail: userData.email,
        password: userData.password,
        suspended: false,
        orgUnitPath: "/"
        // Unit√© organisationnelle par d√©faut
      };
      const response = await this.adminClient.users.insert({
        requestBody: googleUser
      });
      console.log("\u2705 [GoogleWorkspace] Utilisateur cr\xE9\xE9 avec succ\xE8s:", userData.email);
      return {
        success: true,
        user: response.data
      };
    } catch (error) {
      console.error("\u274C [GoogleWorkspace] Erreur cr\xE9ation utilisateur:", error);
      const errorMessage = error instanceof Error ? error.message : "Erreur inconnue";
      return {
        success: false,
        error: errorMessage
      };
    }
  }
  /**
   * Met √† jour le mot de passe d'un utilisateur
   */
  async updateUserPassword(email, newPassword) {
    try {
      console.log(`\u{1F511} [GoogleWorkspace] Mise \xE0 jour mot de passe ${email}...`);
      await this.adminClient.users.update({
        userKey: email,
        requestBody: {
          password: newPassword
        }
      });
      console.log("\u2705 [GoogleWorkspace] Mot de passe mis \xE0 jour:", email);
      return { success: true };
    } catch (error) {
      console.error("\u274C [GoogleWorkspace] Erreur mise \xE0 jour mot de passe:", error);
      const errorMessage = error instanceof Error ? error.message : "Erreur inconnue";
      return {
        success: false,
        error: errorMessage
      };
    }
  }
  /**
   * V√©rifie si un utilisateur existe
   */
  async userExists(email) {
    try {
      await this.adminClient.users.get({ userKey: email });
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Liste tous les utilisateurs du domaine
   */
  async listUsers() {
    try {
      const response = await this.adminClient.users.list({
        domain: this.config.domain,
        maxResults: 500
      });
      return response.data.users ?? [];
    } catch (error) {
      console.error("[GoogleWorkspace] Erreur liste utilisateurs:", error);
      return [];
    }
  }
  /**
   * Supprime un utilisateur
   */
  async deleteUser(email) {
    try {
      console.log(`\u{1F5D1}\uFE0F [GoogleWorkspace] Suppression utilisateur ${email}...`);
      await this.adminClient.users.delete({ userKey: email });
      console.log("\u2705 [GoogleWorkspace] Utilisateur supprim\xE9:", email);
      return { success: true };
    } catch (error) {
      console.error("\u274C [GoogleWorkspace] Erreur suppression utilisateur:", error);
      const errorMessage = error instanceof Error ? error.message : "Erreur inconnue";
      return {
        success: false,
        error: errorMessage
      };
    }
  }
};

// src/services/GoogleWorkspaceIntegrationService.ts
init_crypto();
init_prisma();
var GoogleWorkspaceIntegrationService = class _GoogleWorkspaceIntegrationService {
  static instance = null;
  googleWorkspaceService = null;
  isInitialized = false;
  constructor() {
  }
  static getInstance() {
    if (!this.instance) {
      this.instance = new _GoogleWorkspaceIntegrationService();
    }
    return this.instance;
  }
  /**
   * Initialise le service avec la configuration Google Workspace
   */
  async initialize() {
    try {
      const config = await db.googleWorkspaceConfig.findFirst({
        where: { isActive: true }
      });
      if (!config) {
        console.log("\u26A0\uFE0F [GoogleWorkspaceIntegration] Aucune configuration Google Workspace trouv\xE9e");
        this.isInitialized = false;
        return false;
      }
      const decryptedConfig = {
        clientId: config.clientId,
        clientSecret: decrypt(config.clientSecret),
        domain: config.domain,
        adminEmail: config.adminEmail,
        serviceAccountEmail: config.serviceAccountEmail,
        privateKey: decrypt(config.privateKey),
        isActive: config.isActive
      };
      this.googleWorkspaceService = new GoogleWorkspaceService(decryptedConfig);
      this.isInitialized = true;
      console.log("\u2705 [GoogleWorkspaceIntegration] Service initialis\xE9 avec succ\xE8s");
      return true;
    } catch (error) {
      console.error("\u274C [GoogleWorkspaceIntegration] Erreur initialisation:", error);
      this.isInitialized = false;
      return false;
    }
  }
  /**
   * Cr√©e automatiquement un compte Google Workspace pour un utilisateur CRM
   */
  async createWorkspaceUserForCrmUser(crmUser) {
    try {
      console.log(`\u{1F680} [GoogleWorkspaceIntegration] Cr\xE9ation compte Workspace pour ${crmUser.email}...`);
      if (!this.isInitialized || !this.googleWorkspaceService) {
        const initialized = await this.initialize();
        if (!initialized) {
          return {
            success: false,
            error: "Service Google Workspace non configur\xE9"
          };
        }
      }
      const tempPassword = this.generateSecurePassword();
      const result = await this.googleWorkspaceService.createUser({
        firstName: crmUser.firstName,
        lastName: crmUser.lastName,
        email: crmUser.email,
        password: tempPassword
      });
      if (result.success) {
        await this.saveWorkspaceUserInfo(crmUser.id, {
          workspaceUserId: result.user?.id || "unknown",
          email: crmUser.email,
          tempPassword,
          // √Ä chiffrer en production
          createdAt: /* @__PURE__ */ new Date()
        });
        console.log(`\u2705 [GoogleWorkspaceIntegration] Compte Workspace cr\xE9\xE9 pour ${crmUser.email}`);
        await this.sendWelcomeEmail(crmUser, tempPassword);
        return {
          success: true,
          workspaceUser: result.user
        };
      } else {
        console.error(`\u274C [GoogleWorkspaceIntegration] \xC9chec cr\xE9ation compte pour ${crmUser.email}:`, result.error);
        return {
          success: false,
          error: result.error || "Erreur inconnue lors de la cr\xE9ation du compte"
        };
      }
    } catch (error) {
      console.error("\u274C [GoogleWorkspaceIntegration] Erreur cr\xE9ation utilisateur:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Erreur inconnue"
      };
    }
  }
  /**
   * V√©rifie si l'int√©gration Google Workspace est active
   */
  async isIntegrationActive() {
    try {
      const config = await db.googleWorkspaceConfig.findFirst({
        where: { isActive: true }
      });
      return !!config;
    } catch (error) {
      console.error("\u274C [GoogleWorkspaceIntegration] Erreur v\xE9rification statut:", error);
      return false;
    }
  }
  /**
   * Met √† jour le mot de passe d'un utilisateur Google Workspace
   */
  async updateUserPassword(email, newPassword) {
    try {
      if (!this.isInitialized || !this.googleWorkspaceService) {
        const initialized = await this.initialize();
        if (!initialized) {
          return {
            success: false,
            error: "Service Google Workspace non configur\xE9"
          };
        }
      }
      return await this.googleWorkspaceService.updateUserPassword(email, newPassword);
    } catch (error) {
      console.error("\u274C [GoogleWorkspaceIntegration] Erreur mise \xE0 jour mot de passe:", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Erreur inconnue"
      };
    }
  }
  /**
   * G√©n√®re un mot de passe s√©curis√© temporaire
   */
  generateSecurePassword() {
    const length = 16;
    const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
    let password = "";
    password += "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(Math.random() * 26)];
    password += "abcdefghijklmnopqrstuvwxyz"[Math.floor(Math.random() * 26)];
    password += "0123456789"[Math.floor(Math.random() * 10)];
    password += "!@#$%^&*"[Math.floor(Math.random() * 8)];
    for (let i = password.length; i < length; i++) {
      password += charset[Math.floor(Math.random() * charset.length)];
    }
    return password.split("").sort(() => Math.random() - 0.5).join("");
  }
  /**
   * Sauvegarde les informations du compte Workspace dans la DB
   */
  async saveWorkspaceUserInfo(crmUserId, workspaceInfo) {
    try {
      console.log(`\u{1F4BE} [GoogleWorkspaceIntegration] Sauvegarde infos Workspace pour user ${crmUserId}`, workspaceInfo);
    } catch (error) {
      console.error("\u274C [GoogleWorkspaceIntegration] Erreur sauvegarde infos Workspace:", error);
    }
  }
  /**
   * Envoie un email de bienvenue avec les informations de connexion
   */
  async sendWelcomeEmail(user, _tempPassword) {
    try {
      console.log(`\u{1F4E7} [GoogleWorkspaceIntegration] Envoi email de bienvenue \xE0 ${user.email}`);
    } catch (error) {
      console.error("\u274C [GoogleWorkspaceIntegration] Erreur envoi email de bienvenue:", error);
    }
  }
};
var googleWorkspaceIntegration = GoogleWorkspaceIntegrationService.getInstance();

// src/routes/invitations.ts
var router8 = (0, import_express9.Router)();
router8.use(authMiddleware, impersonationMiddleware);
var createInvitationSchema = import_zod.z.object({
  email: import_zod.z.string().email("L'adresse e-mail est invalide."),
  roleName: import_zod.z.string().min(1, "Le nom du r\xF4le est requis."),
  organizationId: import_zod.z.string().uuid("L'ID de l'organisation est requis et doit \xEAtre un UUID valide."),
  createWorkspaceAccount: import_zod.z.boolean().optional().default(false)
  // ‚úÖ NOUVEAU
});
router8.post("/", authMiddleware, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { email, roleName, organizationId, createWorkspaceAccount } = createInvitationSchema.parse(req2.body);
    const inviterId = req2.user.userId;
    const existingUserInOrg = await db.userOrganization.findFirst({
      where: {
        organizationId,
        User: { email }
      }
    });
    if (existingUserInOrg) {
      res.status(409).json({ message: "Un utilisateur avec cet e-mail est d\xE9j\xE0 membre de cette organisation." });
      return;
    }
    const role = await db.role.findFirst({
      where: {
        name: roleName,
        OR: [
          { organizationId },
          // R√¥le sp√©cifique √† l'organisation
          { organizationId: null }
          // R√¥le global
        ]
      }
    });
    if (!role) {
      res.status(404).json({ message: `Le r\xF4le '${roleName}' n'a pas \xE9t\xE9 trouv\xE9.` });
      return;
    }
    const existingInvitation = await db.invitation.findUnique({
      where: { email_organizationId: { email, organizationId } }
    });
    if (existingInvitation && existingInvitation.status === "PENDING" && existingInvitation.expiresAt > /* @__PURE__ */ new Date()) {
      res.status(409).json({ message: "Une invitation active existe d\xE9j\xE0 pour cette adresse e-mail dans cette organisation." });
      return;
    }
    if (existingInvitation) {
      await db.invitation.delete({ where: { id: existingInvitation.id } });
    }
    const targetUser = await db.user.findUnique({
      where: { email }
    });
    const token = (0, import_uuid.v4)();
    const expiresAt = /* @__PURE__ */ new Date();
    expiresAt.setDate(expiresAt.getDate() + 7);
    const invitationData = {
      email,
      token,
      expiresAt,
      Organization: { connect: { id: organizationId } },
      Role: { connect: { id: role.id } },
      // Relation "Invitation_invitedByIdToUser" c√¥t√© Invitation est expos√©e comme
      // User_Invitation_invitedByIdToUser dans le client Prisma
      User_Invitation_invitedByIdToUser: { connect: { id: inviterId } },
      status: "PENDING",
      createWorkspaceAccount: createWorkspaceAccount || false
      // ‚úÖ NOUVEAU
    };
    if (targetUser) {
      invitationData.User_Invitation_targetUserIdToUser = { connect: { id: targetUser.id } };
    }
    const newInvitation = await db.invitation.create({
      data: invitationData,
      include: {
        Organization: true,
        Role: true
      }
    });
    try {
      await emailService.sendInvitationEmail({
        to: newInvitation.email,
        token: newInvitation.token,
        isExistingUser: !!targetUser,
        organizationName: newInvitation.Organization.name,
        roleName: newInvitation.Role.label || newInvitation.Role.name
      });
    } catch (emailError) {
      console.error("\xC9chec de l'envoi de l'e-mail d'invitation:", emailError);
    }
    res.status(201).json({
      success: true,
      message: "Invitation envoy\xE9e avec succ\xE8s.",
      data: {
        id: newInvitation.id,
        token: newInvitation.token,
        isExistingUser: !!targetUser
      }
    });
  } catch (error) {
    if (error instanceof import_zod.z.ZodError) {
      res.status(400).json({ message: "Donn\xE9es invalides.", details: error.errors });
      return;
    }
    if (error instanceof import_client3.Prisma.PrismaClientKnownRequestError) {
      if (error.code === "P2002") {
        const target = error.meta?.target ?? "champs inconnus";
        console.error(`Erreur de contrainte unique (P2002) sur ${target}:`, error);
        res.status(409).json({
          message: `Conflit de donn\xE9es. Une entr\xE9e avec ces informations existe d\xE9j\xE0.`
        });
        return;
      }
    }
    console.error("Erreur lors de la cr\xE9ation de l'invitation:", error);
    res.status(500).json({ message: "Erreur interne du serveur." });
  }
});
router8.post("/:id/resend", authMiddleware, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { id } = req2.params;
  try {
    const invitation = await db.invitation.findFirst({
      where: { id, status: { in: ["PENDING", "DISABLED"] } }
    });
    if (!invitation) {
      res.status(404).json({ success: false, message: "Invitation non trouv\xE9e, d\xE9j\xE0 utilis\xE9e ou expir\xE9e." });
      return;
    }
    const newToken = (0, import_uuid.v4)();
    const newExpiresAt = /* @__PURE__ */ new Date();
    newExpiresAt.setDate(newExpiresAt.getDate() + 7);
    const updatedInvitation = await db.invitation.update({
      where: { id },
      data: {
        token: newToken,
        expiresAt: newExpiresAt,
        status: "PENDING"
        // R√©activer l'invitation si elle √©tait d√©sactiv√©e
      }
    });
    res.status(200).json({ success: true, message: "L'invitation a \xE9t\xE9 renvoy\xE9e avec succ\xE8s.", data: { token: updatedInvitation.token } });
  } catch (error) {
    console.error("Erreur lors du renvoi de l'invitation:", error);
    res.status(500).json({ success: false, message: "Erreur interne du serveur." });
  }
});
router8.patch("/:id/status", authMiddleware, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { id } = req2.params;
  const { status } = req2.body;
  if (!["PENDING", "DISABLED"].includes(status)) {
    res.status(400).json({ message: "Statut invalide. Seuls PENDING et DISABLED sont autoris\xE9s." });
    return;
  }
  try {
    const invitation = await db.invitation.findUnique({ where: { id } });
    if (!invitation) {
      res.status(404).json({ message: "Invitation non trouv\xE9e." });
      return;
    }
    if (invitation.status !== "PENDING" && invitation.status !== "DISABLED") {
      res.status(400).json({ message: `L'invitation ne peut pas \xEAtre modifi\xE9e car son statut est ${invitation.status}.` });
      return;
    }
    const updatedInvitation = await db.invitation.update({
      where: { id },
      data: { status }
    });
    res.json({ success: true, data: updatedInvitation });
  } catch (error) {
    console.error(`Erreur lors de la mise \xE0 jour du statut de l'invitation ${id}:`, error);
    res.status(500).json({ success: false, message: "Erreur interne du serveur." });
  }
});
var verifyTokenSchema = import_zod.z.object({
  token: import_zod.z.string().uuid("Le format du jeton est invalide.")
});
router8.get("/verify", async (req2, res) => {
  try {
    const { token } = verifyTokenSchema.parse(req2.query);
    const invitation = await db.invitation.findUnique({
      where: {
        token,
        expiresAt: { gte: /* @__PURE__ */ new Date() },
        status: "PENDING"
      },
      include: {
        Organization: { select: { name: true } },
        Role: { select: { name: true, label: true } }
      }
    });
    if (!invitation) {
      res.status(404).json({ message: "Invitation non trouv\xE9e, invalide, expir\xE9e ou d\xE9j\xE0 utilis\xE9e." });
      return;
    }
    const isExistingUser = !!invitation.targetUserId;
    res.json({
      success: true,
      data: {
        email: invitation.email,
        // Normaliser les cl√©s attendues par le frontend (lowercase)
        organization: invitation.Organization,
        role: invitation.Role,
        isExistingUser
      }
    });
  } catch (error) {
    if (error instanceof import_zod.z.ZodError) {
      res.status(400).json({ message: "Jeton invalide fourni.", details: error.errors });
      return;
    }
    console.error("Erreur lors de la v\xE9rification du jeton d'invitation:", error);
    res.status(500).json({ message: "Erreur interne du serveur." });
  }
});
var acceptInvitationSchema = import_zod.z.object({
  token: import_zod.z.string().uuid("Le format du jeton est invalide."),
  firstName: import_zod.z.string().min(1, "Le pr\xE9nom est requis."),
  lastName: import_zod.z.string().min(1, "Le nom est requis."),
  password: import_zod.z.string().min(8, "Le mot de passe doit contenir au moins 8 caract\xE8res.")
});
router8.post("/accept", async (req2, res) => {
  try {
    const invitationToken = import_zod.z.string().uuid("Le format du jeton est invalide.").parse(req2.body.token);
    const invitation = await db.invitation.findUnique({
      where: {
        token: invitationToken,
        expiresAt: { gte: /* @__PURE__ */ new Date() },
        status: "PENDING"
      },
      include: {
        Organization: true
        // Pour r√©cup√©rer les infos organisation
      }
    });
    if (!invitation) {
      res.status(404).json({ message: "Invitation non trouv\xE9e, invalide, expir\xE9e ou d\xE9j\xE0 utilis\xE9e." });
      return;
    }
    if (invitation.targetUserId) {
      const user = await db.user.findUnique({ where: { id: invitation.targetUserId } });
      if (!user) {
        res.status(404).json({ message: "L'utilisateur associ\xE9 \xE0 cette invitation n'existe plus." });
        return;
      }
      if (!user.commercialSlug && user.firstName && user.lastName) {
        const normalizeString2 = (str) => {
          return str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
        };
        const baseSlug2 = `${normalizeString2(user.firstName)}-${normalizeString2(user.lastName)}`;
        let commercialSlug2 = baseSlug2;
        let counter2 = 2;
        while (await db.user.findFirst({
          where: {
            organizationId: invitation.organizationId,
            commercialSlug: commercialSlug2,
            id: { not: user.id }
          }
        })) {
          commercialSlug2 = `${baseSlug2}-${counter2}`;
          counter2++;
        }
        await db.user.update({
          where: { id: user.id },
          data: {
            commercialSlug: commercialSlug2,
            organizationId: invitation.organizationId
          }
        });
      }
      await db.$transaction(async (tx) => {
        await tx.userOrganization.create({
          data: {
            userId: user.id,
            organizationId: invitation.organizationId,
            roleId: invitation.roleId,
            status: "ACTIVE"
          }
        });
        await tx.invitation.update({
          where: { id: invitation.id },
          data: { status: "ACCEPTED" }
        });
      });
      if (invitation.createWorkspaceAccount) {
        try {
          const workspaceService = new GoogleWorkspaceIntegrationService(invitation.organizationId);
          await workspaceService.initialize();
          const workspaceResult = await workspaceService.createUserAccount(
            user.id,
            user.firstName || "",
            user.lastName || ""
          );
          if (workspaceResult.success) {
            console.log(`\u2705 [Invitation] Compte workspace cr\xE9\xE9 pour ${user.email}: ${workspaceResult.email}`);
          } else {
            console.error(`\u26A0\uFE0F [Invitation] \xC9chec cr\xE9ation workspace pour ${user.email}:`, workspaceResult.error);
          }
        } catch (wsError) {
          console.error(`\u26A0\uFE0F [Invitation] Erreur cr\xE9ation workspace:`, wsError);
        }
      }
      res.status(200).json({
        success: true,
        message: invitation.createWorkspaceAccount ? `Vous avez rejoint l'organisation avec succ\xE8s. Un compte Google Workspace sera cr\xE9\xE9.` : `Vous avez rejoint l'organisation avec succ\xE8s.`
      });
      return;
    }
    const { firstName, lastName, password } = acceptInvitationSchema.parse(req2.body);
    const existingUser = await db.user.findUnique({ where: { email: invitation.email } });
    if (existingUser) {
      res.status(409).json({ message: "Un utilisateur avec cette adresse e-mail existe d\xE9j\xE0. Veuillez vous connecter pour accepter l'invitation." });
      return;
    }
    const passwordHash = await import_bcryptjs4.default.hash(password, 10);
    const normalizeString = (str) => {
      return str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
    };
    const baseSlug = `${normalizeString(firstName)}-${normalizeString(lastName)}`;
    let commercialSlug = baseSlug;
    let counter = 2;
    while (await db.user.findFirst({
      where: {
        organizationId: invitation.organizationId,
        commercialSlug
      }
    })) {
      commercialSlug = `${baseSlug}-${counter}`;
      counter++;
    }
    const newUser = await db.$transaction(async (tx) => {
      const createdUser = await tx.user.create({
        data: {
          firstName,
          lastName,
          email: invitation.email,
          passwordHash,
          status: "active",
          role: "user",
          organizationId: invitation.organizationId,
          commercialSlug
          // üéØ Slug commercial automatique
        }
      });
      await tx.userOrganization.create({
        data: {
          userId: createdUser.id,
          organizationId: invitation.organizationId,
          roleId: invitation.roleId
        }
      });
      await tx.invitation.update({
        where: { id: invitation.id },
        data: { status: "ACCEPTED" }
      });
      return createdUser;
    });
    let workspaceEmail = null;
    if (invitation.createWorkspaceAccount) {
      try {
        const workspaceService = new GoogleWorkspaceIntegrationService(invitation.organizationId);
        await workspaceService.initialize();
        const workspaceResult = await workspaceService.createUserAccount(
          newUser.id,
          firstName,
          lastName
        );
        if (workspaceResult.success) {
          workspaceEmail = workspaceResult.email || null;
          console.log(`\u2705 [Invitation] Compte workspace cr\xE9\xE9 pour nouvel utilisateur: ${workspaceEmail}`);
        } else {
          console.error(`\u26A0\uFE0F [Invitation] \xC9chec cr\xE9ation workspace:`, workspaceResult.error);
        }
      } catch (wsError) {
        console.error(`\u26A0\uFE0F [Invitation] Erreur cr\xE9ation workspace:`, wsError);
      }
    }
    res.status(201).json({
      success: true,
      message: invitation.createWorkspaceAccount ? "Inscription r\xE9ussie! Votre compte Google Workspace est en cours de cr\xE9ation." : "Inscription r\xE9ussie!",
      data: {
        userId: newUser.id,
        workspaceEmail
      }
    });
  } catch (error) {
    if (error instanceof import_zod.z.ZodError) {
      res.status(400).json({ message: "Donn\xE9es d'inscription invalides.", details: error.errors });
      return;
    }
    console.error("Erreur lors de l'acceptation de l'invitation:", error);
    res.status(500).json({ message: "Erreur interne du serveur." });
  }
});
router8.delete("/:id", authMiddleware, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { id } = req2.params;
  try {
    const invitation = await db.invitation.findFirst({
      where: { id, status: { in: ["PENDING", "DISABLED"] } }
    });
    if (!invitation) {
      res.status(404).json({ success: false, message: "Invitation non trouv\xE9e, d\xE9j\xE0 utilis\xE9e ou expir\xE9e." });
      return;
    }
    await db.invitation.delete({
      where: { id }
    });
    await db.user.deleteMany({
      where: {
        email: invitation.email,
        status: "invited"
      }
    });
    res.status(200).json({ success: true, message: "L'invitation a \xE9t\xE9 annul\xE9e avec succ\xE8s." });
  } catch (error) {
    console.error("Erreur lors de l'annulation de l'invitation:", error);
    res.status(500).json({ success: false, message: "Erreur interne du serveur." });
  }
});
router8.post("/:id/force-accept", requireRole2(["super_admin"]), async (req2, res) => {
  const { id } = req2.params;
  try {
    const invitation = await db.invitation.findUnique({ where: { id } });
    if (!invitation) {
      return res.status(404).json({ success: false, message: "Invitation non trouv\xE9e." });
    }
    if (invitation.status !== "PENDING") {
      return res.status(400).json({ success: false, message: `L'invitation a d\xE9j\xE0 le statut ${invitation.status}.` });
    }
    const existingUser = await db.user.findUnique({ where: { email: invitation.email } });
    if (existingUser) {
      return res.status(409).json({ success: false, message: "Un utilisateur avec cet e-mail existe d\xE9j\xE0." });
    }
    const tempPassword = (0, import_uuid.v4)();
    const passwordHash = await import_bcryptjs4.default.hash(tempPassword, 10);
    const newUser = await db.$transaction(async (tx) => {
      const createdUser = await tx.user.create({
        data: {
          email: invitation.email,
          passwordHash,
          status: "active",
          role: "user"
          // R√¥le global par d√©faut
          // Le pr√©nom/nom peuvent √™tre vides, l'utilisateur les mettra √† jour
        }
      });
      if (invitation.organizationId) {
        await tx.userOrganization.create({
          data: {
            userId: createdUser.id,
            organizationId: invitation.organizationId,
            roleId: invitation.roleId,
            status: "ACTIVE"
          }
        });
      }
      await tx.invitation.update({
        where: { id: invitation.id },
        data: { status: "ACCEPTED" }
      });
      return tx.user.findUnique({
        where: { id: createdUser.id },
        include: {
          UserOrganization: {
            include: {
              Organization: true,
              Role: true
            }
          }
        }
      });
    });
    res.status(201).json({ success: true, message: "L'utilisateur a \xE9t\xE9 cr\xE9\xE9 et l'invitation accept\xE9e.", data: newUser });
  } catch (error) {
    console.error("Erreur lors de l'acceptation forc\xE9e de l'invitation:", error);
    res.status(500).json({ success: false, message: "Erreur interne du serveur." });
  }
});
router8.get("/", authMiddleware, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { organizationId } = req2.query;
    const requestingUser = req2.user;
    if (!requestingUser) {
      res.status(401).json({ success: false, message: "Utilisateur non authentifi\xE9." });
      return;
    }
    const where = {};
    if (organizationId) {
      where.organizationId = organizationId;
    }
    if (requestingUser.role !== "super_admin" && requestingUser.organizationId) {
      where.organizationId = requestingUser.organizationId;
    }
    where.status = { in: ["PENDING", "DISABLED"] };
    const invitationsRaw = await db.invitation.findMany({
      where,
      include: {
        Role: true,
        Organization: true
      },
      orderBy: { createdAt: "desc" }
    });
    const invitations = invitationsRaw.map((inv) => ({
      ...inv,
      organization: inv.Organization,
      role: inv.Role
    }));
    res.json({ success: true, data: invitations });
  } catch (error) {
    console.error("Erreur lors de la r\xE9cup\xE9ration des invitations:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la r\xE9cup\xE9ration des invitations." });
  }
});
var invitations_default = router8;

// src/routes/organizations.ts
var import_express10 = require("express");
init_database();
var import_zod2 = require("zod");
var import_express_rate_limit = __toESM(require("express-rate-limit"), 1);
var import_crypto5 = require("crypto");
var router9 = (0, import_express10.Router)();
var prisma7 = db;
var sanitizeString = (input) => {
  return input.trim().replace(/[<>]/g, "");
};
var canAccessOrganization = (user, organizationId) => {
  if (user?.role === "super_admin") {
    return true;
  }
  return user?.organizationId === organizationId;
};
var isSuperAdmin = (user) => {
  return user?.role === "super_admin";
};
var isValidId = (id) => {
  if (!id) return false;
  const s = String(id).trim();
  const uuidRe = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  const cuidRe = /^c[a-z0-9]{7,}$/i;
  const simpleRe = /^[a-zA-Z0-9_-]{8,}$/;
  return uuidRe.test(s) || cuidRe.test(s) || simpleRe.test(s);
};
var validateAndSanitizeId = (id, fieldName = "ID") => {
  const sanitized2 = sanitizeString(String(id));
  if (!isValidId(sanitized2)) {
    throw new Error(`${fieldName} invalide`);
  }
  return sanitized2;
};
var GOOGLE_WORKSPACE_MODULES = ["gmail", "calendar", "drive", "meet", "docs", "sheets", "voice"];
var isGoogleWorkspaceModule = (moduleKey) => {
  return GOOGLE_WORKSPACE_MODULES.includes(moduleKey);
};
var getActiveGoogleModules = (moduleStatuses = []) => {
  return moduleStatuses.filter(
    (oms) => oms.active && oms.Module?.key && isGoogleWorkspaceModule(oms.Module.key)
  );
};
async function countRealActiveModules(organizationId) {
  const organization = await prisma7.organization.findUnique({
    where: { id: organizationId },
    select: {
      GoogleWorkspaceConfig: true,
      name: true
    }
  });
  const hasGoogleWorkspace = !!organization?.GoogleWorkspaceConfig;
  const allActiveModules = await prisma7.module.findMany({
    where: {
      active: true
    },
    include: {
      OrganizationModuleStatus: {
        where: {
          organizationId
        }
      }
    }
  });
  const activeModulesForOrg = allActiveModules.filter((module2) => {
    const moduleStatus = module2.OrganizationModuleStatus[0];
    if (module2.key && module2.key.toLowerCase().startsWith("google_") && !hasGoogleWorkspace) {
      return false;
    }
    if (moduleStatus) {
      return moduleStatus.active;
    } else {
      return true;
    }
  });
  return activeModulesForOrg.length;
}
function hasGoogleWorkspaceEnabled(moduleStatuses = [], googleWorkspaceConfig) {
  const hasActiveModules = getActiveGoogleModules(moduleStatuses).length > 0;
  const hasActiveConfig = googleWorkspaceConfig?.isActive === true;
  return hasActiveModules || hasActiveConfig;
}
var extractGoogleWorkspaceDomain = (organization) => {
  if (organization.features?.includes("google_workspace")) {
    return `${organization.name.toLowerCase().replace(/\s+/g, "")}.com`;
  }
  return null;
};
var cleanupOrganizationData = async (tx, organizationId) => {
  const runDelete = async (label, action2) => {
    try {
      await action2();
    } catch (error) {
      console.error(`[ORGANIZATIONS] \u274C \xC9chec suppression ${label} pour ${organizationId}`, error);
      throw error;
    }
  };
  await runDelete("CalendarParticipant", () => tx.calendarParticipant.deleteMany({
    where: {
      CalendarEvent: {
        organizationId
      }
    }
  }));
  await runDelete("FormSubmission", () => tx.formSubmission.deleteMany({
    where: {
      Block: {
        organizationId
      }
    }
  }));
  await runDelete("AIRecommendation", () => tx.aIRecommendation.deleteMany({ where: { organizationId } }));
  await runDelete("AdCampaign", () => tx.adCampaign.deleteMany({ where: { organizationId } }));
  await runDelete("AdPlatformIntegration", () => tx.adPlatformIntegration.deleteMany({ where: { organizationId } }));
  await runDelete("AnalyticsEvent", () => tx.analyticsEvent.deleteMany({ where: { organizationId } }));
  await runDelete("AutomationRule", () => tx.automationRule.deleteMany({ where: { organizationId } }));
  await runDelete("AiUsageLog", () => tx.aiUsageLog.deleteMany({ where: { organizationId } }));
  await runDelete("CallToLeadMapping", () => tx.callToLeadMapping.deleteMany({ where: { organizationId } }));
  await runDelete("CallStatus", () => tx.callStatus.deleteMany({ where: { organizationId } }));
  await runDelete("Category", () => tx.category.deleteMany({ where: { organizationId } }));
  await runDelete("GoogleMailWatch", () => tx.googleMailWatch.deleteMany({ where: { organizationId } }));
  await runDelete("GoogleToken", () => tx.googleToken.deleteMany({ where: { organizationId } }));
  await runDelete("GoogleVoiceCall", () => tx.googleVoiceCall.deleteMany({ where: { organizationId } }));
  await runDelete("GoogleVoiceConfig", () => tx.googleVoiceConfig.deleteMany({ where: { organizationId } }));
  await runDelete("GoogleVoiceSMS", () => tx.googleVoiceSMS.deleteMany({ where: { organizationId } }));
  await runDelete("GoogleWorkspaceConfig", () => tx.googleWorkspaceConfig.deleteMany({ where: { organizationId } }));
  await runDelete("IntegrationsSettings", () => tx.integrationsSettings.deleteMany({ where: { organizationId } }));
  await runDelete("Invitation", () => tx.invitation.deleteMany({ where: { organizationId } }));
  await runDelete("Lead", () => tx.lead.deleteMany({ where: { organizationId } }));
  await runDelete("LeadSource", () => tx.leadSource.deleteMany({ where: { organizationId } }));
  await runDelete("LeadStatus", () => tx.leadStatus.deleteMany({ where: { organizationId } }));
  await runDelete("Module", () => tx.module.deleteMany({ where: { organizationId } }));
  await runDelete("Notification", () => tx.notification.deleteMany({ where: { organizationId } }));
  await runDelete("Order", () => tx.order.deleteMany({ where: { organizationId } }));
  await runDelete("OrganizationModuleStatus", () => tx.organizationModuleStatus.deleteMany({ where: { organizationId } }));
  await runDelete("OrganizationRoleStatus", () => tx.organizationRoleStatus.deleteMany({ where: { organizationId } }));
  await runDelete("Permission", () => tx.permission.deleteMany({ where: { organizationId } }));
  await runDelete("Product", () => tx.product.deleteMany({ where: { organizationId } }));
  await runDelete("Role", () => tx.role.deleteMany({ where: { organizationId } }));
  await runDelete("TechnicalData", () => tx.technicalData.deleteMany({ where: { organizationId } }));
  await runDelete("TelnyxCall", () => tx.telnyxCall.deleteMany({ where: { organizationId } }));
  await runDelete("TelnyxConnection", () => tx.telnyxConnection.deleteMany({ where: { organizationId } }));
  await runDelete("TelnyxMessage", () => tx.telnyxMessage.deleteMany({ where: { organizationId } }));
  await runDelete("TelnyxPhoneNumber", () => tx.telnyxPhoneNumber.deleteMany({ where: { organizationId } }));
  await runDelete("TelnyxUserConfig", () => tx.telnyxUserConfig.deleteMany({ where: { organizationId } }));
  await runDelete("TimelineEvent", () => tx.timelineEvent.deleteMany({ where: { organizationId } }));
  await runDelete("TreeBranchLeafNodeCondition", () => tx.treeBranchLeafNodeCondition.deleteMany({ where: { organizationId } }));
  await runDelete("TreeBranchLeafNodeFormula", () => tx.treeBranchLeafNodeFormula.deleteMany({ where: { organizationId } }));
  await runDelete("TreeBranchLeafNodeTable", () => tx.treeBranchLeafNodeTable.deleteMany({ where: { organizationId } }));
  await runDelete("TreeBranchLeafMarker", () => tx.treeBranchLeafMarker.deleteMany({ where: { organizationId } }));
  await runDelete("TreeBranchLeafTree", () => tx.treeBranchLeafTree.deleteMany({ where: { organizationId } }));
  await runDelete("EcommerceIntegration", () => tx.ecommerceIntegration.deleteMany({ where: { organizationId } }));
  await runDelete("EmailAccount", () => tx.emailAccount.deleteMany({ where: { organizationId } }));
  await runDelete("EmailDomain", () => tx.emailDomain.deleteMany({ where: { organizationId } }));
  await runDelete("EmailTemplate", () => tx.emailTemplate.deleteMany({ where: { organizationId } }));
  await runDelete("CalendarEvent", () => tx.calendarEvent.deleteMany({ where: { organizationId } }));
  await runDelete("Block", () => tx.block.deleteMany({ where: { organizationId } }));
  await runDelete("UserOrganization", () => tx.userOrganization.deleteMany({ where: { organizationId } }));
};
var organizationCreateSchema = import_zod2.z.object({
  name: import_zod2.z.string().min(2, "Nom organisation minimum 2 caract\xE8res").max(100, "Nom organisation maximum 100 caract\xE8res").regex(/^[a-zA-Z0-9\s\-_]+$/, "Nom organisation contient des caract\xE8res non autoris\xE9s"),
  description: import_zod2.z.string().max(500, "Description maximum 500 caract\xE8res").optional(),
  status: import_zod2.z.enum(["ACTIVE", "INACTIVE"], {
    errorMap: () => ({ message: "Statut doit \xEAtre ACTIVE ou INACTIVE" })
  }).optional(),
  // üìû NOUVEAUX CHAMPS DE CONTACT
  website: import_zod2.z.string().url("Site web doit \xEAtre une URL valide").max(255, "Site web maximum 255 caract\xE8res").optional(),
  phone: import_zod2.z.string().max(20, "T\xE9l\xE9phone maximum 20 caract\xE8res").regex(/^[\d\s\-+().]+$/, "Num\xE9ro de t\xE9l\xE9phone contient des caract\xE8res non autoris\xE9s").optional(),
  address: import_zod2.z.string().max(500, "Adresse maximum 500 caract\xE8res").optional(),
  // üåü GOOGLE WORKSPACE CONFIGURATION
  googleWorkspace: import_zod2.z.object({
    enabled: import_zod2.z.boolean().default(false),
    domain: import_zod2.z.string().optional(),
    adminEmail: import_zod2.z.string().email().optional(),
    modules: import_zod2.z.object({
      gmail: import_zod2.z.boolean().default(false),
      calendar: import_zod2.z.boolean().default(false),
      drive: import_zod2.z.boolean().default(false),
      meet: import_zod2.z.boolean().default(false),
      docs: import_zod2.z.boolean().default(false),
      sheets: import_zod2.z.boolean().default(false),
      voice: import_zod2.z.boolean().default(false)
    }).optional()
  }).optional()
});
var organizationUpdateSchema = import_zod2.z.object({
  name: import_zod2.z.string().min(2, "Nom organisation minimum 2 caract\xE8res").max(100, "Nom organisation maximum 100 caract\xE8res").regex(/^[a-zA-Z0-9\s\-_]+$/, "Nom organisation contient des caract\xE8res non autoris\xE9s").optional(),
  description: import_zod2.z.string().max(500, "Description maximum 500 caract\xE8res").nullish(),
  status: import_zod2.z.enum(["ACTIVE", "INACTIVE"], {
    errorMap: () => ({ message: "Statut doit \xEAtre ACTIVE ou INACTIVE" })
  }).optional(),
  // üìû NOUVEAUX CHAMPS DE CONTACT
  website: import_zod2.z.string().url("Site web doit \xEAtre une URL valide").max(255, "Site web maximum 255 caract\xE8res").nullish(),
  phone: import_zod2.z.string().max(20, "T\xE9l\xE9phone maximum 20 caract\xE8res").regex(/^[\d\s\-+().]+$/, "Num\xE9ro de t\xE9l\xE9phone contient des caract\xE8res non autoris\xE9s").nullish(),
  address: import_zod2.z.string().max(500, "Adresse maximum 500 caract\xE8res").nullish(),
  googleWorkspace: import_zod2.z.object({
    enabled: import_zod2.z.boolean().optional(),
    domain: import_zod2.z.string().optional(),
    adminEmail: import_zod2.z.string().email().optional(),
    modules: import_zod2.z.object({
      gmail: import_zod2.z.boolean().optional(),
      calendar: import_zod2.z.boolean().optional(),
      drive: import_zod2.z.boolean().optional(),
      meet: import_zod2.z.boolean().optional(),
      docs: import_zod2.z.boolean().optional(),
      sheets: import_zod2.z.boolean().optional(),
      voice: import_zod2.z.boolean().optional()
    }).optional()
  }).optional()
});
var organizationsRateLimit = (0, import_express_rate_limit.default)({
  windowMs: 60 * 1e3,
  // 1 minute
  max: 300,
  // 300 requ√™tes par minute (tr√®s strict)
  skipSuccessfulRequests: false,
  skipFailedRequests: false,
  handler: (_req, res) => {
    console.log("\u{1F6A8} [ORGANIZATIONS] Rate limit d\xE9pass\xE9");
    res.status(429).json({
      success: false,
      message: "Trop de requ\xEAtes. Veuillez attendre."
    });
  }
});
var organizationsCreateRateLimit = (0, import_express_rate_limit.default)({
  windowMs: 60 * 1e3,
  // 1 minute
  max: 20,
  // 20 cr√©ations par minute max
  skipSuccessfulRequests: false,
  skipFailedRequests: false,
  handler: (_req, res) => {
    res.status(429).json({
      success: false,
      message: "Limite de cr\xE9ation atteinte. Attendez 1 minute."
    });
  }
});
var organizationsDeleteRateLimit = (0, import_express_rate_limit.default)({
  windowMs: 60 * 1e3,
  // 1 minute
  max: 10,
  // 10 suppressions par minute max
  skipSuccessfulRequests: false,
  skipFailedRequests: false,
  handler: (_req, res) => {
    res.status(429).json({
      success: false,
      message: "Limite de suppression atteinte. Attendez 1 minute."
    });
  }
});
var handleZodError = (error) => {
  return {
    success: false,
    message: "Donn\xE9es invalides",
    errors: error.errors.map((e) => `${e.path.join(".")}: ${e.message}`)
  };
};
router9.get("/public", async (_req, res) => {
  try {
    const organizations = await prisma7.organization.findMany({
      where: {
        status: { in: ["ACTIVE", "active"] }
      },
      select: {
        id: true,
        name: true,
        description: true,
        // Optionnel: nombre de membres pour affichage
        _count: {
          select: {
            UserOrganization: {
              where: { status: "ACTIVE" }
            }
          }
        }
      },
      orderBy: { name: "asc" }
    });
    const publicOrgs = organizations.map((org) => ({
      id: org.id,
      name: org.name,
      description: org.description || void 0,
      memberCount: org._count?.UserOrganization || 0
    }));
    console.log(`[Organizations] /public - ${publicOrgs.length} organisations retourn\xE9es`);
    res.json({
      success: true,
      data: publicOrgs
    });
  } catch (error) {
    console.error("[Organizations] Erreur /public:", error);
    res.status(500).json({ success: false, error: "Erreur serveur" });
  }
});
router9.use(authMiddleware);
router9.use(organizationsRateLimit);
router9.get("/active", async (req2, res) => {
  try {
    const requestingUser = req2.user;
    const { search, userId } = req2.query;
    const where = {
      status: { in: ["ACTIVE", "active"] }
      // ‚úÖ Accepter variantes de statut
    };
    if (search && typeof search === "string") {
      const sanitizedSearch = sanitizeString(search);
      where.name = {
        contains: sanitizedSearch,
        mode: "insensitive"
      };
    }
    if (userId && typeof userId === "string") {
      const userOrgs = await prisma7.userOrganization.findMany({
        where: { userId: sanitizeString(userId) },
        select: { organizationId: true }
      });
      const orgIds = userOrgs.map((uo) => uo.organizationId);
      if (orgIds.length === 0) {
        return res.json({ success: true, data: [] });
      }
      where.id = { in: orgIds };
    }
    if (isSuperAdmin(requestingUser)) {
    } else if (requestingUser?.role === "admin" && requestingUser.organizationId) {
      where.id = requestingUser.organizationId;
    } else if (requestingUser?.organizationId) {
      where.id = requestingUser.organizationId;
    } else {
      console.log("[ORGANIZATIONS] Acc\xE8s refus\xE9 - pas d'organisation assign\xE9e");
      return res.status(403).json({
        success: false,
        message: "Acc\xE8s refus\xE9"
      });
    }
    const organizations = await prisma7.organization.findMany({
      where,
      include: {
        _count: {
          select: {
            UserOrganization: true,
            Role: true
          }
        },
        OrganizationModuleStatus: {
          include: {
            Module: true
          }
        },
        Role: {
          select: {
            id: true,
            name: true,
            isGlobal: true
          }
        },
        GoogleWorkspaceConfig: {
          // ‚úÖ NOUVEAU : Inclure la configuration Google Workspace
          select: {
            id: true,
            isActive: true,
            domain: true
          }
        }
      },
      orderBy: {
        name: "asc"
      }
    });
    const enrichedOrganizations = await Promise.all(organizations.map(async (org) => {
      const activeGoogleModules = getActiveGoogleModules(org.OrganizationModuleStatus);
      const realActiveModulesCount = await countRealActiveModules(org.id);
      return {
        ...org,
        stats: {
          totalUsers: org._count?.UserOrganization ?? 0,
          totalRoles: org._count?.Role ?? 0,
          activeModules: realActiveModulesCount,
          // ‚úÖ DYNAMIQUE : Comptage r√©el en temps r√©el
          googleWorkspaceEnabled: hasGoogleWorkspaceEnabled(org.OrganizationModuleStatus, org.GoogleWorkspaceConfig)
        },
        googleWorkspaceDomain: org.GoogleWorkspaceConfig?.domain || extractGoogleWorkspaceDomain(org),
        googleWorkspaceModules: activeGoogleModules.map((oms) => oms.Module).filter(Boolean)
      };
    }));
    res.json({
      success: true,
      data: enrichedOrganizations
    });
  } catch (error) {
    console.error("[ORGANIZATIONS] Erreur GET /active:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la r\xE9cup\xE9ration des organisations actives"
    });
  }
});
router9.get("/", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const requestingUser = req2.user;
    const { search, userId } = req2.query;
    const where = {};
    if (search && typeof search === "string") {
      const sanitizedSearch = sanitizeString(search);
      where.name = {
        contains: sanitizedSearch,
        mode: "insensitive"
      };
    }
    if (userId && typeof userId === "string") {
      const userOrgs = await prisma7.userOrganization.findMany({
        where: { userId: sanitizeString(userId) },
        select: { organizationId: true }
      });
      const orgIds = userOrgs.map((uo) => uo.organizationId);
      if (orgIds.length === 0) {
        return res.json({ success: true, data: [] });
      }
      where.id = { in: orgIds };
    }
    if (isSuperAdmin(requestingUser)) {
    } else if (requestingUser?.role === "admin" && requestingUser.organizationId) {
      where.id = requestingUser.organizationId;
    } else {
      return res.status(403).json({
        success: false,
        message: "Acc\xE8s refus\xE9"
      });
    }
    const organizations = await prisma7.organization.findMany({
      where,
      include: {
        _count: {
          select: {
            UserOrganization: true,
            Role: true
            // ‚úÖ AJOUT : Compter les r√¥les
          }
        },
        OrganizationModuleStatus: {
          include: {
            Module: true
          }
        },
        Role: {
          // ‚úÖ AJOUT : Inclure les r√¥les pour statistiques d√©taill√©es
          select: {
            id: true,
            name: true,
            isGlobal: true
          }
        },
        GoogleWorkspaceConfig: {
          // ‚úÖ NOUVEAU : Inclure la configuration Google Workspace
          select: {
            id: true,
            isActive: true,
            domain: true
          }
        }
      },
      orderBy: {
        name: "asc"
      }
    });
    const enrichedOrganizations = await Promise.all(organizations.map(async (org) => {
      const activeGoogleModules = getActiveGoogleModules(org.OrganizationModuleStatus);
      const realActiveModulesCount = await countRealActiveModules(org.id);
      return {
        ...org,
        stats: {
          totalUsers: org._count?.UserOrganization ?? 0,
          totalRoles: org._count?.Role ?? 0,
          // ‚úÖ CORRIG√â : Nombre r√©el de r√¥les
          activeModules: realActiveModulesCount,
          // ‚úÖ DYNAMIQUE : Comptage r√©el en temps r√©el
          googleWorkspaceEnabled: hasGoogleWorkspaceEnabled(org.OrganizationModuleStatus, org.GoogleWorkspaceConfig)
        },
        googleWorkspaceDomain: org.GoogleWorkspaceConfig?.domain || extractGoogleWorkspaceDomain(org),
        // ‚úÖ AM√âLIOR√â : Utiliser le vrai domaine de la config
        googleWorkspaceModules: activeGoogleModules.map((oms) => oms.Module).filter(Boolean)
      };
    }));
    res.json({
      success: true,
      data: enrichedOrganizations
    });
  } catch (error) {
    console.error("[ORGANIZATIONS] Erreur GET:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la r\xE9cup\xE9ration des organisations"
    });
  }
});
router9.post("/", organizationsCreateRateLimit, requireRole2(["super_admin"]), async (req2, res) => {
  try {
    const validation = organizationCreateSchema.safeParse(req2.body);
    if (!validation.success) {
      console.log("[ORGANIZATIONS] Validation \xE9chou\xE9e:", validation.error);
      return res.status(400).json(handleZodError(validation.error));
    }
    const data = validation.data;
    const sanitizedData = {
      name: sanitizeString(data.name),
      description: data.description ? sanitizeString(data.description) : null,
      status: (data.status || "ACTIVE").toUpperCase(),
      // üìû NOUVEAUX CHAMPS DE CONTACT
      website: data.website ? sanitizeString(data.website) : null,
      phone: data.phone ? sanitizeString(data.phone) : null,
      address: data.address ? sanitizeString(data.address) : null
    };
    console.log("[ORGANIZATIONS] Donn\xE9es sanitis\xE9es:", sanitizedData);
    const existingOrg = await prisma7.organization.findFirst({
      where: {
        name: {
          equals: sanitizedData.name,
          mode: "insensitive"
        }
      }
    });
    if (existingOrg) {
      return res.status(409).json({
        success: false,
        message: "Une organisation avec ce nom existe d\xE9j\xE0"
      });
    }
    const now = /* @__PURE__ */ new Date();
    const generatedId = (0, import_crypto5.randomUUID)();
    const newOrganization = await prisma7.$transaction(async (tx) => {
      const org = await tx.organization.create({
        data: {
          id: generatedId,
          name: sanitizedData.name,
          description: sanitizedData.description,
          status: sanitizedData.status,
          website: sanitizedData.website,
          phone: sanitizedData.phone,
          address: sanitizedData.address,
          createdAt: now,
          updatedAt: now
        }
      });
      if (data.googleWorkspace?.enabled) {
      }
      return org;
    });
    console.log("[ORGANIZATIONS] Organisation cr\xE9\xE9e avec succ\xE8s:", newOrganization.id);
    res.status(201).json({
      success: true,
      message: "Organisation cr\xE9\xE9e avec succ\xE8s",
      data: newOrganization
    });
  } catch (error) {
    console.error("[ORGANIZATIONS] Erreur POST:", error);
    if (error instanceof import_zod2.z.ZodError) {
      return res.status(400).json(handleZodError(error));
    }
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la cr\xE9ation de l'organisation"
    });
  }
});
router9.get("/:id", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const requestingUser = req2.user;
    const sanitizedId = validateAndSanitizeId(id, "ID organisation");
    if (!canAccessOrganization(requestingUser, sanitizedId)) {
      return res.status(403).json({
        success: false,
        message: "Acc\xE8s refus\xE9 \xE0 cette organisation"
      });
    }
    const organization = await prisma7.organization.findUnique({
      where: { id: sanitizedId },
      include: {
        UserOrganization: {
          include: {
            User: {
              select: {
                id: true,
                email: true,
                firstName: true,
                lastName: true
              }
            },
            Role: {
              select: {
                id: true,
                name: true,
                label: true
              }
            }
          }
        },
        OrganizationModuleStatus: {
          include: {
            Module: true
          }
        },
        _count: {
          select: {
            UserOrganization: true,
            Role: true
            // ‚úÖ AJOUT : Compter les r√¥les pour organisation individuelle
          }
        },
        Role: {
          // ‚úÖ AJOUT : Inclure les r√¥les de l'organisation
          select: {
            id: true,
            name: true,
            label: true,
            isGlobal: true
          }
        },
        GoogleWorkspaceConfig: {
          // ‚úÖ NOUVEAU : Inclure la configuration Google Workspace
          select: {
            id: true,
            isActive: true,
            domain: true
          }
        }
      }
    });
    if (!organization) {
      return res.status(404).json({
        success: false,
        message: "Organisation non trouv\xE9e"
      });
    }
    const activeGoogleModules = getActiveGoogleModules(organization.OrganizationModuleStatus);
    const realActiveModulesCount = await countRealActiveModules(organization.id);
    console.log(`[DEBUG] Organisation individuelle ${organization.name}: ${realActiveModulesCount} modules r\xE9ellement actifs`);
    const enrichedOrganization = {
      ...organization,
      stats: {
        totalUsers: organization._count?.UserOrganization ?? 0,
        totalRoles: organization._count?.Role ?? 0,
        // ‚úÖ CORRIG√â : Utilise le count direct des r√¥les
        activeModules: realActiveModulesCount,
        // ‚úÖ DYNAMIQUE : Comptage r√©el en temps r√©el
        googleWorkspaceEnabled: hasGoogleWorkspaceEnabled(organization.OrganizationModuleStatus, organization.GoogleWorkspaceConfig)
      },
      googleWorkspaceDomain: organization.GoogleWorkspaceConfig?.domain || extractGoogleWorkspaceDomain(organization),
      // ‚úÖ AM√âLIOR√â : Utiliser le vrai domaine de la config
      googleWorkspaceModules: activeGoogleModules.map((oms) => oms.Module).filter(Boolean)
    };
    res.json({
      success: true,
      data: enrichedOrganization
    });
  } catch (error) {
    console.error("[ORGANIZATIONS] Erreur GET /:id:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la r\xE9cup\xE9ration de l'organisation"
    });
  }
});
router9.put("/:id", requireRole2(["super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    console.log("\u{1F50D} [ORGANIZATIONS] ID re\xE7u:", id);
    console.log("\u{1F50D} [ORGANIZATIONS] Body re\xE7u:", JSON.stringify(req2.body, null, 2));
    const sanitizedId = validateAndSanitizeId(id, "ID organisation");
    const validation = organizationUpdateSchema.safeParse(req2.body);
    if (!validation.success) {
      console.error("\u274C [ORGANIZATIONS] Erreur validation Zod:", validation.error.errors);
      return res.status(400).json(handleZodError(validation.error));
    }
    console.log("\u2705 [ORGANIZATIONS] Validation Zod r\xE9ussie");
    const data = validation.data;
    const updateData = {};
    if (data.name) updateData.name = sanitizeString(data.name);
    if (data.description !== void 0) {
      updateData.description = data.description ? sanitizeString(data.description) : null;
    }
    if (data.status) updateData.status = data.status;
    if (data.website !== void 0) {
      updateData.website = data.website ? sanitizeString(data.website) : null;
    }
    if (data.phone !== void 0) {
      updateData.phone = data.phone ? sanitizeString(data.phone) : null;
    }
    if (data.address !== void 0) {
      updateData.address = data.address ? sanitizeString(data.address) : null;
    }
    console.log("[ORGANIZATIONS] Donn\xE9es de mise \xE0 jour sanitis\xE9es:", updateData);
    const existingOrg = await prisma7.organization.findUnique({
      where: { id: sanitizedId }
    });
    if (!existingOrg) {
      return res.status(404).json({
        success: false,
        message: "Organisation non trouv\xE9e"
      });
    }
    if (updateData.name && updateData.name !== existingOrg.name) {
      const duplicateOrg = await prisma7.organization.findFirst({
        where: {
          name: {
            equals: updateData.name,
            mode: "insensitive"
          },
          id: { not: sanitizedId }
        }
      });
      if (duplicateOrg) {
        return res.status(409).json({
          success: false,
          message: "Une autre organisation avec ce nom existe d\xE9j\xE0"
        });
      }
    }
    const updatedOrganization = await prisma7.$transaction(async (tx) => {
      const updated = await tx.organization.update({
        where: { id: sanitizedId },
        data: updateData
      });
      if (data.googleWorkspace) {
        console.log("[ORGANIZATIONS] Mise \xE0 jour Google Workspace:", data.googleWorkspace);
        const existingConfig = await tx.googleWorkspaceConfig.findUnique({
          where: { organizationId: sanitizedId }
        });
        const googleWorkspaceData = {};
        if (data.googleWorkspace.modules) {
          const modules = data.googleWorkspace.modules;
          if (modules.gmail !== void 0) googleWorkspaceData.gmailEnabled = modules.gmail;
          if (modules.calendar !== void 0) googleWorkspaceData.calendarEnabled = modules.calendar;
          if (modules.drive !== void 0) googleWorkspaceData.driveEnabled = modules.drive;
          if (modules.meet !== void 0) googleWorkspaceData.meetEnabled = modules.meet;
          if (modules.docs !== void 0) googleWorkspaceData.docsEnabled = modules.docs;
          if (modules.sheets !== void 0) googleWorkspaceData.sheetsEnabled = modules.sheets;
          if (modules.voice !== void 0) googleWorkspaceData.voiceEnabled = modules.voice;
        }
        if (data.googleWorkspace.enabled !== void 0) {
          googleWorkspaceData.enabled = data.googleWorkspace.enabled;
        }
        if (data.googleWorkspace.domain) {
          googleWorkspaceData.domain = sanitizeString(data.googleWorkspace.domain);
        }
        if (data.googleWorkspace.adminEmail) {
          googleWorkspaceData.adminEmail = sanitizeString(data.googleWorkspace.adminEmail);
        }
        if (existingConfig) {
          await tx.googleWorkspaceConfig.update({
            where: { organizationId: sanitizedId },
            data: googleWorkspaceData
          });
        } else {
          await tx.googleWorkspaceConfig.create({
            data: {
              organizationId: sanitizedId,
              enabled: data.googleWorkspace.enabled || false,
              ...googleWorkspaceData
            }
          });
        }
      }
      return updated;
    });
    res.json({
      success: true,
      message: "Organisation mise \xE0 jour avec succ\xE8s",
      data: updatedOrganization
    });
  } catch (error) {
    console.error("[ORGANIZATIONS] Erreur PUT:", error);
    if (error instanceof import_zod2.z.ZodError) {
      return res.status(400).json(handleZodError(error));
    }
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la mise \xE0 jour de l'organisation"
    });
  }
});
router9.delete("/:id", organizationsDeleteRateLimit, requireRole2(["super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const sanitizedId = validateAndSanitizeId(id, "ID organisation");
    const existingOrg = await prisma7.organization.findUnique({
      where: { id: sanitizedId },
      include: {
        _count: {
          select: {
            UserOrganization: true
          }
        }
      }
    });
    if (!existingOrg) {
      return res.status(404).json({
        success: false,
        message: "Organisation non trouv\xE9e"
      });
    }
    if (existingOrg._count.UserOrganization > 0) {
      return res.status(400).json({
        success: false,
        message: "Impossible de supprimer une organisation ayant des utilisateurs"
      });
    }
    await prisma7.$transaction(async (tx) => {
      await cleanupOrganizationData(tx, sanitizedId);
      await tx.organization.delete({
        where: { id: sanitizedId }
      });
    });
    res.json({
      success: true,
      message: "Organisation supprim\xE9e avec succ\xE8s"
    });
  } catch (error) {
    console.error("[ORGANIZATIONS] Erreur DELETE:", error);
    if (error instanceof import_client.Prisma.PrismaClientKnownRequestError) {
      if (error.code === "P2003") {
        return res.status(409).json({
          success: false,
          message: "Impossible de supprimer cette organisation tant que des donn\xE9es associ\xE9es existent (modules, r\xF4les, configurations, etc.)."
        });
      }
    }
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la suppression de l'organisation"
    });
  }
});
router9.get("/:id/google-modules", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const sanitizedId = validateAndSanitizeId(id, "ID organisation");
    const requestingUser = req2.user;
    if (!canAccessOrganization(requestingUser, sanitizedId)) {
      return res.status(403).json({
        success: false,
        message: "Acc\xE8s refus\xE9 \xE0 cette organisation"
      });
    }
    const moduleStatuses = await prisma7.organizationModuleStatus.findMany({
      where: {
        organizationId: sanitizedId,
        Module: {
          key: {
            in: [...GOOGLE_WORKSPACE_MODULES]
          }
        }
      },
      include: {
        Module: true
      }
    });
    const defaultModules = {
      gmail: { enabled: false, configured: false },
      calendar: { enabled: false, configured: false },
      drive: { enabled: false, configured: false },
      meet: { enabled: false, configured: false },
      docs: { enabled: false, configured: false },
      sheets: { enabled: false, configured: false },
      voice: { enabled: false, configured: false }
    };
    moduleStatuses.forEach((status) => {
      if (status.Module?.key && defaultModules[status.Module.key]) {
        defaultModules[status.Module.key] = {
          enabled: status.active,
          configured: status.active
          // Simplifi√© pour le moment
        };
      }
    });
    res.json({
      success: true,
      data: defaultModules
    });
  } catch (error) {
    console.error("[ORGANIZATIONS] Erreur GET google-modules:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la r\xE9cup\xE9ration des modules Google"
    });
  }
});
router9.post("/:id/google-modules/:module/toggle", requireRole2(["super_admin"]), async (req2, res) => {
  try {
    const { id, module: module2 } = req2.params;
    const { enabled } = req2.body;
    const sanitizedId = validateAndSanitizeId(id, "ID organisation");
    const sanitizedModule = sanitizeString(module2);
    if (!isGoogleWorkspaceModule(sanitizedModule)) {
      return res.status(400).json({
        success: false,
        message: "Module Google Workspace invalide"
      });
    }
    if (typeof enabled !== "boolean") {
      return res.status(400).json({
        success: false,
        message: "Le param\xE8tre enabled doit \xEAtre un bool\xE9en"
      });
    }
    await prisma7.$transaction(async (tx) => {
      let moduleRecord = await tx.module.findFirst({
        where: { key: sanitizedModule }
      });
      if (!moduleRecord) {
        moduleRecord = await tx.module.create({
          data: {
            key: sanitizedModule,
            label: sanitizedModule.charAt(0).toUpperCase() + sanitizedModule.slice(1),
            feature: `google_${sanitizedModule}`,
            active: true,
            order: GOOGLE_WORKSPACE_MODULES.indexOf(sanitizedModule)
          }
        });
      }
      await tx.organizationModuleStatus.upsert({
        where: {
          organizationId_moduleId: {
            organizationId: sanitizedId,
            moduleId: moduleRecord.id
          }
        },
        update: {
          active: enabled
        },
        create: {
          organizationId: sanitizedId,
          moduleId: moduleRecord.id,
          active: enabled
        }
      });
    });
    res.json({
      success: true,
      message: `Module ${sanitizedModule} ${enabled ? "activ\xE9" : "d\xE9sactiv\xE9"} avec succ\xE8s`
    });
  } catch (error) {
    console.error("[ORGANIZATIONS] Erreur POST google-modules toggle:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la mise \xE0 jour du module Google"
    });
  }
});
router9.get("/:id/google-workspace/domain-status", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const sanitizedId = validateAndSanitizeId(id, "ID organisation");
    const requestingUser = req2.user;
    if (!canAccessOrganization(requestingUser, sanitizedId)) {
      return res.status(403).json({
        success: false,
        message: "Acc\xE8s refus\xE9 \xE0 cette organisation"
      });
    }
    const organization = await prisma7.organization.findUnique({
      where: { id: sanitizedId }
    });
    if (!organization) {
      return res.status(404).json({
        success: false,
        message: "Organisation non trouv\xE9e"
      });
    }
    const googleConfig = await prisma7.googleWorkspaceConfig.findUnique({
      where: { organizationId: sanitizedId }
    });
    const domain = googleConfig?.domain || "2thier.be";
    const requiredRecords = {
      verification: {
        type: "TXT",
        name: "@",
        value: `google-site-verification=ABC123XYZ${Date.now().toString().slice(-6)}`
      },
      mx: [
        { priority: 1, server: "aspmx.l.google.com." },
        { priority: 5, server: "alt1.aspmx.l.google.com." },
        { priority: 5, server: "alt2.aspmx.l.google.com." },
        { priority: 10, server: "alt3.aspmx.l.google.com." },
        { priority: 10, server: "alt4.aspmx.l.google.com." }
      ],
      security: {
        spf: "v=spf1 include:_spf.google.com ~all",
        dmarc: "v=DMARC1; p=quarantine; rua=mailto:admin@" + domain
      }
    };
    const isConfigured = false;
    res.json({
      success: true,
      data: {
        domain,
        isConfigured,
        requiredRecords: isConfigured ? null : requiredRecords
      }
    });
  } catch (error) {
    console.error("[ORGANIZATIONS] Erreur GET domain-status:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la v\xE9rification du domaine"
    });
  }
});
var organizations_default = router9;

// src/routes/autoGoogleAuthRoutes.ts
var import_express11 = require("express");
init_database();
var router10 = (0, import_express11.Router)();
var connectCache = /* @__PURE__ */ new Map();
router10.get("/status", authMiddleware, async (req2, res) => {
  const { userId, organizationId } = req2.query;
  if (!userId || !organizationId) {
    return res.json({
      success: true,
      data: {
        connected: false,
        email: null,
        scopes: [],
        lastSync: null,
        error: !organizationId ? "Organization ID requis" : "User ID requis"
      }
    });
  }
  try {
    const tokens2 = await db.googleToken.findUnique({
      where: {
        userId_organizationId: { userId, organizationId }
      }
    });
    if (!tokens2 || !tokens2.accessToken) {
      return res.json({
        success: true,
        data: {
          connected: false,
          email: null,
          scopes: tokens2?.scope?.split(" ") || [],
          lastSync: null
        }
      });
    }
    return res.json({
      success: true,
      data: {
        connected: true,
        email: tokens2.googleEmail || null,
        scopes: tokens2.scope?.split(" ") || [],
        lastSync: tokens2.updatedAt || null,
        expiresAt: tokens2.expiresAt
      }
    });
  } catch (error) {
    console.error("[AutoGoogleAuth] Erreur status:", error);
    return res.json({
      success: true,
      data: {
        connected: false,
        email: null,
        scopes: [],
        lastSync: null,
        error: "Erreur serveur"
      }
    });
  }
});
router10.post("/connect", authMiddleware, async (req2, res) => {
  const { userId, organizationId } = req2.body;
  const caller = req2.user;
  if (!userId || !organizationId) {
    return res.status(400).json({ success: false, error: "userId et organizationId sont requis." });
  }
  if (!caller) {
    return res.status(401).json({ success: false, error: "Authentification requise." });
  }
  const isSuperAdmin2 = caller.role === "super_admin" || caller.isSuperAdmin === true;
  if (!isSuperAdmin2 && caller.userId !== userId) {
    return res.status(403).json({ success: false, error: "Acc\xE8s interdit: utilisateur non autoris\xE9." });
  }
  if (!isSuperAdmin2) {
    const membership = await db.userOrganization.findFirst({ where: { userId: caller.userId, organizationId } });
    if (!membership) {
      return res.status(403).json({ success: false, error: "Acc\xE8s interdit: organisation non autoris\xE9e." });
    }
  }
  try {
    const key2 = `${userId}:${organizationId || "none"}`;
    const now = Date.now();
    const cached = connectCache.get(key2);
    if (cached && cached.expiresAt > now) {
      res.setHeader("X-AutoGoogle-Cache-Until", new Date(cached.expiresAt).toISOString());
      return res.json({ ...cached.payload, cached: true });
    }
    const tokens2 = await db.googleToken.findUnique({
      where: {
        userId_organizationId: { userId, organizationId }
      }
    });
    const nowDate = /* @__PURE__ */ new Date();
    const isLocallyValid = !!tokens2?.accessToken && !!tokens2?.expiresAt && tokens2.expiresAt > nowDate;
    if (isLocallyValid) {
      const ttlConnected = 15e3;
      const payload2 = {
        success: true,
        isConnected: true,
        needsManualAuth: false,
        message: "Connexion Google d\xE9j\xE0 active (token local valide).",
        cacheTtlMs: ttlConnected
      };
      connectCache.set(key2, { expiresAt: now + ttlConnected, payload: payload2 });
      res.setHeader("X-AutoGoogle-Cache-Until", new Date(now + ttlConnected).toISOString());
      return res.json(payload2);
    }
    console.log("[AutoGoogleAuth] \u26A0\uFE0F Connexion Google non active: OAuth d\xE9sactiv\xE9 via auto-connect.");
    const ttlManual = 6e4;
    const payload = {
      success: true,
      isConnected: false,
      needsManualAuth: true,
      message: "Connexion Google requise: demandez \xE0 un admin d'activer Google Workspace via la page Organisation (Admin) et le scheduler.",
      requiresAdmin: true,
      cacheTtlMs: ttlManual
    };
    connectCache.set(key2, { expiresAt: now + ttlManual, payload });
    res.setHeader("X-AutoGoogle-Cache-Until", new Date(now + ttlManual).toISOString());
    res.setHeader("Retry-After", Math.ceil(ttlManual / 1e3).toString());
    return res.json(payload);
  } catch (error) {
    console.error("[AutoGoogleAuth] Erreur lors de la connexion automatique:", error);
    res.status(500).json({ success: false, error: "Erreur interne du serveur lors de la connexion Google." });
  }
});
router10.post("/trigger-logout", authMiddleware, async (req2, res) => {
  const { userId } = req2.body;
  console.log("[GOOGLE-LOGOUT] Re\xE7u logout CRM pour utilisateur:", userId);
  if (!userId) {
    return res.status(400).json({ success: false, error: "userId requis." });
  }
  try {
    console.log("[GOOGLE-LOGOUT] Politique NO-OP: aucune action sur les tokens Google");
    return res.status(200).json({ success: true, message: "Aucune d\xE9connexion Google effectu\xE9e (politique persistante)." });
  } catch (error) {
    console.error("[AutoGoogleAuth] Erreur inattendue trigger-logout (no-op):", error);
    return res.status(200).json({ success: true, message: "Aucune d\xE9connexion Google effectu\xE9e (no-op avec erreur interne ignor\xE9e)." });
  }
});
var autoGoogleAuthRoutes_default = router10;

// src/routes/google-auth.ts
var import_express13 = require("express");
init_database();
init_crypto();
var import_googleapis7 = require("googleapis");

// src/utils/googleTokenRefresh.ts
var import_googleapis6 = require("googleapis");
init_database();
init_crypto();
async function refreshGoogleTokenIfNeeded(organizationId, userId) {
  try {
    console.log("[REFRESH-TOKEN] \u{1F50D} V\xE9rification token pour organisation:", organizationId, "userId:", userId);
    let googleToken;
    if (userId) {
      googleToken = await db.googleToken.findUnique({
        where: {
          userId_organizationId: { userId, organizationId }
        }
      });
    } else {
      console.log("[REFRESH-TOKEN] \u26A0\uFE0F userId non fourni, fallback sur findFirst");
      googleToken = await db.googleToken.findFirst({
        where: { organizationId }
      });
    }
    if (!googleToken) {
      console.log("[REFRESH-TOKEN] \u274C Aucun token trouv\xE9 pour l'organisation:", organizationId);
      return { success: false, error: "no_token_found" };
    }
    console.log("[REFRESH-TOKEN] \u{1F4CB} Token trouv\xE9, expiration:", googleToken.expiresAt);
    const now = /* @__PURE__ */ new Date();
    const thirtyMinutesFromNow = new Date(now.getTime() + 30 * 60 * 1e3);
    const isExpiring = googleToken.expiresAt && googleToken.expiresAt <= thirtyMinutesFromNow;
    const isExpired = googleToken.expiresAt && googleToken.expiresAt <= now;
    console.log("[REFRESH-TOKEN] \u23F0 Maintenant:", now.toISOString());
    console.log("[REFRESH-TOKEN] \u23F0 Token expire le:", googleToken.expiresAt?.toISOString());
    console.log("[REFRESH-TOKEN] \u26A0\uFE0F Token expirant bient\xF4t (30min)?", isExpiring);
    console.log("[REFRESH-TOKEN] \u274C Token d\xE9j\xE0 expir\xE9?", isExpired);
    console.log("[REFRESH-TOKEN] \u23F0 \xC9tat du token (d\xE9lai 30min):");
    console.log("  - Expire le:", googleToken.expiresAt);
    console.log("  - Maintenant:", now);
    console.log("  - Expir\xE9:", isExpired);
    console.log("  - Expire bient\xF4t (30min):", isExpiring);
    if (!isExpiring && !isExpired) {
      console.log("[REFRESH-TOKEN] \u2705 Token encore valide (plus de 30min), pas de refresh n\xE9cessaire");
      return {
        success: true,
        accessToken: googleToken.accessToken,
        refreshToken: googleToken.refreshToken || void 0,
        expiresAt: googleToken.expiresAt
      };
    }
    if (!googleToken.refreshToken) {
      console.log("[REFRESH-TOKEN] \u274C Token expir\xE9 mais pas de refresh token disponible");
      return { success: false, error: "no_refresh_token" };
    }
    console.log("[REFRESH-TOKEN] \u{1F504} Token expir\xE9/expirant (moins de 30min), tentative de refresh...");
    const googleConfig = await db.googleWorkspaceConfig.findUnique({
      where: { organizationId }
    });
    if (!googleConfig || !googleConfig.clientId || !googleConfig.clientSecret) {
      console.log("[REFRESH-TOKEN] \u274C Configuration OAuth manquante pour l'organisation:", organizationId);
      console.log("[REFRESH-TOKEN] \u{1F4CB} Config trouv\xE9e:", !!googleConfig);
      if (googleConfig) {
        console.log("[REFRESH-TOKEN] \u{1F4CB} ClientId pr\xE9sent:", !!googleConfig.clientId);
        console.log("[REFRESH-TOKEN] \u{1F4CB} ClientSecret pr\xE9sent:", !!googleConfig.clientSecret);
      }
      return { success: false, error: "missing_oauth_config" };
    }
    console.log("[REFRESH-TOKEN] \u{1F527} Configuration OAuth client...");
    const clientId = googleConfig.clientId ? decrypt(googleConfig.clientId) : null;
    const clientSecret = googleConfig.clientSecret ? decrypt(googleConfig.clientSecret) : null;
    if (!clientId || !clientSecret) {
      console.log("[REFRESH-TOKEN] \u274C Configuration OAuth manquante/invalide (apr\xE8s d\xE9chiffrement)");
      return { success: false, error: "missing_oauth_config" };
    }
    const oauth2Client = new import_googleapis6.google.auth.OAuth2(clientId, clientSecret);
    console.log("[REFRESH-TOKEN] \u{1F511} Configuration des credentials...");
    oauth2Client.setCredentials({
      refresh_token: googleToken.refreshToken || void 0
    });
    try {
      console.log("[REFRESH-TOKEN] \u{1F680} Tentative de refresh du token...");
      const { credentials } = await oauth2Client.refreshAccessToken();
      console.log("[REFRESH-TOKEN] \u2705 Refresh r\xE9ussi!");
      console.log("[REFRESH-TOKEN] \u{1F4CB} Nouveau token expire le:", new Date(credentials.expiry_date || 0));
      console.log("[REFRESH-TOKEN] \u{1F4CB} Token re\xE7u:", !!credentials.access_token);
      console.log("[REFRESH-TOKEN] \u{1F4CB} Nouveau refresh token re\xE7u:", !!credentials.refresh_token);
      const newExpiresAt = credentials.expiry_date ? new Date(credentials.expiry_date) : null;
      console.log("[REFRESH-TOKEN] \u{1F4BE} Sauvegarde du nouveau token...");
      if (userId) {
        await db.googleToken.update({
          where: {
            userId_organizationId: { userId, organizationId }
          },
          data: {
            accessToken: credentials.access_token,
            expiresAt: newExpiresAt,
            updatedAt: /* @__PURE__ */ new Date(),
            lastRefreshAt: /* @__PURE__ */ new Date(),
            refreshCount: { increment: 1 },
            // Garder l'ancien refresh token sauf si un nouveau est fourni
            ...credentials.refresh_token && {
              refreshToken: credentials.refresh_token
            }
          }
        });
      } else if (googleToken.id) {
        await db.googleToken.update({
          where: { id: googleToken.id },
          data: {
            accessToken: credentials.access_token,
            expiresAt: newExpiresAt,
            updatedAt: /* @__PURE__ */ new Date(),
            lastRefreshAt: /* @__PURE__ */ new Date(),
            refreshCount: { increment: 1 },
            ...credentials.refresh_token && {
              refreshToken: credentials.refresh_token
            }
          }
        });
      }
      console.log("[REFRESH-TOKEN] \u{1F4BE} Token mis \xE0 jour en base de donn\xE9es");
      return {
        success: true,
        accessToken: credentials.access_token,
        refreshToken: credentials.refresh_token || googleToken.refreshToken || void 0,
        expiresAt: newExpiresAt
      };
    } catch (refreshError) {
      console.error("[REFRESH-TOKEN] \u274C Erreur lors du refresh:", refreshError);
      const errorMessage = refreshError instanceof Error ? refreshError.message : String(refreshError);
      console.log("[REFRESH-TOKEN] \u{1F50D} Message d'erreur:", errorMessage);
      if (errorMessage.includes("invalid_grant")) {
        console.log("[REFRESH-TOKEN] \u{1F6A8} Refresh token invalide ou r\xE9voqu\xE9");
        return { success: false, error: "invalid_refresh_token" };
      } else if (errorMessage.includes("invalid_client")) {
        console.log("[REFRESH-TOKEN] \u{1F6A8} Configuration OAuth invalide");
        return { success: false, error: "invalid_oauth_config" };
      } else {
        console.log("[REFRESH-TOKEN] \u{1F6A8} Erreur g\xE9n\xE9rique:", errorMessage);
        return { success: false, error: "refresh_failed" };
      }
    }
  } catch (error) {
    console.error("[REFRESH-TOKEN] \u274C Erreur g\xE9n\xE9rale dans refreshGoogleTokenIfNeeded:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.log("[REFRESH-TOKEN] \u{1F50D} D\xE9tails de l'erreur g\xE9n\xE9rale:", errorMessage);
    return { success: false, error: "general_error" };
  }
}

// src/google-auth/routes/gmail.ts
var import_express12 = require("express");
var import_formidable = __toESM(require("formidable"), 1);
var import_fs4 = __toESM(require("fs"), 1);
var import_path2 = __toESM(require("path"), 1);
var formidableMiddleware = (req2, res, next) => {
  console.log("[DEBUG FORMIDABLE] ==================== D\xC9BUT ANALYSE REQU\xCATE ====================");
  console.log("[DEBUG FORMIDABLE] \u{1F4E5} Headers re\xE7us:", JSON.stringify(req2.headers, null, 2));
  console.log("[DEBUG FORMIDABLE] \u{1F3AF} Content-Type:", req2.headers["content-type"]);
  console.log("[DEBUG FORMIDABLE] \u{1F4CA} Content-Length:", req2.headers["content-length"]);
  console.log("[DEBUG FORMIDABLE] \u{1F527} Method:", req2.method);
  console.log("[DEBUG FORMIDABLE] \u{1F310} URL:", req2.url);
  console.log("[DEBUG FORMIDABLE] ================== TRANSFERT VERS FORMIDABLE ==================");
  if (!req2.headers["content-type"]?.includes("multipart/form-data")) {
    console.log("[DEBUG FORMIDABLE] \u26A0\uFE0F Pas de multipart/form-data - skip Formidable");
    return next();
  }
  const form = (0, import_formidable.default)({
    maxFileSize: 50 * 1024 * 1024,
    // 50MB
    maxFiles: 10,
    maxFields: 50,
    maxFieldsSize: 50 * 1024 * 1024,
    // 50MB pour les champs
    allowEmptyFiles: false,
    multiples: true,
    keepExtensions: true,
    encoding: "utf-8",
    uploadDir: import_path2.default.join(process.cwd(), "uploads"),
    // Dossier temporaire
    hashAlgorithm: false
    // Pas de hash pour la performance
  });
  const uploadDir = import_path2.default.join(process.cwd(), "uploads");
  if (!import_fs4.default.existsSync(uploadDir)) {
    import_fs4.default.mkdirSync(uploadDir, { recursive: true });
  }
  console.log("[DEBUG FORMIDABLE] \u{1F527} Configuration Formidable appliqu\xE9e");
  console.log("[DEBUG FORMIDABLE] \u{1F4C1} Upload Directory:", uploadDir);
  form.parse(req2, (err, fields, files) => {
    if (err) {
      console.error("[DEBUG FORMIDABLE] \u274C Erreur parsing:", err);
      return res.status(400).json({
        error: "Erreur lors du parsing du formulaire",
        details: err.message
      });
    }
    console.log("[DEBUG FORMIDABLE] \u2705 Parsing r\xE9ussi !");
    console.log("[DEBUG FORMIDABLE] \u{1F4DD} Fields:", Object.keys(fields));
    console.log("[DEBUG FORMIDABLE] \u{1F4CE} Files:", Object.keys(files));
    req2.body = {};
    for (const [key2, value] of Object.entries(fields)) {
      req2.body[key2] = Array.isArray(value) ? value[0] : value;
    }
    req2.files = {};
    for (const [key2, fileArray] of Object.entries(files)) {
      const fileList = Array.isArray(fileArray) ? fileArray : [fileArray];
      req2.files[key2] = fileList.map((file) => ({
        name: file.originalFilename || file.newFilename,
        data: import_fs4.default.readFileSync(file.filepath),
        // Lire le fichier en Buffer
        size: file.size,
        mimetype: file.mimetype,
        tempFilePath: file.filepath
        // Pour nettoyage ult√©rieur
      }));
    }
    console.log("[DEBUG FORMIDABLE] \u{1F504} Donn\xE9es transform\xE9es pour compatibilit\xE9");
    console.log("[DEBUG FORMIDABLE] ==================== FIN ANALYSE REQU\xCATE ====================");
    res.on("finish", () => {
      for (const [, fileArray] of Object.entries(files)) {
        const fileList = Array.isArray(fileArray) ? fileArray : [fileArray];
        fileList.forEach((file) => {
          if (import_fs4.default.existsSync(file.filepath)) {
            import_fs4.default.unlinkSync(file.filepath);
            console.log("[DEBUG FORMIDABLE] \u{1F5D1}\uFE0F Fichier temporaire supprim\xE9:", file.filepath);
          }
        });
      }
    });
    next();
  });
};
var router11 = (0, import_express12.Router)();
router11.get("/messages", getMessages);
router11.get("/messages/:id", getMessage);
router11.patch("/messages/:id", modifyMessage);
router11.delete("/messages/:id", deleteMessage);
router11.post("/messages/:id/trash", trashMessage);
router11.post("/messages/:id/untrash", untrashMessage);
router11.post("/trash/empty", emptyTrash);
router11.get("/drafts", getDrafts);
router11.post("/drafts", formidableMiddleware, saveDraft);
router11.delete("/drafts/:id", deleteDraft);
router11.post("/drafts/:id/send", sendDraft);
router11.post("/send", formidableMiddleware, (req2, res, next) => {
  console.log("[ROUTE SEND] \u{1F680} === D\xC9BUT TRAITEMENT ROUTE /send (FORMIDABLE) ===");
  req2.setTimeout(3e5);
  res.setTimeout(3e5);
  console.log("[ROUTE SEND] \u23F0 Timeouts configur\xE9s \xE0 5 minutes");
  console.log("[ROUTE SEND] \u{1F4DD} req.body apr\xE8s Formidable:", req2.body);
  console.log("[ROUTE SEND] \u{1F4CE} req.files apr\xE8s Formidable:", req2.files);
  if (req2.files) {
    console.log("[ROUTE SEND] \u{1F4CE} Fichiers d\xE9tect\xE9s:");
    Object.keys(req2.files).forEach((fieldName) => {
      const files = req2.files[fieldName];
      if (Array.isArray(files)) {
        console.log("[ROUTE SEND] \u{1F4CE}", fieldName, ":", files.length, "fichiers");
        files.forEach((file, index) => {
          console.log("[ROUTE SEND] \u{1F4CE}   -", index + 1, ":", file.name, "(", file.size, "bytes)");
        });
      } else {
        console.log("[ROUTE SEND] \u{1F4CE}", fieldName, ":", files.name, "(", files.size, "bytes)");
      }
    });
  } else {
    console.log("[ROUTE SEND] \u{1F4CE} Aucun fichier d\xE9tect\xE9");
  }
  console.log("[ROUTE SEND] \u2705 Formidable a trait\xE9 la requ\xEAte SANS ERREUR");
  console.log("[ROUTE SEND] \u2705 Transfert vers sendMessage...");
  next();
}, sendMessage);
router11.get("/labels", getLabels);
router11.post("/labels", createLabel);
router11.patch("/labels/:id", updateLabel);
router11.delete("/labels/:id", deleteLabel);
router11.get("/messages/:messageId/attachments/:id", getAttachment);
var gmail_default = router11;

// src/security/securityLogger.ts
var import_winston = __toESM(require("winston"), 1);
var import_winston_daily_rotate_file = __toESM(require("winston-daily-rotate-file"), 1);
var import_path3 = __toESM(require("path"), 1);
var isProduction2 = process.env.NODE_ENV === "production";
var transports = [
  // Console pour tous les environnements
  new import_winston.default.transports.Console({
    format: import_winston.default.format.combine(
      import_winston.default.format.colorize(),
      import_winston.default.format.simple(),
      import_winston.default.format.printf(({ timestamp, level, message, ...meta }) => {
        const sanitized2 = sanitizeLogData(meta);
        return `${timestamp} [${level}]: ${message} ${Object.keys(sanitized2).length ? JSON.stringify(sanitized2) : ""}`;
      })
    )
  })
];
if (!isProduction2) {
  transports.push(
    // Fichier de log rotatif pour la s√©curit√©
    new import_winston_daily_rotate_file.default({
      filename: import_path3.default.join(process.cwd(), "logs", "security-%DATE%.log"),
      datePattern: "YYYY-MM-DD",
      zippedArchive: true,
      maxSize: "20m",
      maxFiles: "14d",
      createSymlink: true,
      symlinkName: "security-current.log"
    }),
    // Fichier s√©par√© pour les erreurs critiques
    new import_winston_daily_rotate_file.default({
      filename: import_path3.default.join(process.cwd(), "logs", "security-errors-%DATE%.log"),
      datePattern: "YYYY-MM-DD",
      level: "error",
      zippedArchive: true,
      maxSize: "20m",
      maxFiles: "30d"
    })
  );
}
var securityLogger = import_winston.default.createLogger({
  level: "info",
  format: import_winston.default.format.combine(
    import_winston.default.format.timestamp({
      format: "YYYY-MM-DD HH:mm:ss"
    }),
    import_winston.default.format.errors({ stack: true }),
    import_winston.default.format.json(),
    import_winston.default.format.printf(({ timestamp, level, message, ...meta }) => {
      return JSON.stringify({
        timestamp,
        level: level.toUpperCase(),
        message,
        ...sanitizeLogData(meta)
      });
    })
  ),
  defaultMeta: { service: "crm-security" },
  transports
});
function sanitizeLogData(data) {
  if (!data || typeof data !== "object") return data;
  const sensitiveFields = [
    "password",
    "token",
    "secret",
    "key",
    "auth",
    "authorization",
    "cookie",
    "session",
    "csrf",
    "api_key",
    "access_token",
    "refresh_token"
  ];
  const sanitized2 = { ...data };
  Object.keys(sanitized2).forEach((key2) => {
    const lowerKey = key2.toLowerCase();
    if (sensitiveFields.some((field) => lowerKey.includes(field))) {
      sanitized2[key2] = "[REDACTED]";
    } else if (typeof sanitized2[key2] === "object" && sanitized2[key2] !== null) {
      sanitized2[key2] = sanitizeLogData(sanitized2[key2]);
    }
  });
  return sanitized2;
}
function logSecurityEvent(eventType, details, level = "info") {
  const securityEvent = {
    eventType,
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    details: sanitizeLogData(details),
    severity: level,
    source: "CRM_SECURITY_SYSTEM"
  };
  securityLogger[level](`SECURITY_EVENT: ${eventType}`, securityEvent);
  if (level === "error" || eventType.includes("ATTACK") || eventType.includes("BREACH")) {
    console.error(`\u{1F6A8} ALERTE S\xC9CURIT\xC9: ${eventType}`, securityEvent);
  }
}
var securityMetrics = {
  requestCount: 0,
  blockedRequests: 0,
  suspiciousActivity: 0,
  lastReset: /* @__PURE__ */ new Date()
};

// src/routes/google-auth.ts
var router12 = (0, import_express13.Router)();
var GOOGLE_SCOPES = GOOGLE_SCOPES_LIST.join(" ");
function getFrontendUrl() {
  const codespaceName = process.env.CODESPACE_NAME;
  if (codespaceName) {
    const codespaceUrl = `https://${codespaceName}-5173.app.github.dev`;
    console.log("[GOOGLE-AUTH] \u{1F680} Codespaces d\xE9tect\xE9, FRONTEND_URL:", codespaceUrl);
    return codespaceUrl;
  }
  const frontendUrl = process.env.FRONTEND_URL;
  if (frontendUrl) {
    console.log("[GOOGLE-AUTH] \u{1F4CC} FRONTEND_URL explicite:", frontendUrl);
    return frontendUrl;
  }
  if (process.env.NODE_ENV === "production") {
    console.log("[GOOGLE-AUTH] \u{1F310} Production d\xE9tect\xE9e, FRONTEND_URL: https://app.2thier.be");
    return "https://app.2thier.be";
  }
  console.log("[GOOGLE-AUTH] \u{1F3E0} Local d\xE9tect\xE9, FRONTEND_URL: http://localhost:5173");
  return "http://localhost:5173";
}
function getOAuthRedirectUri(hostHeader) {
  const host = hostHeader || "localhost:4000";
  console.log("[GOOGLE-AUTH] \u{1F4CD} D\xE9tection environnement - Host re\xE7u:", host);
  if (host.includes("app.github.dev")) {
    const hostWithoutPort = host.split(":")[0];
    const match = hostWithoutPort.match(/^(.+?)-\d+\.app\.github\.dev$/);
    const codespaceName = match ? match[1] : hostWithoutPort.replace(".app.github.dev", "");
    const redirectUri2 = `https://${codespaceName}-4000.app.github.dev/api/google-auth/callback`;
    console.log("[GOOGLE-AUTH] \u{1F680} Codespaces d\xE9tect\xE9:", {
      originalHost: host,
      hostWithoutPort,
      codespaceName,
      redirectUri: redirectUri2
    });
    return redirectUri2;
  }
  if (host.includes("app.2thier.be") || host.includes("2thier.be")) {
    const redirectUri2 = "https://app.2thier.be/api/google-auth/callback";
    console.log("[GOOGLE-AUTH] \u{1F310} Production d\xE9tect\xE9e:", { host, redirectUri: redirectUri2 });
    return redirectUri2;
  }
  const redirectUri = "http://localhost:4000/api/google-auth/callback";
  console.log("[GOOGLE-AUTH] \u{1F3E0} Local d\xE9tect\xE9:", { host, redirectUri });
  return redirectUri;
}
function encodeOAuthState(stateObj) {
  return Buffer.from(JSON.stringify(stateObj), "utf8").toString("base64url");
}
function parseOAuthState(raw) {
  try {
    return JSON.parse(raw);
  } catch {
    const decoded = Buffer.from(String(raw), "base64url").toString("utf8");
    return JSON.parse(decoded);
  }
}
async function getGoogleWorkspaceConfig(organizationId) {
  try {
    console.log("[GOOGLE-AUTH] \u{1F4CB} Recherche config pour organisation:", organizationId);
    const config = await db.googleWorkspaceConfig.findUnique({
      where: { organizationId }
    });
    console.log("[GOOGLE-AUTH] \u{1F4CA} Config brute depuis BDD:", config ? "Trouv\xE9e" : "Non trouv\xE9e");
    if (config) {
      console.log("[GOOGLE-AUTH] \u{1F511} clientId crypt\xE9:", config.clientId ? "Pr\xE9sent" : "Manquant");
      console.log("[GOOGLE-AUTH] \u{1F510} clientSecret crypt\xE9:", config.clientSecret ? "Pr\xE9sent" : "Manquant");
      console.log("[GOOGLE-AUTH] \u{1F517} redirectUri:", config.redirectUri);
    }
    if (!config) {
      console.log("[GOOGLE-AUTH] \u274C Aucune configuration trouv\xE9e");
      return null;
    }
    const decryptedConfig = {
      clientId: config.clientId ? decrypt(config.clientId) : null,
      clientSecret: config.clientSecret ? decrypt(config.clientSecret) : null,
      redirectUri: config.redirectUri,
      adminEmail: config.adminEmail,
      // Ajout de l'email admin
      isConfigured: !!config.clientId && !!config.clientSecret && !!config.redirectUri
    };
    console.log("[GOOGLE-AUTH] \u{1F513} Config d\xE9crypt\xE9e:");
    console.log("[GOOGLE-AUTH] \u{1F194} clientId d\xE9crypt\xE9:", decryptedConfig.clientId ? "OK" : "ERREUR");
    console.log("[GOOGLE-AUTH] \u{1F510} clientSecret d\xE9crypt\xE9:", decryptedConfig.clientSecret ? "OK" : "ERREUR");
    console.log("[GOOGLE-AUTH] \u{1F517} redirectUri final:", decryptedConfig.redirectUri);
    console.log("[GOOGLE-AUTH] \u{1F4E7} adminEmail:", decryptedConfig.adminEmail);
    console.log("[GOOGLE-AUTH] \u2705 isConfigured:", decryptedConfig.isConfigured);
    return decryptedConfig;
  } catch (error) {
    console.error("[GOOGLE-AUTH] \u274C Erreur r\xE9cup\xE9ration config:", error);
    return null;
  }
}
async function activateGoogleModules(organizationId, grantedScopes) {
  try {
    console.log("[GOOGLE-AUTH] \u{1F527} D\xE9but activation modules pour org:", organizationId);
    console.log("[GOOGLE-AUTH] \u{1F510} Scopes accord\xE9s:", grantedScopes);
    const scopesArray = grantedScopes.split(" ");
    const moduleMapping = [
      {
        name: "Gmail",
        scopes: ["https://mail.google.com/", "https://www.googleapis.com/auth/gmail.readonly", "https://www.googleapis.com/auth/gmail.send", "https://www.googleapis.com/auth/gmail.modify"],
        configField: "gmailEnabled"
      },
      {
        name: "Calendar",
        scopes: ["https://www.googleapis.com/auth/calendar"],
        configField: "calendarEnabled"
      },
      {
        name: "Drive",
        scopes: ["https://www.googleapis.com/auth/drive"],
        configField: "driveEnabled"
      },
      {
        name: "Docs",
        scopes: ["https://www.googleapis.com/auth/documents"],
        configField: "docsEnabled"
      },
      {
        name: "Sheets",
        scopes: ["https://www.googleapis.com/auth/spreadsheets"],
        configField: "sheetsEnabled"
      },
      {
        name: "Meet",
        scopes: ["https://www.googleapis.com/auth/meetings"],
        configField: "meetEnabled"
      }
    ];
    const modulesToActivate = [];
    const configUpdates = {};
    for (const module2 of moduleMapping) {
      const hasRequiredScopes = module2.scopes.some((scope) => scopesArray.includes(scope));
      if (hasRequiredScopes) {
        modulesToActivate.push(module2.name);
        configUpdates[module2.configField] = true;
        console.log("[GOOGLE-AUTH] \u2705 Module activable:", module2.name);
      } else {
        console.log("[GOOGLE-AUTH] \u274C Module non activable (scopes manquants):", module2.name);
      }
    }
    if (Object.keys(configUpdates).length > 0) {
      console.log("[GOOGLE-AUTH] \u{1F4BE} Mise \xE0 jour config avec modules:", configUpdates);
      await db.googleWorkspaceConfig.update({
        where: { organizationId },
        data: {
          ...configUpdates,
          enabled: true,
          isActive: true,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    }
    console.log("[GOOGLE-AUTH] \u{1F527} Activation des modules CRM...");
    for (const moduleName of modulesToActivate) {
      try {
        const module2 = await db.module.findFirst({
          where: {
            label: {
              contains: moduleName,
              mode: "insensitive"
            }
          }
        });
        if (module2) {
          await db.organizationModule.upsert({
            where: {
              organizationId_moduleId: {
                organizationId,
                moduleId: module2.id
              }
            },
            update: {
              isActive: true,
              activatedAt: /* @__PURE__ */ new Date(),
              updatedAt: /* @__PURE__ */ new Date()
            },
            create: {
              organizationId,
              moduleId: module2.id,
              isActive: true,
              activatedAt: /* @__PURE__ */ new Date()
            }
          });
          console.log("[GOOGLE-AUTH] \u2705 Module CRM activ\xE9:", moduleName, "(", module2.id, ")");
        } else {
          console.log("[GOOGLE-AUTH] \u26A0\uFE0F Module CRM non trouv\xE9:", moduleName);
        }
      } catch (moduleError) {
        console.error("[GOOGLE-AUTH] \u274C Erreur activation module", moduleName, ":", moduleError);
      }
    }
    console.log("[GOOGLE-AUTH] \u2705 Activation des modules termin\xE9e. Modules activ\xE9s:", modulesToActivate);
    return modulesToActivate;
  } catch (error) {
    console.error("[GOOGLE-AUTH] \u274C Erreur activation modules:", error);
    return [];
  }
}
router12.get("/debug", (req2, res) => {
  const hostHeader = req2.headers.host || "localhost:4000";
  const redirectUri = getOAuthRedirectUri(hostHeader);
  res.json({
    debug: {
      host_header: hostHeader,
      generated_redirect_uri: redirectUri,
      environment: hostHeader.includes("app.github.dev") ? "Codespaces" : hostHeader.includes("2thier.be") ? "Production" : "Local"
    }
  });
});
router12.get("/redirect-uri", (req2, res) => {
  const hostHeader = req2.headers.host || "localhost:4000";
  const redirectUri = getOAuthRedirectUri(hostHeader);
  res.json({
    redirectUri,
    environment: hostHeader.includes("app.github.dev") ? "Codespaces" : hostHeader.includes("2thier.be") ? "Production" : "Local"
  });
});
router12.get("/url", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.query.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "Organization ID requis"
      });
    }
    const config = await getGoogleWorkspaceConfig(organizationId);
    if (!config || !config.isConfigured) {
      return res.status(400).json({
        success: false,
        message: "Google Workspace non configur\xE9 pour cette organisation"
      });
    }
    const stateObj = {
      userId: req2.user?.userId || void 0,
      organizationId
    };
    const hostHeader1 = req2.headers.host || "localhost:4000";
    const actualRedirectUri = getOAuthRedirectUri(hostHeader1);
    console.log("[GOOGLE-AUTH] \u{1F3AF} Redirect URI (auto-d\xE9tect\xE9):", actualRedirectUri);
    stateObj.redirectUri = actualRedirectUri;
    const stateParam = encodeOAuthState(stateObj);
    const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${config.clientId}&redirect_uri=${encodeURIComponent(actualRedirectUri)}&scope=${encodeURIComponent(GOOGLE_SCOPES)}&response_type=code&access_type=offline&prompt=consent&include_granted_scopes=true&enable_granular_consent=true&state=${encodeURIComponent(stateParam)}`;
    res.json({
      success: true,
      data: {
        authUrl,
        scopes: GOOGLE_SCOPES.split(" "),
        clientConfigured: true
      }
    });
  } catch (error) {
    console.error("[GOOGLE-AUTH] Erreur g\xE9n\xE9ration URL:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la g\xE9n\xE9ration de l'URL d'authentification"
    });
  }
});
router12.get("/connect", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.query.organizationId || req2.user?.organizationId?.toString();
    const forceConsent = req2.query.force_consent === "true";
    console.log("[GOOGLE-AUTH] \u{1F50D} OrganizationId extrait:", organizationId);
    console.log("[GOOGLE-AUTH] \u{1F504} Force consent:", forceConsent);
    console.log("[GOOGLE-AUTH] \u{1F464} User info:", req2.user ? "Pr\xE9sent" : "Absent");
    console.log("[GOOGLE-AUTH] \u{1F3E2} User organizationId:", req2.user?.organizationId);
    if (!organizationId) {
      console.log("[GOOGLE-AUTH] \u274C Aucun organizationId trouv\xE9 (query ou user)");
      return res.status(400).json({
        success: false,
        message: "Organization ID requis (non trouv\xE9 dans query ou profil utilisateur)"
      });
    }
    if (forceConsent && req2.user?.userId) {
      console.log("[GOOGLE-AUTH] \u{1F5D1}\uFE0F Suppression de l'ancien token pour forcer le consentement...");
      try {
        await db.googleToken.deleteMany({
          where: {
            userId: req2.user.userId,
            organizationId
          }
        });
        console.log("[GOOGLE-AUTH] \u2705 Ancien token supprim\xE9");
      } catch (deleteError) {
        console.warn("[GOOGLE-AUTH] \u26A0\uFE0F Erreur suppression ancien token:", deleteError);
      }
    }
    const config = await getGoogleWorkspaceConfig(organizationId);
    console.log("[GOOGLE-AUTH] \u{1F50D} Configuration r\xE9cup\xE9r\xE9e pour org:", organizationId);
    console.log("[GOOGLE-AUTH] \u{1F527} Config compl\xE8te:", JSON.stringify(config, null, 2));
    if (!config || !config.isConfigured) {
      console.log("[GOOGLE-AUTH] \u274C Configuration manquante ou incompl\xE8te");
      return res.status(400).json({
        success: false,
        message: "Google Workspace non configur\xE9 pour cette organisation"
      });
    }
    console.log("[GOOGLE-AUTH] \u2705 Configuration valide d\xE9tect\xE9e");
    console.log("[GOOGLE-AUTH] \u{1F194} ClientId:", config.clientId);
    console.log("[GOOGLE-AUTH] \u{1F3E2} Domain:", config.domain);
    const hostHeader = req2.headers.host || "localhost:4000";
    const actualRedirectUri = getOAuthRedirectUri(hostHeader);
    console.log("[GOOGLE-AUTH] \u{1F3AF} Redirect URI (auto-d\xE9tect\xE9):", actualRedirectUri);
    const stateParam = encodeOAuthState({
      userId: req2.user?.userId || void 0,
      organizationId,
      redirectUri: actualRedirectUri
    });
    const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${config.clientId}&redirect_uri=${encodeURIComponent(actualRedirectUri)}&scope=${encodeURIComponent(GOOGLE_SCOPES)}&response_type=code&access_type=offline&prompt=consent&include_granted_scopes=true&enable_granular_consent=true&state=${encodeURIComponent(stateParam)}`;
    console.log("[GOOGLE-AUTH] \u{1F310} URL g\xE9n\xE9r\xE9e:", authUrl);
    res.json({
      success: true,
      data: {
        authUrl,
        scopes: GOOGLE_SCOPES.split(" "),
        clientConfigured: true,
        forceConsent: true
        // Indique qu'on force le consentement
      }
    });
  } catch (error) {
    console.error("[GOOGLE-AUTH] Erreur g\xE9n\xE9ration URL connect:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la g\xE9n\xE9ration de l'URL d'authentification"
    });
  }
});
router12.get("/callback", async (req2, res) => {
  try {
    const { code, state, error } = req2.query;
    console.log("[GOOGLE-AUTH] \u{1F504} Callback OAuth re\xE7u");
    console.log("[GOOGLE-AUTH] \u{1F4CB} State (organizationId):", state);
    console.log("[GOOGLE-AUTH] \u{1F511} Code pr\xE9sent:", !!code);
    console.log("[GOOGLE-AUTH] \u274C Erreur pr\xE9sente:", !!error);
    if (error) {
      console.log("[GOOGLE-AUTH] \u274C Erreur OAuth:", error);
      return res.redirect(`${getFrontendUrl()}/google-auth-callback?google_error=${error}`);
    }
    if (!code || !state) {
      console.log("[GOOGLE-AUTH] \u274C Param\xE8tres manquants - Code:", !!code, "State:", !!state);
      return res.redirect(`${getFrontendUrl()}/google-auth-callback?google_error=missing_params`);
    }
    let organizationId;
    let userId;
    let platform;
    let redirectUriFromState;
    try {
      const parsedState = parseOAuthState(state);
      organizationId = parsedState.organizationId;
      userId = parsedState.userId;
      platform = parsedState.platform;
      redirectUriFromState = parsedState.redirectUri;
      if (!organizationId || !userId) {
        throw new Error("State object is missing organizationId or userId");
      }
      if (platform && (platform === "google_ads" || platform === "meta_ads")) {
        console.log("[GOOGLE-AUTH] \u{1F504} Redirection vers gestionnaire int\xE9grations publicitaires:", platform);
        const callbackPath = `/api/integrations/advertising/oauth/${platform}/callback`;
        const redirectUrl = `${callbackPath}?${new URLSearchParams(req2.query).toString()}`;
        return res.redirect(redirectUrl);
      }
    } catch {
      console.error("[GOOGLE-AUTH] \u274C State invalide, non-JSON ou champs manquants:", state);
      return res.redirect(`${getFrontendUrl()}/google-auth-callback?google_error=invalid_state`);
    }
    console.log("[GOOGLE-AUTH] \u{1F3E2} Organisation cible:", organizationId, "pour utilisateur:", userId);
    const config = await getGoogleWorkspaceConfig(organizationId);
    if (!config || !config.isConfigured || !config.adminEmail) {
      console.log("[GOOGLE-AUTH] \u274C Configuration manquante ou email admin non d\xE9fini pour org:", organizationId);
      return res.redirect(`${getFrontendUrl()}/google-auth-callback?google_error=config_incomplete`);
    }
    console.log("[GOOGLE-AUTH] \u2705 Configuration trouv\xE9e, email admin cible:", config.adminEmail);
    console.log("[GOOGLE-AUTH] \u{1F504} \xC9change du code contre les tokens...");
    const hostHeader2 = req2.headers.host || "localhost:4000";
    const actualRedirectUri = redirectUriFromState && typeof redirectUriFromState === "string" ? redirectUriFromState : getOAuthRedirectUri(hostHeader2);
    console.log("[GOOGLE-AUTH] \u{1F3AF} Callback - Redirect URI pour \xE9change de tokens:", {
      hostHeader: hostHeader2,
      redirectUri: actualRedirectUri,
      environment: hostHeader2.includes("app.github.dev") ? "Codespaces" : hostHeader2.includes("2thier.be") ? "Production" : "Local"
    });
    const oauth2Client = new import_googleapis7.google.auth.OAuth2(
      config.clientId,
      config.clientSecret,
      actualRedirectUri
    );
    try {
      console.log("[GOOGLE-AUTH] \u{1F511} Tentative d'\xE9change de code avec Google:", {
        clientId: config.clientId.substring(0, 20) + "...",
        redirectUri: actualRedirectUri,
        code: code.substring(0, 20) + "..."
      });
      const { tokens: tokens2 } = await oauth2Client.getToken(code);
      console.log("[GOOGLE-AUTH] \u2705 Tokens re\xE7us:", {
        accessToken: !!tokens2.access_token,
        refreshToken: !!tokens2.refresh_token,
        expiresAt: tokens2.expiry_date ? new Date(tokens2.expiry_date) : null,
        scope: tokens2.scope
      });
      oauth2Client.setCredentials(tokens2);
      const oauth2 = import_googleapis7.google.oauth2({ version: "v2", auth: oauth2Client });
      const userInfo = await oauth2.userinfo.get();
      console.log("[GOOGLE-AUTH] \u2705 Informations du compte Google connect\xE9:", {
        email: userInfo.data.email,
        name: userInfo.data.name
      });
      if (userInfo.data.email?.toLowerCase() !== config.adminEmail.toLowerCase()) {
        console.log(`[GOOGLE-AUTH] \u274C ERREUR DE COMPTE : L'utilisateur s'est connect\xE9 avec ${userInfo.data.email}, mais la configuration attendait ${config.adminEmail}.`);
        return res.redirect(`${getFrontendUrl()}/google-auth-callback?google_error=account_mismatch&expected=${encodeURIComponent(config.adminEmail)}&connected_as=${encodeURIComponent(userInfo.data.email || "")}`);
      }
      console.log("[GOOGLE-AUTH] \u2705 Connexion Google valid\xE9e pour l'admin:", config.adminEmail);
      console.log("[GOOGLE-AUTH] \u{1F4BE} Sauvegarde des tokens pour l'utilisateur:", userId, "dans l'organisation:", organizationId);
      await googleOAuthService.saveUserTokens(userId, organizationId, tokens2, userInfo.data.email || void 0);
      const googleTokenRecord = await db.googleToken.findFirst({
        where: { userId, organizationId }
      });
      console.log("[GOOGLE-AUTH] \u2705 Tokens sauvegard\xE9s pour l'utilisateur:", googleTokenRecord?.id);
      console.log("[GOOGLE-AUTH] \u{1F527} Activation des modules Google Workspace...");
      await activateGoogleModules(organizationId, tokens2.scope || "");
      console.log("[GOOGLE-AUTH] \u{1F389} Authentification Google compl\xE8te avec succ\xE8s !");
      return res.redirect(`${getFrontendUrl()}/google-auth-callback?google_success=1&organizationId=${organizationId}&admin_email=${encodeURIComponent(config.adminEmail)}`);
    } catch (tokenError) {
      const error2 = tokenError;
      console.error("[GOOGLE-AUTH] \u274C Erreur lors de l'\xE9change des tokens:", error2);
      console.error("[GOOGLE-AUTH] \u{1F4CA} D\xE9tails erreur:");
      console.error("[GOOGLE-AUTH] \u{1F194} Status:", error2.response?.status);
      console.error("[GOOGLE-AUTH] \u{1F4DD} Message:", error2.message);
      console.error("[GOOGLE-AUTH] \u{1F4CB} Data:", error2.response?.data);
      console.error("[GOOGLE-AUTH] \u{1F517} URL appel\xE9e:", error2.config?.url);
      let errorType = "token_exchange_failed";
      if (error2.response?.status === 400) {
        if (error2.response?.data?.error === "invalid_client") {
          errorType = "invalid_client_config";
        } else if (error2.response?.data?.error === "invalid_grant") {
          errorType = "invalid_authorization_code";
        }
      } else if (error2.response?.status === 401) {
        errorType = "unauthorized_client";
      }
      return res.redirect(`${getFrontendUrl()}/google-auth-callback?google_error=${errorType}&details=${encodeURIComponent(error2.message || "Erreur inconnue")}`);
    }
  } catch (error) {
    console.error("[GOOGLE-AUTH] \u274C Erreur callback g\xE9n\xE9rale:", error);
    return res.redirect(`${getFrontendUrl()}/google-auth-callback?google_error=callback_error`);
  }
});
router12.get("/status", authMiddleware, async (req2, res) => {
  try {
    console.log("[GOOGLE-AUTH] \u{1F4CA} V\xE9rification statut connexion pour user:", req2.user?.userId);
    if (!req2.user?.userId) {
      return res.json({
        success: true,
        data: {
          connected: false,
          email: null,
          scopes: [],
          lastSync: null,
          error: "Utilisateur non authentifi\xE9"
        }
      });
    }
    const organizationId = req2.query.organizationId;
    if (!organizationId) {
      return res.json({
        success: true,
        data: {
          connected: false,
          email: null,
          scopes: [],
          lastSync: null,
          error: "Organization ID requis"
        }
      });
    }
    const userId = req2.user?.userId;
    console.log("[GOOGLE-AUTH] \u{1F504} Tentative de refresh automatique pour organisation:", organizationId, "userId:", userId);
    const refreshResult = await refreshGoogleTokenIfNeeded(organizationId, userId);
    if (!refreshResult.success) {
      console.log("[GOOGLE-AUTH] \u274C Refresh automatique \xE9chou\xE9:", refreshResult.error);
      if (refreshResult.error === "no_token_found") {
        return res.json({
          success: true,
          data: {
            connected: false,
            email: null,
            scopes: [],
            lastSync: null,
            error: "Aucun token Google trouv\xE9"
          }
        });
      } else if (refreshResult.error === "no_refresh_token") {
        return res.json({
          success: true,
          data: {
            connected: false,
            email: null,
            scopes: [],
            lastSync: null,
            error: "Token expir\xE9, reconnexion requise"
          }
        });
      } else if (refreshResult.error === "invalid_refresh_token") {
        return res.json({
          success: true,
          data: {
            connected: false,
            email: null,
            scopes: [],
            lastSync: null,
            error: "Token r\xE9voqu\xE9, reconnexion requise"
          }
        });
      } else {
        return res.json({
          success: true,
          data: {
            connected: false,
            email: null,
            scopes: [],
            lastSync: null,
            error: "Erreur de connexion Google"
          }
        });
      }
    }
    console.log("[GOOGLE-AUTH] \u2705 Token valide ou rafra\xEEchi avec succ\xE8s");
    let userEmail = null;
    let tokenValid = false;
    let scopes = [];
    try {
      const oauth2Client = new import_googleapis7.google.auth.OAuth2();
      oauth2Client.setCredentials({
        access_token: refreshResult.accessToken,
        refresh_token: refreshResult.refreshToken,
        expiry_date: refreshResult.expiresAt?.getTime()
      });
      const oauth2 = import_googleapis7.google.oauth2({ version: "v2", auth: oauth2Client });
      const userInfo = await oauth2.userinfo.get();
      userEmail = userInfo.data.email;
      tokenValid = true;
      let googleToken;
      if (userId) {
        googleToken = await db.googleToken.findUnique({
          where: { userId_organizationId: { userId, organizationId } }
        });
      } else {
        googleToken = await db.googleToken.findFirst({
          where: { organizationId }
        });
      }
      scopes = googleToken?.scope ? googleToken.scope.split(" ") : [];
      console.log("[GOOGLE-AUTH] \u2705 Token valid\xE9 avec succ\xE8s, email:", userEmail);
    } catch (tokenError) {
      console.log("[GOOGLE-AUTH] \u274C Erreur validation token final:", tokenError);
      tokenValid = false;
    }
    let googleTokenInfo;
    if (userId) {
      googleTokenInfo = await db.googleToken.findUnique({
        where: { userId_organizationId: { userId, organizationId } }
      });
    } else {
      googleTokenInfo = await db.googleToken.findFirst({
        where: { organizationId }
      });
    }
    res.json({
      success: true,
      data: {
        connected: tokenValid,
        isValid: tokenValid,
        // ‚úÖ Ajout explicite pour v√©rification c√¥t√© client
        email: userEmail,
        scopes,
        lastSync: googleTokenInfo?.updatedAt,
        expiresAt: refreshResult.expiresAt,
        isExpired: false,
        // Le token est maintenant garanti valide
        autoRefreshEnabled: true
        // Indicateur que le refresh automatique est actif
      }
    });
  } catch (error) {
    console.error("[GOOGLE-AUTH] \u274C Erreur statut:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la v\xE9rification du statut"
    });
  }
});
router12.post("/disconnect", authMiddleware, async (req2, res) => {
  try {
    console.log("[GOOGLE-AUTH] \u{1F504} D\xE9but d\xE9connexion pour user:", req2.user?.userId);
    if (!req2.user?.userId) {
      return res.status(401).json({
        success: false,
        message: "Utilisateur non authentifi\xE9"
      });
    }
    const { organizationId } = req2.body;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "Organization ID requis"
      });
    }
    try {
      logSecurityEvent("GOOGLE_DISCONNECT_REQUESTED", {
        userId: req2.user.userId,
        organizationId,
        ip: req2.ip,
        userAgent: req2.headers["user-agent"] || null
      }, "info");
    } catch (e) {
      console.warn("[GOOGLE-AUTH] Warn: \xE9chec logSecurityEvent (REQUESTED):", e?.message);
    }
    const currentUserId = req2.user.userId;
    let googleToken;
    if (currentUserId) {
      googleToken = await db.googleToken.findUnique({
        where: { userId_organizationId: { userId: currentUserId, organizationId } }
      });
    } else {
      googleToken = await db.googleToken.findFirst({
        where: { organizationId }
      });
    }
    if (googleToken) {
      try {
        console.log("[GOOGLE-AUTH] \u{1F6AB} R\xE9vocation du token c\xF4t\xE9 Google...");
        const oauth2Client = new import_googleapis7.google.auth.OAuth2();
        oauth2Client.setCredentials({
          access_token: googleToken.accessToken
        });
        await oauth2Client.revokeCredentials();
        console.log("[GOOGLE-AUTH] \u2705 Token r\xE9voqu\xE9 c\xF4t\xE9 Google");
      } catch (revokeError) {
        console.log("[GOOGLE-AUTH] \u26A0\uFE0F Erreur r\xE9vocation c\xF4t\xE9 Google (peut-\xEAtre d\xE9j\xE0 r\xE9voqu\xE9):", revokeError);
      }
      console.log("[GOOGLE-AUTH] \u{1F5D1}\uFE0F Suppression du token de la base...");
      if (currentUserId) {
        await db.googleToken.delete({
          where: { userId_organizationId: { userId: currentUserId, organizationId } }
        });
      } else if (googleToken.id) {
        await db.googleToken.delete({
          where: { id: googleToken.id }
        });
      }
      console.log("[GOOGLE-AUTH] \u2705 Token supprim\xE9 de la base");
    }
    console.log("[GOOGLE-AUTH] \u{1F527} D\xE9sactivation des modules Google...");
    await db.googleWorkspaceConfig.update({
      where: { organizationId },
      data: {
        enabled: false,
        gmailEnabled: false,
        calendarEnabled: false,
        driveEnabled: false,
        docsEnabled: false,
        sheetsEnabled: false,
        meetEnabled: false,
        voiceEnabled: false,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    const googleModules = await db.module.findMany({
      where: {
        name: {
          in: ["Gmail", "Calendar", "Drive", "Docs", "Sheets", "Meet"],
          mode: "insensitive"
        }
      }
    });
    for (const module2 of googleModules) {
      await db.organizationModule.updateMany({
        where: {
          organizationId,
          moduleId: module2.id
        },
        data: {
          isActive: false,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    }
    console.log("[GOOGLE-AUTH] \u2705 Modules Google d\xE9sactiv\xE9s");
    console.log("[GOOGLE-AUTH] \u{1F389} D\xE9connexion Google compl\xE8te");
    try {
      logSecurityEvent("GOOGLE_DISCONNECT_COMPLETED", {
        userId: req2.user.userId,
        organizationId,
        ip: req2.ip,
        userAgent: req2.headers["user-agent"] || null
      }, "info");
    } catch (e) {
      console.warn("[GOOGLE-AUTH] Warn: \xE9chec logSecurityEvent (COMPLETED):", e?.message);
    }
    res.json({
      success: true,
      message: "D\xE9connect\xE9 de Google Workspace avec succ\xE8s"
    });
  } catch (error) {
    console.error("[GOOGLE-AUTH] \u274C Erreur d\xE9connexion:", error);
    try {
      const orgIdFromBody = req2.body && typeof req2.body.organizationId === "string" ? req2.body.organizationId : null;
      const errMsg = error instanceof Error ? error.message : String(error);
      logSecurityEvent("GOOGLE_DISCONNECT_ERROR", {
        userId: req2.user?.userId || null,
        organizationId: orgIdFromBody,
        ip: req2.ip,
        userAgent: req2.headers["user-agent"] || null,
        error: errMsg
      }, "error");
    } catch (e) {
      console.warn("[GOOGLE-AUTH] Warn: \xE9chec logSecurityEvent (ERROR):", e?.message);
    }
    res.status(500).json({
      success: false,
      message: "Erreur lors de la d\xE9connexion"
    });
  }
});
router12.post("/toggle-module", authMiddleware, async (req2, res) => {
  try {
    const { moduleName, enabled, organizationId } = req2.body;
    console.log("[GOOGLE-AUTH] \u{1F527} Toggle module:", moduleName, "enabled:", enabled, "pour organization:", organizationId);
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "Organization ID requis"
      });
    }
    if (!moduleName || typeof enabled !== "boolean") {
      return res.status(400).json({
        success: false,
        message: "Param\xE8tres invalides (moduleName et enabled requis)"
      });
    }
    const userId = req2.user?.userId;
    let googleToken;
    if (userId) {
      googleToken = await db.googleToken.findUnique({
        where: { userId_organizationId: { userId, organizationId } }
      });
    } else {
      googleToken = await db.googleToken.findFirst({
        where: { organizationId }
      });
    }
    if (!googleToken && enabled) {
      return res.status(400).json({
        success: false,
        message: "Connexion Google requise pour activer les modules"
      });
    }
    const moduleConfigMap = {
      "Gmail": "gmailEnabled",
      "Calendar": "calendarEnabled",
      "Drive": "driveEnabled",
      "Docs": "docsEnabled",
      "Sheets": "sheetsEnabled",
      "Meet": "meetEnabled",
      "Voice": "voiceEnabled"
    };
    const configField = moduleConfigMap[moduleName];
    if (!configField) {
      return res.status(400).json({
        success: false,
        message: "Module non reconnu"
      });
    }
    const updateData = {
      [configField]: enabled,
      updatedAt: /* @__PURE__ */ new Date()
    };
    await db.googleWorkspaceConfig.update({
      where: { organizationId },
      data: updateData
    });
    const module2 = await db.module.findFirst({
      where: {
        name: {
          contains: moduleName,
          mode: "insensitive"
        }
      }
    });
    if (module2) {
      await db.organizationModule.upsert({
        where: {
          organizationId_moduleId: {
            organizationId,
            moduleId: module2.id
          }
        },
        update: {
          isActive: enabled,
          activatedAt: enabled ? /* @__PURE__ */ new Date() : null,
          updatedAt: /* @__PURE__ */ new Date()
        },
        create: {
          organizationId,
          moduleId: module2.id,
          isActive: enabled,
          activatedAt: enabled ? /* @__PURE__ */ new Date() : null
        }
      });
    }
    console.log("[GOOGLE-AUTH] \u2705 Module", moduleName, enabled ? "activ\xE9" : "d\xE9sactiv\xE9");
    res.json({
      success: true,
      message: `Module ${moduleName} ${enabled ? "activ\xE9" : "d\xE9sactiv\xE9"} avec succ\xE8s`,
      data: {
        moduleName,
        enabled
      }
    });
  } catch (error) {
    console.error("[GOOGLE-AUTH] \u274C Erreur toggle module:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la modification du module"
    });
  }
});
router12.use("/gmail", authMiddleware, gmail_default);
console.log("[GOOGLE-AUTH] Routes Gmail centralis\xE9es mont\xE9es sur /gmail");
var google_auth_default = router12;

// src/routes/google-scheduler.ts
var import_express14 = require("express");

// src/services/GoogleTokenRefreshScheduler.ts
init_database();
init_crypto();
var GoogleTokenRefreshScheduler = class {
  intervalId = null;
  isRunning = false;
  REFRESH_INTERVAL = 50 * 60 * 1e3;
  // 50 minutes
  refreshCount = 0;
  lastRefreshTime = null;
  constructor() {
    console.log("\u{1F504} [GoogleTokenScheduler] Scheduler initialis\xE9");
  }
  start() {
    if (this.isRunning) {
      console.log("\u26A0\uFE0F [GoogleTokenScheduler] Scheduler d\xE9j\xE0 en cours d'ex\xE9cution");
      return;
    }
    this.isRunning = true;
    this.refreshAllTokens();
    this.intervalId = setInterval(() => {
      this.refreshAllTokens();
    }, this.REFRESH_INTERVAL);
    console.log("\u{1F680} [GoogleTokenScheduler] Scheduler d\xE9marr\xE9 - refresh toutes les 50 minutes");
  }
  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
    this.isRunning = false;
    console.log("\u23F9\uFE0F [GoogleTokenScheduler] Scheduler arr\xEAt\xE9");
  }
  getStatus() {
    return {
      isRunning: this.isRunning,
      refreshInterval: this.REFRESH_INTERVAL,
      refreshCount: this.refreshCount,
      lastRefresh: this.lastRefreshTime
    };
  }
  async forceRefreshAll() {
    console.log("\u{1F525} [GoogleTokenScheduler] Refresh forc\xE9 de tous les tokens");
    await this.refreshAllTokens({ ignoreExpiry: true });
  }
  async refreshAllTokens(options = {}) {
    try {
      console.log("\u{1F504} [GoogleTokenScheduler] D\xE9but du refresh de tous les tokens...");
      this.lastRefreshTime = /* @__PURE__ */ new Date();
      const ignoreExpiry = options.ignoreExpiry === true;
      const tokensToRefresh = await db.googleToken.findMany({
        where: {
          // Ne tenter un refresh que si un refresh token existe
          refreshToken: {
            not: null
          },
          ...ignoreExpiry ? {} : {
            OR: [
              // Tokens qui expirent dans moins de 10 minutes
              {
                expiresAt: {
                  lte: new Date(Date.now() + 10 * 60 * 1e3)
                }
              },
              // Ou tokens sans date d'expiration (consid√©r√©s comme expir√©s)
              {
                expiresAt: null
              }
            ]
          }
        },
        include: {
          Organization: true
        }
      });
      console.log(`\u{1F50D} [GoogleTokenScheduler] ${tokensToRefresh.length} tokens trouv\xE9s \xE0 refresher${ignoreExpiry ? " (mode forc\xE9)" : ""}`);
      let successCount = 0;
      let errorCount = 0;
      for (const token of tokensToRefresh) {
        const success = await this.refreshSingleToken(token);
        if (success) {
          successCount++;
        } else {
          errorCount++;
        }
      }
      this.refreshCount++;
      console.log(`\u2705 [GoogleTokenScheduler] Refresh termin\xE9: ${successCount} succ\xE8s, ${errorCount} erreurs`);
    } catch (error) {
      console.error("\u274C [GoogleTokenScheduler] Erreur lors du refresh g\xE9n\xE9ral:", error);
    }
  }
  async refreshSingleToken(token) {
    const oldExpiresAt = token.expiresAt;
    try {
      console.log(`\u{1F504} [GoogleTokenScheduler] Refresh token pour org ${token.organizationId}`);
      if (!token.refreshToken) {
        const errorMsg = "Aucun refresh token disponible";
        console.error(`\u274C [GoogleTokenScheduler] ${errorMsg} pour org ${token.organizationId}`);
        await this.logRefreshHistory({
          organizationId: token.organizationId,
          success: false,
          message: errorMsg,
          errorDetails: "Missing refresh token",
          oldExpiresAt,
          newExpiresAt: null
        });
        return false;
      }
      const googleConfig = await db.googleWorkspaceConfig.findUnique({
        where: { organizationId: token.organizationId }
      });
      const adminEmail = googleConfig?.adminEmail?.trim().toLowerCase();
      const tokenEmail = token.googleEmail?.trim().toLowerCase();
      if (adminEmail && tokenEmail !== adminEmail) {
        console.log(`\u23ED\uFE0F [GoogleTokenScheduler] Token ignor\xE9 (non-admin) pour org ${token.organizationId}: ${token.googleEmail ?? "(sans googleEmail)"}`);
        return true;
      }
      const clientId = googleConfig?.clientId ? decrypt(googleConfig.clientId) : null;
      const clientSecret = googleConfig?.clientSecret ? decrypt(googleConfig.clientSecret) : null;
      if (!clientId || !clientSecret) {
        const errorMsg = "Configuration OAuth (clientId/clientSecret) manquante ou invalide";
        console.error(`\u274C [GoogleTokenScheduler] ${errorMsg} pour org ${token.organizationId}`);
        await this.logRefreshHistory({
          organizationId: token.organizationId,
          success: false,
          message: errorMsg,
          errorDetails: "Missing or invalid encrypted OAuth credentials",
          oldExpiresAt,
          newExpiresAt: null
        });
        return false;
      }
      const response = await fetch("https://oauth2.googleapis.com/token", {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          client_id: clientId,
          client_secret: clientSecret,
          refresh_token: token.refreshToken,
          grant_type: "refresh_token"
        })
      });
      if (!response.ok) {
        const rawBody = await response.text();
        let googleError;
        let googleErrorDescription;
        try {
          const parsed = JSON.parse(rawBody);
          googleError = parsed.error;
          googleErrorDescription = parsed.error_description;
        } catch {
        }
        let errorMsg = `Erreur Google OAuth: ${response.status}`;
        if (googleError === "invalid_grant") {
          errorMsg = "Refresh token r\xE9voqu\xE9/invalide (r\xE9authentification requise)";
          try {
            await db.googleToken.update({
              where: { id: token.id },
              data: { refreshToken: null, updatedAt: /* @__PURE__ */ new Date() }
            });
          } catch (cleanupError) {
            console.warn("[GoogleTokenScheduler] \u26A0\uFE0F Impossible de nettoyer refreshToken apr\xE8s invalid_grant:", cleanupError);
          }
        } else if (googleError === "invalid_client") {
          errorMsg = "Client OAuth invalide (clientId/clientSecret incorrects)";
        } else if (googleError) {
          errorMsg = `Erreur Google OAuth (${googleError})`;
        }
        const errorDetails = [
          googleError ? `error=${googleError}` : null,
          googleErrorDescription ? `error_description=${googleErrorDescription}` : null,
          rawBody || null
        ].filter(Boolean).join(" | ");
        console.error(`\u274C [GoogleTokenScheduler] ${errorMsg} pour org ${token.organizationId}:`, errorDetails);
        await this.logRefreshHistory({
          organizationId: token.organizationId,
          success: false,
          message: errorMsg,
          errorDetails,
          oldExpiresAt,
          newExpiresAt: null
        });
        return false;
      }
      const tokenData = await response.json();
      const newExpiresAt = new Date(Date.now() + tokenData.expires_in * 1e3);
      await db.googleToken.update({
        where: { id: token.id },
        data: {
          accessToken: tokenData.access_token,
          expiresAt: newExpiresAt,
          updatedAt: /* @__PURE__ */ new Date(),
          lastRefreshAt: /* @__PURE__ */ new Date(),
          refreshCount: { increment: 1 },
          // Mettre √† jour le refresh token s'il y en a un nouveau
          ...tokenData.refresh_token && { refreshToken: tokenData.refresh_token },
          // Mettre √† jour le scope s'il y en a un nouveau
          ...tokenData.scope && { scope: tokenData.scope }
        }
      });
      const successMsg = "Token refreshed successfully";
      console.log(`\u2705 [GoogleTokenScheduler] ${successMsg} pour org ${token.organizationId}, expire \xE0 ${newExpiresAt.toISOString()}`);
      await this.logRefreshHistory({
        organizationId: token.organizationId,
        success: true,
        message: successMsg,
        errorDetails: null,
        oldExpiresAt,
        newExpiresAt
      });
      return true;
    } catch (error) {
      const errorMsg = "Erreur lors du refresh du token";
      const errorDetails = error instanceof Error ? error.message : "Erreur inconnue";
      console.error(`\u274C [GoogleTokenScheduler] ${errorMsg} pour org ${token.organizationId}:`, error);
      await this.logRefreshHistory({
        organizationId: token.organizationId,
        success: false,
        message: errorMsg,
        errorDetails,
        oldExpiresAt,
        newExpiresAt: null
      });
      return false;
    }
  }
  async logRefreshHistory({
    organizationId,
    success,
    message,
    errorDetails,
    oldExpiresAt,
    newExpiresAt
  }) {
    try {
      await db.googleTokenRefreshHistory.create({
        data: {
          organizationId,
          success,
          message,
          errorDetails,
          oldExpiresAt,
          newExpiresAt,
          refreshedAt: /* @__PURE__ */ new Date()
        }
      });
    } catch (error) {
      console.error("\u274C [GoogleTokenScheduler] Erreur lors de l'enregistrement de l'historique:", error);
    }
  }
};
var googleTokenScheduler = new GoogleTokenRefreshScheduler();

// src/routes/google-scheduler.ts
init_database();
var router13 = (0, import_express14.Router)();
router13.use(authMiddleware);
router13.use(requireRole2(["admin", "super_admin"]));
router13.get("/status", (_req, res) => {
  try {
    const status = googleTokenScheduler.getStatus();
    res.json({
      success: true,
      scheduler: {
        isRunning: status.isRunning,
        checkIntervalMinutes: status.checkIntervalMinutes,
        refreshMarginMinutes: status.refreshMarginMinutes,
        description: status.isRunning ? `Scheduler actif - v\xE9rifications toutes les ${status.checkIntervalMinutes} min, refresh ${status.refreshMarginMinutes} min avant expiration` : "Scheduler arr\xEAt\xE9"
      },
      message: status.isRunning ? "\u2705 Le scheduler de refresh automatique est actif" : "\u26A0\uFE0F Le scheduler de refresh automatique est arr\xEAt\xE9"
    });
  } catch (error) {
    console.error("[GoogleSchedulerAPI] Erreur status:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la r\xE9cup\xE9ration du statut",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router13.post("/refresh-all", async (_req, res) => {
  try {
    console.log("[GoogleSchedulerAPI] \u{1F527} Refresh forc\xE9 demand\xE9 pour tous les tokens");
    await googleTokenScheduler.forceRefreshAll();
    res.json({
      success: true,
      message: "\u2705 Refresh forc\xE9 de tous les tokens termin\xE9 - v\xE9rifiez les logs serveur pour les d\xE9tails"
    });
  } catch (error) {
    console.error("[GoogleSchedulerAPI] Erreur refresh-all:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors du refresh forc\xE9",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router13.post("/refresh/:organizationId", async (req2, res) => {
  try {
    const { organizationId } = req2.params;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        error: "ID d'organisation requis"
      });
    }
    console.log(`[GoogleSchedulerAPI] \u{1F527} Refresh forc\xE9 demand\xE9 pour organisation: ${organizationId}`);
    await googleTokenScheduler.refreshTokenForOrganization(organizationId);
    res.json({
      success: true,
      message: `\u2705 Refresh forc\xE9 pour l'organisation ${organizationId} termin\xE9 - v\xE9rifiez les logs serveur pour les d\xE9tails`
    });
  } catch (error) {
    console.error("[GoogleSchedulerAPI] Erreur refresh specific:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors du refresh sp\xE9cifique",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router13.post("/restart", (_req, res) => {
  try {
    console.log("[GoogleSchedulerAPI] \u{1F504} Red\xE9marrage du scheduler demand\xE9");
    googleTokenScheduler.stop();
    googleTokenScheduler.start();
    res.json({
      success: true,
      message: "\u2705 Scheduler red\xE9marr\xE9 avec succ\xE8s"
    });
  } catch (error) {
    console.error("[GoogleSchedulerAPI] Erreur restart:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors du red\xE9marrage du scheduler",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router13.get("/tokens-info", async (_req, res) => {
  try {
    const tokens2 = await db.googleToken.findMany({
      include: {
        organization: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });
    const now = /* @__PURE__ */ new Date();
    const tokensInfo = tokens2.map((token) => {
      const expiresAt = token.expiresAt;
      let status = "unknown";
      let minutesToExpiry = null;
      if (expiresAt) {
        const timeToExpiry = expiresAt.getTime() - now.getTime();
        minutesToExpiry = Math.round(timeToExpiry / 1e3 / 60);
        if (expiresAt <= now) {
          status = "expired";
        } else if (minutesToExpiry <= 10) {
          status = "expiring_soon";
        } else {
          status = "valid";
        }
      }
      return {
        organizationId: token.organizationId,
        organizationName: token.organization?.name || "Unknown",
        status,
        expiresAt: expiresAt?.toISOString(),
        minutesToExpiry,
        hasRefreshToken: !!token.refreshToken,
        lastUpdated: token.updatedAt?.toISOString()
      };
    });
    const summary = {
      total: tokens2.length,
      valid: tokensInfo.filter((t) => t.status === "valid").length,
      expiring_soon: tokensInfo.filter((t) => t.status === "expiring_soon").length,
      expired: tokensInfo.filter((t) => t.status === "expired").length,
      unknown: tokensInfo.filter((t) => t.status === "unknown").length
    };
    res.json({
      success: true,
      summary,
      tokens: tokensInfo
    });
  } catch (error) {
    console.error("[GoogleSchedulerAPI] Erreur tokens-info:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la r\xE9cup\xE9ration des informations tokens",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
var google_scheduler_default = router13;

// src/routes/google-tokens.ts
var import_express15 = require("express");
init_database();
var router14 = (0, import_express15.Router)();
router14.use(authMiddleware);
router14.use(requireRole2(["admin", "super_admin"]));
router14.get("/scheduler/status", async (_req, res) => {
  try {
    const status = googleTokenScheduler.getStatus();
    const totalTokens = await db.googleToken.count();
    const activeTokens = await db.googleToken.count({
      where: {
        expiresAt: {
          gt: /* @__PURE__ */ new Date()
        }
      }
    });
    const recentErrors = [];
    const schedulerStatus = {
      isRunning: status.isRunning,
      nextRefresh: status.isRunning ? new Date(Date.now() + 50 * 60 * 1e3).toISOString() : null,
      // 50 min dans le futur
      lastRefresh: status.lastRefresh ? status.lastRefresh.toISOString() : null,
      refreshCount: status.refreshCount,
      totalUsers: totalTokens,
      activeTokens,
      errors: recentErrors
    };
    res.json({
      success: true,
      data: schedulerStatus
    });
  } catch (error) {
    console.error("[GoogleTokensAPI] Erreur status:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration du statut",
      error: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router14.get("/organization/:organizationId", async (req2, res) => {
  try {
    const { organizationId } = req2.params;
    const googleConfig = await db.googleWorkspaceConfig.findUnique({
      where: { organizationId },
      select: { adminEmail: true }
    });
    const adminEmail = googleConfig?.adminEmail?.trim() || null;
    const token = adminEmail ? await db.googleToken.findFirst({
      where: {
        organizationId,
        googleEmail: {
          equals: adminEmail,
          mode: "insensitive"
        }
      },
      orderBy: { updatedAt: "desc" },
      include: { User: { select: { email: true, firstName: true, lastName: true } } }
    }) : await db.googleToken.findFirst({
      where: { organizationId },
      orderBy: { updatedAt: "desc" },
      include: { User: { select: { email: true, firstName: true, lastName: true } } }
    });
    if (!token) {
      return res.json({
        success: false,
        message: "Aucun token trouv\xE9 pour cette organisation"
      });
    }
    const now = /* @__PURE__ */ new Date();
    const expiresAt = token.expiresAt;
    const isExpired = expiresAt ? expiresAt <= now : true;
    let timeUntilExpiry = "N/A";
    if (expiresAt && !isExpired) {
      const diff = expiresAt.getTime() - now.getTime();
      const minutes = Math.floor(diff / 1e3 / 60);
      const seconds = Math.floor(diff % (1e3 * 60) / 1e3);
      timeUntilExpiry = `${minutes}m ${seconds}s`;
    } else if (isExpired) {
      timeUntilExpiry = "Expir\xE9";
    }
    const tokenInfo = {
      id: token.id,
      organizationId: token.organizationId,
      userId: token.userId,
      userEmail: token.User?.email,
      userName: token.User ? `${token.User.firstName} ${token.User.lastName}` : null,
      googleEmail: token.googleEmail,
      accessToken: token.accessToken ? `${token.accessToken.substring(0, 20)}...` : "",
      // Masquer le token
      refreshToken: token.refreshToken,
      // ‚úÖ Retourner null au lieu de 'Absent' pour que le frontend puisse d√©tecter
      hasRefreshToken: !!token.refreshToken,
      // ‚úÖ Ajouter un indicateur bool√©en clair
      tokenType: token.tokenType || "Bearer",
      expiresIn: 3600,
      // Les tokens Google durent 1 heure
      scope: token.scope || "",
      createdAt: token.createdAt?.toISOString() || "",
      updatedAt: token.updatedAt?.toISOString() || "",
      expiresAt: expiresAt?.toISOString() || "",
      lastRefreshAt: token.lastRefreshAt?.toISOString() || null,
      refreshCount: token.refreshCount || 0,
      isExpired,
      timeUntilExpiry
    };
    res.json({
      success: true,
      data: tokenInfo
    });
  } catch (error) {
    console.error("[GoogleTokensAPI] Erreur organization token:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration du token",
      error: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router14.post("/scheduler/start", (_req, res) => {
  try {
    googleTokenScheduler.start();
    res.json({
      success: true,
      message: "Scheduler d\xE9marr\xE9 avec succ\xE8s"
    });
  } catch (error) {
    console.error("[GoogleTokensAPI] Erreur start scheduler:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors du d\xE9marrage du scheduler",
      error: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router14.post("/scheduler/stop", (_req, res) => {
  try {
    googleTokenScheduler.stop();
    res.json({
      success: true,
      message: "Scheduler arr\xEAt\xE9 avec succ\xE8s"
    });
  } catch (error) {
    console.error("[GoogleTokensAPI] Erreur stop scheduler:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de l'arr\xEAt du scheduler",
      error: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router14.post("/scheduler/refresh-now", async (_req, res) => {
  try {
    await googleTokenScheduler.forceRefreshAll();
    res.json({
      success: true,
      message: "Refresh imm\xE9diat lanc\xE9 avec succ\xE8s"
    });
  } catch (error) {
    console.error("[GoogleTokensAPI] Erreur refresh now:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors du refresh imm\xE9diat",
      error: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router14.get("/refresh-history/:organizationId", async (req2, res) => {
  try {
    const { organizationId } = req2.params;
    console.log(`[GoogleTokensAPI] R\xE9cup\xE9ration historique pour org: ${organizationId}`);
    const history = await db.googleTokenRefreshHistory.findMany({
      where: {
        organizationId
      },
      orderBy: {
        refreshedAt: "desc"
      },
      take: 50
      // Limiter aux 50 derniers
    });
    const formattedHistory = history.map((entry) => ({
      id: entry.id,
      timestamp: entry.refreshedAt.toISOString(),
      success: entry.success,
      message: entry.message,
      errorDetails: entry.errorDetails,
      oldExpiresAt: entry.oldExpiresAt?.toISOString(),
      newExpiresAt: entry.newExpiresAt?.toISOString()
    }));
    res.json({
      success: true,
      data: formattedHistory
    });
  } catch (error) {
    console.error("[GoogleTokensAPI] Erreur refresh history:", error);
    res.json({
      success: true,
      data: []
    });
  }
});
var google_tokens_default = router14;

// src/routes/googleWorkspace.ts
var import_express16 = require("express");
init_database();
var import_zod3 = require("zod");
init_crypto();
var import_nanoid = require("nanoid");
var router15 = (0, import_express16.Router)();
var prisma8 = db;
router15.use(authMiddleware);
var googleWorkspaceConfigSchema = import_zod3.z.object({
  clientId: import_zod3.z.string().optional().default(""),
  // Optionnel pour l'activation simple
  clientSecret: import_zod3.z.string().optional(),
  // Optionnel pour la mise √† jour
  redirectUri: import_zod3.z.string().optional(),
  // URL optionnelle
  domain: import_zod3.z.string().optional().default(""),
  // Optionnel pour l'activation simple
  adminEmail: import_zod3.z.string().optional().default(""),
  // Optionnel pour l'activation simple
  // Champs compte de service
  serviceAccountEmail: import_zod3.z.string().optional(),
  privateKey: import_zod3.z.string().optional(),
  // √âtat de la configuration
  isActive: import_zod3.z.boolean().default(false),
  // Modules √† activer
  gmailEnabled: import_zod3.z.boolean().default(false),
  calendarEnabled: import_zod3.z.boolean().default(false),
  driveEnabled: import_zod3.z.boolean().default(false),
  meetEnabled: import_zod3.z.boolean().default(false),
  docsEnabled: import_zod3.z.boolean().default(false),
  sheetsEnabled: import_zod3.z.boolean().default(false),
  voiceEnabled: import_zod3.z.boolean().default(false)
});
router15.get("/:id/google-workspace/config", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  console.log("[GOOGLE-WORKSPACE] GET /organizations/:id/google-workspace/config");
  try {
    const { id } = req2.params;
    const requestingUser = req2.user;
    if (requestingUser?.role !== "super_admin" && requestingUser?.organizationId !== id) {
      return res.status(403).json({
        success: false,
        message: "Acc\xE8s refus\xE9 \xE0 cette organisation"
      });
    }
    const config = await prisma8.googleWorkspaceConfig.findUnique({
      where: { organizationId: id }
    });
    if (!config) {
      return res.json({
        success: true,
        data: {
          isConfigured: false,
          clientId: "",
          clientSecret: "",
          redirectUri: `${process.env.FRONTEND_URL || "http://localhost:3000"}/api/auth/google/callback`,
          domain: "",
          adminEmail: "",
          serviceAccountEmail: "",
          privateKey: "",
          isActive: false,
          gmailEnabled: false,
          calendarEnabled: false,
          driveEnabled: false,
          meetEnabled: false,
          docsEnabled: false,
          sheetsEnabled: false,
          voiceEnabled: false,
          enabled: false
        }
      });
    }
    const isCompleteConfig = !!(config.clientId && config.clientSecret && config.domain && config.adminEmail);
    const safeConfig = {
      isConfigured: isCompleteConfig,
      clientId: config.clientId ? decrypt(config.clientId) : "",
      // üîì D√©crypter pour affichage
      clientSecret: config.clientSecret ? decrypt(config.clientSecret) : "",
      // üîì D√©crypter pour affichage
      hasClientSecret: !!config.clientSecret,
      redirectUri: config.redirectUri || `${process.env.FRONTEND_URL || "http://localhost:3000"}/api/auth/google/callback`,
      domain: config.domain || "",
      adminEmail: config.adminEmail || "",
      serviceAccountEmail: config.serviceAccountEmail || "",
      privateKey: config.privateKey ? decrypt(config.privateKey) : "",
      // üîì D√©crypter pour affichage
      hasPrivateKey: !!config.privateKey,
      isActive: config.enabled || false,
      gmailEnabled: config.gmailEnabled,
      calendarEnabled: config.calendarEnabled,
      driveEnabled: config.driveEnabled,
      meetEnabled: config.meetEnabled,
      docsEnabled: config.docsEnabled,
      sheetsEnabled: config.sheetsEnabled,
      voiceEnabled: config.voiceEnabled,
      enabled: config.enabled && isCompleteConfig
      // Enabled seulement si config compl√®te
    };
    res.json({
      success: true,
      data: safeConfig
    });
  } catch (error) {
    console.error("[GOOGLE-WORKSPACE] Erreur GET config:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la r\xE9cup\xE9ration de la configuration"
    });
  }
});
router15.post("/:id/google-workspace/config", requireRole2(["super_admin"]), async (req2, res) => {
  console.log("[GOOGLE-WORKSPACE] POST /organizations/:id/google-workspace/config");
  try {
    const { id } = req2.params;
    const requestingUser = req2.user;
    if (requestingUser?.role !== "super_admin") {
      return res.status(403).json({
        success: false,
        message: "Seuls les Super Admins peuvent configurer Google Workspace"
      });
    }
    const validationResult2 = googleWorkspaceConfigSchema.safeParse(req2.body);
    if (!validationResult2.success) {
      return res.status(400).json({
        success: false,
        message: "Donn\xE9es invalides",
        errors: validationResult2.error.errors
      });
    }
    const data = validationResult2.data;
    const organization = await prisma8.organization.findUnique({
      where: { id }
    });
    if (!organization) {
      return res.status(404).json({
        success: false,
        message: "Organisation non trouv\xE9e"
      });
    }
    const redirectUri = data.redirectUri || `${process.env.FRONTEND_URL || "http://localhost:3000"}/api/auth/google/callback`;
    const existingConfig = await prisma8.googleWorkspaceConfig.findUnique({
      where: { organizationId: id }
    });
    const encryptedClientId = data.clientId ? encrypt(data.clientId) : existingConfig?.clientId;
    const encryptedClientSecret = data.clientSecret ? encrypt(data.clientSecret) : existingConfig?.clientSecret;
    const encryptedPrivateKey = data.privateKey ? encrypt(data.privateKey) : existingConfig?.privateKey;
    const configData = {
      clientId: encryptedClientId,
      clientSecret: encryptedClientSecret,
      redirectUri,
      domain: data.domain,
      adminEmail: data.adminEmail,
      serviceAccountEmail: data.serviceAccountEmail || existingConfig?.serviceAccountEmail,
      privateKey: encryptedPrivateKey,
      enabled: data.isActive || false,
      gmailEnabled: data.gmailEnabled,
      calendarEnabled: data.calendarEnabled,
      driveEnabled: data.driveEnabled,
      meetEnabled: data.meetEnabled,
      docsEnabled: data.docsEnabled,
      sheetsEnabled: data.sheetsEnabled,
      voiceEnabled: data.voiceEnabled,
      updatedAt: /* @__PURE__ */ new Date()
    };
    const config = await prisma8.googleWorkspaceConfig.upsert({
      where: { organizationId: id },
      update: configData,
      create: {
        id: (0, import_nanoid.nanoid)(),
        // G√©n√©ration d'un ID unique pour le nouveau record
        organizationId: id,
        ...configData
      }
    });
    console.log(`[GOOGLE-WORKSPACE] Configuration sauvegard\xE9e pour l'organisation ${id}`);
    res.json({
      success: true,
      message: "Configuration Google Workspace sauvegard\xE9e avec succ\xE8s",
      data: {
        id: config.id,
        enabled: config.enabled
      }
    });
  } catch (error) {
    console.error("[GOOGLE-WORKSPACE] Erreur POST config:", error);
    console.error("[GOOGLE-WORKSPACE] D\xE9tails erreur:", error instanceof Error ? error.message : String(error));
    console.error("[GOOGLE-WORKSPACE] Stack:", error instanceof Error ? error.stack : "N/A");
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la sauvegarde de la configuration",
      error: error instanceof Error ? error.message : String(error)
    });
  }
});
router15.get("/:id/google-workspace/auth-url", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  console.log("[GOOGLE-WORKSPACE] GET /organizations/:id/google-workspace/auth-url");
  try {
    const { id } = req2.params;
    const requestingUser = req2.user;
    if (requestingUser?.role !== "super_admin" && requestingUser?.organizationId !== id) {
      return res.status(403).json({
        success: false,
        message: "Acc\xE8s refus\xE9 \xE0 cette organisation"
      });
    }
    const config = await prisma8.googleWorkspaceConfig.findUnique({
      where: { organizationId: id }
    });
    if (!config) {
      return res.status(400).json({
        success: false,
        message: "Configuration Google Workspace non trouv\xE9e. Veuillez d'abord configurer les credentials."
      });
    }
    const missingFields = [];
    if (!config.clientId) missingFields.push("Client ID");
    if (!config.clientSecret) missingFields.push("Client Secret");
    if (!config.domain) missingFields.push("Domaine");
    if (!config.adminEmail) missingFields.push("Email Admin");
    if (missingFields.length > 0) {
      return res.status(400).json({
        success: false,
        message: `Configuration incompl\xE8te. Champs manquants : ${missingFields.join(", ")}`
      });
    }
    if (!config.enabled) {
      return res.status(400).json({
        success: false,
        message: "Configuration Google Workspace d\xE9sactiv\xE9e"
      });
    }
    const scopes = [
      "https://www.googleapis.com/auth/userinfo.email",
      "https://www.googleapis.com/auth/userinfo.profile"
    ];
    if (config.gmailEnabled) {
      scopes.push("https://mail.google.com/");
      scopes.push("https://www.googleapis.com/auth/gmail.readonly");
      scopes.push("https://www.googleapis.com/auth/gmail.send");
      scopes.push("https://www.googleapis.com/auth/gmail.modify");
    }
    if (config.calendarEnabled) {
      scopes.push("https://www.googleapis.com/auth/calendar");
      scopes.push("https://www.googleapis.com/auth/calendar.events");
    }
    if (config.driveEnabled) {
      scopes.push("https://www.googleapis.com/auth/drive");
    }
    if (config.docsEnabled) {
      scopes.push("https://www.googleapis.com/auth/documents");
    }
    if (config.sheetsEnabled) {
      scopes.push("https://www.googleapis.com/auth/spreadsheets");
    }
    if (config.meetEnabled) {
      scopes.push("https://www.googleapis.com/auth/meetings");
    }
    scopes.push("https://www.googleapis.com/auth/presentations");
    scopes.push("https://www.googleapis.com/auth/contacts");
    scopes.push("https://www.googleapis.com/auth/forms");
    const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${encodeURIComponent(config.clientId)}&redirect_uri=${encodeURIComponent(config.redirectUri || "")}&response_type=code&scope=${encodeURIComponent(scopes.join(" "))}&state=${encodeURIComponent(JSON.stringify({ organizationId: id, userId: requestingUser?.id }))}&access_type=offline&prompt=consent`;
    res.json({
      success: true,
      data: {
        authUrl,
        scopes
      }
    });
  } catch (error) {
    console.error("[GOOGLE-WORKSPACE] Erreur GET auth-url:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la g\xE9n\xE9ration de l'URL d'authentification"
    });
  }
});
router15.get("/users/:userId/status", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  console.log("[GOOGLE-WORKSPACE] GET /users/:userId/status");
  try {
    const { userId } = req2.params;
    const requestingUser = req2.user;
    const targetUser = await prisma8.user.findUnique({
      where: { id: userId },
      include: {
        UserOrganization: {
          include: {
            Organization: {
              include: {
                GoogleWorkspaceConfig: true
              }
            }
          }
        }
      }
    });
    if (!targetUser) {
      return res.status(404).json({
        success: false,
        message: "Utilisateur non trouv\xE9"
      });
    }
    const userOrg = targetUser.UserOrganization?.[0];
    if (requestingUser?.role !== "super_admin" && requestingUser?.organizationId !== userOrg?.organizationId) {
      return res.status(403).json({
        success: false,
        message: "Acc\xE8s refus\xE9 \xE0 cet utilisateur"
      });
    }
    const googleConfig = userOrg?.Organization?.GoogleWorkspaceConfig;
    const googleUserStatus = await prisma8.googleWorkspaceUser.findUnique({
      where: { userId }
    });
    const normalizeString = (str) => {
      return str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-zA-Z0-9]/g, "").trim();
    };
    const generateEmail = (firstName, lastName, domain) => {
      const normalizedFirstName = normalizeString(firstName);
      const normalizedLastName = normalizeString(lastName);
      return `${normalizedFirstName}.${normalizedLastName}@${domain}`;
    };
    let suggestedEmail = "";
    if (googleConfig?.domain) {
      suggestedEmail = generateEmail(targetUser.firstName, targetUser.lastName, googleConfig.domain);
    }
    const status = {
      hasGoogleAccount: !!googleUserStatus,
      email: googleUserStatus?.email || suggestedEmail,
      isActivated: googleUserStatus?.isActive || false,
      organizationDomain: googleConfig?.domain || null,
      lastSync: googleUserStatus?.lastSync?.toISOString() || null,
      services: {
        gmail: googleUserStatus?.gmailEnabled || false,
        calendar: googleUserStatus?.calendarEnabled || false,
        drive: googleUserStatus?.driveEnabled || false,
        meet: googleUserStatus?.meetEnabled || false
      }
    };
    res.json({
      success: true,
      data: status
    });
  } catch (error) {
    console.error("[GOOGLE-WORKSPACE] Erreur GET status:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la r\xE9cup\xE9ration du statut"
    });
  }
});
router15.post("/users/create", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  console.log("[GOOGLE-WORKSPACE] POST /users/create");
  try {
    const { userId, email, activateServices = true } = req2.body;
    const requestingUser = req2.user;
    if (!userId || !email) {
      return res.status(400).json({
        success: false,
        message: "userId et email sont requis"
      });
    }
    const targetUser = await prisma8.user.findUnique({
      where: { id: userId },
      include: {
        UserOrganization: {
          include: {
            Organization: {
              include: {
                GoogleWorkspaceConfig: true
              }
            }
          }
        }
      }
    });
    if (!targetUser) {
      return res.status(404).json({
        success: false,
        message: "Utilisateur non trouv\xE9"
      });
    }
    const userOrg = targetUser.UserOrganization?.[0];
    if (requestingUser?.role !== "super_admin" && requestingUser?.organizationId !== userOrg?.organizationId) {
      return res.status(403).json({
        success: false,
        message: "Acc\xE8s refus\xE9 \xE0 cet utilisateur"
      });
    }
    const googleConfig = userOrg?.Organization?.GoogleWorkspaceConfig;
    if (!googleConfig || !googleConfig.isActive) {
      return res.status(400).json({
        success: false,
        message: "Google Workspace n'est pas configur\xE9 pour cette organisation"
      });
    }
    const existingGoogleUser = await prisma8.googleWorkspaceUser.findUnique({
      where: { userId }
    });
    if (existingGoogleUser) {
      const updatedGoogleUser = await prisma8.googleWorkspaceUser.update({
        where: { userId },
        data: {
          email,
          isActive: activateServices,
          gmailEnabled: activateServices && googleConfig.gmailEnabled,
          calendarEnabled: activateServices && googleConfig.calendarEnabled,
          driveEnabled: activateServices && googleConfig.driveEnabled,
          meetEnabled: activateServices && googleConfig.meetEnabled,
          lastSync: /* @__PURE__ */ new Date()
        }
      });
      res.json({
        success: true,
        message: "Compte Google Workspace mis \xE0 jour avec succ\xE8s",
        data: updatedGoogleUser
      });
    } else {
      const newGoogleUser = await prisma8.googleWorkspaceUser.create({
        data: {
          userId,
          email,
          isActive: activateServices,
          gmailEnabled: activateServices && googleConfig.gmailEnabled,
          calendarEnabled: activateServices && googleConfig.calendarEnabled,
          driveEnabled: activateServices && googleConfig.driveEnabled,
          meetEnabled: activateServices && googleConfig.meetEnabled,
          lastSync: /* @__PURE__ */ new Date()
        }
      });
      res.json({
        success: true,
        message: "Compte Google Workspace cr\xE9\xE9 avec succ\xE8s",
        data: newGoogleUser
      });
    }
  } catch (error) {
    console.error("[GOOGLE-WORKSPACE] Erreur POST create:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la cr\xE9ation du compte"
    });
  }
});
router15.post("/users/:userId/sync", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  console.log("[GOOGLE-WORKSPACE] POST /users/:userId/sync");
  try {
    const { userId } = req2.params;
    const requestingUser = req2.user;
    const googleUser = await prisma8.googleWorkspaceUser.findUnique({
      where: { userId },
      include: {
        User: {
          include: {
            UserOrganization: true
          }
        }
      }
    });
    if (!googleUser) {
      return res.status(404).json({
        success: false,
        message: "Compte Google Workspace non trouv\xE9 pour cet utilisateur"
      });
    }
    const userOrg = googleUser.User.UserOrganization?.[0];
    if (requestingUser?.role !== "super_admin" && requestingUser?.organizationId !== userOrg?.organizationId) {
      return res.status(403).json({
        success: false,
        message: "Acc\xE8s refus\xE9 \xE0 cet utilisateur"
      });
    }
    const updatedGoogleUser = await prisma8.googleWorkspaceUser.update({
      where: { userId },
      data: {
        lastSync: /* @__PURE__ */ new Date()
      }
    });
    res.json({
      success: true,
      message: "Synchronisation r\xE9ussie",
      data: updatedGoogleUser
    });
  } catch (error) {
    console.error("[GOOGLE-WORKSPACE] Erreur POST sync:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la synchronisation"
    });
  }
});
router15.post("/users/:userId/deactivate", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  console.log("[GOOGLE-WORKSPACE] POST /users/:userId/deactivate");
  try {
    const { userId } = req2.params;
    const requestingUser = req2.user;
    const googleUser = await prisma8.googleWorkspaceUser.findUnique({
      where: { userId },
      include: {
        User: {
          include: {
            UserOrganization: true
          }
        }
      }
    });
    if (!googleUser) {
      return res.status(404).json({
        success: false,
        message: "Compte Google Workspace non trouv\xE9 pour cet utilisateur"
      });
    }
    const userOrg = googleUser.User.UserOrganization?.[0];
    if (requestingUser?.role !== "super_admin" && requestingUser?.organizationId !== userOrg?.organizationId) {
      return res.status(403).json({
        success: false,
        message: "Acc\xE8s refus\xE9 \xE0 cet utilisateur"
      });
    }
    const updatedGoogleUser = await prisma8.googleWorkspaceUser.update({
      where: { userId },
      data: {
        isActive: false,
        gmailEnabled: false,
        calendarEnabled: false,
        driveEnabled: false,
        meetEnabled: false,
        lastSync: /* @__PURE__ */ new Date()
      }
    });
    res.json({
      success: true,
      message: "Compte Google Workspace d\xE9sactiv\xE9 avec succ\xE8s",
      data: updatedGoogleUser
    });
  } catch (error) {
    console.error("[GOOGLE-WORKSPACE] Erreur POST deactivate:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la d\xE9sactivation"
    });
  }
});
var googleWorkspace_default = router15;

// src/routes/blocks.ts
var import_express17 = require("express");
var import_uuid2 = require("uuid");

// src/helpers/adaptBlockStructure.ts
var adaptBlockStructure = (block) => {
  return {
    ...block,
    sections: block.Section.map((section) => ({
      ...section,
      fields: section.Field.map((field) => ({
        ...field,
        options: field.FieldOption
        // Renommer FieldOption en options
      }))
    }))
  };
};

// src/routes/blocks.ts
init_prisma();
var router16 = (0, import_express17.Router)();
router16.use(authMiddleware, impersonationMiddleware);
async function ensureSectionTypeColumnExists() {
  try {
    await db.$executeRawUnsafe(
      `ALTER TABLE "Section" ADD COLUMN IF NOT EXISTS "sectionType" TEXT NOT NULL DEFAULT 'normal'`
    );
  } catch (e) {
    console.warn("[API] ensureSectionTypeColumnExists (blocks.ts) - avertissement:", e);
  }
}
router16.get(
  "/",
  // Middleware anti-cache pour forcer le rechargement
  (req2, res, next) => {
    res.set({
      "Cache-Control": "no-cache, no-store, must-revalidate",
      "Pragma": "no-cache",
      "Expires": "0",
      "ETag": false,
      "Last-Modified": false
    });
    if (req2.headers["if-none-match"]) delete req2.headers["if-none-match"];
    if (req2.headers["if-modified-since"]) delete req2.headers["if-modified-since"];
    next();
  },
  requireRole2(["admin", "super_admin"]),
  async (req2, res) => {
    const user = req2.user;
    const organizationId = req2.query.organizationId || req2.headers["x-organization-id"] || user?.organizationId;
    const whereClause = {};
    if (organizationId) {
      whereClause.organizationId = organizationId;
    } else if (user?.isSuperAdmin || user?.role === "super_admin") {
    } else {
      res.json({ success: true, data: [] });
      return;
    }
    try {
      const blocks = await db.block.findMany({
        where: whereClause,
        include: {
          Section: {
            // Utilise le nom de la relation d√©fini dans le sch√©ma Prisma
            orderBy: { order: "asc" },
            include: {
              Field: {
                // Utilise le nom de la relation
                orderBy: { order: "asc" },
                include: {
                  FieldOption: {
                    // Utilise le nom de la relation
                    orderBy: { order: "asc" }
                  }
                }
              }
            }
          }
        }
      });
      const blocksWithAdaptedStructure = blocks.map(adaptBlockStructure);
      res.set({
        "Cache-Control": "no-cache, no-store, must-revalidate",
        "Pragma": "no-cache",
        "Expires": "0"
      });
      res.json({ success: true, data: blocksWithAdaptedStructure });
    } catch (error) {
      console.error("[API] Erreur lors de la r\xE9cup\xE9ration des blocks:", error);
      res.status(500).json({ success: false, message: "Erreur serveur lors de la r\xE9cup\xE9ration des formulaires" });
    }
  }
);
router16.get("/read", async (req2, res) => {
  try {
    const user = req2.user;
    const organizationId = req2.query.organizationId || req2.headers["x-organization-id"] || user?.organizationId;
    if (!organizationId) {
      res.json({ success: true, data: [] });
      return;
    }
    const blocks = await db.block.findMany({
      where: { organizationId },
      include: {
        Section: {
          orderBy: { order: "asc" },
          include: {
            Field: {
              orderBy: { order: "asc" },
              include: { FieldOption: { orderBy: { order: "asc" } } }
            }
          }
        }
      },
      orderBy: { updatedAt: "desc" }
    });
    const adapted = blocks.map(adaptBlockStructure);
    res.json({ success: true, data: adapted });
  } catch (error) {
    console.error("[API] Erreur GET /api/blocks/read:", error);
    res.status(500).json({ success: false, message: "Erreur serveur lors de la r\xE9cup\xE9ration des formulaires (lecture)" });
  }
});
router16.get("/:id/read", async (req2, res) => {
  try {
    const { id } = req2.params;
    const user = req2.user;
    const organizationId = req2.query.organizationId || req2.headers["x-organization-id"] || user?.organizationId;
    if (!organizationId) {
      res.status(404).json({ success: false, message: "Formulaire non trouv\xE9" });
      return;
    }
    const block = await db.block.findFirst({
      where: { id, organizationId },
      include: {
        Section: {
          orderBy: { order: "asc" },
          include: {
            Field: {
              orderBy: { order: "asc" },
              include: { FieldOption: { orderBy: { order: "asc" } } }
            }
          }
        }
      }
    });
    if (!block) {
      res.status(404).json({ success: false, message: "Formulaire non trouv\xE9" });
      return;
    }
    const adapted = adaptBlockStructure(block);
    res.json({ success: true, data: adapted });
  } catch (error) {
    console.error("[API] Erreur GET /api/blocks/:id/read:", error);
    res.status(500).json({ success: false, message: "Erreur serveur lors de la r\xE9cup\xE9ration du formulaire" });
  }
});
router16.post("/", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { name, organizationId } = req2.body;
  if (!name || !organizationId) {
    res.status(400).json({ success: false, message: "Nom et organisation requis." });
    return;
  }
  const block = await db.block.create({ data: { id: (0, import_uuid2.v4)(), name, organizationId, createdAt: /* @__PURE__ */ new Date(), updatedAt: /* @__PURE__ */ new Date() } });
  res.json({ success: true, data: block });
});
router16.put("/:id", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { id } = req2.params;
  const { name } = req2.body;
  const block = await db.block.update({ where: { id }, data: { name, updatedAt: /* @__PURE__ */ new Date() } });
  res.json({ success: true, data: block });
});
router16.delete("/:id", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { id } = req2.params;
  try {
    const sections = await db.section.findMany({ where: { blockId: id } });
    for (const section of sections) {
      await db.field.deleteMany({ where: { sectionId: section.id } });
    }
    await db.section.deleteMany({ where: { blockId: id } });
    await db.block.delete({ where: { id } });
    res.json({ success: true });
  } catch (error) {
    console.error(`[API] Erreur lors de la suppression du block ${id}:`, error);
    res.status(500).json({ success: false, message: "Erreur serveur lors de la suppression du block." });
  }
});
router16.post("/:blockId/sections", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { blockId } = req2.params;
  const { name, order, type } = req2.body;
  try {
    if (!name) {
      res.status(400).json({ success: false, message: "Le nom de la section est requis." });
      return;
    }
    if (typeof type !== "undefined") {
      await ensureSectionTypeColumnExists();
    }
    try {
      await db.section.create({
        data: {
          id: (0, import_uuid2.v4)(),
          name,
          order: order || 0,
          blockId,
          sectionType: type || "normal"
        }
      });
    } catch (err) {
      const msg = String(err?.message || "");
      if (msg.includes("sectionType") && (msg.includes("does not exist") || msg.includes("doesn't exist") || msg.includes("column") || msg.includes("relation"))) {
        await ensureSectionTypeColumnExists();
        await db.section.create({
          data: {
            id: (0, import_uuid2.v4)(),
            name,
            order: order || 0,
            blockId,
            sectionType: type || "normal"
          }
        });
      } else if (msg.includes("Unknown arg") && msg.includes("sectionType")) {
        const created = await db.section.create({
          data: {
            id: (0, import_uuid2.v4)(),
            name,
            order: order || 0,
            blockId
          }
        });
        if (typeof type !== "undefined") {
          await ensureSectionTypeColumnExists();
          await db.$executeRaw`UPDATE "Section" SET "sectionType" = ${type || "normal"} WHERE id = ${created.id}`;
        }
      } else {
        throw err;
      }
    }
    const updatedBlockWithRelations = await db.block.findUnique({
      where: { id: blockId },
      include: {
        Section: {
          // Utilise le nom de la relation d√©fini dans le sch√©ma Prisma
          orderBy: { order: "asc" },
          include: {
            Field: {
              // Utilise le nom de la relation
              orderBy: { order: "asc" },
              include: {
                FieldOption: {
                  // Utilise le nom de la relation
                  orderBy: { order: "asc" }
                }
              }
            }
          }
        }
      }
    });
    if (!updatedBlockWithRelations) {
      res.status(404).json({ success: false, message: "Block non trouv\xE9 apr\xE8s ajout de la section." });
      return;
    }
    const adaptedBlock = adaptBlockStructure(updatedBlockWithRelations);
    res.status(201).json(adaptedBlock);
  } catch (error) {
    console.error("Erreur lors de l'ajout de la section:", error);
    res.status(500).json({ success: false, message: "Erreur serveur lors de l'ajout de la section." });
  }
});
router16.delete("/:blockId/sections/:sectionId", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { blockId, sectionId } = req2.params;
  try {
    await db.field.deleteMany({
      where: { sectionId }
    });
    await db.section.delete({
      where: { id: sectionId }
    });
    const updatedBlockWithRelations = await db.block.findUnique({
      where: { id: blockId },
      include: {
        Section: {
          // Utilise le nom de la relation d√©fini dans le sch√©ma Prisma
          orderBy: { order: "asc" },
          include: {
            Field: {
              // Utilise le nom de la relation
              orderBy: { order: "asc" },
              include: {
                FieldOption: {
                  // Utilise le nom de la relation
                  orderBy: { order: "asc" }
                }
              }
            }
          }
        }
      }
    });
    if (!updatedBlockWithRelations) {
      res.status(404).json({ success: false, message: "Block non trouv\xE9 apr\xE8s suppression de la section." });
      return;
    }
    const adaptedBlock = adaptBlockStructure(updatedBlockWithRelations);
    res.json(adaptedBlock);
  } catch (error) {
    console.error("Erreur lors de la suppression de la section:", error);
    res.status(500).json({ success: false, message: "Erreur serveur lors de la suppression de la section." });
  }
});
router16.put("/:blockId/sections/reorder", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { blockId } = req2.params;
  const { sections } = req2.body;
  console.log(`[API] R\xE9ordonnancement des sections pour le block ${blockId}`, sections);
  if (!sections || !Array.isArray(sections)) {
    res.status(400).json({ success: false, message: "La liste des sections est requise." });
    return;
  }
  try {
    const sectionIds = sections.map((s) => s.id);
    const sectionsInDb = await db.section.findMany({
      where: {
        id: { in: sectionIds },
        blockId
      }
    });
    if (sectionsInDb.length !== sections.length) {
      res.status(400).json({ success: false, message: "Certaines sections n'appartiennent pas au bon formulaire ou n'existent pas." });
      return;
    }
    await db.$transaction(
      sections.map(
        (section) => db.section.update({
          where: {
            id: section.id,
            // On s'assure aussi que la section appartient bien au bloc pour la s√©curit√©
            blockId
          },
          data: { order: section.order }
        })
      )
    );
    const updatedBlockWithRelations = await db.block.findUnique({
      where: { id: blockId },
      include: {
        Section: {
          // Utilise le nom de la relation d√©fini dans le sch√©ma Prisma
          orderBy: { order: "asc" },
          include: {
            Field: {
              // Utilise le nom de la relation
              orderBy: { order: "asc" },
              include: {
                FieldOption: {
                  // Utilise le nom de la relation
                  orderBy: { order: "asc" }
                }
              }
            }
          }
        }
      }
    });
    if (!updatedBlockWithRelations) {
      res.status(404).json({ success: false, message: "Block non trouv\xE9 apr\xE8s le r\xE9ordonnancement des sections." });
      return;
    }
    const adaptedBlock = adaptBlockStructure(updatedBlockWithRelations);
    res.json(adaptedBlock);
  } catch (error) {
    console.error("Erreur lors du r\xE9ordonnancement des sections:", error);
    res.status(500).json({ success: false, message: "Erreur serveur lors du r\xE9ordonnancement des sections." });
  }
});
var blocks_default = router16;

// src/routes/notifications.ts
var import_express18 = require("express");
init_UniversalNotificationService();
init_prisma();
var router17 = (0, import_express18.Router)();
router17.use(authMiddleware);
router17.get("/", async (req2, res) => {
  try {
    const user = req2.user;
    if (!user || !user.userId) {
      res.status(401).json({ success: false, message: "Utilisateur non authentifi\xE9." });
      return;
    }
    const userId = user.userId;
    if (user.role === "super_admin") {
      const notifications2 = await db.notification.findMany({
        where: {
          status: "PENDING"
        },
        orderBy: {
          createdAt: "desc"
        },
        include: {
          Organization: true
          // Include organization details for context
        }
      });
      res.json({ success: true, data: notifications2 });
      return;
    }
    const userOrganizations = await db.userOrganization.findMany({
      where: { userId },
      select: { organizationId: true }
    });
    const orgIds = userOrganizations.map((uo) => uo.organizationId);
    const notifications = await db.notification.findMany({
      where: {
        OR: [
          { organizationId: { in: orgIds } },
          { userId }
        ],
        status: "PENDING"
      },
      orderBy: {
        createdAt: "desc"
      },
      include: {
        Organization: true
        // Include organization details for context
      }
    });
    res.json({ success: true, data: notifications });
  } catch (error) {
    console.error("\xC9chec de la r\xE9cup\xE9ration des notifications:", error);
    res.status(500).json({ success: false, message: "\xC9chec de la r\xE9cup\xE9ration des notifications" });
  }
});
router17.post("/", async (req2, res) => {
  try {
    const user = req2.user;
    if (!user || !user.userId) {
      res.status(401).json({ success: false, message: "Utilisateur non authentifi\xE9." });
      return;
    }
    const userId = user.userId;
    const { type, data, organizationId } = req2.body;
    if (!type || !data) {
      res.status(400).json({ success: false, message: "Type et data sont requis" });
      return;
    }
    let targetOrgId = organizationId;
    if (!targetOrgId) {
      const userOrg = await db.userOrganization.findFirst({
        where: { userId },
        select: { organizationId: true }
      });
      targetOrgId = userOrg?.organizationId;
    }
    const notification = await db.notification.create({
      data: {
        type,
        data,
        userId,
        organizationId: targetOrgId,
        status: "PENDING"
      },
      include: {
        Organization: true
      }
    });
    res.status(201).json({ success: true, data: notification });
  } catch (error) {
    console.error("\xC9chec de la cr\xE9ation de la notification:", error);
    res.status(500).json({ success: false, message: "\xC9chec de la cr\xE9ation de la notification" });
  }
});
router17.patch("/:id/read", async (req2, res) => {
  try {
    const { id: notificationId } = req2.params;
    const user = req2.user;
    if (!user || !user.userId) {
      res.status(401).json({ success: false, message: "Utilisateur non authentifi\xE9." });
      return;
    }
    const userId = user.userId;
    const notification = await db.notification.findUnique({
      where: { id: notificationId }
    });
    if (!notification) {
      res.status(404).json({ success: false, message: "Notification non trouv\xE9e" });
      return;
    }
    const userOrganizations = await db.userOrganization.findMany({
      where: { userId },
      select: { organizationId: true }
    });
    const orgIds = userOrganizations.map((uo) => uo.organizationId);
    const canAccess = notification.userId === userId || notification.organizationId && orgIds.includes(notification.organizationId);
    if (!canAccess) {
      res.status(403).json({ success: false, message: "Interdit: Vous n'avez pas acc\xE8s \xE0 cette notification." });
      return;
    }
    const updatedNotification = await db.notification.update({
      where: { id: notificationId },
      data: { status: "READ" }
    });
    res.json({ success: true, data: updatedNotification });
  } catch (error) {
    console.error("\xC9chec de la mise \xE0 jour de la notification:", error);
    res.status(500).json({ success: false, message: "\xC9chec de la mise \xE0 jour de la notification" });
  }
});
router17.delete("/:id", async (req2, res) => {
  try {
    const { id: notificationId } = req2.params;
    const user = req2.user;
    if (!user || !user.userId) {
      res.status(401).json({ success: false, message: "Utilisateur non authentifi\xE9." });
      return;
    }
    const userId = user.userId;
    const notification = await db.notification.findUnique({
      where: { id: notificationId }
    });
    if (!notification) {
      res.status(404).json({ success: false, message: "Notification non trouv\xE9e" });
      return;
    }
    const userOrganizations = await db.userOrganization.findMany({
      where: { userId },
      select: { organizationId: true }
    });
    const orgIds = userOrganizations.map((uo) => uo.organizationId);
    const canAccess = notification.userId === userId || notification.organizationId && orgIds.includes(notification.organizationId);
    if (!canAccess) {
      res.status(403).json({ success: false, message: "Interdit: Vous n'avez pas acc\xE8s \xE0 cette notification." });
      return;
    }
    await db.notification.delete({
      where: { id: notificationId }
    });
    res.json({ success: true, message: "Notification supprim\xE9e avec succ\xE8s." });
  } catch (error) {
    console.error("\xC9chec de la suppression de la notification:", error);
    res.status(500).json({ success: false, message: "\xC9chec de la suppression de la notification" });
  }
});
router17.post("/check-emails", async (req2, res) => {
  try {
    const user = req2.user;
    if (!user || !user.userId) {
      res.status(401).json({ success: false, message: "Utilisateur non authentifi\xE9." });
      return;
    }
    console.log(`\u{1F514} [API] V\xE9rification manuelle des emails pour l'utilisateur ${user.userId}`);
    try {
      const { autoMailSync: autoMailSync2 } = await Promise.resolve().then(() => (init_AutoMailSyncService(), AutoMailSyncService_exports));
      console.log("\u{1F525} [API] D\xE9clenchement sync manuelle imm\xE9diate...");
      await autoMailSync2.syncForUser(user.userId);
      console.log("\u2705 [API] Synchronisation manuelle termin\xE9e avec succ\xE8s");
    } catch (syncError) {
      console.error("\u274C [API] Erreur sync manuelle:", syncError);
    }
    const notificationService = UniversalNotificationService_default.getInstance();
    console.log("\u{1F31F} [API] V\xE9rification manuelle de TOUS les types d'\xE9v\xE9nements...");
    notificationService.emit("manual-check-requested", { userId: user.userId });
    res.json({
      success: true,
      message: "V\xE9rification des nouveaux emails effectu\xE9e avec succ\xE8s."
    });
  } catch (error) {
    console.error("\xC9chec de la v\xE9rification des emails:", error);
    res.status(500).json({ success: false, message: "\xC9chec de la v\xE9rification des emails" });
  }
});
router17.post("/check-emails-all", async (req2, res) => {
  try {
    const user = req2.user;
    if (!user || !user.userId) {
      res.status(401).json({ success: false, message: "Utilisateur non authentifi\xE9." });
      return;
    }
    if (user.role !== "admin" && user.role !== "super_admin") {
      res.status(403).json({ success: false, message: "Permissions insuffisantes. Admin requis." });
      return;
    }
    console.log(`\u{1F514} [API] V\xE9rification manuelle globale des emails par ${user.role} ${user.userId}`);
    const notificationService = RealTimeEmailNotificationService.getInstance();
    await notificationService.performBackupCheck();
    res.json({
      success: true,
      message: "V\xE9rification des nouveaux emails effectu\xE9e pour tous les utilisateurs."
    });
  } catch (error) {
    console.error("\xC9chec de la v\xE9rification globale des emails:", error);
    res.status(500).json({ success: false, message: "\xC9chec de la v\xE9rification globale des emails" });
  }
});
var notifications_default = router17;

// src/routes/notificationSystemRoutes.ts
var import_express19 = require("express");

// src/services/NotificationSystemService.ts
init_UniversalNotificationService();
init_RealTimeEmailNotificationService();
init_AutoMailSyncService();

// src/services/notificationSystemInit.ts
var notificationSystem = null;
function getNotificationSystemStatus() {
  if (!notificationSystem) {
    return { status: "not_initialized" };
  }
  return notificationSystem.getStatus();
}
function getNotificationSystemInstance() {
  return notificationSystem;
}

// src/routes/notificationSystemRoutes.ts
init_UniversalNotificationService();
var router18 = (0, import_express19.Router)();
router18.use(authMiddleware);
router18.get("/status", async (req2, res) => {
  try {
    const status = getNotificationSystemStatus();
    res.json({
      success: true,
      data: status,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("\u274C [NotificationSystemAPI] Erreur statut:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration du statut"
    });
  }
});
router18.post("/test-email", requireRole(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { userId, organizationId } = req2.user;
    const universalService = UniversalNotificationService_default.getInstance();
    await universalService.notifyNewEmail({
      emailId: "test-" + Date.now(),
      from: "system@2thier.be",
      subject: "Test de notification - " + (/* @__PURE__ */ new Date()).toLocaleTimeString("fr-FR"),
      userId,
      organizationId
    });
    res.json({
      success: true,
      message: "Notification email de test cr\xE9\xE9e avec succ\xE8s"
    });
  } catch (error) {
    console.error("\u274C [NotificationSystemAPI] Erreur test email:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la cr\xE9ation de la notification test"
    });
  }
});
router18.post("/test-lead", requireRole(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { userId, organizationId } = req2.user;
    const universalService = UniversalNotificationService_default.getInstance();
    await universalService.notifyNewLead({
      leadId: "test-lead-" + Date.now(),
      name: "Lead de Test",
      email: "test@example.com",
      phone: "+32 123 456 789",
      source: "Test API",
      userId,
      organizationId
    });
    res.json({
      success: true,
      message: "Notification lead de test cr\xE9\xE9e avec succ\xE8s"
    });
  } catch (error) {
    console.error("\u274C [NotificationSystemAPI] Erreur test lead:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la cr\xE9ation de la notification test"
    });
  }
});
router18.post("/test-call", requireRole(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { userId, organizationId } = req2.user;
    const universalService = UniversalNotificationService_default.getInstance();
    await universalService.notifyMissedCall({
      from: "+32 123 456 789",
      duration: 0,
      userId,
      organizationId
    });
    res.json({
      success: true,
      message: "Notification appel manqu\xE9 de test cr\xE9\xE9e avec succ\xE8s"
    });
  } catch (error) {
    console.error("\u274C [NotificationSystemAPI] Erreur test appel:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la cr\xE9ation de la notification test"
    });
  }
});
router18.get("/stats/:organizationId", requireRole(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { organizationId } = req2.params;
    const universalService = UniversalNotificationService_default.getInstance();
    const stats = await universalService.getStats(organizationId);
    res.json({
      success: true,
      data: stats,
      organizationId
    });
  } catch (error) {
    console.error("\u274C [NotificationSystemAPI] Erreur stats:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration des statistiques"
    });
  }
});
router18.post("/restart", requireRole(["super_admin"]), async (req2, res) => {
  try {
    console.log(`\u{1F504} [NotificationSystemAPI] Red\xE9marrage demand\xE9 par ${req2.user?.email}`);
    const system = getNotificationSystemInstance();
    if (system) {
      await system.stop();
      await system.start();
    }
    res.json({
      success: true,
      message: "Syst\xE8me de notifications red\xE9marr\xE9 avec succ\xE8s"
    });
  } catch (error) {
    console.error("\u274C [NotificationSystemAPI] Erreur red\xE9marrage:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors du red\xE9marrage du syst\xE8me"
    });
  }
});
var notificationSystemRoutes_default = router18;

// src/routes/settingsRoutes.ts
var import_express20 = require("express");
init_prisma();
var router19 = (0, import_express20.Router)();
router19.use(authMiddleware);
router19.get("/lead-statuses", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    console.log("[LEAD-STATUSES] R\xE9cup\xE9ration des statuts pour l'organisation:", organizationId);
    const statuses = await db.leadStatus.findMany({
      where: {
        organizationId
      },
      orderBy: {
        order: "asc"
      }
    });
    console.log(`[LEAD-STATUSES] ${statuses.length} statuts trouv\xE9s`);
    res.json(statuses);
  } catch (error) {
    console.error("[LEAD-STATUSES] Erreur lors de la r\xE9cup\xE9ration des statuts:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration des statuts",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.post("/lead-statuses", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const { name, color, order, isDefault } = req2.body;
    if (isDefault) {
      await db.leadStatus.updateMany({
        where: {
          organizationId,
          isDefault: true
        },
        data: {
          isDefault: false
        }
      });
    }
    const newStatus = await db.leadStatus.create({
      data: {
        name,
        color,
        order: order || 0,
        isDefault: isDefault || false,
        organizationId
      }
    });
    console.log("[LEAD-STATUSES] Nouveau statut cr\xE9\xE9:", newStatus.name);
    res.status(201).json(newStatus);
  } catch (error) {
    console.error("[LEAD-STATUSES] Erreur lors de la cr\xE9ation du statut:", error);
    res.status(500).json({
      error: "Erreur lors de la cr\xE9ation du statut",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.put("/lead-statuses/reorder", async (req2, res) => {
  console.log("\u{1F6A8} [DEBUG] LEAD-STATUSES REORDER - ROUTE APPEL\xC9E !");
  console.log("\u{1F6A8} [DEBUG] Body received:", req2.body);
  console.log("\u{1F6A8} [DEBUG] Headers:", req2.headers);
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      console.log("\u{1F6A8} [DEBUG] PAS D'ORG ID");
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const { statuses } = req2.body;
    if (!Array.isArray(statuses)) {
      console.log("\u{1F6A8} [DEBUG] PAS UN ARRAY:", typeof statuses, statuses);
      return res.status(400).json({
        error: "Array de statuts requis"
      });
    }
    console.log("[LEAD-STATUSES] \u{1F4E5} DONN\xC9ES RE\xC7UES:", JSON.stringify(statuses, null, 2));
    console.log("[LEAD-STATUSES] \u{1F4CA} R\xE9organisation de", statuses.length, "statuts pour org:", organizationId);
    for (const status of statuses) {
      if (!status.id || status.order === void 0) {
        console.error("[LEAD-STATUSES] \u274C Statut invalide:", status);
        return res.status(400).json({
          error: `Statut invalide: ${JSON.stringify(status)}`
        });
      }
    }
    const updatePromises = statuses.map(async (status) => {
      console.log(`[LEAD-STATUSES] \u{1F504} Mise \xE0 jour ${status.id} -> order: ${status.order}`);
      const result = await db.leadStatus.updateMany({
        where: { id: status.id, organizationId },
        data: { order: status.order }
      });
      console.log(`[LEAD-STATUSES] \u2705 R\xE9sultat pour ${status.id}: ${result.count} ligne(s) modifi\xE9e(s)`);
      return result;
    });
    const results = await Promise.all(updatePromises);
    console.log("[LEAD-STATUSES] \u{1F4CB} R\xE9sultats globaux:", results.map((r) => r.count));
    res.json({
      success: true,
      message: "Ordre mis \xE0 jour avec succ\xE8s"
    });
  } catch (error) {
    console.error("[LEAD-STATUSES] Erreur lors de la r\xE9organisation:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9organisation"
    });
  }
});
router19.put("/lead-statuses/:id", (req2, res) => {
  console.log("[ROUTE] PUT /api/settings/lead-statuses/:id atteint", req2.params.id);
  res.status(200).json({ id: req2.params.id, ...req2.body });
});
router19.delete("/lead-statuses/:id", (req2, res) => {
  console.log("[ROUTE] DELETE /api/settings/lead-statuses/:id atteint", req2.params.id);
  res.status(204).send();
});
router19.get("/call-statuses", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    console.log("[CALL-STATUSES] R\xE9cup\xE9ration des statuts pour l'organisation:", organizationId);
    const callStatuses = await db.callStatus.findMany({
      where: {
        organizationId
      },
      orderBy: {
        order: "asc"
      }
    });
    if (callStatuses.length === 0) {
      console.log("[CALL-STATUSES] Aucun statut trouv\xE9");
    }
    console.log(`[CALL-STATUSES] ${callStatuses.length} statuts trouv\xE9s`);
    res.json(callStatuses);
  } catch (error) {
    console.error("[CALL-STATUSES] Erreur lors de la r\xE9cup\xE9ration des statuts:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration des statuts d'appel",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.post("/call-statuses", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const statuses = req2.body;
    if (!Array.isArray(statuses)) {
      return res.status(400).json({
        error: "Le corps de la requ\xEAte doit \xEAtre un tableau de statuts"
      });
    }
    console.log(`[CALL-STATUSES] Sauvegarde en lot de ${statuses.length} statuts`);
    await db.callStatus.deleteMany({
      where: {
        organizationId
      }
    });
    const savedStatuses = [];
    for (let i = 0; i < statuses.length; i++) {
      const status = statuses[i];
      const savedStatus = await db.callStatus.create({
        data: {
          name: status.name,
          color: status.color,
          order: i,
          organizationId
        }
      });
      savedStatuses.push(savedStatus);
    }
    console.log(`[CALL-STATUSES] ${savedStatuses.length} statuts sauvegard\xE9s`);
    res.json(savedStatuses);
  } catch (error) {
    console.error("[CALL-STATUSES] Erreur lors de la sauvegarde des statuts:", error);
    res.status(500).json({
      error: "Erreur lors de la sauvegarde des statuts d'appel",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.post("/call-statuses/reorder", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const { statusIds } = req2.body;
    if (!Array.isArray(statusIds)) {
      return res.status(400).json({
        error: "statusIds doit \xEAtre un tableau"
      });
    }
    console.log(`[CALL-STATUSES] R\xE9organisation de ${statusIds.length} statuts`);
    for (let i = 0; i < statusIds.length; i++) {
      await db.callStatus.update({
        where: {
          id: statusIds[i],
          organizationId
        },
        data: {
          order: i
        }
      });
    }
    const updatedStatuses = await db.callStatus.findMany({
      where: {
        organizationId
      },
      orderBy: {
        order: "asc"
      }
    });
    console.log(`[CALL-STATUSES] R\xE9organisation termin\xE9e`);
    res.json(updatedStatuses);
  } catch (error) {
    console.error("[CALL-STATUSES] Erreur lors de la r\xE9organisation:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9organisation des statuts d'appel",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.put("/call-statuses/reorder", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const { statuses } = req2.body;
    if (!Array.isArray(statuses)) {
      return res.status(400).json({
        error: "Array de statuts requis"
      });
    }
    console.log(`[CALL-STATUSES] PUT R\xE9organisation de ${statuses.length} statuts`);
    const updatePromises = statuses.map(
      (status) => db.callStatus.update({
        where: { id: status.id },
        data: { order: status.order }
      })
    );
    await Promise.all(updatePromises);
    console.log(`[CALL-STATUSES] PUT R\xE9organisation termin\xE9e`);
    res.json({
      success: true,
      message: "Ordre mis \xE0 jour avec succ\xE8s"
    });
  } catch (error) {
    console.error("[CALL-STATUSES] PUT Erreur lors de la r\xE9organisation:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9organisation des statuts d'appel",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.post("/call-statuses/add", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const { name, color } = req2.body;
    if (!name || !color) {
      return res.status(400).json({
        error: "Le nom et la couleur sont requis"
      });
    }
    const maxOrder = await db.callStatus.aggregate({
      where: {
        organizationId
      },
      _max: {
        order: true
      }
    });
    const nextOrder = (maxOrder._max.order || 0) + 1;
    const newStatus = await db.callStatus.create({
      data: {
        name,
        color,
        order: nextOrder,
        organizationId
      }
    });
    console.log(`[CALL-STATUSES] Nouveau statut cr\xE9\xE9: ${newStatus.name}`);
    res.status(201).json(newStatus);
  } catch (error) {
    console.error("[CALL-STATUSES] Erreur lors de la cr\xE9ation du statut:", error);
    res.status(500).json({
      error: "Erreur lors de la cr\xE9ation du statut d'appel",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.put("/call-statuses/:id", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const { id } = req2.params;
    const { name, color } = req2.body;
    console.log(`[CALL-STATUSES] Mise \xE0 jour du statut ${id}`);
    const updatedStatus = await db.callStatus.update({
      where: {
        id,
        organizationId
      },
      data: {
        name,
        color
      }
    });
    console.log(`[CALL-STATUSES] Statut mis \xE0 jour: ${updatedStatus.name}`);
    res.json(updatedStatus);
  } catch (error) {
    console.error("[CALL-STATUSES] Erreur lors de la mise \xE0 jour du statut:", error);
    res.status(500).json({
      error: "Erreur lors de la mise \xE0 jour du statut d'appel",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.delete("/call-statuses/:id", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const { id } = req2.params;
    console.log(`[CALL-STATUSES] Suppression du statut ${id}`);
    await db.callStatus.delete({
      where: {
        id,
        organizationId
      }
    });
    console.log(`[CALL-STATUSES] Statut supprim\xE9`);
    res.status(204).send();
  } catch (error) {
    console.error("[CALL-STATUSES] Erreur lors de la suppression du statut:", error);
    res.status(500).json({
      error: "Erreur lors de la suppression du statut d'appel",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.get("/call-to-lead-mappings", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    console.log("[MAPPINGS] R\xE9cup\xE9ration des mappings pour l'organisation:", organizationId);
    const mappings = await db.callToLeadMapping.findMany({
      where: {
        organizationId,
        isActive: true
      },
      include: {
        CallStatus: true,
        LeadStatus: true
      },
      orderBy: {
        priority: "asc"
      }
    });
    console.log(`[MAPPINGS] ${mappings.length} mappings trouv\xE9s`);
    res.json(mappings);
  } catch (error) {
    console.error("[MAPPINGS] Erreur lors de la r\xE9cup\xE9ration des mappings:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration des mappings",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.post("/call-to-lead-mappings", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const { callStatusId, leadStatusId, condition, priority } = req2.body;
    if (!callStatusId || !leadStatusId) {
      return res.status(400).json({
        error: "callStatusId et leadStatusId sont requis"
      });
    }
    console.log(`[MAPPINGS] Cr\xE9ation d'un mapping: ${callStatusId} -> ${leadStatusId}`);
    const mapping = await db.callToLeadMapping.create({
      data: {
        organizationId,
        callStatusId,
        leadStatusId,
        condition: condition || null,
        priority: priority || 0
      },
      include: {
        CallStatus: true,
        LeadStatus: true
      }
    });
    console.log(`[MAPPINGS] Mapping cr\xE9\xE9: ${mapping.id}`);
    res.status(201).json(mapping);
  } catch (error) {
    console.error("[MAPPINGS] Erreur lors de la cr\xE9ation du mapping:", error);
    res.status(500).json({
      error: "Erreur lors de la cr\xE9ation du mapping",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.put("/call-to-lead-mappings/:id", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const { id } = req2.params;
    const { callStatusId, leadStatusId, condition, priority, isActive } = req2.body;
    console.log(`[MAPPINGS] Mise \xE0 jour du mapping ${id}`);
    const mapping = await db.callToLeadMapping.update({
      where: {
        id,
        organizationId
      },
      data: {
        callStatusId,
        leadStatusId,
        condition,
        priority,
        isActive
      },
      include: {
        CallStatus: true,
        LeadStatus: true
      }
    });
    console.log(`[MAPPINGS] Mapping mis \xE0 jour: ${mapping.id}`);
    res.json(mapping);
  } catch (error) {
    console.error("[MAPPINGS] Erreur lors de la mise \xE0 jour du mapping:", error);
    res.status(500).json({
      error: "Erreur lors de la mise \xE0 jour du mapping",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.delete("/call-to-lead-mappings/:id", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const { id } = req2.params;
    console.log(`[MAPPINGS] Suppression du mapping ${id}`);
    await db.callToLeadMapping.delete({
      where: {
        id,
        organizationId
      }
    });
    console.log(`[MAPPINGS] Mapping supprim\xE9`);
    res.status(204).send();
  } catch (error) {
    console.error("[MAPPINGS] Erreur lors de la suppression du mapping:", error);
    res.status(500).json({
      error: "Erreur lors de la suppression du mapping",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.post("/call-to-lead-mappings/bulk", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const { mappings } = req2.body;
    if (!Array.isArray(mappings)) {
      return res.status(400).json({
        error: "mappings doit \xEAtre un tableau"
      });
    }
    console.log(`[MAPPINGS] Sauvegarde en lot de ${mappings.length} mappings`);
    await db.callToLeadMapping.deleteMany({
      where: {
        organizationId
      }
    });
    const savedMappings = [];
    for (let i = 0; i < mappings.length; i++) {
      const mapping = mappings[i];
      const savedMapping = await db.callToLeadMapping.create({
        data: {
          organizationId,
          callStatusId: mapping.callStatusId,
          leadStatusId: mapping.leadStatusId,
          condition: mapping.condition || null,
          priority: i,
          isActive: mapping.isActive !== false
        },
        include: {
          CallStatus: true,
          LeadStatus: true
        }
      });
      savedMappings.push(savedMapping);
    }
    console.log(`[MAPPINGS] ${savedMappings.length} mappings sauvegard\xE9s`);
    res.json(savedMappings);
  } catch (error) {
    console.error("[MAPPINGS] Erreur lors de la sauvegarde des mappings:", error);
    res.status(500).json({
      error: "Erreur lors de la sauvegarde des mappings",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.get("/call-lead-mappings", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    console.log("[MAPPINGS] R\xE9cup\xE9ration des mappings pour l'organisation:", organizationId);
    const mappings = await db.callToLeadMapping.findMany({
      where: {
        organizationId
      },
      include: {
        CallStatus: true,
        LeadStatus: true
      },
      orderBy: {
        priority: "asc"
      }
    });
    console.log(`[MAPPINGS] ${mappings.length} mappings trouv\xE9s`);
    res.json(mappings);
  } catch (error) {
    console.error("[MAPPINGS] Erreur lors de la r\xE9cup\xE9ration des mappings:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration des mappings",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.get("/call-lead-mappings", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    console.log("[MAPPINGS] R\xE9cup\xE9ration des mappings pour l'organisation:", organizationId);
    const mappings = await db.callToLeadMapping.findMany({
      where: {
        organizationId
      },
      include: {
        CallStatus: true,
        LeadStatus: true
      },
      orderBy: {
        priority: "asc"
      }
    });
    console.log(`[MAPPINGS] ${mappings.length} mappings trouv\xE9s`);
    res.json(mappings);
  } catch (error) {
    console.error("[MAPPINGS] Erreur lors de la r\xE9cup\xE9ration des mappings:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration des mappings",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.get("/email-templates", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const templates = await db.emailTemplate.findMany({
      where: { organizationId }
    });
    res.json(templates);
  } catch (error) {
    console.error("[TEMPLATES] Erreur lors de la r\xE9cup\xE9ration des mod\xE8les:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration des mod\xE8les",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.get("/lead-sources", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const sources = await db.leadSource.findMany({
      where: { organizationId }
    });
    res.json(sources);
  } catch (error) {
    console.error("[SOURCES] Erreur lors de la r\xE9cup\xE9ration des sources:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration des sources",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.post("/call-lead-mappings", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const { callStatusId, leadStatusId, priority, description } = req2.body;
    console.log("[MAPPINGS] Cr\xE9ation d'un nouveau mapping:", {
      callStatusId,
      leadStatusId,
      organizationId,
      priority
    });
    const newMapping = await db.callToLeadMapping.create({
      data: {
        callStatusId,
        leadStatusId,
        organizationId,
        priority: priority || 1,
        description: description || null
      },
      include: {
        CallStatus: true,
        LeadStatus: true
      }
    });
    console.log("[MAPPINGS] Nouveau mapping cr\xE9\xE9:", newMapping.id);
    res.status(201).json(newMapping);
  } catch (error) {
    console.error("[MAPPINGS] Erreur lors de la cr\xE9ation du mapping:", error);
    res.status(500).json({
      error: "Erreur lors de la cr\xE9ation du mapping",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.put("/call-lead-mappings/:id", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    const mappingId = req2.params.id;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const { callStatusId, leadStatusId, priority, description } = req2.body;
    console.log("[MAPPINGS] Mise \xE0 jour du mapping:", mappingId);
    const updatedMapping = await db.callToLeadMapping.update({
      where: {
        id: mappingId,
        organizationId
      },
      data: {
        callStatusId,
        leadStatusId,
        priority,
        description
      },
      include: {
        CallStatus: true,
        LeadStatus: true
      }
    });
    console.log("[MAPPINGS] Mapping mis \xE0 jour:", updatedMapping.id);
    res.json(updatedMapping);
  } catch (error) {
    console.error("[MAPPINGS] Erreur lors de la mise \xE0 jour du mapping:", error);
    res.status(500).json({
      error: "Erreur lors de la mise \xE0 jour du mapping",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.delete("/call-lead-mappings/:id", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    const mappingId = req2.params.id;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    console.log("[MAPPINGS] Suppression du mapping:", mappingId);
    await db.callToLeadMapping.delete({
      where: {
        id: mappingId,
        organizationId
      }
    });
    console.log("[MAPPINGS] Mapping supprim\xE9:", mappingId);
    res.status(204).send();
  } catch (error) {
    console.error("[MAPPINGS] Erreur lors de la suppression du mapping:", error);
    res.status(500).json({
      error: "Erreur lors de la suppression du mapping",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.post("/call-lead-mappings", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const { callStatusId, leadStatusId, priority } = req2.body;
    if (!callStatusId || !leadStatusId) {
      return res.status(400).json({
        error: "callStatusId et leadStatusId sont requis"
      });
    }
    console.log("[MAPPING] Cr\xE9ation d'un nouveau mapping:", { callStatusId, leadStatusId, priority });
    const existingMapping = await db.callToLeadMapping.findFirst({
      where: {
        callStatusId,
        organizationId
      }
    });
    if (existingMapping) {
      const updatedMapping = await db.callToLeadMapping.update({
        where: { id: existingMapping.id },
        data: {
          leadStatusId,
          priority: priority || existingMapping.priority
        },
        include: {
          CallStatus: true,
          LeadStatus: true
        }
      });
      console.log("[MAPPING] Mapping mis \xE0 jour:", updatedMapping.id);
      return res.json(updatedMapping);
    } else {
      const newMapping = await db.callToLeadMapping.create({
        data: {
          callStatusId,
          leadStatusId,
          organizationId,
          priority: priority || 1
        },
        include: {
          CallStatus: true,
          LeadStatus: true
        }
      });
      console.log("[MAPPING] Nouveau mapping cr\xE9\xE9:", newMapping.id);
      return res.json(newMapping);
    }
  } catch (error) {
    console.error("[MAPPING] Erreur lors de la cr\xE9ation du mapping:", error);
    res.status(500).json({
      error: "Erreur lors de la cr\xE9ation du mapping",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.put("/call-lead-mappings/:id", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    const mappingId = req2.params.id;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const { callStatusId, leadStatusId, priority } = req2.body;
    console.log("[MAPPING] Modification du mapping:", mappingId, { callStatusId, leadStatusId, priority });
    const updatedMapping = await db.callToLeadMapping.update({
      where: {
        id: mappingId,
        organizationId
      },
      data: {
        ...callStatusId && { callStatusId },
        ...leadStatusId && { leadStatusId },
        ...priority !== void 0 && { priority }
      },
      include: {
        CallStatus: true,
        LeadStatus: true
      }
    });
    console.log("[MAPPING] Mapping mis \xE0 jour:", updatedMapping.id);
    res.json(updatedMapping);
  } catch (error) {
    console.error("[MAPPING] Erreur lors de la modification du mapping:", error);
    res.status(500).json({
      error: "Erreur lors de la modification du mapping",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.delete("/call-lead-mappings/:id", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    const mappingId = req2.params.id;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    console.log("[MAPPING] Suppression du mapping:", mappingId);
    await db.callToLeadMapping.delete({
      where: {
        id: mappingId,
        organizationId
      }
    });
    console.log("[MAPPING] Mapping supprim\xE9:", mappingId);
    res.json({ success: true, message: "Mapping supprim\xE9 avec succ\xE8s" });
  } catch (error) {
    console.error("[MAPPING] Erreur lors de la suppression du mapping:", error);
    res.status(500).json({
      error: "Erreur lors de la suppression du mapping",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.post("/initialize-default-statuses", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    console.log("\u{1F680} [INIT] Initialisation des statuts par d\xE9faut pour l'organisation:", organizationId);
    const defaultCallStatuses = [
      { name: "\u{1F4DE} Pas de r\xE9ponse", description: "Le client n'a pas d\xE9croch\xE9", color: "#f39c12", icon: "\u{1F4DE}", order: 1 },
      { name: "\u{1F4DE} Num\xE9ro incorrect / injoignable", description: "Num\xE9ro invalide ou injoignable", color: "#e74c3c", icon: "\u{1F4DE}", order: 2 },
      { name: "\u{1F4DE} Rappel programm\xE9", description: "Rappel planifi\xE9 avec le client", color: "#3498db", icon: "\u{1F4DE}", order: 3 },
      { name: "\u{1F4DE} Contact\xE9 \u2013 Pas int\xE9ress\xE9", description: "Client contact\xE9 mais pas int\xE9ress\xE9", color: "#e67e22", icon: "\u{1F4DE}", order: 4 },
      { name: "\u{1F4DE} Contact\xE9 \u2013 Non qualifi\xE9", description: "Lead ne correspond pas \xE0 nos crit\xE8res", color: "#95a5a6", icon: "\u26A0\uFE0F", order: 5 },
      { name: "\u{1F4DE} Contact\xE9 \u2013 \xC0 rappeler plus tard", description: "Client demande \xE0 \xEAtre rappel\xE9 plus tard", color: "#f1c40f", icon: "\u{1F4DE}", order: 6 },
      { name: "\u{1F4DE} Contact\xE9 \u2013 Information envoy\xE9e (mail/sms)", description: "Informations envoy\xE9es au client", color: "#9b59b6", icon: "\u{1F4DE}", order: 7 },
      { name: "\u{1F4DE} Contact\xE9 \u2013 Rendez-vous fix\xE9", description: "RDV fix\xE9 avec le client", color: "#2ecc71", icon: "\u{1F4DE}", order: 8 },
      { name: "\u{1F4DE} Contact\xE9 \u2013 Refus (non direct \xE0 l'appel)", description: "Refus lors de l'appel", color: "#c0392b", icon: "\u{1F4DE}", order: 9 },
      { name: "\u{1F4DE} Contact\xE9 \u2013 Refus ferme (apr\xE8s devis/visite)", description: "Refus d\xE9finitif apr\xE8s devis/visite", color: "#8e44ad", icon: "\u{1F4DE}", order: 10 },
      { name: "\u{1F4DE} Contact\xE9 \u2013 Refus d\xE9finitif", description: "Refus d\xE9finitif du prospect", color: "#a93226", icon: "\u274C", order: 11 },
      { name: "\u{1F4DE} Contact\xE9 \u2013 Devis demand\xE9", description: "Client demande un devis", color: "#16a085", icon: "\u{1F4DE}", order: 12 },
      { name: "\u{1F4DE} Contact\xE9 \u2013 Devis envoy\xE9", description: "Devis envoy\xE9 au client", color: "#27ae60", icon: "\u{1F4DE}", order: 13 },
      { name: "\u{1F4DE} Contact\xE9 \u2013 En n\xE9gociation", description: "N\xE9gociation en cours", color: "#f39c12", icon: "\u{1F4DE}", order: 14 },
      { name: "\u{1F4DE} Contact\xE9 \u2013 Gagn\xE9 (vente conclue)", description: "Vente finalis\xE9e", color: "#2ecc71", icon: "\u{1F4DE}", order: 15 }
    ];
    const defaultLeadStatuses = [
      { name: "\u{1F7E2} Nouveau lead", description: "Lead nouvellement cr\xE9\xE9", color: "#2ecc71", order: 1 },
      { name: "\u{1F7E1} Contacter (d\xE8s le 1er appel tent\xE9)", description: "\xC0 contacter d\xE8s le premier appel", color: "#f1c40f", order: 2 },
      { name: "\u{1F7E1} En attente de rappel (si convenu avec le client)", description: "Rappel convenu avec le client", color: "#f39c12", order: 3 },
      { name: "\u{1F7E1} Information envoy\xE9e", description: "Informations envoy\xE9es au client", color: "#f1c40f", order: 4 },
      { name: "\u{1F7E0} Devis en pr\xE9paration", description: "Devis en cours de pr\xE9paration", color: "#e67e22", order: 5 },
      { name: "\u{1F7E0} Devis envoy\xE9", description: "Devis envoy\xE9 au client", color: "#d35400", order: 6 },
      { name: "\u{1F7E0} En n\xE9gociation", description: "N\xE9gociation en cours", color: "#e74c3c", order: 7 },
      { name: "\u{1F3AF} Cibl\xE9 (objectif client)", description: "Client cibl\xE9 comme objectif", color: "#9b59b6", order: 8 },
      { name: "\u{1F7E3} Non trait\xE9 dans le d\xE9lai (auto)", description: "Non trait\xE9 automatiquement", color: "#8e44ad", order: 9 },
      { name: "\u26A0\uFE0F Non qualifi\xE9", description: "Lead ne correspond pas aux crit\xE8res", color: "#95a5a6", order: 10 },
      { name: "\u{1F534} Perdu (apr\xE8s visite/devis non sign\xE9, ou auto via SLA)", description: "Lead perdu", color: "#c0392b", order: 11 },
      { name: "\u274C Refus\xE9 (non direct / pas int\xE9ress\xE9)", description: "Refus direct", color: "#e74c3c", order: 12 },
      { name: "\u{1F7E2} Gagn\xE9", description: "Lead gagn\xE9", color: "#27ae60", order: 13 },
      { name: "\u26AB Injoignable / Archiv\xE9", description: "Lead injoignable ou archiv\xE9", color: "#34495e", order: 14 }
    ];
    for (const status of defaultCallStatuses) {
      try {
        await db.callStatus.upsert({
          where: {
            organizationId_name: {
              organizationId,
              name: status.name
            }
          },
          update: {},
          // Ne pas modifier si existe d√©j√†
          create: {
            ...status,
            organizationId,
            isActive: true,
            isDefault: false
          }
        });
        console.log(`\u2705 [INIT] Statut d'appel cr\xE9\xE9: ${status.name}`);
      } catch {
        console.log(`\u26A0\uFE0F [INIT] Statut d'appel existe d\xE9j\xE0: ${status.name}`);
      }
    }
    for (const status of defaultLeadStatuses) {
      try {
        await db.leadStatus.upsert({
          where: {
            organizationId_name: {
              organizationId,
              name: status.name
            }
          },
          update: {},
          // Ne pas modifier si existe d√©j√†
          create: {
            ...status,
            organizationId,
            isDefault: false
          }
        });
        console.log(`\u2705 [INIT] Statut de lead cr\xE9\xE9: ${status.name}`);
      } catch {
        console.log(`\u26A0\uFE0F [INIT] Statut de lead existe d\xE9j\xE0: ${status.name}`);
      }
    }
    const mappings = [
      { callStatusName: "\u{1F4DE} Pas de r\xE9ponse", leadStatusName: "\u{1F7E1} Contacter (d\xE8s le 1er appel tent\xE9)" },
      { callStatusName: "\u{1F4DE} Num\xE9ro incorrect / injoignable", leadStatusName: "\u26AB Injoignable / Archiv\xE9" },
      { callStatusName: "\u{1F4DE} Rappel programm\xE9", leadStatusName: "\u{1F7E1} En attente de rappel (si convenu avec le client)" },
      { callStatusName: "\u{1F4DE} Contact\xE9 \u2013 Pas int\xE9ress\xE9", leadStatusName: "\u274C Refus\xE9 (non direct / pas int\xE9ress\xE9)" },
      { callStatusName: "\u{1F4DE} Contact\xE9 \u2013 Non qualifi\xE9", leadStatusName: "\u26A0\uFE0F Non qualifi\xE9" },
      { callStatusName: "\u{1F4DE} Contact\xE9 \u2013 Refus (non direct \xE0 l'appel)", leadStatusName: "\u274C Refus\xE9 (non direct / pas int\xE9ress\xE9)" },
      { callStatusName: "\u{1F4DE} Contact\xE9 \u2013 Refus ferme (apr\xE8s devis/visite)", leadStatusName: "\u{1F534} Perdu (apr\xE8s visite/devis non sign\xE9, ou auto via SLA)" },
      { callStatusName: "\u{1F4DE} Contact\xE9 \u2013 Refus d\xE9finitif", leadStatusName: "\u274C Refus\xE9 (non direct / pas int\xE9ress\xE9)" },
      { callStatusName: "\u{1F4DE} Contact\xE9 \u2013 \xC0 rappeler plus tard", leadStatusName: "\u{1F7E1} En attente de rappel (si convenu avec le client)" },
      { callStatusName: "\u{1F4DE} Contact\xE9 \u2013 Information envoy\xE9e (mail/sms)", leadStatusName: "\u{1F7E1} Information envoy\xE9e" },
      { callStatusName: "\u{1F4DE} Contact\xE9 \u2013 Rendez-vous fix\xE9", leadStatusName: "\u{1F3AF} Cibl\xE9 (objectif client)" },
      { callStatusName: "\u{1F4DE} Contact\xE9 \u2013 Devis demand\xE9", leadStatusName: "\u{1F7E0} Devis en pr\xE9paration" },
      { callStatusName: "\u{1F4DE} Contact\xE9 \u2013 Devis envoy\xE9", leadStatusName: "\u{1F7E0} Devis envoy\xE9" },
      { callStatusName: "\u{1F4DE} Contact\xE9 \u2013 En n\xE9gociation", leadStatusName: "\u{1F7E0} En n\xE9gociation" },
      { callStatusName: "\u{1F4DE} Contact\xE9 \u2013 Gagn\xE9 (vente conclue)", leadStatusName: "\u{1F7E2} Gagn\xE9" }
    ];
    const callStatuses = await db.callStatus.findMany({ where: { organizationId } });
    const leadStatuses = await db.leadStatus.findMany({ where: { organizationId } });
    for (const mapping of mappings) {
      const callStatus = callStatuses.find((cs) => cs.name === mapping.callStatusName);
      const leadStatus = leadStatuses.find((ls) => ls.name === mapping.leadStatusName);
      if (callStatus && leadStatus) {
        try {
          await db.callToLeadMapping.upsert({
            where: {
              organizationId_callStatusId_leadStatusId: {
                organizationId,
                callStatusId: callStatus.id,
                leadStatusId: leadStatus.id
              }
            },
            update: {},
            create: {
              organizationId,
              callStatusId: callStatus.id,
              leadStatusId: leadStatus.id,
              condition: "automatic",
              priority: 1,
              description: `Mapping automatique: ${mapping.callStatusName} \u2192 ${mapping.leadStatusName}`,
              isActive: true
            }
          });
          console.log(`\u2705 [INIT] Mapping cr\xE9\xE9: ${mapping.callStatusName} \u2192 ${mapping.leadStatusName}`);
        } catch {
          console.log(`\u26A0\uFE0F [INIT] Mapping existe d\xE9j\xE0: ${mapping.callStatusName} \u2192 ${mapping.leadStatusName}`);
        }
      }
    }
    console.log("\u{1F389} [INIT] Initialisation termin\xE9e avec succ\xE8s !");
    res.json({
      success: true,
      message: "Statuts par d\xE9faut initialis\xE9s avec succ\xE8s !",
      details: {
        callStatuses: defaultCallStatuses.length,
        leadStatuses: defaultLeadStatuses.length,
        mappings: mappings.length
      }
    });
  } catch (error) {
    console.error("\u274C [INIT] Erreur lors de l'initialisation des statuts:", error);
    res.status(500).json({
      error: "Erreur lors de l'initialisation des statuts",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.get("/ai-measure", async (req2, res) => {
  try {
    return res.json({
      success: true,
      data: {
        markerWidthCm: 13,
        markerHeightCm: 20.5,
        boardSizeCm: 29.7
      }
    });
  } catch (error) {
    console.error("[AI-MEASURE] Erreur r\xE9cup\xE9ration config:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la r\xE9cup\xE9ration de la configuration",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router19.post("/ai-measure", async (req2, res) => {
  try {
    return res.status(400).json({
      success: false,
      error: "Configuration d\xE9sactiv\xE9e: M\xE9tr\xE9 A4 V10 est fixe (13\xD720.5cm)."
    });
  } catch (error) {
    console.error("[AI-MEASURE] Erreur sauvegarde config:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la sauvegarde de la configuration",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
var settingsRoutes_default = router19;

// src/routes/leadsRoutes.ts
var import_express21 = require("express");
var import_fs5 = __toESM(require("fs"), 1);
var import_path4 = __toESM(require("path"), 1);
init_prisma();

// src/services/formResponsePdfGenerator.ts
var import_pdfkit = __toESM(require("pdfkit"), 1);
async function generateFormResponsePdf(data) {
  return new Promise((resolve, reject) => {
    try {
      const sanitizeText2 = (input) => {
        if (input === null || input === void 0) return "";
        const raw = String(input);
        return raw.normalize("NFKD").replace(new RegExp("\\p{Extended_Pictographic}", "gu"), "").replace(/[^\x09\x0A\x0D\x20-\x7E\u00A0-\u017F]/g, "").replace(/\s+/g, " ").trim();
      };
      const doc = new import_pdfkit.default({
        size: "A4",
        margin: 50,
        info: {
          Title: `R\xE9capitulatif - ${data.formName}`,
          Author: "2Thier CRM",
          Subject: `R\xE9ponses formulaire ${data.contact.email || "N/A"}`,
          CreationDate: /* @__PURE__ */ new Date()
        }
      });
      const chunks = [];
      doc.on("data", (chunk) => chunks.push(chunk));
      doc.on("end", () => resolve(Buffer.concat(chunks)));
      doc.on("error", reject);
      doc.fontSize(24).fillColor("#1890ff").text("R\xE9capitulatif du Formulaire", { align: "center" });
      doc.moveDown(0.5);
      doc.fontSize(14).fillColor("#333").text(sanitizeText2(data.formName), { align: "center" });
      doc.moveDown(0.3);
      doc.fontSize(10).fillColor("#888").text(`Soumis le ${data.submittedAt.toLocaleDateString("fr-BE", {
        day: "2-digit",
        month: "long",
        year: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      })}`, { align: "center" });
      if (data.leadNumber) {
        doc.text(`R\xE9f\xE9rence: ${data.leadNumber}`, { align: "center" });
      }
      doc.moveDown(1);
      doc.fillColor("#1890ff").fontSize(14).text("Informations de Contact");
      doc.moveDown(0.5);
      doc.strokeColor("#e8e8e8").lineWidth(1).moveTo(50, doc.y).lineTo(545, doc.y).stroke();
      doc.moveDown(0.5);
      doc.fontSize(11).fillColor("#333");
      const contact = data.contact;
      const contactLines = [
        contact.civility && `Civilit\xE9: ${contact.civility === "mme" ? "Madame" : "Monsieur"}`,
        contact.firstName && contact.lastName && `Nom: ${contact.firstName} ${contact.lastName}`,
        contact.email && `Email: ${contact.email}`,
        contact.phone && `T\xE9l\xE9phone: ${contact.phone}`
      ].filter(Boolean).map(sanitizeText2);
      contactLines.forEach((line) => {
        doc.text(line);
        doc.moveDown(0.3);
      });
      doc.moveDown(1);
      doc.fillColor("#1890ff").fontSize(14).text("R\xE9ponses au Questionnaire");
      doc.moveDown(0.5);
      doc.strokeColor("#e8e8e8").lineWidth(1).moveTo(50, doc.y).lineTo(545, doc.y).stroke();
      doc.moveDown(0.5);
      const sortedQuestions = [...data.questions].sort((a, b) => {
        const keys = Object.keys(data.answers);
        return keys.indexOf(a.questionKey) - keys.indexOf(b.questionKey);
      });
      for (const question of sortedQuestions) {
        const answer = data.answers[question.questionKey];
        if (answer === void 0 || answer === null || answer === "") continue;
        if (["prenom", "nom", "email", "telephone", "civilite"].includes(question.questionKey)) continue;
        if (doc.y > 700) {
          doc.addPage();
        }
        const icon = sanitizeText2(question.icon || "") || "\u2022";
        doc.fontSize(11).fillColor("#1890ff").text(`${icon} ${sanitizeText2(question.title)}`, { continued: false });
        doc.moveDown(0.2);
        let displayValue = "";
        if (Array.isArray(answer)) {
          const selectedLabels = answer.map((val) => {
            const option = question.options?.find((o) => o.value === val);
            return option ? `${sanitizeText2(option.icon || "")} ${sanitizeText2(option.label)}`.trim() : sanitizeText2(val);
          });
          displayValue = selectedLabels.join(", ");
        } else if (question.options && question.questionType.includes("choice")) {
          const option = question.options.find((o) => o.value === answer);
          displayValue = option ? `${sanitizeText2(option.icon || "")} ${sanitizeText2(option.label)}`.trim() : sanitizeText2(answer);
        } else {
          displayValue = sanitizeText2(answer);
        }
        doc.fontSize(10).fillColor("#333").text(`   \u2192 ${displayValue}`);
        doc.moveDown(0.5);
      }
      doc.moveDown(2);
      doc.strokeColor("#e8e8e8").lineWidth(1).moveTo(50, doc.y).lineTo(545, doc.y).stroke();
      doc.moveDown(0.5);
      doc.fontSize(9).fillColor("#888").text("Document g\xE9n\xE9r\xE9 automatiquement par 2Thier CRM", { align: "center" });
      doc.text(`${(/* @__PURE__ */ new Date()).toLocaleDateString("fr-BE")} - ${sanitizeText2(data.formSlug)}`, { align: "center" });
      doc.end();
    } catch (error) {
      reject(error);
    }
  });
}

// src/routes/leadsRoutes.ts
var router20 = (0, import_express21.Router)();
router20.use(authMiddleware);
router20.get("/", async (req2, res) => {
  try {
    const authReq = req2;
    const isSuperAdmin2 = authReq.user?.role === "super_admin" || authReq.user?.isSuperAdmin === true || authReq.user?.role?.toLowerCase().includes("super");
    if (isSuperAdmin2) {
      try {
        const allLeads = await db.lead.findMany({
          include: {
            User: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                email: true
              }
            },
            LeadStatus: true,
            Organization: {
              select: {
                id: true,
                name: true
              }
            }
          },
          orderBy: {
            updatedAt: "desc"
          }
        });
        const formattedLeads2 = allLeads.map((lead) => {
          const data = lead.data || {};
          const formattedName = lead.firstName && lead.lastName ? `${lead.firstName} ${lead.lastName}` : lead.firstName || lead.lastName || data.name || `Lead ${lead.id.slice(0, 8)}`;
          return {
            id: lead.id,
            name: formattedName,
            firstName: lead.firstName || data.firstName || "",
            lastName: lead.lastName || data.lastName || "",
            email: lead.email || data.email || "",
            phone: lead.phone || data.phone || "",
            company: lead.company || data.company || "",
            status: lead.status,
            source: lead.source || "unknown",
            assignedTo: lead.User,
            leadStatus: lead.LeadStatus,
            createdAt: lead.createdAt,
            updatedAt: lead.updatedAt,
            statusId: lead.statusId,
            organizationId: lead.organizationId,
            assignedToId: lead.assignedToId,
            // Donn√©es additionnelles pour la compatibilit√©
            data: lead.data,
            // Information organisation pour SuperAdmin
            organization: lead.Organization
          };
        });
        res.json({ success: true, data: formattedLeads2 });
        return;
      } catch (error) {
        console.error("[LEADS] Erreur lors de la r\xE9cup\xE9ration des leads pour SuperAdmin:", error);
        res.status(500).json({
          success: false,
          error: "Erreur lors de la r\xE9cup\xE9ration des leads pour SuperAdmin",
          message: error instanceof Error ? error.message : "Erreur inconnue"
        });
        return;
      }
    }
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e pour utilisateur non-SuperAdmin"
      });
    }
    console.log("[LEADS] \u{1F464} Utilisateur normal - R\xE9cup\xE9ration des leads pour l'organisation:", organizationId);
    const leads = await db.lead.findMany({
      where: {
        organizationId
      },
      include: {
        User: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        LeadStatus: true
      },
      orderBy: {
        updatedAt: "desc"
      }
    });
    const formattedLeads = leads.map((lead) => {
      const data = lead.data || {};
      const formattedName = lead.firstName && lead.lastName ? `${lead.firstName} ${lead.lastName}` : lead.firstName || lead.lastName || data.name || `Lead ${lead.id.slice(0, 8)}`;
      return {
        id: lead.id,
        name: formattedName,
        firstName: lead.firstName || data.firstName || "",
        lastName: lead.lastName || data.lastName || "",
        email: lead.email || data.email || "",
        phone: lead.phone || data.phone || "",
        company: lead.company || data.company || "",
        status: lead.status,
        source: lead.source || "unknown",
        assignedTo: lead.User,
        leadStatus: lead.LeadStatus,
        createdAt: lead.createdAt,
        updatedAt: lead.updatedAt,
        statusId: lead.statusId,
        organizationId: lead.organizationId,
        assignedToId: lead.assignedToId,
        // Donn√©es additionnelles pour la compatibilit√©
        data: lead.data
      };
    });
    res.json({ success: true, data: formattedLeads });
  } catch (error) {
    console.error("[LEADS] Erreur lors de la r\xE9cup\xE9ration des leads:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la r\xE9cup\xE9ration des leads",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router20.post("/", async (req2, res) => {
  try {
    const authReq = req2;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    console.log("[LEADS] POST - Cr\xE9ation d'un nouveau lead");
    console.log("[LEADS] Donn\xE9es re\xE7ues:", req2.body);
    console.log("[LEADS] Organisation:", organizationId);
    const {
      firstName,
      lastName,
      email,
      phone,
      company,
      source,
      status = "new",
      statusId,
      notes,
      website,
      linkedin,
      data
    } = req2.body;
    if (!firstName || !lastName || !email || !company) {
      return res.status(400).json({
        error: "Les champs pr\xE9nom, nom, email et soci\xE9t\xE9 sont requis"
      });
    }
    let finalStatusId = statusId;
    if (statusId) {
      const statusExists = await db.leadStatus.findUnique({
        where: { id: statusId }
      });
      if (!statusExists) {
        console.log("[LEADS] Statut non trouv\xE9, utilisation du statut par d\xE9faut");
        finalStatusId = null;
      }
    }
    if (!finalStatusId) {
      const defaultStatus = await db.leadStatus.findFirst({
        where: {
          organizationId,
          isDefault: true
        }
      });
      if (defaultStatus) {
        finalStatusId = defaultStatus.id;
        console.log("[LEADS] Statut par d\xE9faut assign\xE9:", defaultStatus.name);
      }
    }
    const now = /* @__PURE__ */ new Date();
    const newLead = await db.lead.create({
      data: {
        firstName,
        lastName,
        email,
        phone: phone || null,
        company,
        source: source || "manual",
        status,
        statusId: finalStatusId,
        notes: notes || null,
        website: website || null,
        linkedin: linkedin || null,
        createdAt: now,
        updatedAt: now,
        organizationId,
        assignedToId: authReq.user?.userId || null,
        // Donn√©es JSON pour compatibilit√©
        data: data || {
          name: `${firstName} ${lastName}`,
          email,
          phone: phone || "",
          company,
          notes: notes || "",
          website: website || "",
          linkedin: linkedin || "",
          source: source || "manual"
        }
      },
      include: {
        User: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        LeadStatus: true
      }
    });
    console.log("[LEADS] Lead cr\xE9\xE9 avec succ\xE8s:", newLead.id);
    const formattedLead = {
      id: newLead.id,
      name: `${newLead.firstName} ${newLead.lastName}`,
      firstName: newLead.firstName,
      lastName: newLead.lastName,
      email: newLead.email,
      phone: newLead.phone,
      company: newLead.company,
      status: newLead.status,
      source: newLead.source,
      assignedTo: newLead.User,
      leadStatus: newLead.LeadStatus,
      createdAt: newLead.createdAt,
      updatedAt: newLead.updatedAt,
      statusId: newLead.statusId,
      organizationId: newLead.organizationId,
      assignedToId: newLead.assignedToId,
      data: newLead.data
    };
    res.status(201).json(formattedLead);
  } catch (error) {
    console.error("[LEADS] Erreur lors de la cr\xE9ation du lead:", error);
    res.status(500).json({
      error: "Erreur lors de la cr\xE9ation du lead",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router20.get("/:id", async (req2, res) => {
  try {
    const authReq = req2;
    const { id } = req2.params;
    const organizationId = authReq.user?.organizationId;
    const isSuperAdmin2 = authReq.user?.role === "super_admin" || authReq.user?.isSuperAdmin === true || authReq.user?.role?.toLowerCase().includes("super");
    let whereCondition;
    if (isSuperAdmin2) {
      whereCondition = { id };
    } else {
      if (!organizationId) {
        return res.status(400).json({
          error: "Organisation non sp\xE9cifi\xE9e"
        });
      }
      whereCondition = {
        id,
        organizationId
        // S√©curit√©: s'assurer que le lead appartient √† l'organisation
      };
    }
    const lead = await db.lead.findFirst({
      where: whereCondition,
      include: {
        User: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        LeadStatus: true,
        Organization: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });
    if (!lead) {
      console.log("[LEADS] Lead non trouv\xE9:", id);
      return res.status(404).json({
        error: "Lead non trouv\xE9 ou non autoris\xE9"
      });
    }
    const data = lead.data || {};
    const formattedLead = {
      id: lead.id,
      name: lead.firstName && lead.lastName ? `${lead.firstName} ${lead.lastName}` : lead.firstName || lead.lastName || data.name || `Lead ${lead.id.slice(0, 8)}`,
      firstName: lead.firstName || data.firstName || "",
      lastName: lead.lastName || data.lastName || "",
      email: lead.email || data.email || "",
      phone: lead.phone || data.phone || "",
      company: lead.company || data.company || "",
      status: lead.status,
      source: lead.source || "unknown",
      assignedTo: lead.User,
      leadStatus: lead.LeadStatus,
      createdAt: lead.createdAt,
      updatedAt: lead.updatedAt,
      statusId: lead.statusId,
      organizationId: lead.organizationId,
      assignedToId: lead.assignedToId,
      notes: lead.notes || data.notes || "",
      website: lead.website || data.website || "",
      linkedin: lead.linkedin || data.linkedin || "",
      lastContactDate: lead.lastContactDate,
      nextFollowUpDate: lead.nextFollowUpDate,
      // Donn√©es additionnelles pour la compatibilit√©
      data: lead.data
    };
    res.json(formattedLead);
  } catch (error) {
    console.error("[LEADS] Erreur lors de la r\xE9cup\xE9ration du lead:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration du lead",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router20.post("/:id/form-pdf/regenerate", async (req2, res) => {
  try {
    const authReq = req2;
    const { id } = req2.params;
    const organizationId = authReq.user?.organizationId;
    const isSuperAdmin2 = authReq.user?.role === "super_admin" || authReq.user?.isSuperAdmin === true || authReq.user?.role?.toLowerCase().includes("super");
    let whereCondition;
    if (isSuperAdmin2) {
      whereCondition = { id };
    } else {
      if (!organizationId) {
        return res.status(400).json({ error: "Organisation non sp\xE9cifi\xE9e" });
      }
      whereCondition = { id, organizationId };
    }
    const lead = await db.lead.findFirst({ where: whereCondition });
    if (!lead) {
      return res.status(404).json({ error: "Lead non trouv\xE9 ou non autoris\xE9" });
    }
    const latestSubmission = await db.website_form_submissions.findFirst({
      where: { leadId: lead.id },
      orderBy: { createdAt: "desc" },
      include: {
        form: {
          include: {
            questions: {
              orderBy: { order: "asc" }
            }
          }
        }
      }
    });
    if (!latestSubmission || !latestSubmission.form) {
      return res.status(404).json({ error: "Aucune soumission de formulaire trouv\xE9e pour ce lead" });
    }
    const form = latestSubmission.form;
    const pdfData = {
      formName: form.name,
      formSlug: form.slug,
      submittedAt: latestSubmission.createdAt,
      contact: {
        firstName: lead.firstName || void 0,
        lastName: lead.lastName || void 0,
        email: lead.email || void 0,
        phone: lead.phone || void 0,
        civility: lead.data?.civility
      },
      answers: latestSubmission.formData || {},
      questions: (form.questions || []).map((q) => ({
        questionKey: q.questionKey,
        title: q.title,
        subtitle: q.subtitle || void 0,
        icon: q.icon || void 0,
        questionType: q.questionType,
        options: q.options || void 0
      })),
      leadNumber: lead.leadNumber || void 0
    };
    const pdfBuffer = await generateFormResponsePdf(pdfData);
    const uploadsDir2 = import_path4.default.join(process.cwd(), "public", "uploads", "form-responses");
    if (!import_fs5.default.existsSync(uploadsDir2)) {
      import_fs5.default.mkdirSync(uploadsDir2, { recursive: true });
    }
    const pdfFileName = `formulaire-${form.slug}-${lead.id.substring(0, 8)}-${Date.now()}.pdf`;
    const pdfPath = import_path4.default.join(uploadsDir2, pdfFileName);
    import_fs5.default.writeFileSync(pdfPath, pdfBuffer);
    const pdfUrl = `/uploads/form-responses/${pdfFileName}`;
    const existingData = typeof lead.data === "object" && lead.data ? lead.data : {};
    const updatedLead = await db.lead.update({
      where: { id: lead.id },
      data: {
        data: {
          ...existingData,
          formPdfUrl: pdfUrl,
          formSlug: form.slug,
          formName: form.name
        }
      }
    });
    return res.json({
      success: true,
      pdfUrl,
      formName: form.name,
      formSlug: form.slug,
      leadId: updatedLead.id
    });
  } catch (error) {
    console.error("[LEADS] Erreur r\xE9g\xE9n\xE9ration PDF formulaire:", error);
    return res.status(500).json({
      error: "Erreur lors de la r\xE9g\xE9n\xE9ration du PDF",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router20.put("/:id", async (req2, res) => {
  try {
    const authReq = req2;
    const { id } = req2.params;
    const organizationId = authReq.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        error: "Organisation non sp\xE9cifi\xE9e"
      });
    }
    const existingLead = await db.lead.findFirst({
      where: {
        id,
        organizationId
      }
    });
    if (!existingLead) {
      return res.status(404).json({
        error: "Lead non trouv\xE9 ou non autoris\xE9"
      });
    }
    const {
      firstName,
      lastName,
      email,
      phone,
      company,
      source,
      status,
      statusId,
      notes,
      website,
      linkedin,
      assignedToId,
      nextFollowUpDate,
      data
    } = req2.body;
    const updateData = {};
    if (firstName !== void 0) updateData.firstName = firstName;
    if (lastName !== void 0) updateData.lastName = lastName;
    if (email !== void 0) updateData.email = email;
    if (phone !== void 0) updateData.phone = phone;
    if (company !== void 0) updateData.company = company;
    if (source !== void 0) updateData.source = source;
    if (status !== void 0) {
      const validStatuses = ["new", "contacted", "meeting", "proposal", "won", "lost"];
      const statusMapping = {
        "nouveau": "new",
        "en_cours": "contacted",
        "contacte": "contacted",
        "contact\xE9": "contacted",
        "rdv": "meeting",
        "rendez_vous": "meeting",
        "devis": "proposal",
        "gagne": "won",
        "gagn\xE9": "won",
        "perdu": "lost",
        "termine": "won",
        "termin\xE9": "won"
      };
      const normalizedStatus = statusMapping[status.toLowerCase()] || status;
      if (!validStatuses.includes(normalizedStatus)) {
        console.warn("[LEADS] Statut invalide:", status, '- utilisation de "new" par d\xE9faut');
        updateData.status = "new";
      } else {
        updateData.status = normalizedStatus;
      }
    }
    if (statusId !== void 0) updateData.statusId = statusId;
    if (notes !== void 0) updateData.notes = notes;
    if (website !== void 0) updateData.website = website;
    if (linkedin !== void 0) updateData.linkedin = linkedin;
    if (assignedToId !== void 0) updateData.assignedToId = assignedToId;
    if (nextFollowUpDate !== void 0) updateData.nextFollowUpDate = nextFollowUpDate ? new Date(nextFollowUpDate) : null;
    if (data !== void 0) updateData.data = data;
    const updatedLead = await db.lead.update({
      where: { id },
      data: {
        ...updateData,
        updatedAt: /* @__PURE__ */ new Date()
      },
      include: {
        User: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        LeadStatus: true
      }
    });
    console.log("[LEADS] Lead modifi\xE9 avec succ\xE8s:", updatedLead.id);
    const formattedLead = {
      id: updatedLead.id,
      name: updatedLead.firstName && updatedLead.lastName ? `${updatedLead.firstName} ${updatedLead.lastName}` : updatedLead.firstName || updatedLead.lastName || updatedLead.data?.name || `Lead ${updatedLead.id.slice(0, 8)}`,
      firstName: updatedLead.firstName || "",
      lastName: updatedLead.lastName || "",
      email: updatedLead.email || "",
      phone: updatedLead.phone || "",
      company: updatedLead.company || "",
      status: updatedLead.status,
      source: updatedLead.source || "unknown",
      assignedTo: updatedLead.User,
      leadStatus: updatedLead.LeadStatus,
      createdAt: updatedLead.createdAt,
      updatedAt: updatedLead.updatedAt,
      statusId: updatedLead.statusId,
      organizationId: updatedLead.organizationId,
      assignedToId: updatedLead.assignedToId,
      notes: updatedLead.notes || "",
      website: updatedLead.website || "",
      linkedin: updatedLead.linkedin || "",
      nextFollowUpDate: updatedLead.nextFollowUpDate,
      data: updatedLead.data
    };
    res.json(formattedLead);
  } catch (error) {
    console.error("[LEADS] Erreur lors de la modification du lead:", error);
    res.status(500).json({
      error: "Erreur lors de la modification du lead",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router20.delete("/:id", async (req2, res) => {
  try {
    const authReq = req2;
    const { id } = req2.params;
    console.log("[LEADS] \u{1F5D1}\uFE0F Demande de suppression du lead:", id, "par utilisateur:", {
      id: authReq.user?.userId || authReq.user?.id,
      email: authReq.user?.email,
      role: authReq.user?.role,
      isSuperAdmin: authReq.user?.isSuperAdmin,
      organizationId: authReq.user?.organizationId
    });
    const isSuperAdmin2 = authReq.user?.role === "super_admin" || authReq.user?.isSuperAdmin === true || authReq.user?.role?.toLowerCase().includes("super");
    const whereCondition = { id };
    if (!isSuperAdmin2) {
      const organizationId = authReq.user?.organizationId;
      if (!organizationId) {
        return res.status(400).json({ error: "Organisation non sp\xE9cifi\xE9e" });
      }
      whereCondition.organizationId = organizationId;
    }
    const existing = await db.lead.findFirst({ where: whereCondition });
    if (!existing) {
      console.log("[LEADS] \u274C Lead non trouv\xE9 ou non autoris\xE9 pour suppression:", id);
      return res.status(404).json({ error: "Lead non trouv\xE9 ou non autoris\xE9" });
    }
    await db.lead.delete({ where: { id } });
    console.log("[LEADS] \u2705 Lead supprim\xE9 avec succ\xE8s:", id);
    return res.status(204).send();
  } catch (error) {
    console.error("[LEADS] Erreur lors de la suppression du lead:", error);
    return res.status(500).json({
      error: "Erreur lors de la suppression du lead",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router20.get("/:id/history", async (req2, res) => {
  try {
    const authReq = req2;
    const { id } = req2.params;
    const isSuperAdmin2 = authReq.user?.role === "super_admin" || authReq.user?.isSuperAdmin === true || authReq.user?.role?.toLowerCase().includes("super");
    const whereCond = isSuperAdmin2 ? { id } : { id, organizationId: authReq.user?.organizationId };
    const lead = await db.lead.findFirst({ where: whereCond });
    if (!lead) return res.status(404).json({ success: false, error: "Lead non trouv\xE9 ou non autoris\xE9" });
    const dataObj = lead.data || {};
    const history = Array.isArray(dataObj.history) ? dataObj.history : [];
    return res.json({ success: true, data: history });
  } catch (e) {
    console.error("[LEADS] GET history error", e);
    return res.status(500).json({ success: false, error: "Erreur lors du chargement de l'historique" });
  }
});
router20.post("/:id/history", async (req2, res) => {
  try {
    const authReq = req2;
    const { id } = req2.params;
    const organizationId = authReq.user?.organizationId;
    const isSuperAdmin2 = authReq.user?.role === "super_admin" || authReq.user?.isSuperAdmin === true || authReq.user?.role?.toLowerCase().includes("super");
    const whereCond = isSuperAdmin2 ? { id } : { id, organizationId };
    const lead = await db.lead.findFirst({ where: whereCond });
    if (!lead) return res.status(404).json({ success: false, error: "Lead non trouv\xE9 ou non autoris\xE9" });
    const { type = "internal", content = "", author } = req2.body || {};
    const historyItem = {
      type,
      content,
      author: author || (authReq.user?.email ?? "system"),
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    const dataObj = lead.data || {};
    const existing = Array.isArray(dataObj.history) ? dataObj.history : [];
    dataObj.history = [historyItem, ...existing];
    await db.lead.update({ where: { id: lead.id }, data: { data: dataObj } });
    return res.status(201).json({ success: true, item: historyItem });
  } catch (e) {
    console.error("[LEADS] POST history error", e);
    return res.status(500).json({ success: false, error: "Erreur lors de l'ajout \xE0 l'historique" });
  }
});
router20.get("/:id/documents", async (req2, res) => {
  try {
    const authReq = req2;
    const { id } = req2.params;
    const isSuperAdmin2 = authReq.user?.role === "super_admin" || authReq.user?.isSuperAdmin === true || authReq.user?.role?.toLowerCase().includes("super");
    const whereCond = isSuperAdmin2 ? { id } : { id, organizationId: authReq.user?.organizationId };
    const lead = await db.lead.findFirst({ where: whereCond });
    if (!lead) return res.status(404).json({ success: false, error: "Lead non trouv\xE9 ou non autoris\xE9" });
    const dataObj = lead.data || {};
    const docs = Array.isArray(dataObj.documents) ? dataObj.documents : [];
    return res.json({ success: true, data: docs });
  } catch (e) {
    console.error("[LEADS] GET documents error", e);
    return res.status(500).json({ success: false, error: "Erreur lors du chargement des documents" });
  }
});
router20.post("/:id/documents", async (req2, res) => {
  try {
    const authReq = req2;
    const { id } = req2.params;
    const organizationId = authReq.user?.organizationId;
    const isSuperAdmin2 = authReq.user?.role === "super_admin" || authReq.user?.isSuperAdmin === true || authReq.user?.role?.toLowerCase().includes("super");
    const whereCond = isSuperAdmin2 ? { id } : { id, organizationId };
    const lead = await db.lead.findFirst({ where: whereCond });
    if (!lead) return res.status(404).json({ success: false, error: "Lead non trouv\xE9 ou non autoris\xE9" });
    const body2 = req2.body || {};
    const newDoc = {
      id: body2.id || cryptoRandomId(),
      name: body2.name || "Document",
      type: body2.type || "devis",
      url: body2.url || null,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      meta: body2.meta || {}
    };
    const dataObj = lead.data || {};
    const existingDocs = Array.isArray(dataObj.documents) ? dataObj.documents : [];
    const updatedDocs = [newDoc, ...existingDocs];
    dataObj.documents = updatedDocs;
    await db.lead.update({ where: { id: lead.id }, data: { data: dataObj } });
    return res.status(201).json({ success: true, item: newDoc });
  } catch (e) {
    console.error("[LEADS] POST documents error", e);
    return res.status(500).json({ success: false, error: "Erreur lors de l'ajout du document" });
  }
});
var leadsRoutes_default = router20;

// src/routes/rolesRoutes.ts
var import_express22 = require("express");
init_database();
var import_zod4 = require("zod");
var import_express_rate_limit2 = __toESM(require("express-rate-limit"), 1);
var router21 = (0, import_express22.Router)();
var prisma10 = db;
var sanitizeString2 = (input) => {
  return input.trim().replace(/[<>]/g, "");
};
var roleCreateSchema = import_zod4.z.object({
  name: import_zod4.z.string().min(2, "Nom du r\xF4le minimum 2 caract\xE8res").max(50, "Nom du r\xF4le maximum 50 caract\xE8res").regex(/^[a-zA-Z0-9_\-\s]+$/, "Nom du r\xF4le contient des caract\xE8res non autoris\xE9s"),
  description: import_zod4.z.string().max(500, "Description maximum 500 caract\xE8res").optional(),
  organizationId: import_zod4.z.string().uuid("ID organisation invalide").optional()
});
var roleUpdateSchema = import_zod4.z.object({
  name: import_zod4.z.string().min(2, "Nom du r\xF4le minimum 2 caract\xE8res").max(50, "Nom du r\xF4le maximum 50 caract\xE8res").regex(/^[a-zA-Z0-9_\-\s]+$/, "Nom du r\xF4le contient des caract\xE8res non autoris\xE9s").optional(),
  description: import_zod4.z.string().max(500, "Description maximum 500 caract\xE8res").optional()
});
var roleQuerySchema = import_zod4.z.object({
  // Accepter 'current' OU n'importe quelle cha√Æne non vide (IDs personnalis√©s autoris√©s)
  organizationId: import_zod4.z.string().min(1, "ID organisation invalide").optional()
});
var rolesRateLimit = (0, import_express_rate_limit2.default)({
  windowMs: 15 * 60 * 1e3,
  // 15 minutes
  max: 100,
  // 100 requ√™tes max (lecture fr√©quente)
  message: {
    success: false,
    message: "Trop de requ\xEAtes sur les r\xF4les, r\xE9essayez plus tard"
  },
  standardHeaders: true,
  legacyHeaders: false
});
var rolesCreateRateLimit = (0, import_express_rate_limit2.default)({
  windowMs: 15 * 60 * 1e3,
  // 15 minutes  
  max: 10,
  // 10 cr√©ations max
  message: {
    success: false,
    message: "Trop de cr\xE9ations de r\xF4les, r\xE9essayez plus tard"
  }
});
var handleZodError2 = (error) => {
  return {
    success: false,
    message: "Donn\xE9es invalides",
    errors: error.errors.map((e) => `${e.path.join(".")}: ${e.message}`)
  };
};
router21.use(authMiddleware);
router21.use(rolesRateLimit);
router21.get("/", async (req2, res) => {
  console.log("[ROLES] GET /roles - R\xE9cup\xE9ration des r\xF4les S\xC9CURIS\xC9E");
  try {
    const queryValidation = roleQuerySchema.safeParse(req2.query);
    if (!queryValidation.success) {
      console.log("[ROLES] Validation \xE9chou\xE9e:", queryValidation.error);
      res.status(400).json(handleZodError2(queryValidation.error));
      return;
    }
    const { organizationId } = queryValidation.data;
    const requestingUser = req2.user;
    console.log(`[ROLES] User role: ${requestingUser?.role}`);
    console.log(`[ROLES] Organization ID: ${organizationId || requestingUser?.organizationId}`);
    let finalOrganizationId = organizationId;
    if (organizationId === "current") {
      finalOrganizationId = requestingUser?.organizationId;
    }
    const whereClause = {};
    if (finalOrganizationId) {
      whereClause.OR = [
        { organizationId: finalOrganizationId },
        { organizationId: null }
        // R√¥les globaux
      ];
    }
    if (requestingUser?.role !== "super_admin") {
      whereClause.OR = [
        { organizationId: requestingUser?.organizationId },
        { organizationId: null }
        // R√¥les globaux toujours disponibles
      ];
      console.log(`[ROLES] Non-SuperAdmin: Filtering for org ${requestingUser?.organizationId} + global roles`);
    }
    if (!finalOrganizationId && requestingUser?.role === "super_admin") {
      console.log("[ROLES] SuperAdmin: Returning all roles (global and organization-specific)");
    }
    console.log("[ROLES] Final where clause:", whereClause);
    const roles = await prisma10.role.findMany({
      where: whereClause,
      include: {
        Permission: true,
        Organization: true
      },
      orderBy: { name: "asc" }
    });
    console.log(`[ROLES] Found ${roles.length} total roles based on filter.`);
    res.status(200).json({ success: true, data: roles });
    return;
  } catch (error) {
    console.error("[ROLES] Erreur lors de la r\xE9cup\xE9ration des r\xF4les:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne lors de la r\xE9cup\xE9ration des r\xF4les"
    });
  }
});
router21.get("/:id", async (req2, res) => {
  const { id } = req2.params;
  console.log(`[ROLES] GET /roles/${id} - R\xE9cup\xE9ration du r\xF4le S\xC9CURIS\xC9E`);
  try {
    if (!id || typeof id !== "string" || id.trim() === "") {
      res.status(400).json({
        success: false,
        message: "ID du r\xF4le invalide"
      });
      return;
    }
    if (!req2.user) {
      res.status(401).json({
        success: false,
        message: "Utilisateur non authentifi\xE9"
      });
      return;
    }
    const requestingUser = req2.user;
    const sanitizedId = sanitizeString2(id.trim());
    const role = await prisma10.role.findUnique({
      where: { id: sanitizedId },
      include: {
        Permission: true,
        UserOrganizations: {
          include: {
            Organization: true,
            User: {
              select: { id: true, firstName: true, lastName: true, email: true }
            }
          }
        },
        Organization: true
      }
    });
    if (!role) {
      res.status(404).json({
        success: false,
        message: "R\xF4le non trouv\xE9"
      });
      return;
    }
    if (requestingUser.role !== "super_admin") {
      if (!requestingUser.organizationId || role.organizationId !== requestingUser.organizationId) {
        res.status(403).json({
          success: false,
          message: "Acc\xE8s refus\xE9: vous ne pouvez voir que les r\xF4les de votre organisation"
        });
        return;
      }
    }
    console.log(`[ROLES] R\xF4le "${role.name}" r\xE9cup\xE9r\xE9 avec succ\xE8s`);
    res.json({
      success: true,
      data: role
    });
  } catch (error) {
    console.error("[ROLES] Error fetching role:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur"
    });
  }
});
router21.post("/", rolesCreateRateLimit, async (req2, res) => {
  console.log("[ROLES] POST /roles - Cr\xE9ation d'un r\xF4le S\xC9CURIS\xC9E");
  try {
    const bodyValidation = roleCreateSchema.safeParse(req2.body);
    if (!bodyValidation.success) {
      console.log("[ROLES] Validation cr\xE9ation \xE9chou\xE9e:", bodyValidation.error);
      res.status(400).json(handleZodError2(bodyValidation.error));
      return;
    }
    if (!req2.user) {
      res.status(401).json({
        success: false,
        message: "Utilisateur non authentifi\xE9"
      });
      return;
    }
    const requestingUser = req2.user;
    const { name, description, organizationId } = bodyValidation.data;
    const sanitizedName = sanitizeString2(name);
    const sanitizedDescription = description ? sanitizeString2(description) : "";
    console.log(`[ROLES] Cr\xE9ation r\xF4le: ${sanitizedName} pour org: ${organizationId || requestingUser.organizationId}`);
    if (requestingUser.role !== "super_admin") {
      const targetOrgId = organizationId || requestingUser.organizationId;
      if (!requestingUser.organizationId || requestingUser.organizationId !== targetOrgId) {
        res.status(403).json({
          success: false,
          message: "Acc\xE8s refus\xE9: vous ne pouvez cr\xE9er des r\xF4les que pour votre organisation"
        });
        return;
      }
    }
    const finalOrgId = organizationId || requestingUser.organizationId;
    const existingRole = await prisma10.role.findFirst({
      where: {
        name: sanitizedName,
        organizationId: finalOrgId
      }
    });
    if (existingRole) {
      res.status(409).json({
        success: false,
        message: `Un r\xF4le avec le nom "${sanitizedName}" existe d\xE9j\xE0 dans cette organisation`
      });
      return;
    }
    if (sanitizedName === "super_admin") {
      res.status(400).json({
        success: false,
        message: 'Le nom de r\xF4le "super_admin" est r\xE9serv\xE9 et ne peut pas \xEAtre cr\xE9\xE9.'
      });
      return;
    }
    const newRole = await prisma10.role.create({
      data: {
        id: `role_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: sanitizedName,
        label: sanitizedName,
        description: sanitizedDescription,
        organizationId: finalOrgId,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      },
      include: {
        UserOrganizations: {
          include: {
            Organization: true,
            User: true
          }
        },
        Organization: true
      }
    });
    console.log(`[ROLES] R\xF4le cr\xE9\xE9 avec succ\xE8s: ${newRole.id}`);
    res.status(201).json({
      success: true,
      data: newRole,
      message: `R\xF4le "${sanitizedName}" cr\xE9\xE9 avec succ\xE8s`
    });
  } catch (error) {
    console.error("[ROLES] Error creating role:", error);
    res.status(500).json({ success: false, message: "Erreur interne du serveur" });
  }
});
router21.put("/:id", async (req2, res) => {
  const { id } = req2.params;
  console.log(`[ROLES] PUT /roles/${id} - Mise \xE0 jour du r\xF4le S\xC9CURIS\xC9E`);
  try {
    if (!id || typeof id !== "string" || id.trim() === "") {
      res.status(400).json({
        success: false,
        message: "ID du r\xF4le invalide"
      });
      return;
    }
    const bodyValidation = roleUpdateSchema.safeParse(req2.body);
    if (!bodyValidation.success) {
      console.log("[ROLES] Validation modification \xE9chou\xE9e:", bodyValidation.error);
      res.status(400).json(handleZodError2(bodyValidation.error));
      return;
    }
    if (!req2.user) {
      res.status(401).json({
        success: false,
        message: "Utilisateur non authentifi\xE9"
      });
      return;
    }
    const requestingUser = req2.user;
    const { name, description } = bodyValidation.data;
    const sanitizedName = name ? sanitizeString2(name) : void 0;
    const sanitizedDescription = description ? sanitizeString2(description) : void 0;
    const existingRole = await prisma10.role.findUnique({
      where: { id: id.trim() }
    });
    if (!existingRole) {
      res.status(404).json({
        success: false,
        message: "R\xF4le non trouv\xE9"
      });
      return;
    }
    if (requestingUser.role !== "super_admin") {
      if (!requestingUser.organizationId || existingRole.organizationId !== requestingUser.organizationId) {
        res.status(403).json({
          success: false,
          message: "Acc\xE8s refus\xE9: vous ne pouvez modifier que les r\xF4les de votre organisation"
        });
        return;
      }
    }
    if (existingRole.name === "super_admin") {
      res.status(403).json({
        success: false,
        message: 'Le r\xF4le "super_admin" est prot\xE9g\xE9 et ne peut pas \xEAtre modifi\xE9.'
      });
      return;
    }
    if (sanitizedName && sanitizedName !== existingRole.name) {
      const duplicateRole = await prisma10.role.findFirst({
        where: {
          name: sanitizedName,
          organizationId: existingRole.organizationId,
          id: { not: id.trim() }
        }
      });
      if (duplicateRole) {
        res.status(409).json({
          success: false,
          message: `Un r\xF4le avec le nom "${sanitizedName}" existe d\xE9j\xE0 dans cette organisation`
        });
        return;
      }
    }
    const updateData = {
      updatedAt: /* @__PURE__ */ new Date()
    };
    if (sanitizedName !== void 0) {
      updateData.name = sanitizedName;
      updateData.label = sanitizedName;
    }
    if (sanitizedDescription !== void 0) {
      updateData.description = sanitizedDescription;
    }
    const updatedRole = await prisma10.role.update({
      where: { id: id.trim() },
      data: updateData,
      include: {
        UserOrganizations: {
          include: {
            Organization: true,
            User: true
          }
        },
        Organization: true
      }
    });
    console.log(`[ROLES] R\xF4le modifi\xE9 avec succ\xE8s: ${updatedRole.id}`);
    res.status(200).json({
      success: true,
      data: updatedRole,
      message: "R\xF4le modifi\xE9 avec succ\xE8s"
    });
  } catch (error) {
    console.error("[ROLES] Erreur lors de la modification du r\xF4le:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne lors de la modification du r\xF4le"
    });
  }
});
router21.delete("/:id", async (req2, res) => {
  const { id } = req2.params;
  console.log(`[ROLES] DELETE /roles/${id} - Suppression du r\xF4le S\xC9CURIS\xC9E`);
  try {
    if (!id || typeof id !== "string" || id.trim() === "") {
      res.status(400).json({
        success: false,
        message: "ID du r\xF4le invalide"
      });
      return;
    }
    if (!req2.user) {
      res.status(401).json({
        success: false,
        message: "Utilisateur non authentifi\xE9"
      });
      return;
    }
    const requestingUser = req2.user;
    const roleId = id.trim();
    const existingRole = await prisma10.role.findUnique({
      where: { id: roleId },
      include: {
        UserOrganizations: true
        // Pour v√©rifier s'il y a des utilisateurs assign√©s
      }
    });
    if (!existingRole) {
      res.status(404).json({
        success: false,
        message: "R\xF4le non trouv\xE9"
      });
      return;
    }
    if (requestingUser.role !== "super_admin") {
      if (!requestingUser.organizationId || existingRole.organizationId !== requestingUser.organizationId) {
        res.status(403).json({
          success: false,
          message: "Acc\xE8s refus\xE9: vous ne pouvez supprimer que les r\xF4les de votre organisation"
        });
        return;
      }
    }
    if (existingRole.name === "super_admin") {
      res.status(400).json({
        success: false,
        message: 'Le r\xF4le "super_admin" est prot\xE9g\xE9 et ne peut pas \xEAtre supprim\xE9.'
      });
      return;
    }
    if (existingRole.UserOrganizations && existingRole.UserOrganizations.length > 0) {
      res.status(409).json({
        success: false,
        message: `Impossible de supprimer le r\xF4le "${existingRole.name}": ${existingRole.UserOrganizations.length} utilisateur(s) y sont encore assign\xE9(s)`
      });
      return;
    }
    await prisma10.role.delete({
      where: { id: roleId }
    });
    console.log(`[ROLES] R\xF4le supprim\xE9 avec succ\xE8s: ${roleId} (${existingRole.name})`);
    res.status(200).json({
      success: true,
      message: `R\xF4le "${existingRole.name}" supprim\xE9 avec succ\xE8s`
    });
  } catch (error) {
    console.error("[ROLES] Erreur lors de la suppression du r\xF4le:", error);
    res.status(500).json({ success: false, message: "Erreur interne du serveur" });
  }
});
var rolesRoutes_default = router21;

// src/routes/usersRoutes.ts
var import_express23 = require("express");
init_database();
var import_zod5 = require("zod");
var import_express_rate_limit3 = __toESM(require("express-rate-limit"), 1);
var router22 = (0, import_express23.Router)();
var prisma11 = db;
var sanitizeString3 = (input) => {
  return input.trim().replace(/[<>]/g, "");
};
var userUpdateSchema = import_zod5.z.object({
  // Accepter des IDs non-UUID (ex: cuid, cha√Ænes custom)
  roleId: import_zod5.z.string().min(1, "ID r\xF4le requis").optional(),
  status: import_zod5.z.enum(["ACTIVE", "INACTIVE"], {
    errorMap: () => ({ message: "Statut doit \xEAtre ACTIVE ou INACTIVE" })
  }).optional()
});
var userOrganizationSchema = import_zod5.z.object({
  // IDs non-UUID support√©s
  userId: import_zod5.z.string().min(1, "ID utilisateur requis"),
  organizationId: import_zod5.z.string().min(1, "ID organisation requis"),
  roleId: import_zod5.z.string().min(1, "ID r\xF4le requis")
});
var usersRateLimit = (0, import_express_rate_limit3.default)({
  windowMs: 15 * 60 * 1e3,
  // 15 minutes
  max: 200,
  // 200 requ√™tes max
  message: {
    success: false,
    message: "Trop de requ\xEAtes utilisateurs, r\xE9essayez plus tard"
  }
});
var usersModifyRateLimit = (0, import_express_rate_limit3.default)({
  windowMs: 10 * 60 * 1e3,
  // 10 minutes
  max: 30,
  // 30 modifications max
  message: {
    success: false,
    message: "Trop de modifications utilisateurs, r\xE9essayez plus tard"
  }
});
var handleZodError3 = (error) => {
  return {
    success: false,
    message: "Donn\xE9es invalides",
    errors: error.errors.map((e) => `${e.path.join(".")}: ${e.message}`)
  };
};
router22.use(authMiddleware);
router22.use(usersRateLimit);
router22.use("/invitations", invitations_default);
router22.get("/free", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  console.log("[USERS] GET /users/free - R\xE9cup\xE9ration utilisateurs libres S\xC9CURIS\xC9E");
  try {
    const freeUsers = await prisma11.user.findMany({
      where: {
        UserOrganization: {
          none: {}
        }
      },
      select: {
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        createdAt: true,
        status: true
      },
      orderBy: { createdAt: "desc" }
    });
    console.log(`[USERS] Found ${freeUsers.length} free users`);
    res.json({ success: true, data: freeUsers });
  } catch (error) {
    console.error("[USERS] Erreur r\xE9cup\xE9ration utilisateurs libres:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la r\xE9cup\xE9ration des utilisateurs libres"
    });
  }
});
router22.get("/", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  console.log("[USERS] GET /users - R\xE9cup\xE9ration utilisateurs S\xC9CURIS\xC9E");
  try {
    const sessionUser = req2.user;
    if (sessionUser?.isSuperAdmin) {
      console.log("[USERS] SuperAdmin request - showing ALL users");
      const allUsers = await prisma11.user.findMany({
        include: {
          UserOrganization: {
            include: {
              Role: true,
              Organization: {
                include: {
                  GoogleWorkspaceConfig: true
                }
              }
            }
          }
        },
        orderBy: { createdAt: "desc" }
      });
      console.log(`[USERS] Found ${allUsers.length} total users for SuperAdmin`);
      return res.json({ success: true, data: allUsers });
    }
    const organizationId = sessionUser?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "L'ID de l'organisation est manquant"
      });
    }
    console.log(`[USERS] Standard user request - org: ${organizationId}`);
    const usersInOrg = await prisma11.user.findMany({
      where: {
        UserOrganization: {
          some: { organizationId }
        }
      },
      include: {
        UserOrganization: {
          where: { organizationId },
          include: {
            Role: true,
            Organization: {
              include: {
                GoogleWorkspaceConfig: true
              }
            }
          }
        }
      },
      orderBy: { createdAt: "desc" }
    });
    console.log(`[USERS] Found ${usersInOrg.length} users for org ${organizationId}`);
    res.json({ success: true, data: usersInOrg });
  } catch (error) {
    console.error("[USERS] Erreur r\xE9cup\xE9ration utilisateurs:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur"
    });
  }
});
router22.get("/:userId/organizations", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { userId } = req2.params;
  console.log(`[USERS] GET /users/${userId}/organizations - S\xC9CURIS\xC9`);
  try {
    if (!userId || !import_zod5.z.string().min(1).safeParse(userId).success) {
      return res.status(400).json({
        success: false,
        message: "ID utilisateur invalide ou manquant"
      });
    }
    const userOrganizations = await prisma11.userOrganization.findMany({
      where: { userId: sanitizeString3(userId) },
      include: {
        Organization: true,
        Role: true
      },
      orderBy: {
        Organization: { name: "asc" }
      }
    });
    console.log(`[USERS] Found ${userOrganizations.length} organizations for user ${userId}`);
    res.json({ success: true, data: userOrganizations });
  } catch (error) {
    console.error(`[USERS] Erreur organisations utilisateur ${userId}:`, error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur"
    });
  }
});
router22.post("/user-organizations", usersModifyRateLimit, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  console.log("[USERS] POST /users/user-organizations - Assignation S\xC9CURIS\xC9E");
  try {
    const validation = userOrganizationSchema.safeParse(req2.body);
    if (!validation.success) {
      console.log("[USERS] Validation \xE9chou\xE9e:", validation.error);
      return res.status(400).json(handleZodError3(validation.error));
    }
    const { userId, organizationId, roleId } = validation.data;
    const newId = `uo_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
    const now = /* @__PURE__ */ new Date();
    const existingAssignment = await prisma11.userOrganization.findFirst({
      where: { userId, organizationId }
    });
    if (existingAssignment) {
      return res.status(409).json({
        success: false,
        message: "L'utilisateur est d\xE9j\xE0 dans cette organisation"
      });
    }
    const newUserOrganization = await prisma11.userOrganization.create({
      data: {
        id: newId,
        userId,
        organizationId,
        roleId,
        status: "ACTIVE",
        updatedAt: now
      },
      include: {
        Organization: true,
        Role: true
      }
    });
    console.log(`[USERS] Assignation r\xE9ussie: user ${userId} \u2192 org ${organizationId}`);
    res.status(201).json({ success: true, data: newUserOrganization });
  } catch (error) {
    console.error("[USERS] Erreur assignation utilisateur:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur"
    });
  }
});
router22.patch("/user-organizations/:userOrganizationId", usersModifyRateLimit, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { userOrganizationId } = req2.params;
  console.log(`[USERS] PATCH /users/user-organizations/${userOrganizationId} - S\xC9CURIS\xC9`);
  try {
    if (!userOrganizationId || !import_zod5.z.string().min(1).safeParse(userOrganizationId).success) {
      return res.status(400).json({
        success: false,
        message: "ID relation utilisateur-organisation invalide ou manquant"
      });
    }
    const validation = userUpdateSchema.safeParse(req2.body);
    if (!validation.success) {
      console.log("[USERS] Validation \xE9chou\xE9e:", validation.error);
      return res.status(400).json(handleZodError3(validation.error));
    }
    const { roleId, status } = validation.data;
    const updateData = {};
    if (roleId) updateData.roleId = roleId;
    if (status) updateData.status = status;
    updateData.updatedAt = /* @__PURE__ */ new Date();
    if (Object.keys(updateData).length === 0) {
      return res.status(400).json({
        success: false,
        message: "Aucune donn\xE9e de mise \xE0 jour fournie"
      });
    }
    const updatedUserOrganization = await prisma11.userOrganization.update({
      where: { id: sanitizeString3(userOrganizationId) },
      data: updateData,
      include: {
        Organization: true,
        Role: true,
        User: { select: { id: true, email: true, firstName: true, lastName: true } }
      }
    });
    console.log(`[USERS] Mise \xE0 jour r\xE9ussie: relation ${userOrganizationId}`);
    res.json({ success: true, data: updatedUserOrganization });
  } catch (error) {
    const e = error;
    if (e?.code === "P2025") {
      return res.status(404).json({
        success: false,
        message: "Relation utilisateur-organisation introuvable"
      });
    }
    console.error("[USERS] Erreur mise \xE0 jour utilisateur:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur"
    });
  }
});
router22.delete("/user-organizations/:userOrganizationId", usersModifyRateLimit, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { userOrganizationId } = req2.params;
  console.log(`[USERS] DELETE /users/user-organizations/${userOrganizationId} - S\xC9CURIS\xC9`);
  try {
    if (!userOrganizationId || !import_zod5.z.string().min(1).safeParse(userOrganizationId).success) {
      return res.status(400).json({
        success: false,
        message: "ID relation utilisateur-organisation invalide ou manquant"
      });
    }
    const relationToDelete = await prisma11.userOrganization.findUnique({
      where: { id: sanitizeString3(userOrganizationId) },
      select: { userId: true }
    });
    if (!relationToDelete) {
      return res.status(404).json({
        success: false,
        message: "Relation non trouv\xE9e"
      });
    }
    const remainingRelations = await prisma11.userOrganization.count({
      where: {
        userId: relationToDelete.userId,
        id: { not: sanitizeString3(userOrganizationId) }
      }
    });
    if (remainingRelations === 0) {
      return res.status(400).json({
        success: false,
        message: "Impossible de supprimer la derni\xE8re organisation de l'utilisateur"
      });
    }
    await prisma11.userOrganization.delete({
      where: { id: sanitizeString3(userOrganizationId) }
    });
    console.log(`[USERS] Suppression relation r\xE9ussie: ${userOrganizationId}`);
    res.json({ success: true, message: "Utilisateur retir\xE9 de l'organisation avec succ\xE8s" });
  } catch (error) {
    console.error("[USERS] Erreur suppression relation:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur"
    });
  }
});
router22.patch("/:userId", usersModifyRateLimit, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { userId } = req2.params;
  console.log(`[USERS] PATCH /users/${userId} - Modification informations utilisateur`);
  try {
    const userInfoSchema = import_zod5.z.object({
      firstName: import_zod5.z.string().min(1, "Pr\xE9nom requis").max(50, "Pr\xE9nom trop long").optional(),
      lastName: import_zod5.z.string().min(1, "Nom requis").max(50, "Nom trop long").optional(),
      email: import_zod5.z.string().email("Email invalide").optional(),
      phoneNumber: import_zod5.z.string().nullable().optional(),
      address: import_zod5.z.string().nullable().optional(),
      vatNumber: import_zod5.z.string().nullable().optional(),
      avatarUrl: import_zod5.z.string().url("URL avatar invalide").nullable().optional()
    });
    const validationResult2 = userInfoSchema.safeParse(req2.body);
    if (!validationResult2.success) {
      console.error("[USERS] Validation error:", validationResult2.error.errors);
      return res.status(400).json({
        success: false,
        message: "Donn\xE9es invalides",
        errors: validationResult2.error.errors
      });
    }
    const updateData = validationResult2.data;
    const sessionUser = req2.user;
    const userToUpdate = await prisma11.user.findUnique({
      where: { id: sanitizeString3(userId) }
    });
    if (!userToUpdate) {
      return res.status(404).json({
        success: false,
        message: "Utilisateur non trouv\xE9"
      });
    }
    if (!sessionUser?.isSuperAdmin) {
      const userOrganization = await prisma11.userOrganization.findFirst({
        where: {
          userId: sanitizeString3(userId),
          organizationId: sessionUser?.organizationId
        }
      });
      if (!userOrganization) {
        return res.status(403).json({
          success: false,
          message: "Vous ne pouvez modifier que les utilisateurs de votre organisation"
        });
      }
    }
    const updatedUser = await prisma11.user.update({
      where: { id: sanitizeString3(userId) },
      data: updateData,
      include: {
        UserOrganization: {
          include: {
            Role: true,
            Organization: {
              include: {
                GoogleWorkspaceConfig: true
              }
            }
          }
        }
      }
    });
    console.log(`[USERS] User ${sessionUser?.email} updated user ${updatedUser.email}`);
    res.json({
      success: true,
      message: "Informations utilisateur mises \xE0 jour avec succ\xE8s",
      data: updatedUser
    });
  } catch (error) {
    console.error("[USERS] Erreur modification utilisateur:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur lors de la modification"
    });
  }
});
router22.delete("/:userId", usersModifyRateLimit, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { userId } = req2.params;
  const sessionUser = req2.user;
  console.log(`[USERS] DELETE /users/${userId} - ADMIN/SUPER ADMIN S\xC9CURIS\xC9`);
  try {
    if (!userId || !import_zod5.z.string().min(1).safeParse(userId).success) {
      return res.status(400).json({
        success: false,
        message: "ID utilisateur invalide ou manquant"
      });
    }
    const userToDelete = await prisma11.user.findUnique({
      where: { id: sanitizeString3(userId) },
      include: { UserOrganization: true }
    });
    if (!userToDelete) {
      return res.status(404).json({
        success: false,
        message: "Utilisateur non trouv\xE9"
      });
    }
    if (userToDelete.id === sessionUser?.id) {
      return res.status(400).json({
        success: false,
        message: "Vous ne pouvez pas supprimer votre propre compte"
      });
    }
    if (!sessionUser?.isSuperAdmin) {
      const isUserFree = userToDelete.UserOrganization.length === 0;
      const isInSameOrg = userToDelete.UserOrganization.some(
        (uo) => uo.organizationId === sessionUser?.organizationId
      );
      if (!isUserFree && !isInSameOrg) {
        return res.status(403).json({
          success: false,
          message: "Vous ne pouvez supprimer que les utilisateurs libres ou de votre organisation"
        });
      }
    }
    await prisma11.$transaction(async (tx) => {
      await tx.userOrganization.deleteMany({
        where: { userId: sanitizeString3(userId) }
      });
      await tx.user.delete({
        where: { id: sanitizeString3(userId) }
      });
    });
    console.log(`[USERS] User ${sessionUser?.email} deleted user ${userToDelete.email}`);
    res.json({
      success: true,
      message: `Utilisateur ${userToDelete.email} supprim\xE9 avec succ\xE8s`
    });
  } catch (error) {
    console.error("[USERS] Erreur suppression utilisateur:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur lors de la suppression"
    });
  }
});
router22.get("/:userId/rights-summary", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { userId } = req2.params;
    const { organizationId } = req2.query;
    console.log(`[USERS] R\xE9cup\xE9ration du r\xE9sum\xE9 des droits pour utilisateur ${userId} dans organisation ${organizationId}`);
    if (!userId || !organizationId) {
      return res.status(400).json({
        success: false,
        message: "ID utilisateur et organisation requis"
      });
    }
    const userWithOrgInfo = await prisma11.user.findUnique({
      where: { id: sanitizeString3(userId) },
      include: {
        UserOrganization: {
          where: { organizationId: sanitizeString3(organizationId) },
          include: {
            Role: {
              include: {
                Permission: {
                  include: {
                    Module: true
                  }
                }
              }
            },
            Organization: {
              include: {
                Module: {
                  where: { active: true },
                  orderBy: { order: "asc" }
                },
                OrganizationModuleStatus: true
              }
            }
          }
        }
      }
    });
    if (!userWithOrgInfo) {
      return res.status(404).json({
        success: false,
        message: "Utilisateur non trouv\xE9"
      });
    }
    const userOrgRelation = userWithOrgInfo.UserOrganization[0];
    if (!userOrgRelation) {
      return res.status(404).json({
        success: false,
        message: "Utilisateur non associ\xE9 \xE0 cette organisation"
      });
    }
    const organization = userOrgRelation.Organization;
    const role = userOrgRelation.Role;
    const permissions = role.Permission;
    const permissionsByModule = {};
    permissions.forEach((permission) => {
      if (permission.allowed && permission.Module) {
        const moduleKey = permission.Module.key;
        if (!permissionsByModule[moduleKey]) {
          permissionsByModule[moduleKey] = {
            label: permission.Module.label,
            actions: []
          };
        }
        permissionsByModule[moduleKey].actions.push(permission.action);
      }
    });
    const rightsSummary = {
      userInfo: {
        id: userWithOrgInfo.id,
        email: userWithOrgInfo.email,
        firstName: userWithOrgInfo.firstName,
        lastName: userWithOrgInfo.lastName,
        accountStatus: userWithOrgInfo.status,
        lastConnection: userWithOrgInfo.updatedAt
      },
      organizationInfo: {
        id: organization.id,
        name: organization.name,
        status: organization.status,
        moduleCount: organization.Module.length
      },
      roles: [role.label],
      permissions: permissionsByModule
    };
    const isSuperAdminRole = role.label?.toLowerCase().includes("super") && role.label?.toLowerCase().includes("admin");
    if (isSuperAdminRole && Object.keys(permissionsByModule).length === 0) {
      console.log("[USERS][rights-summary] Aucun permission explicite trouv\xE9e pour un r\xF4le SuperAdmin \u2013 g\xE9n\xE9ration synth\xE9tique de toutes les permissions actives.");
      const moduleIds = organization.Module.map((m) => m.id);
      if (moduleIds.length > 0) {
        const rawPerms = await prisma11.permission.findMany({
          where: { moduleId: { in: moduleIds } },
          include: { Module: true }
        });
        const synthetic = {};
        rawPerms.forEach((p) => {
          if (!p.Module) return;
          const key2 = p.Module.key;
          if (!synthetic[key2]) {
            synthetic[key2] = { label: p.Module.label || key2, actions: [], isActive: true, synthetic: true };
          }
          if (!synthetic[key2].actions.includes(p.action)) {
            synthetic[key2].actions.push(p.action);
          }
        });
        rightsSummary.permissions = synthetic;
        rightsSummary.organizationInfo.moduleCount = Object.keys(synthetic).length;
        rightsSummary.synthetic = true;
        console.log(`[USERS][rights-summary] Permissions synth\xE9tiques g\xE9n\xE9r\xE9es: ${Object.keys(synthetic).length} modules.`);
      }
    }
    console.log(`[USERS] R\xE9sum\xE9 des droits g\xE9n\xE9r\xE9 pour ${userWithOrgInfo.email} dans ${organization.name}`);
    console.log(`[USERS] R\xF4le: ${role.label}, Permissions: ${Object.keys(rightsSummary.permissions).length} modules (synthetic=${rightsSummary.synthetic ? "yes" : "no"})`);
    res.json({
      success: true,
      data: rightsSummary
    });
  } catch (error) {
    console.error("[USERS] Erreur r\xE9cup\xE9ration r\xE9sum\xE9 des droits:", error);
    res.status(500).json({
      success: false,
      message: "Erreur interne du serveur lors de la r\xE9cup\xE9ration du r\xE9sum\xE9 des droits"
    });
  }
});
router22.post("/me/current-organization", async (req2, res) => {
  const authReq = req2;
  try {
    const userId = authReq.user?.id;
    const { organizationId } = req2.body;
    if (!userId) {
      return res.status(401).json({
        success: false,
        message: "Utilisateur non authentifi\xE9"
      });
    }
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "ID organisation requis"
      });
    }
    console.log(`[USERS] Changement d'organisation pour ${userId} vers ${organizationId}`);
    const userOrg = await prisma11.userOrganization.findFirst({
      where: {
        userId,
        organizationId
      },
      include: {
        Organization: true,
        Role: true
      }
    });
    if (!userOrg) {
      return res.status(403).json({
        success: false,
        message: "Vous n'appartenez pas \xE0 cette organisation"
      });
    }
    if (req2.session) {
      req2.session.currentOrganizationId = organizationId;
      await new Promise((resolve, reject) => {
        req2.session.save((err) => {
          if (err) reject(err);
          else resolve();
        });
      });
      console.log(`[USERS] \u2705 Organisation chang\xE9e avec succ\xE8s vers ${userOrg.Organization.name}`);
      return res.json({
        success: true,
        message: "Organisation chang\xE9e avec succ\xE8s",
        data: {
          organizationId,
          organizationName: userOrg.Organization.name,
          role: userOrg.Role.label
        }
      });
    } else {
      return res.status(500).json({
        success: false,
        message: "Session non disponible"
      });
    }
  } catch (error) {
    console.error("[USERS] Erreur changement organisation:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors du changement d'organisation"
    });
  }
});
var usersRoutes_default = router22;

// src/routes/adminPasswordRoutes.ts
var import_express24 = require("express");
var router23 = (0, import_express24.Router)();
router23.use(authenticateToken);
router23.get("/users-emails", (_req, res) => {
  console.log("[ADMIN-PASSWORD] GET /admin-password/users-emails - R\xE9cup\xE9ration des emails");
  const defaultUsersEmails = [
    {
      id: "1",
      userId: "1",
      firstName: "Admin",
      lastName: "System",
      email: "admin@2thier.be",
      organization: "2thier.be",
      hasEmailConfig: true,
      lastEmailCheck: (/* @__PURE__ */ new Date()).toISOString()
    },
    {
      id: "2",
      userId: "2",
      firstName: "John",
      lastName: "Doe",
      email: "john.doe@example.com",
      organization: "Example Corp",
      hasEmailConfig: false,
      lastEmailCheck: null
    }
  ];
  res.json(defaultUsersEmails);
});
router23.get("/users-services", (_req, res) => {
  console.log("[ADMIN-PASSWORD] GET /admin-password/users-services - R\xE9cup\xE9ration des utilisateurs et services");
  const defaultUsersServices = [
    {
      id: "1",
      userId: "1",
      firstName: "Admin",
      lastName: "System",
      email: "admin@2thier.be",
      organization: "2thier.be",
      services: {
        email: { configured: true, status: "active" },
        calendar: { configured: true, status: "active" },
        drive: { configured: false, status: "inactive" }
      }
    },
    {
      id: "2",
      userId: "2",
      firstName: "John",
      lastName: "Doe",
      email: "john.doe@example.com",
      organization: "Example Corp",
      services: {
        email: { configured: false, status: "inactive" },
        calendar: { configured: false, status: "inactive" },
        drive: { configured: false, status: "inactive" }
      }
    }
  ];
  res.json(defaultUsersServices);
});
router23.post("/configure-email", (_req, res) => {
  console.log("[ADMIN-PASSWORD] POST /admin-password/configure-email - Configuration email");
  res.status(201).json({
    success: true,
    message: "Configuration email mise \xE0 jour avec succ\xE8s",
    configuredAt: (/* @__PURE__ */ new Date()).toISOString()
  });
});
router23.put("/update-password", (_req, res) => {
  console.log("[ADMIN-PASSWORD] PUT /admin-password/update-password - Mise \xE0 jour mot de passe");
  res.json({
    success: true,
    message: "Mot de passe mis \xE0 jour avec succ\xE8s",
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  });
});
router23.get("/email-status/:userId", (req2, res) => {
  const { userId } = req2.params;
  console.log(`[ADMIN-PASSWORD] GET /admin-password/email-status/${userId} - Statut email`);
  res.json({
    userId,
    hasEmailConfig: true,
    lastSync: (/* @__PURE__ */ new Date()).toISOString(),
    status: "active"
  });
});
var adminPasswordRoutes_default = router23;

// src/routes/services.ts
var import_express25 = __toESM(require("express"), 1);
var import_express_rate_limit4 = __toESM(require("express-rate-limit"), 1);
var import_zod6 = require("zod");
init_prisma();
var router24 = import_express25.default.Router();
var servicesRateLimit = (0, import_express_rate_limit4.default)({
  windowMs: 15 * 60 * 1e3,
  // 15 minutes
  max: 100,
  // Augment√© pour les appels bulk l√©gitimes
  message: {
    success: false,
    message: "Trop de requ\xEAtes vers les services. Veuillez patienter."
  },
  standardHeaders: true,
  legacyHeaders: false
});
var serviceParamsSchema = import_zod6.z.object({
  serviceName: import_zod6.z.enum(["email", "telnyx"]),
  // Certains environnements utilisent des IDs non-UUID (cuid, etc.)
  userId: import_zod6.z.string().min(1, "ID utilisateur invalide")
});
router24.use(authMiddleware);
router24.use(servicesRateLimit);
var handleServiceToggle = async (res, userId, serviceType, isActive) => {
  try {
    const validatedUserId = import_zod6.z.string().min(1).parse(userId);
    await db.userService.upsert({
      where: {
        userId_serviceType: { userId: validatedUserId, serviceType }
      },
      update: { isActive },
      create: { userId: validatedUserId, serviceType, isActive, isConfigured: false }
    });
    res.json({
      success: true,
      message: `Service ${serviceType} mis \xE0 jour.`,
      data: { userId: validatedUserId, serviceType, isActive }
    });
  } catch (error) {
    console.error(`[API/Services] Erreur lors de la mise \xE0 jour du service ${serviceType}:`, error);
    if (error instanceof import_zod6.z.ZodError) {
      return res.status(400).json({ success: false, message: "Param\xE8tres invalides", errors: error.errors });
    }
    res.status(500).json({ success: false, message: `Impossible de mettre \xE0 jour le service ${serviceType}.` });
  }
};
var mapService = (s) => ({
  id: s.id,
  userId: s.userId,
  serviceType: s.serviceType,
  serviceName: s.serviceType.toLowerCase(),
  isActive: s.isActive,
  isConfigured: s.isConfigured,
  email: s.email ?? void 0,
  phoneNumber: s.phoneNumber ?? void 0,
  apiKey: s.apiKey ?? void 0,
  data: s.data ?? void 0,
  createdAt: s.createdAt,
  updatedAt: s.updatedAt
});
router24.get("/status/:userId", async (req2, res) => {
  try {
    const { userId } = import_zod6.z.object({ userId: import_zod6.z.string().min(1) }).parse(req2.params);
    const services = await db.userService.findMany({ where: { userId } });
    res.json({ success: true, data: services.map(mapService) });
  } catch (error) {
    console.error(`[API/Services] Erreur GET /status/${req2.params.userId}:`, error);
    if (error instanceof import_zod6.z.ZodError) {
      return res.status(400).json({ success: false, message: "ID utilisateur invalide." });
    }
    res.status(500).json({ success: false, message: "Erreur serveur." });
  }
});
router24.post("/status/bulk", async (req2, res) => {
  try {
    const { userIds } = import_zod6.z.object({ userIds: import_zod6.z.array(import_zod6.z.string().min(1)) }).parse(req2.body);
    if (userIds.length === 0) {
      return res.json({ success: true, data: {} });
    }
    const services = await db.userService.findMany({
      where: { userId: { in: userIds } }
    });
    const servicesByUser = services.reduce((acc, service) => {
      if (!acc[service.userId]) acc[service.userId] = [];
      acc[service.userId].push(mapService(service));
      return acc;
    }, {});
    res.json({ success: true, data: servicesByUser });
  } catch (error) {
    console.error("[API/Services] Erreur POST /status/bulk:", error);
    if (error instanceof import_zod6.z.ZodError) {
      return res.status(400).json({ success: false, message: "Donn\xE9es invalides." });
    }
    res.status(500).json({ success: false, message: "Erreur serveur." });
  }
});
router24.post("/:serviceName/enable/:userId", async (req2, res) => {
  const { serviceName, userId } = serviceParamsSchema.parse(req2.params);
  await handleServiceToggle(res, userId, serviceName.toUpperCase(), true);
});
router24.post("/:serviceName/disable/:userId", async (req2, res) => {
  const { serviceName, userId } = serviceParamsSchema.parse(req2.params);
  await handleServiceToggle(res, userId, serviceName.toUpperCase(), false);
});
var services_default = router24;

// src/routes/permissions.ts
var import_express26 = require("express");
init_database();
var prisma12 = db;
var router25 = (0, import_express26.Router)();
router25.use(authMiddleware, impersonationMiddleware);
var getEffectiveUser = async (req2) => {
  const originalUser = req2.user;
  const impersonatedUser = req2.impersonatedUser;
  if (originalUser && originalUser.role === "super_admin" && impersonatedUser) {
    const userOrg = await prisma12.userOrganization.findFirst({
      where: { userId: impersonatedUser.id },
      select: { organizationId: true }
    });
    return {
      userId: impersonatedUser.id,
      role: impersonatedUser.role,
      organizationId: req2.impersonatedOrganizationId || userOrg?.organizationId
    };
  }
  return req2.user;
};
router25.get("/", async (req2, res) => {
  const { roleId, organizationId } = req2.query;
  if (!req2.user) {
    res.status(401).json({ success: false, message: "Utilisateur non authentifi\xE9." });
    return;
  }
  const effectiveUser = await getEffectiveUser(req2);
  if (!effectiveUser) {
    res.status(401).json({ success: false, message: "Utilisateur effectif non d\xE9termin\xE9." });
    return;
  }
  if (!roleId) {
    res.status(400).json({ success: false, message: "Le param\xE8tre roleId est manquant" });
    return;
  }
  try {
    const role = await prisma12.role.findUnique({
      where: { id: roleId }
    });
    if (!role) {
      res.status(404).json({ success: false, message: "R\xF4le non trouv\xE9." });
      return;
    }
    const isEffectivelySuperAdmin = effectiveUser.role === "super_admin";
    if (!isEffectivelySuperAdmin) {
      if (!effectiveUser.organizationId || role.organizationId !== effectiveUser.organizationId) {
        res.status(403).json({ success: false, message: "Vous n'avez pas la permission de voir les permissions de ce r\xF4le." });
        return;
      }
    } else {
      if (organizationId && role.organizationId && role.organizationId !== organizationId) {
        res.status(403).json({ success: false, message: "Ce r\xF4le n'appartient pas \xE0 l'organisation s\xE9lectionn\xE9e." });
        return;
      }
    }
    const permissions = await prisma12.permission.findMany({
      where: {
        roleId
      }
    });
    res.json({ success: true, data: permissions });
  } catch (error) {
    console.error("[API][permissions] Erreur lors de la r\xE9cup\xE9ration des permissions :", error);
    res.status(500).json({ success: false, message: "Erreur interne du serveur" });
  }
});
router25.post("/bulk", async (req2, res) => {
  const { roleId, permissions, organizationId } = req2.body;
  if (!req2.user) {
    res.status(401).json({ success: false, message: "Utilisateur non authentifi\xE9." });
    return;
  }
  const effectiveUser = await getEffectiveUser(req2);
  if (!effectiveUser) {
    res.status(401).json({ success: false, message: "Utilisateur effectif non d\xE9termin\xE9." });
    return;
  }
  if (!roleId || !Array.isArray(permissions)) {
    res.status(400).json({ success: false, message: "Param\xE8tres invalides" });
    return;
  }
  try {
    const roleToUpdate = await prisma12.role.findUnique({
      where: { id: roleId }
    });
    if (!roleToUpdate) {
      res.status(404).json({ success: false, message: "R\xF4le non trouv\xE9." });
      return;
    }
    const isEffectivelySuperAdmin = effectiveUser.role === "super_admin";
    if (!isEffectivelySuperAdmin) {
      if (!effectiveUser.organizationId || roleToUpdate.organizationId !== effectiveUser.organizationId) {
        res.status(403).json({ success: false, message: "Vous n'avez pas la permission de modifier ce r\xF4le." });
        return;
      }
    } else {
      if (organizationId && roleToUpdate.organizationId && roleToUpdate.organizationId !== organizationId) {
        res.status(403).json({ success: false, message: "Ce r\xF4le n'appartient pas \xE0 l'organisation s\xE9lectionn\xE9e." });
        return;
      }
    }
    await prisma12.$transaction([
      prisma12.permission.deleteMany({
        where: {
          roleId
        }
      }),
      ...permissions.length > 0 ? [prisma12.permission.createMany({
        data: permissions.map((p) => ({
          id: `perm_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
          roleId,
          organizationId: roleToUpdate.organizationId || null,
          moduleId: p.moduleId,
          action: p.action,
          resource: p.resource,
          allowed: p.allowed,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        })),
        skipDuplicates: true
      })] : []
    ]);
    res.status(200).json({ success: true, message: "Permissions mises \xE0 jour avec succ\xE8s" });
  } catch (error) {
    console.error("[API][permissions/bulk] Erreur lors de la mise \xE0 jour en masse:", error);
    res.status(500).json({ success: false, message: "Erreur interne du serveur" });
  }
});
router25.post("/", async (req2, res) => {
  const { roleId, permissions, organizationId } = req2.body;
  if (!req2.user) {
    res.status(401).json({ success: false, message: "Utilisateur non authentifi\xE9." });
    return;
  }
  const effectiveUser = await getEffectiveUser(req2);
  if (!effectiveUser) {
    res.status(401).json({ success: false, message: "Utilisateur effectif non d\xE9termin\xE9." });
    return;
  }
  if (!roleId || !Array.isArray(permissions)) {
    res.status(400).json({ success: false, message: "Param\xE8tres invalides" });
    return;
  }
  try {
    const roleToUpdate = await prisma12.role.findUnique({
      where: { id: roleId }
    });
    if (!roleToUpdate) {
      res.status(404).json({ success: false, message: "R\xF4le non trouv\xE9." });
      return;
    }
    const isEffectivelySuperAdmin = effectiveUser.role === "super_admin";
    if (!isEffectivelySuperAdmin) {
      if (!effectiveUser.organizationId || roleToUpdate.organizationId !== effectiveUser.organizationId) {
        res.status(403).json({ success: false, message: "Vous n'avez pas la permission de modifier ce r\xF4le." });
        return;
      }
    } else {
      if (organizationId && roleToUpdate.organizationId && roleToUpdate.organizationId !== organizationId) {
        res.status(403).json({ success: false, message: "Ce r\xF4le n'appartient pas \xE0 l'organisation s\xE9lectionn\xE9e." });
        return;
      }
    }
    await prisma12.$transaction([
      prisma12.permission.deleteMany({
        where: {
          roleId
        }
      }),
      ...permissions.length > 0 ? [prisma12.permission.createMany({
        data: permissions.map((p) => ({
          id: `perm_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
          roleId,
          organizationId: roleToUpdate.organizationId || null,
          moduleId: p.moduleId,
          action: p.action,
          resource: p.resource,
          allowed: p.allowed,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        })),
        skipDuplicates: true
      })] : []
    ]);
    res.status(200).json({ success: true, message: "Permissions mises \xE0 jour avec succ\xE8s" });
  } catch (error) {
    console.error("[API][permissions] Erreur lors de la mise \xE0 jour:", error);
    res.status(500).json({ success: false, message: "Erreur interne du serveur" });
  }
});
var permissions_default = router25;

// src/routes/admin.ts
var import_express27 = __toESM(require("express"), 1);
init_database();
init_crypto();
var prisma13 = db;
var router26 = import_express27.default.Router();
router26.use(authMiddleware, impersonationMiddleware);
router26.get("/users/:id", requireRole2(["super_admin"]), async (req2, res) => {
  const { id } = req2.params;
  try {
    const user = await prisma13.user.findUnique({
      where: { id },
      select: {
        // On ne s√©lectionne que les champs n√©cessaires
        id: true,
        email: true,
        firstName: true,
        lastName: true,
        role: true,
        status: true
      }
    });
    if (!user) {
      res.status(404).json({ error: "Utilisateur non trouv\xE9" });
      return;
    }
    res.json(user);
  } catch (error) {
    console.error(`Erreur lors de la r\xE9cup\xE9ration de l'utilisateur ${id}:`, error);
    res.status(500).json({ error: "Erreur interne du serveur" });
  }
});
router26.get("/users/mail-status", requireRole2(["super_admin"]), async (_req, res) => {
  try {
    const users = await prisma13.user.findMany({
      include: {
        mailSettings: true
      }
    });
    const usersWithMailStatus = users.map((user) => {
      return {
        id: user.id,
        email: user.email,
        name: `${user.firstName || ""} ${user.lastName || ""}`.trim() || user.email,
        isMailConfigured: user.mailSettings?.isVerified ?? false
      };
    });
    res.json(usersWithMailStatus);
  } catch (error) {
    console.error("Erreur lors de la r\xE9cup\xE9ration des utilisateurs:", error);
    res.status(500).json({ error: "Erreur interne du serveur" });
  }
});
router26.post("/mail/settings", requireRole2(["super_admin"]), async (req2, res) => {
  const { userId, password } = req2.body;
  if (!userId || !password) {
    res.status(400).json({ error: "L'ID de l'utilisateur et le mot de passe sont requis." });
    return;
  }
  try {
    const user = await prisma13.user.findUnique({ where: { id: userId } });
    if (!user) {
      res.status(404).json({ error: "Utilisateur non trouv\xE9." });
      return;
    }
    const userName = `${user.firstName || ""} ${user.lastName || ""}`.trim();
    if (!userName) {
      res.status(400).json({ error: "Le nom de l'utilisateur n'est pas d\xE9fini, impossible de cr\xE9er l'adresse email." });
      return;
    }
    const encryptedPassword = encrypt(password);
    const userEmail = `${userName.replace(/\s+/g, ".").toLowerCase()}@2thier.be`;
    await prisma13.mailSettings.upsert({
      where: { userId },
      update: {
        encryptedPassword,
        isVerified: true
      },
      create: {
        userId,
        emailAddress: userEmail,
        encryptedPassword,
        imapHost: "imap.one.com",
        imapPort: 993,
        smtpHost: "mail.one.com",
        smtpPort: 465,
        isVerified: true
      }
    });
    res.status(200).json({ message: "Configuration mail mise \xE0 jour avec succ\xE8s." });
  } catch (error) {
    console.error("Erreur lors de la mise \xE0 jour de la configuration mail:", error);
    res.status(500).json({ error: "Erreur interne du serveur" });
  }
});
router26.get("/mail/settings", async (req2, res) => {
  try {
    const userId = req2.user?.userId;
    if (!userId) {
      res.status(401).json({ error: "Utilisateur non authentifi\xE9." });
      return;
    }
    const mailSettings = await prisma13.mailSettings.findUnique({
      where: { userId }
    });
    if (!mailSettings) {
      res.status(404).json({ error: "Aucune configuration mail trouv\xE9e pour cet utilisateur." });
      return;
    }
    const { encryptedPassword: _encryptedPassword, ...settings } = mailSettings;
    res.status(200).json(settings);
  } catch (error) {
    console.error("Erreur lors de la r\xE9cup\xE9ration des param\xE8tres mail:", error);
    res.status(500).json({ error: "Erreur interne du serveur" });
  }
});
var admin_default = router26;

// src/routes/impersonate.ts
var import_express28 = require("express");
var router27 = (0, import_express28.Router)();
router27.post("/", authMiddleware, async (req2, res) => {
  try {
    const { userId, organizationId } = req2.body;
    console.log("[Impersonate Route] Nouvelle demande d'usurpation:", { userId, organizationId });
    const currentUser = req2.user;
    if (!currentUser || currentUser.role !== "super_admin") {
      console.log("[Impersonate Route] Acc\xE8s refus\xE9 - utilisateur non super admin");
      return res.status(403).json({
        success: false,
        message: "Seuls les super administrateurs peuvent usurper l'identit\xE9"
      });
    }
    console.log("[Impersonate Route] Usurpation autoris\xE9e pour:", { userId, organizationId });
    return res.json({
      success: true,
      message: "Usurpation d'identit\xE9 activ\xE9e",
      impersonation: {
        userId: userId || null,
        organizationId: organizationId || null
      }
    });
  } catch (error) {
    console.error("[Impersonate Route] Erreur:", error);
    return res.status(500).json({
      success: false,
      message: "Erreur lors de la configuration de l'usurpation"
    });
  }
});
router27.delete("/", authMiddleware, async (req2, res) => {
  try {
    const currentUser = req2.user;
    if (!currentUser || currentUser.role !== "super_admin") {
      return res.status(403).json({
        success: false,
        message: "Seuls les super administrateurs peuvent arr\xEAter l'usurpation"
      });
    }
    console.log("[Impersonate Route] Arr\xEAt de l'usurpation demand\xE9");
    return res.json({
      success: true,
      message: "Usurpation d'identit\xE9 d\xE9sactiv\xE9e"
    });
  } catch (error) {
    console.error("[Impersonate Route] Erreur lors de l'arr\xEAt:", error);
    return res.status(500).json({
      success: false,
      message: "Erreur lors de l'arr\xEAt de l'usurpation"
    });
  }
});
var impersonate_default = router27;

// src/routes/calendar.ts
var import_express29 = require("express");

// src/middlewares/impersonation.js
var impersonationMiddleware2 = (req2, res, next) => {
  next();
};

// src/routes/calendar.ts
init_prisma();
var router28 = (0, import_express29.Router)();
router28.use((req2, _res, next) => {
  try {
    const hasUser = Boolean(req2.user);
    console.log(`[CALENDAR ROUTES][TRACE] ${req2.method} ${req2.originalUrl} avant middlewares sp\xE9cifiques - user?`, hasUser);
  } catch (e) {
    console.warn("[CALENDAR ROUTES][TRACE] logging pr\xE9-middleware \xE9chou\xE9", e);
  }
  next();
});
var sseClients = [];
function broadcast(orgId, event, payload) {
  const data = `event: ${event}
data: ${JSON.stringify(payload)}

`;
  sseClients.filter((c) => c.organizationId === orgId).forEach((c) => c.res.write(data));
}
function initSSE(req2, res) {
  if (!req2.user) {
    console.log("[CALENDAR ROUTES][SSE] \u274C Rejet connexion SSE: pas de user");
    return res.status(401).end();
  }
  let organizationId = req2.user.organizationId;
  if (!organizationId && req2.query.organizationId && req2.user.role === "super_admin") {
    organizationId = String(req2.query.organizationId);
    console.log("[CALENDAR ROUTES][SSE] \u2699\uFE0F Fallback organizationId depuis query pour super_admin:", organizationId);
  }
  if (!organizationId) {
    console.log("[CALENDAR ROUTES][SSE] \u274C Aucun organizationId d\xE9termin\xE9");
    return res.status(400).json({ error: "organizationId manquant pour SSE" });
  }
  console.log("[CALENDAR ROUTES][SSE] \u2705 Connexion SSE accept\xE9e pour org", organizationId);
  res.setHeader("Content-Type", "text/event-stream");
  res.setHeader("Cache-Control", "no-cache");
  res.setHeader("Connection", "keep-alive");
  res.flushHeaders?.();
  const clientId = Date.now().toString() + Math.random();
  sseClients.push({ id: clientId, res, organizationId });
  res.write(`event: connected
data: {"clientId":"${clientId}"}

`);
  req2.on("close", () => {
    const idx = sseClients.findIndex((c) => c.id === clientId);
    if (idx !== -1) sseClients.splice(idx, 1);
  });
}
router28.use(authMiddleware, impersonationMiddleware2);
router28.get("/stream", (req2, res) => {
  initSSE(req2, res);
});
router28.get("/events", async (req2, res) => {
  try {
    console.log("[CALENDAR ROUTES] GET /events - D\xE9but de la requ\xEAte");
    const { userId, startDate, endDate, forceSync } = req2.query;
    const userIdToSearch = userId || req2.user.userId;
    const organizationId = req2.user.organizationId;
    const whereClause = {
      organizationId,
      OR: [
        { ownerId: userIdToSearch },
        { CalendarParticipant: { some: { userId: userIdToSearch } } }
      ]
    };
    if (startDate && endDate) {
      whereClause.startDate = { gte: new Date(startDate), lte: new Date(endDate) };
    }
    let events = await db.calendarEvent.findMany({
      where: whereClause,
      include: {
        CalendarParticipant: { include: { User: { select: { id: true, firstName: true, lastName: true, email: true } } } },
        User: { select: { id: true, firstName: true, lastName: true, email: true } }
      },
      orderBy: { startDate: "asc" }
    });
    console.log("[CALENDAR ROUTES] \xC9v\xE9nements locaux trouv\xE9s:", events.length);
    try {
      const todayStart = /* @__PURE__ */ new Date();
      todayStart.setHours(0, 0, 0, 0);
      const notesToCarry = events.filter((e) => e.type === "note" && e.status !== "done" && e.startDate < todayStart && (!e.dueDate || e.dueDate >= todayStart));
      if (notesToCarry.length) {
        console.log("[CALENDAR ROUTES] \u{1F501} Report automatique de", notesToCarry.length, "notes non termin\xE9es");
        for (const n of notesToCarry) {
          await db.calendarEvent.update({
            where: { id: n.id },
            data: {
              startDate: todayStart,
              endDate: null,
              // allDay; pas n√©cessaire
              allDay: true
            }
          });
        }
        events = await db.calendarEvent.findMany({
          where: whereClause,
          include: {
            CalendarParticipant: { include: { User: { select: { id: true, firstName: true, lastName: true, email: true } } } },
            User: { select: { id: true, firstName: true, lastName: true, email: true } }
          },
          orderBy: { startDate: "asc" }
        });
      }
    } catch (carryErr) {
      console.warn("[CALENDAR ROUTES] \u26A0\uFE0F Erreur report notes:", carryErr);
    }
    const needSync = forceSync === "true" || events.length === 0;
    if (needSync) {
      console.log("[CALENDAR ROUTES] \u{1F504} Lancement auto-sync Google Calendar (needSync=", needSync, ")");
      try {
        const syncStart = startDate ? new Date(startDate) : new Date(Date.now() - 7 * 24 * 3600 * 1e3);
        const syncEnd = endDate ? new Date(endDate) : new Date(Date.now() + 30 * 24 * 3600 * 1e3);
        const googleEvents = await googleCalendarService.syncEvents(organizationId, syncStart, syncEnd, userIdToSearch);
        console.log("[CALENDAR ROUTES] Google events r\xE9cup\xE9r\xE9s:", googleEvents.length);
        for (const gEvent of googleEvents) {
          const gId = gEvent.id;
          if (!gId || !gEvent.start?.dateTime || !gEvent.end?.dateTime) continue;
          const existing = await db.calendarEvent.findFirst({
            where: { organizationId, externalCalendarId: gId }
          });
          const baseData = {
            id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
            title: gEvent.summary || "Sans titre",
            description: gEvent.description || null,
            startDate: new Date(gEvent.start.dateTime),
            endDate: new Date(gEvent.end.dateTime),
            type: "google_sync",
            status: "synced",
            organizationId,
            ownerId: userIdToSearch,
            externalCalendarId: gId,
            updatedAt: /* @__PURE__ */ new Date()
          };
          if (existing) {
            await db.calendarEvent.update({ where: { id: existing.id }, data: baseData });
          } else {
            await db.calendarEvent.create({ data: baseData });
          }
        }
        events = await db.calendarEvent.findMany({
          where: whereClause,
          include: {
            CalendarParticipant: { include: { User: { select: { id: true, firstName: true, lastName: true, email: true } } } },
            User: { select: { id: true, firstName: true, lastName: true, email: true } }
          },
          orderBy: { startDate: "asc" }
        });
        console.log("[CALENDAR ROUTES] \xC9v\xE9nements apr\xE8s auto-sync:", events.length);
      } catch (syncError) {
        console.warn("[CALENDAR ROUTES] \u26A0\uFE0F Auto-sync \xE9chou\xE9e (les \xE9v\xE9nements locaux restent affich\xE9s):", syncError);
      }
    }
    return res.json(events);
  } catch (error) {
    console.error("Erreur r\xE9cup\xE9ration \xE9v\xE9nements:", error);
    return res.status(500).json({ error: "Erreur serveur" });
  }
});
router28.get("/ai-suggestions", async (req2, res) => {
  try {
    const { leadId } = req2.query;
    const organizationId = req2.user.organizationId;
    if (!leadId) {
      return res.status(400).json({ error: "Param\xE8tre leadId requis" });
    }
    const lead = await db.lead.findFirst({
      where: { id: leadId, organizationId },
      select: { id: true, firstName: true, lastName: true, lastContactDate: true, nextFollowUpDate: true, status: true, createdAt: true }
    });
    if (!lead) return res.status(404).json({ error: "Lead introuvable" });
    const horizonDays = 5;
    const now = /* @__PURE__ */ new Date();
    const horizon = /* @__PURE__ */ new Date();
    horizon.setDate(horizon.getDate() + horizonDays);
    const events = await db.calendarEvent.findMany({
      where: {
        organizationId,
        startDate: { gte: now, lte: horizon }
      },
      select: { id: true, startDate: true, endDate: true, title: true }
    });
    const isBusy = (slotStart, slotEnd) => {
      return events.some((ev) => {
        const evStart = ev.startDate;
        const evEnd = ev.endDate || new Date(ev.startDate.getTime() + 30 * 6e4);
        return evStart < slotEnd && evEnd > slotStart;
      });
    };
    const candidateHours = [9, 9.5, 10, 10.5, 11, 14, 14.5, 15, 15.5, 16];
    const suggestions = [];
    for (let d = 0; d < horizonDays; d++) {
      const day = new Date(now.getFullYear(), now.getMonth(), now.getDate() + d, 0, 0, 0, 0);
      for (const h of candidateHours) {
        const hour = Math.floor(h);
        const minutes = h % 1 ? 30 : 0;
        const slotStart = new Date(day.getFullYear(), day.getMonth(), day.getDate(), hour, minutes, 0, 0);
        if (slotStart < now) continue;
        const slotEnd = new Date(slotStart.getTime() + 30 * 6e4);
        const busy = isBusy(slotStart, slotEnd);
        let score = 50;
        const reasons = [];
        if (!busy) {
          score += 15;
          reasons.push("Cr\xE9neau libre");
        } else {
          score -= 25;
          reasons.push("Conflit calendrier");
        }
        const within48h = slotStart.getTime() - now.getTime() <= 48 * 3600 * 1e3;
        if (within48h) {
          score += 10;
          reasons.push("Suivi rapide (<48h)");
        }
        if (hour >= 9 && hour <= 11) {
          score += 5;
          reasons.push("Matin propice");
        }
        if (hour >= 14 && hour <= 16 && !within48h) {
          score += 3;
          reasons.push("Cr\xE9neau stable");
        }
        if (lead.lastContactDate) {
          const daysSinceLast = (now.getTime() - new Date(lead.lastContactDate).getTime()) / 864e5;
          if (daysSinceLast > 5) {
            score += 7;
            reasons.push("Relance n\xE9cessaire");
          }
        } else {
          score += 6;
          reasons.push("Aucun contact pr\xE9alable");
        }
        if (lead.nextFollowUpDate) {
          const diff = Math.abs(new Date(lead.nextFollowUpDate).getTime() - slotStart.getTime()) / 864e5;
          if (diff <= 1.5) {
            score += 8;
            reasons.push("Align\xE9 \xE0 la prochaine relance");
          }
        }
        if (score > 100) score = 100;
        if (score < 0) score = 0;
        const type = score >= 85 ? "best" : score >= 70 ? "good" : "ok";
        suggestions.push({
          date: slotStart.toISOString(),
          endDate: slotEnd.toISOString(),
          score,
          type,
          reason: reasons.join(" \xB7 "),
          evidence: {
            busy,
            within48h,
            lastContactDate: lead.lastContactDate,
            nextFollowUpDate: lead.nextFollowUpDate
          }
        });
      }
    }
    const filtered = suggestions.filter((s) => s.score >= 55).sort((a, b) => b.score - a.score).slice(0, 25);
    res.json({ success: true, data: filtered });
  } catch (error) {
    console.error("[CALENDAR ROUTES] Erreur ai-suggestions:", error);
    res.status(500).json({ error: "Erreur g\xE9n\xE9ration suggestions" });
  }
});
router28.post("/sync", async (req2, res) => {
  try {
    const userId = req2.user.userId;
    const organizationId = req2.user.organizationId;
    const { startDate, endDate } = req2.body;
    const syncStart = startDate ? new Date(startDate) : new Date(Date.now() - 7 * 24 * 3600 * 1e3);
    const syncEnd = endDate ? new Date(endDate) : new Date(Date.now() + 30 * 24 * 3600 * 1e3);
    console.log("[CALENDAR SYNC] D\xE9but sync pour org:", organizationId, "du", syncStart, "au", syncEnd);
    const googleEvents = await googleCalendarService.syncEvents(
      organizationId,
      syncStart,
      syncEnd,
      req2.user.userId
    );
    let createdCount = 0;
    let updatedCount = 0;
    for (const gEvent of googleEvents) {
      if (!gEvent.start?.dateTime || !gEvent.end?.dateTime) continue;
      const existingEvent = gEvent.id ? await db.calendarEvent.findFirst({
        where: { organizationId, externalCalendarId: gEvent.id }
      }) : null;
      const eventData = {
        id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
        title: gEvent.summary || "Sans titre",
        description: gEvent.description || null,
        startDate: new Date(gEvent.start.dateTime),
        endDate: new Date(gEvent.end.dateTime),
        type: "google_sync",
        status: "synced",
        organizationId,
        ownerId: userId,
        externalCalendarId: gEvent.id || null,
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (existingEvent) {
        await db.calendarEvent.update({ where: { id: existingEvent.id }, data: eventData });
        updatedCount++;
      } else {
        await db.calendarEvent.create({ data: eventData });
        createdCount++;
      }
    }
    res.json({ message: "Synchronisation termin\xE9e.", created: createdCount, updated: updatedCount });
  } catch (error) {
    console.error("Erreur de synchronisation Google Calendar:", error);
    res.status(500).json({ error: "Erreur lors de la synchronisation." });
  }
});
router28.post("/events", async (req2, res) => {
  try {
    console.log("[CALENDAR ROUTES] POST /events - D\xE9but cr\xE9ation \xE9v\xE9nement");
    console.log("[CALENDAR ROUTES] Body:", req2.body);
    console.log("[CALENDAR ROUTES] User:", req2.user);
    const eventData = req2.body;
    const userId = req2.user.userId;
    const organizationId = req2.user.organizationId;
    console.log("[CALENDAR ROUTES] userId:", userId);
    console.log("[CALENDAR ROUTES] organizationId:", organizationId);
    console.log("[CALENDAR ROUTES] eventData BRUT:", eventData);
    const prismaData = {
      id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
      title: eventData.title,
      description: eventData.description || null,
      startDate: eventData.start || eventData.startDate,
      endDate: eventData.end || eventData.endDate,
      allDay: eventData.isAllDay || eventData.allDay || false,
      type: eventData.category || eventData.type || "rendez-vous",
      // üéØ category ‚Üí type
      status: eventData.priority || eventData.status || "normal",
      // üéØ priority ‚Üí status  
      notes: eventData.notes || null,
      location: eventData.location || null,
      ownerId: userId,
      organizationId,
      updatedAt: /* @__PURE__ */ new Date()
    };
    console.log("[CALENDAR ROUTES] Donn\xE9es pr\xE9par\xE9es pour Prisma:", prismaData);
    console.log("[CALENDAR ROUTES] Champs mapp\xE9s correctement:", {
      "category \u2192 type": eventData.category + " \u2192 " + prismaData.type,
      "priority \u2192 status": eventData.priority + " \u2192 " + prismaData.status,
      "organizer": eventData.organizer + " (ignor\xE9 - pas de champ dans Prisma)"
    });
    const event = await db.calendarEvent.create({
      data: prismaData
    });
    console.log("[CALENDAR ROUTES] \xC9v\xE9nement cr\xE9\xE9:", event);
    try {
      const googleEventData = {
        summary: event.title,
        description: event.description,
        start: {
          dateTime: new Date(event.startDate).toISOString(),
          timeZone: "Europe/Brussels"
        },
        end: {
          dateTime: new Date(event.endDate).toISOString(),
          timeZone: "Europe/Brussels"
        }
      };
      const externalCalendarId = await googleCalendarService.createEvent(organizationId, googleEventData, req2.user.userId);
      const updatedEvent = await db.calendarEvent.update({
        where: { id: event.id },
        data: {
          externalCalendarId
        },
        include: {
          project: { select: { id: true, name: true, clientName: true } },
          lead: { select: { id: true, firstName: true, lastName: true, email: true } }
        }
      });
      broadcast(organizationId, "event.created", updatedEvent);
      return res.status(201).json(updatedEvent);
    } catch (googleError) {
      console.warn("[CALENDAR ROUTES] Erreur Google Calendar (\xE9v\xE9nement cr\xE9\xE9 en local):", googleError);
    }
    broadcast(organizationId, "event.created", event);
    res.status(201).json(event);
  } catch (error) {
    console.error("Erreur cr\xE9ation \xE9v\xE9nement:", error);
    res.status(500).json({ error: "Erreur lors de la cr\xE9ation de l'\xE9v\xE9nement" });
  }
});
router28.post("/notes", async (req2, res) => {
  const startedAt = Date.now();
  console.log("\n[CALENDAR ROUTES] \u25B6 POST /notes - D\xE9but");
  console.log("[CALENDAR ROUTES] \u25B6 Body re\xE7u:", req2.body);
  try {
    const { title, description, dueDate, priority, category } = req2.body;
    let organizationId = req2.user?.organizationId;
    if (!organizationId && req2.user?.role === "super_admin" && (req2.body.organizationId || req2.query.organizationId)) {
      organizationId = String(req2.body.organizationId || req2.query.organizationId);
      console.log("[CALENDAR ROUTES][POST /notes] \u2699\uFE0F Fallback organizationId super_admin:", organizationId);
    }
    if (!organizationId) {
      console.warn("[CALENDAR ROUTES][POST /notes] \u274C organizationId introuvable");
      return res.status(400).json({ error: "organizationId requis" });
    }
    const ownerId = req2.user.userId;
    if (!title || typeof title !== "string") {
      console.warn("[CALENDAR ROUTES] \u26A0\uFE0F Titre manquant ou invalide");
      return res.status(400).json({ error: "Titre requis" });
    }
    const allowedPriorities = ["low", "medium", "high", "urgent"];
    const normalizedPriority = priority && allowedPriorities.includes(priority) ? priority : null;
    const safeCategory = category ? String(category).slice(0, 64) : null;
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    let parsedDue = null;
    if (dueDate) {
      try {
        parsedDue = new Date(dueDate);
        if (isNaN(parsedDue.getTime())) {
          console.warn("[CALENDAR ROUTES] \u26A0\uFE0F dueDate invalide, ignor\xE9e:", dueDate);
          parsedDue = null;
        }
      } catch (e) {
        console.warn("[CALENDAR ROUTES] \u26A0\uFE0F Erreur parsing dueDate, ignor\xE9e:", dueDate, e);
        parsedDue = null;
      }
    }
    console.log("[CALENDAR ROUTES] \u2714 Donn\xE9es normalis\xE9es:", { title, hasDescription: !!description, parsedDue, normalizedPriority, safeCategory, organizationId, ownerId });
    const data = {
      id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
      title,
      description: description || null,
      startDate: today,
      endDate: null,
      allDay: true,
      type: "note",
      status: "pending",
      dueDate: parsedDue,
      priority: normalizedPriority,
      category: safeCategory,
      organizationId,
      ownerId,
      updatedAt: /* @__PURE__ */ new Date()
    };
    console.log("[CALENDAR ROUTES] \u2795 Cr\xE9ation Prisma calendarEvent avec data:", data);
    let note;
    try {
      note = await db.calendarEvent.create({ data });
    } catch (prismaCreateError) {
      console.error("[CALENDAR ROUTES] \u274C Prisma create a \xE9chou\xE9");
      if (prismaCreateError?.code) {
        console.error("[CALENDAR ROUTES] \u274C Prisma error code:", prismaCreateError.code, "meta:", prismaCreateError.meta);
      }
      console.error("[CALENDAR ROUTES] \u274C D\xE9tails erreur:", prismaCreateError);
      throw prismaCreateError;
    }
    console.log("[CALENDAR ROUTES] \u2705 Note cr\xE9\xE9e:", { id: note.id, title: note.title });
    broadcast(organizationId, "note.created", note);
    const duration = Date.now() - startedAt;
    console.log("[CALENDAR ROUTES] \u23F1 Dur\xE9e cr\xE9ation note ms:", duration);
    res.status(201).json(note);
  } catch (error) {
    const duration = Date.now() - startedAt;
    console.error("[CALENDAR ROUTES] \u274C Erreur cr\xE9ation note apr\xE8s", duration, "ms");
    if (error instanceof Error) {
      console.error("[CALENDAR ROUTES] \u274C Stack:", error.stack);
    } else {
      console.error("[CALENDAR ROUTES] \u274C Valeur erreur non-Error:", error);
    }
    const prismaErr = error;
    if (prismaErr && typeof prismaErr === "object" && "code" in prismaErr && prismaErr.code) {
      console.error("[CALENDAR ROUTES] \u274C Prisma code:", prismaErr.code, "meta:", prismaErr.meta);
    }
    res.status(500).json({ error: "Erreur cr\xE9ation note" });
  }
});
router28.patch("/notes/:id/done", async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.user.organizationId;
    const existing = await db.calendarEvent.findFirst({ where: { id, organizationId, type: "note" } });
    if (!existing) return res.status(404).json({ error: "Note introuvable" });
    const updated = await db.calendarEvent.update({
      where: { id },
      data: { status: "done", completedAt: /* @__PURE__ */ new Date() }
    });
    broadcast(organizationId, "note.updated", updated);
    res.json(updated);
  } catch (error) {
    console.error("[CALENDAR ROUTES] Erreur completion note:", error);
    res.status(500).json({ error: "Erreur completion note" });
  }
});
router28.get("/notes/summary", async (req2, res) => {
  try {
    const organizationId = req2.user.organizationId;
    const todayStart = /* @__PURE__ */ new Date();
    todayStart.setHours(0, 0, 0, 0);
    const active = await db.calendarEvent.findMany({
      where: { organizationId, type: "note", status: { not: "done" } },
      select: { id: true, dueDate: true, startDate: true, title: true }
    });
    const overdue = active.filter((n) => n.dueDate && n.dueDate < todayStart).map((n) => n.id);
    res.json({ totalActive: active.length, overdueCount: overdue.length, overdueIds: overdue });
  } catch (e) {
    console.error("[CALENDAR ROUTES] Erreur notes/summary:", e);
    res.status(500).json({ error: "Erreur summary notes" });
  }
});
router28.get("/notes/history", async (req2, res) => {
  try {
    const organizationId = req2.user.organizationId;
    const { from, to, format } = req2.query;
    const where = { organizationId, type: "note", status: "done", completedAt: { not: null } };
    if (from || to) {
      where.startDate = {};
      if (from) where.startDate.gte = /* @__PURE__ */ new Date(from + "T00:00:00");
      if (to) where.startDate.lte = /* @__PURE__ */ new Date(to + "T23:59:59");
    }
    const notes = await db.calendarEvent.findMany({ where, orderBy: { completedAt: "desc" } });
    const enriched = notes.map((n) => ({
      id: n.id,
      title: n.title,
      description: n.description,
      createdDate: n.startDate,
      dueDate: n.dueDate,
      completedAt: n.completedAt,
      completionDelayMinutes: n.completedAt && n.startDate ? Math.round((n.completedAt.getTime() - n.startDate.getTime()) / 6e4) : null,
      overdue: n.dueDate && n.completedAt ? n.completedAt > n.dueDate : false,
      priority: n.priority,
      category: n.category
    }));
    if (format === "csv") {
      const header = "id;title;createdDate;dueDate;completedAt;completionDelayMinutes;overdue;priority;category";
      const rows = enriched.map((e) => [e.id, e.title.replace(/;/g, ","), e.createdDate?.toISOString(), e.dueDate?.toISOString() || "", e.completedAt?.toISOString() || "", e.completionDelayMinutes ?? "", e.overdue, e.priority || "", e.category || ""].join(";"));
      const csv = [header, ...rows].join("\n");
      res.setHeader("Content-Type", "text/csv; charset=utf-8");
      return res.send(csv);
    }
    res.json({ success: true, data: enriched });
  } catch (e) {
    console.error("[CALENDAR ROUTES] Erreur notes/history:", e);
    res.status(500).json({ error: "Erreur history notes" });
  }
});
router28.put("/events/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const eventData = req2.body;
    const organizationId = req2.user.organizationId;
    const updatedEvent = await db.calendarEvent.update({
      where: { id, organizationId },
      data: eventData
    });
    if (updatedEvent.externalCalendarId) {
      try {
        const googleEventData = {
          summary: updatedEvent.title,
          description: updatedEvent.description,
          start: {
            dateTime: new Date(updatedEvent.startDate).toISOString(),
            timeZone: "Europe/Brussels"
          },
          end: {
            dateTime: new Date(updatedEvent.endDate).toISOString(),
            timeZone: "Europe/Brussels"
          }
        };
        await googleCalendarService.updateEvent(organizationId, updatedEvent.externalCalendarId, googleEventData, req2.user.userId);
      } catch (googleError) {
        console.warn("[CALENDAR ROUTES] Erreur mise \xE0 jour Google Calendar:", googleError);
      }
    }
    res.json(updatedEvent);
  } catch (error) {
    console.error("Erreur modification \xE9v\xE9nement:", error);
    res.status(500).json({ error: "Erreur lors de la modification de l'\xE9v\xE9nement" });
  }
});
router28.delete("/events/:id", async (req2, res) => {
  try {
    console.log("[CALENDAR ROUTES] DELETE /events/:id - D\xE9but suppression");
    const { id } = req2.params;
    const organizationId = req2.user.organizationId;
    console.log("[CALENDAR ROUTES] ID \xE0 supprimer:", id);
    console.log("[CALENDAR ROUTES] OrganizationId:", organizationId);
    const eventToDelete = await db.calendarEvent.findUnique({ where: { id, organizationId } });
    console.log("[CALENDAR ROUTES] \xC9v\xE9nement trouv\xE9:", eventToDelete);
    if (!eventToDelete) {
      console.log("[CALENDAR ROUTES] \u274C \xC9v\xE9nement non trouv\xE9");
      return res.status(404).json({ error: "\xC9v\xE9nement non trouv\xE9." });
    }
    console.log("[CALENDAR ROUTES] \u{1F5D1}\uFE0F Suppression de l'\xE9v\xE9nement...");
    await db.calendarEvent.delete({ where: { id } });
    console.log("[CALENDAR ROUTES] \u2705 \xC9v\xE9nement supprim\xE9 de la base de donn\xE9es");
    if (eventToDelete.externalCalendarId) {
      try {
        console.log("[CALENDAR ROUTES] \u{1F504} Suppression de Google Calendar...");
        await googleCalendarService.deleteEvent(organizationId, eventToDelete.externalCalendarId, req2.user.userId);
        console.log("[CALENDAR ROUTES] \u2705 \xC9v\xE9nement supprim\xE9 de Google Calendar");
      } catch (googleError) {
        console.warn("[CALENDAR ROUTES] \u26A0\uFE0F Erreur suppression Google Calendar:", googleError);
      }
    }
    console.log("[CALENDAR ROUTES] \u2705 Suppression termin\xE9e avec succ\xE8s");
    res.json({ message: "\xC9v\xE9nement supprim\xE9 avec succ\xE8s" });
  } catch (error) {
    console.error("[CALENDAR ROUTES] \u274C Erreur suppression \xE9v\xE9nement:", error);
    res.status(500).json({ error: "Erreur lors de la suppression de l'\xE9v\xE9nement" });
  }
});
var calendar_default = router28;

// src/routes/clients.ts
var import_express30 = require("express");
init_database();
var router29 = (0, import_express30.Router)();
var prisma14 = db;
router29.use(authenticateToken);
router29.get("/", async (req2, res) => {
  try {
    console.log("[CLIENTS] R\xE9cup\xE9ration des clients pour l'organisation:", req2.organizationId);
    const leads = await prisma14.lead.findMany({
      where: {
        organizationId: req2.organizationId,
        // Filtrer pour obtenir les leads qui sont devenus des clients
        OR: [
          { status: { contains: "client", mode: "insensitive" } },
          { status: { contains: "converti", mode: "insensitive" } },
          { status: { contains: "actif", mode: "insensitive" } }
        ]
      },
      include: {
        assignedTo: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        leadStatus: true
      },
      orderBy: {
        updatedAt: "desc"
      }
    });
    const clients = leads.map((lead) => {
      const data = lead.data || {};
      return {
        id: lead.id,
        name: data.company || data.name || `Lead ${lead.id.slice(0, 8)}`,
        email: data.email || data.contactEmail || "",
        phone: data.phone || data.phoneNumber || "",
        company: data.company || "",
        status: lead.status,
        assignedTo: lead.assignedTo,
        createdAt: lead.createdAt,
        updatedAt: lead.updatedAt
      };
    });
    console.log(`[CLIENTS] ${clients.length} clients trouv\xE9s`);
    res.json(clients);
  } catch (error) {
    console.error("[CLIENTS] Erreur lors de la r\xE9cup\xE9ration des clients:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration des clients",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router29.get("/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    console.log("[CLIENTS] R\xE9cup\xE9ration du client:", id);
    const lead = await prisma14.lead.findFirst({
      where: {
        id,
        organizationId: req2.organizationId
      },
      include: {
        assignedTo: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        leadStatus: true
      }
    });
    if (!lead) {
      return res.status(404).json({ error: "Client non trouv\xE9" });
    }
    const data = lead.data || {};
    const client = {
      id: lead.id,
      name: data.company || data.name || `Lead ${lead.id.slice(0, 8)}`,
      email: data.email || data.contactEmail || "",
      phone: data.phone || data.phoneNumber || "",
      company: data.company || "",
      status: lead.status,
      assignedTo: lead.assignedTo,
      createdAt: lead.createdAt,
      updatedAt: lead.updatedAt,
      data: lead.data
    };
    res.json(client);
  } catch (error) {
    console.error("[CLIENTS] Erreur lors de la r\xE9cup\xE9ration du client:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration du client",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router29.post("/", async (req2, res) => {
  try {
    const { name, email, phone, company } = req2.body;
    console.log("[CLIENTS] Cr\xE9ation d'un nouveau client:", { name, email, company });
    const lead = await prisma14.lead.create({
      data: {
        organizationId: req2.organizationId,
        status: "client",
        data: {
          name,
          email,
          phone,
          company,
          source: "manuel"
        }
      },
      include: {
        assignedTo: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        }
      }
    });
    const client = {
      id: lead.id,
      name: company || name,
      email,
      phone,
      company,
      status: lead.status,
      assignedTo: lead.assignedTo,
      createdAt: lead.createdAt,
      updatedAt: lead.updatedAt
    };
    res.status(201).json(client);
  } catch (error) {
    console.error("[CLIENTS] Erreur lors de la cr\xE9ation du client:", error);
    res.status(500).json({
      error: "Erreur lors de la cr\xE9ation du client",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
var clients_default = router29;

// src/routes/projects.ts
var import_express31 = require("express");
init_database();
var router30 = (0, import_express31.Router)();
var prisma15 = db;
router30.use(authenticateToken);
router30.get("/", async (req2, res) => {
  try {
    console.log("[PROJECTS] R\xE9cup\xE9ration des projets pour l'organisation:", req2.organizationId);
    const projectLeads = await prisma15.lead.findMany({
      where: {
        organizationId: req2.organizationId,
        OR: [
          { status: { contains: "projet", mode: "insensitive" } },
          { status: { contains: "en cours", mode: "insensitive" } },
          { status: { contains: "development", mode: "insensitive" } }
        ]
      },
      include: {
        assignedTo: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        leadStatus: true
      },
      orderBy: {
        updatedAt: "desc"
      }
    });
    const projects = projectLeads.map((lead) => {
      const data = lead.data || {};
      return {
        id: lead.id,
        name: data.name || `Projet ${lead.id.slice(0, 8)}`,
        description: data.description || "",
        status: lead.status,
        client: data.clientName || "",
        assignedTo: lead.assignedTo,
        budget: data.budget || 0,
        deadline: data.deadline || null,
        priority: data.priority || "medium",
        createdAt: lead.createdAt,
        updatedAt: lead.updatedAt
      };
    });
    if (projects.length === 0) {
      const sampleProjects = [
        {
          id: "sample-1",
          name: "Site web entreprise",
          description: "D\xE9veloppement du site vitrine",
          status: "en cours",
          client: "Client Exemple",
          assignedTo: null,
          budget: 5e3,
          deadline: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3).toISOString(),
          priority: "high",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        },
        {
          id: "sample-2",
          name: "Application mobile",
          description: "App iOS/Android",
          status: "planifi\xE9",
          client: "Autre Client",
          assignedTo: null,
          budget: 15e3,
          deadline: new Date(Date.now() + 60 * 24 * 60 * 60 * 1e3).toISOString(),
          priority: "medium",
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }
      ];
      console.log("[PROJECTS] Aucun projet trouv\xE9, retour d'exemples");
      return res.json(sampleProjects);
    }
    console.log(`[PROJECTS] ${projects.length} projets trouv\xE9s`);
    res.json(projects);
  } catch (error) {
    console.error("[PROJECTS] Erreur lors de la r\xE9cup\xE9ration des projets:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration des projets",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router30.get("/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    console.log("[PROJECTS] R\xE9cup\xE9ration du projet:", id);
    if (id.startsWith("sample-")) {
      const sampleProject = {
        id,
        name: id === "sample-1" ? "Site web entreprise" : "Application mobile",
        description: id === "sample-1" ? "D\xE9veloppement du site vitrine" : "App iOS/Android",
        status: "en cours",
        client: "Client Exemple",
        assignedTo: null,
        budget: id === "sample-1" ? 5e3 : 15e3,
        deadline: new Date(Date.now() + 30 * 24 * 60 * 60 * 1e3).toISOString(),
        priority: "high",
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      return res.json(sampleProject);
    }
    const lead = await prisma15.lead.findFirst({
      where: {
        id,
        organizationId: req2.organizationId
      },
      include: {
        assignedTo: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        }
      }
    });
    if (!lead) {
      return res.status(404).json({ error: "Projet non trouv\xE9" });
    }
    const data = lead.data || {};
    const project = {
      id: lead.id,
      name: data.name || `Projet ${lead.id.slice(0, 8)}`,
      description: data.description || "",
      status: lead.status,
      client: data.clientName || "",
      assignedTo: lead.assignedTo,
      budget: data.budget || 0,
      deadline: data.deadline || null,
      priority: data.priority || "medium",
      createdAt: lead.createdAt,
      updatedAt: lead.updatedAt,
      data: lead.data
    };
    res.json(project);
  } catch (error) {
    console.error("[PROJECTS] Erreur lors de la r\xE9cup\xE9ration du projet:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration du projet",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router30.post("/", async (req2, res) => {
  try {
    const { name, description, clientName, budget, deadline, priority } = req2.body;
    console.log("[PROJECTS] Cr\xE9ation d'un nouveau projet:", { name, clientName });
    const lead = await prisma15.lead.create({
      data: {
        organizationId: req2.organizationId,
        status: "projet",
        data: {
          name,
          description,
          clientName,
          budget: budget ? parseFloat(budget) : 0,
          deadline,
          priority: priority || "medium",
          source: "manuel"
        }
      },
      include: {
        assignedTo: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        }
      }
    });
    const project = {
      id: lead.id,
      name,
      description,
      status: lead.status,
      client: clientName,
      assignedTo: lead.assignedTo,
      budget: budget ? parseFloat(budget) : 0,
      deadline,
      priority: priority || "medium",
      createdAt: lead.createdAt,
      updatedAt: lead.updatedAt
    };
    res.status(201).json(project);
  } catch (error) {
    console.error("[PROJECTS] Erreur lors de la cr\xE9ation du projet:", error);
    res.status(500).json({
      error: "Erreur lors de la cr\xE9ation du projet",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
var projects_default = router30;

// src/routes/emails.ts
var import_express32 = require("express");

// src/services/GmailService.ts
var import_googleapis8 = require("googleapis");

// src/services/AutoGoogleAuthService.ts
init_prisma();
var AutoGoogleAuthService = class _AutoGoogleAuthService {
  static instance = null;
  constructor() {
  }
  static getInstance() {
    if (!this.instance) {
      this.instance = new _AutoGoogleAuthService();
    }
    return this.instance;
  }
  /**
   * Connecte automatiquement l'utilisateur √† Google Workspace lors de sa connexion au CRM
   * Utilise les credentials stock√©s ou initie la premi√®re connexion
   */
  async autoConnectToGoogle(userId, organizationId) {
    try {
      const existingTokens = await googleOAuthService.getUserTokens(userId);
      if (existingTokens) {
        const now = /* @__PURE__ */ new Date();
        const isExpired = existingTokens.expiresAt && existingTokens.expiresAt <= now;
        if (!isExpired) {
          return {
            success: true,
            isConnected: true,
            needsManualAuth: false,
            message: "Connexion Google automatique r\xE9ussie (tokens existants)"
          };
        } else {
          return {
            success: true,
            isConnected: true,
            needsManualAuth: false,
            message: "Connexion Google - refresh d\xE9l\xE9gu\xE9 au middleware"
          };
        }
      }
      if (organizationId) {
        const orgConnection = await this.checkOrganizationGoogleConnection(organizationId);
        if (orgConnection.hasConnection) {
          return {
            success: true,
            isConnected: true,
            needsManualAuth: false,
            message: "Connexion Google via organisation r\xE9ussie"
          };
        }
      }
      console.log("[AutoGoogleAuth] \u{1F510} G\xE9n\xE9ration de l'URL d'autorisation pour premi\xE8re connexion");
      const authUrl = googleOAuthService.getAuthUrl(userId, userId);
      console.log("[AutoGoogleAuth] URL g\xE9n\xE9r\xE9e:", authUrl);
      return {
        success: true,
        isConnected: false,
        needsManualAuth: true,
        authUrl,
        message: "Premi\xE8re connexion Google requise"
      };
    } catch (error) {
      console.error(`\u274C [AutoGoogleAuth] Erreur connexion automatique pour user ${userId}:`, error);
      return {
        success: false,
        isConnected: false,
        needsManualAuth: true,
        message: error instanceof Error ? error.message : "Erreur inconnue"
      };
    }
  }
  /**
   * Teste si les tokens existants sont valides (VERSION MOINS AGRESSIVE)
   */
  async testExistingTokens(userId) {
    try {
      const tokens2 = await googleOAuthService.getUserTokens(userId);
      if (!tokens2) {
        return false;
      }
      const now = /* @__PURE__ */ new Date();
      const isExpired = tokens2.expiresAt && tokens2.expiresAt <= now;
      if (isExpired) {
        return false;
      }
      return true;
    } catch (error) {
      console.error(`\u274C [AutoGoogleAuth] Test tokens failed for user ${userId}:`, error);
      return false;
    }
  }
  /**
   * Tente de rafra√Æchir automatiquement les tokens (VERSION MOINS AGRESSIVE)
   */
  async attemptTokenRefresh(userId) {
    try {
      const tokens2 = await googleOAuthService.getUserTokens(userId);
      return !!tokens2;
    } catch (error) {
      console.error(`\u274C [AutoGoogleAuth] Token refresh failed for user ${userId}:`, error);
      return false;
    }
  }
  /**
   * V√©rifie si l'organisation a une connexion Google centralis√©e
   */
  async checkOrganizationGoogleConnection(organizationId) {
    try {
      const workspaceConfig = await db.googleWorkspaceConfig.findFirst({
        where: { isActive: true }
      });
      if (workspaceConfig) {
        return {
          hasConnection: true,
          connectionType: "workspace"
        };
      }
      return {
        hasConnection: false,
        connectionType: void 0
      };
    } catch (error) {
      console.error(`\u274C [AutoGoogleAuth] Erreur v\xE9rification connexion org ${organizationId}:`, error);
      return { hasConnection: false };
    }
  }
  /**
   * Configure la connexion automatique lors du login
   * √Ä appeler dans le processus d'authentification du CRM
   */
  async handleLoginGoogleConnection(userId, organizationId) {
    try {
      setTimeout(async () => {
        try {
          const result = await this.autoConnectToGoogle(userId, organizationId);
          if (result.success && result.isConnected) {
            this.notifyFrontendGoogleConnected(userId);
          } else if (result.needsManualAuth) {
            this.notifyFrontendManualAuthRequired(userId, result.authUrl);
          } else {
          }
        } catch (timeoutError) {
          console.error(`\u274C [AutoGoogleAuth] Erreur dans setTimeout pour user ${userId}:`, timeoutError);
        }
      }, 5 * 60 * 1e3);
    } catch (error) {
      console.error(`\u274C [AutoGoogleAuth] Erreur handleLoginGoogleConnection pour user ${userId}:`, error);
    }
  }
  /**
   * Notifie le frontend que Google est connect√© automatiquement
   */
  notifyFrontendGoogleConnected(userId) {
  }
  /**
   * Notifie le frontend qu'une connexion manuelle est requise
   */
  notifyFrontendManualAuthRequired(userId, authUrl) {
  }
  /**
   * D√©connecte automatiquement Google lors du logout du CRM
   */
  async handleLogoutGoogleDisconnection(userId) {
    try {
    } catch (error) {
      console.error(`\u274C [AutoGoogleAuth] Erreur nettoyage session Google pour user ${userId}:`, error);
    }
  }
  /**
   * Obtient le statut de connexion Google actuel
   */
  async getGoogleConnectionStatus(userId, organizationId) {
    try {
      const isPersonallyConnected = await googleOAuthService.isUserConnected(userId);
      if (isPersonallyConnected) {
        const tokens2 = await googleOAuthService.getUserTokens(userId);
        return {
          isConnected: true,
          connectionType: "personal",
          lastConnected: tokens2?.updatedAt || tokens2?.createdAt,
          needsReauth: false
        };
      }
      if (organizationId) {
        const orgConnection = await this.checkOrganizationGoogleConnection(organizationId);
        if (orgConnection.hasConnection) {
          return {
            isConnected: true,
            connectionType: orgConnection.connectionType === "workspace" ? "workspace" : "organization",
            needsReauth: false
          };
        }
      }
      return {
        isConnected: false,
        needsReauth: true
      };
    } catch (error) {
      console.error(`\u274C [AutoGoogleAuth] Erreur statut connexion pour user ${userId}:`, error);
      return {
        isConnected: false,
        needsReauth: true
      };
    }
  }
};
var autoGoogleAuthService = AutoGoogleAuthService.getInstance();

// src/services/GmailService.ts
var GmailService = class {
  getOAuthClientForUser(userId) {
    const authService = AutoGoogleAuthService.getInstance();
    const oauth2Client = authService.getOAuth2ClientForUser(userId);
    if (!oauth2Client) {
      throw new Error(`User ${userId} is not authenticated with Google.`);
    }
    return oauth2Client;
  }
  async getGmailClient(userId) {
    const oauth2Client = this.getOAuthClientForUser(userId);
    return import_googleapis8.google.gmail({ version: "v1", auth: oauth2Client });
  }
  // Extrait un header sp√©cifique d'une liste de headers
  extractHeader(headers, name) {
    const header = headers.find((h) => h.name.toLowerCase() === name.toLowerCase());
    return header ? header.value : "";
  }
  // D√©code le corps d'un message (Base64URL)
  decodeBody(bodyData) {
    if (!bodyData) return "";
    return Buffer.from(bodyData, "base64url").toString("utf-8");
  }
  // Trouve la meilleure partie du corps de l'email √† afficher
  getMessageBody(payload) {
    let body2 = "";
    if (payload.parts) {
      const htmlPart = payload.parts.find((part) => part.mimeType === "text/html");
      if (htmlPart && htmlPart.body?.data) {
        body2 = this.decodeBody(htmlPart.body.data);
      } else {
        const textPart = payload.parts.find((part) => part.mimeType === "text/plain");
        if (textPart && textPart.body?.data) {
          body2 = this.decodeBody(textPart.body.data);
        }
      }
    } else if (payload.body?.data) {
      body2 = this.decodeBody(payload.body.data);
    }
    return body2;
  }
  async listThreads(userId, mailbox) {
    try {
      const gmail = await this.getGmailClient(userId);
      const response = await gmail.users.threads.list({
        userId: "me",
        labelIds: [mailbox.toUpperCase()],
        maxResults: 30
      });
      const threads = response.data.threads || [];
      if (threads.length === 0) {
        return [];
      }
      const threadDetailsPromises = threads.map(
        (thread) => gmail.users.threads.get({ userId: "me", id: thread.id, format: "metadata", metadataHeaders: ["Subject", "From", "To", "Date"] })
      );
      const detailedThreads = await Promise.all(threadDetailsPromises);
      const formattedThreads = detailedThreads.map((res) => {
        const firstMessage = res.data.messages?.[0];
        const headers = firstMessage?.payload?.headers || [];
        return {
          id: res.data.id,
          subject: this.extractHeader(headers, "Subject"),
          snippet: res.data.snippet || "",
          timestamp: firstMessage?.internalDate ? new Date(parseInt(firstMessage.internalDate, 10)).toISOString() : (/* @__PURE__ */ new Date()).toISOString(),
          from: this.extractHeader(headers, "From"),
          to: this.extractHeader(headers, "To"),
          unread: firstMessage?.labelIds?.includes("UNREAD") || false,
          hasAttachments: firstMessage?.payload?.parts?.some((p) => p.filename) || false,
          isStarred: firstMessage?.labelIds?.includes("STARRED") || false,
          messages: []
          // Sera charg√© au clic
        };
      });
      return formattedThreads;
    } catch (error) {
      const gaxiosError = error;
      console.error("Error listing Gmail threads:", gaxiosError.message);
      if (gaxiosError.response?.status === 401) {
        throw new Error("Authentication failed. Please reconnect your Google account.");
      }
      throw new Error("Could not retrieve Gmail threads.");
    }
  }
  async getThreadDetails(userId, threadId) {
    try {
      const gmail = await this.getGmailClient(userId);
      const response = await gmail.users.threads.get({
        userId: "me",
        id: threadId
      });
      const thread = response.data;
      if (!thread || !thread.messages) {
        throw new Error("Thread not found or empty.");
      }
      const messages = thread.messages.map((msg) => {
        const headers = msg.payload?.headers || [];
        return {
          id: msg.id,
          body: this.getMessageBody(msg.payload),
          from: this.extractHeader(headers, "From"),
          to: this.extractHeader(headers, "To"),
          subject: this.extractHeader(headers, "Subject"),
          timestamp: msg.internalDate ? new Date(parseInt(msg.internalDate, 10)).toISOString() : (/* @__PURE__ */ new Date()).toISOString(),
          isRead: !msg.labelIds?.includes("UNREAD"),
          headers: headers.reduce((acc, h) => ({ ...acc, [h.name]: h.value }), {})
        };
      });
      const firstMessageHeaders = thread.messages[0]?.payload?.headers || [];
      return {
        id: thread.id,
        subject: this.extractHeader(firstMessageHeaders, "Subject"),
        snippet: thread.snippet || "",
        timestamp: thread.messages[0]?.internalDate ? new Date(parseInt(thread.messages[0].internalDate, 10)).toISOString() : (/* @__PURE__ */ new Date()).toISOString(),
        from: this.extractHeader(firstMessageHeaders, "From"),
        to: this.extractHeader(firstMessageHeaders, "To"),
        unread: thread.messages[0]?.labelIds?.includes("UNREAD") || false,
        hasAttachments: thread.messages.some((m) => m.payload?.parts?.some((p) => p.filename)),
        isStarred: thread.messages[0]?.labelIds?.includes("STARRED") || false,
        messages
      };
    } catch (error) {
      console.error("Error getting Gmail thread details:", error);
      throw new Error("Could not retrieve thread details.");
    }
  }
  async sendEmail(userId, to, subject, body2) {
    try {
      const gmail = await this.getGmailClient(userId);
      const userProfile = await gmail.users.getProfile({ userId: "me" });
      const fromEmail = userProfile.data.emailAddress;
      if (!fromEmail) {
        throw new Error("Could not determine user's email address.");
      }
      const emailLines = [
        `From: "${fromEmail}" <${fromEmail}>`,
        `To: ${to}`,
        "Content-type: text/html;charset=iso-8859-1",
        "MIME-Version: 1.0",
        `Subject: ${subject}`,
        "",
        body2
      ];
      const email = emailLines.join("\r\n");
      const response = await gmail.users.messages.send({
        userId: "me",
        requestBody: {
          raw: Buffer.from(email).toString("base64url")
        }
      });
      return response.data;
    } catch (error) {
      console.error("Error sending email:", error);
      throw new Error("Could not send email.");
    }
  }
};
var GmailService_default = new GmailService();

// src/routes/emails.ts
var router31 = (0, import_express32.Router)();
router31.get("/", authMiddleware, async (req2, res) => {
  if (!req2.user?.userId) {
    return res.status(401).json({ error: "Authentification requise" });
  }
  const { folder = "INBOX" } = req2.query;
  try {
    const threads = await GmailService_default.listThreads(req2.user.userId, folder);
    res.json(threads);
  } catch (error) {
    console.error(`Erreur lors de la r\xE9cup\xE9ration des emails Gmail du dossier ${folder}:`, error);
    if (error instanceof Error && error.message.includes("Authentication failed")) {
      return res.status(401).json({
        error: "Authentification Google requise",
        needsAuth: true
      });
    }
    if (error instanceof Error && error.message.includes("not authenticated with Google")) {
      return res.status(200).json([]);
    }
    console.warn(`Gmail non disponible pour user ${req2.user.userId}, retour d'un tableau vide`);
    res.status(200).json([]);
  }
});
router31.get("/thread/:threadId", authMiddleware, async (req2, res) => {
  if (!req2.user?.userId) {
    return res.status(401).json({ error: "Authentification requise" });
  }
  const { threadId } = req2.params;
  try {
    const threadDetails = await GmailService_default.getThreadDetails(req2.user.userId, threadId);
    res.json(threadDetails);
  } catch (error) {
    console.error(`Erreur lors de la r\xE9cup\xE9ration du thread ${threadId}:`, error);
    res.status(500).json({ error: "Une erreur interne est survenue." });
  }
});
router31.post("/send", authMiddleware, async (req2, res) => {
  if (!req2.user?.userId) {
    return res.status(401).json({ error: "Authentification requise" });
  }
  const { to, subject, body: body2 } = req2.body;
  if (!to || !subject || !body2) {
    return res.status(400).json({ error: "Destinataire, sujet et corps requis" });
  }
  try {
    const result = await GmailService_default.sendEmail(req2.user.userId, to, subject, body2);
    res.json({ success: true, messageId: result.id });
  } catch (error) {
    console.error("Erreur lors de l'envoi de l'email:", error);
    res.status(500).json({ error: "Une erreur interne est survenue." });
  }
});
var emails_default = router31;

// src/routes/gemini.ts
var import_express33 = __toESM(require("express"), 1);

// src/services/GoogleGeminiService.ts
var import_generative_ai = require("@google/generative-ai");
var GoogleGeminiService = class {
  isDemoMode;
  apiKey;
  genAI = null;
  model = null;
  primaryModelName;
  fallbackModelNames = [];
  modelCache = /* @__PURE__ */ new Map();
  modelName;
  // compat h√©ritage routes existantes
  // Observabilit√© / R√©silience
  consecutiveFailures = 0;
  lastError = null;
  lastSuccessAt = null;
  degradedUntil = null;
  // timestamp ms si circuit breaker actif
  // Param√®tres r√©silience
  maxRetries;
  baseTimeoutMs;
  perAttemptExtraTimeoutMs;
  constructor() {
    this.apiKey = process.env.GOOGLE_AI_API_KEY;
    const forcedMode = process.env.AI_MODE;
    this.isDemoMode = forcedMode === "force-mock" ? true : !this.apiKey && forcedMode !== "force-live";
    const explicitDefaultModel = process.env.GEMINI_MODEL?.trim();
    const fastModel = process.env.GEMINI_FAST_MODEL?.trim();
    this.primaryModelName = fastModel || explicitDefaultModel || "gemini-2.5-flash";
    const fallbackEnv = process.env.GEMINI_MODEL_FALLBACKS || explicitDefaultModel || "gemini-2.5-pro";
    this.fallbackModelNames = fallbackEnv.split(",").map((name) => name.trim()).filter((name) => !!name && name !== this.primaryModelName);
    this.modelName = this.primaryModelName;
    this.maxRetries = Math.max(0, parseInt(process.env.AI_MAX_RETRIES || "2", 10) || 2);
    this.baseTimeoutMs = Math.max(2e3, parseInt(process.env.AI_TIMEOUT_MS || "12000", 10) || 12e3);
    this.perAttemptExtraTimeoutMs = Math.max(0, parseInt(process.env.AI_RETRY_TIMEOUT_INCREMENT_MS || "2000", 10) || 2e3);
    if (this.isDemoMode) {
      console.log("\u{1F916} GoogleGeminiService initialis\xE9 (mode d\xE9veloppement - d\xE9mo)");
      console.log("\u2139\uFE0F  Pour activer l'API r\xE9elle, configurez GOOGLE_AI_API_KEY dans .env");
    } else {
      console.log("\u{1F916} GoogleGeminiService initialis\xE9 (mode production - API r\xE9elle)");
      this.genAI = new import_generative_ai.GoogleGenerativeAI(this.apiKey);
      this.model = this.getModelInstance(this.primaryModelName);
      this.modelCache.set(this.primaryModelName, this.model);
      console.log(`\u2705 Cl\xE9 API Gemini d\xE9tect\xE9e, mod\xE8le rapide: ${this.primaryModelName} (API v1beta)`);
      if (this.fallbackModelNames.length > 0) {
        console.log(`\u21AA\uFE0F  Mod\xE8les de secours configur\xE9s: ${this.fallbackModelNames.join(", ")}`);
      }
    }
  }
  /** Indique si on est en mode live */
  isLive() {
    return !this.isDemoMode;
  }
  /** Chat g√©n√©rique multi-modules */
  async chat(params) {
    const { prompt } = params;
    if (this.isDemoMode) {
      return { success: true, mode: "mock", content: this.buildDemoChat(prompt), model: "demo" };
    }
    if (this.degradedUntil && Date.now() < this.degradedUntil) {
      return {
        success: true,
        mode: "mock",
        content: this.buildDemoChat(prompt),
        error: this.lastError || "circuit-breaker-active",
        model: "fallback-mock"
      };
    }
    try {
      const result = await this.callGeminiAPIWithFallbacks(prompt);
      if (result.success) {
        this.recordSuccess();
        return { success: true, content: result.content, mode: "live", model: result.modelUsed };
      }
      this.recordFailure(result.error || "unknown-error");
      return {
        success: true,
        content: this.buildDemoChat(prompt),
        mode: "mock",
        error: result.error,
        model: result.modelUsed || this.primaryModelName
      };
    } catch (e) {
      const msg = e.message;
      this.recordFailure(msg);
      return {
        success: true,
        content: this.buildDemoChat(prompt),
        mode: "mock",
        error: msg,
        model: this.primaryModelName
      };
    }
  }
  buildDemoChat(userPrompt) {
    return `
R\xE9ponse simplifi\xE9e (mode simul\xE9) pour: ${userPrompt.slice(0, 120)}...
Je peux proposer: planifier un RDV, analyser un lead, g\xE9n\xE9rer un email ou la prochaine action. Pr\xE9cisez votre besoin.`;
  }
  /**
   * üìß G√âN√âRATION EMAIL PERSONNALIS√â
   * G√©n√®re un email personnalis√© pour un prospect
   */
  async generatePersonalizedEmail(leadData, emailType = "initial") {
    try {
      console.log(`\u{1F916} [Gemini] G\xE9n\xE9ration email ${emailType} pour ${leadData.name}`);
      if (this.isDemoMode) {
        return this.generateDemoEmail(leadData, emailType);
      }
      const prompt = this.buildEmailPrompt(leadData, emailType);
      const result = await this.callGeminiAPIWithFallbacks(prompt, emailType === "initial" ? void 0 : [this.primaryModelName, ...this.fallbackModelNames]);
      if (result.success && result.content) {
        return {
          success: true,
          email: this.parseEmailResponse(result.content),
          source: "gemini-api",
          model: result.modelUsed
        };
      }
      console.warn("\u26A0\uFE0F Erreur API Gemini, fallback vers d\xE9mo");
      return { ...this.generateDemoEmail(leadData, emailType), model: "demo" };
    } catch (error) {
      console.error("\u274C Erreur g\xE9n\xE9ration email:", error);
      return { success: false, error: error.message };
    }
  }
  /**
   * üìã ANALYSE ET R√âSUM√â DE LEAD
   * Analyse les donn√©es d'un lead et g√©n√®re un r√©sum√© intelligent
   */
  async analyzeLeadData(leadData) {
    try {
      console.log(`\u{1F916} [Gemini] Analyse lead ${leadData.name || "Anonyme"}`);
      if (this.isDemoMode) {
        return this.generateDemoAnalysis(leadData);
      }
      return { success: false, error: "Vertex AI non configur\xE9" };
    } catch (error) {
      console.error("\u274C Erreur analyse lead:", error);
      return { success: false, error: error.message };
    }
  }
  /**
   * üìù G√âN√âRATION PROPOSITION COMMERCIALE
   * Cr√©e une proposition commerciale personnalis√©e
   */
  async generateCommercialProposal(leadData, productData) {
    try {
      console.log(`\u{1F916} [Gemini] G\xE9n\xE9ration proposition pour ${leadData.name}`);
      if (this.isDemoMode) {
        return this.generateDemoProposal(leadData, productData);
      }
      return { success: false, error: "Vertex AI non configur\xE9" };
    } catch (error) {
      console.error("\u274C Erreur g\xE9n\xE9ration proposition:", error);
      return { success: false, error: error.message };
    }
  }
  /**
   * üîç ANALYSE SENTIMENT EMAIL
   * Analyse le sentiment d'un email re√ßu
   */
  async analyzeSentiment(emailContent) {
    try {
      console.log("\u{1F916} [Gemini] Analyse sentiment email");
      if (this.isDemoMode) {
        return this.generateDemoSentiment(emailContent);
      }
      return { success: false, error: "Vertex AI non configur\xE9" };
    } catch (error) {
      console.error("\u274C Erreur analyse sentiment:", error);
      return { success: false, error: error.message };
    }
  }
  /**
   * üí¨ SUGGESTION R√âPONSE EMAIL
   * Sugg√®re une r√©ponse appropri√©e √† un email
   */
  async suggestEmailResponse(emailContent, context = {}) {
    try {
      console.log("\u{1F916} [Gemini] Suggestion r\xE9ponse email");
      if (this.isDemoMode) {
        return this.generateDemoResponse(emailContent, context);
      }
      return { success: false, error: "Vertex AI non configur\xE9" };
    } catch (error) {
      console.error("\u274C Erreur suggestion email:", error);
      return { success: false, error: error.message };
    }
  }
  /**
   * üé≠ M√âTHODES DEMO (SIMULATION)
   * Ces m√©thodes simulent les r√©ponses de Gemini en attendant la configuration
   */
  generateDemoEmail(leadData, emailType) {
    const emailTemplates = {
      initial: {
        subject: `Bonjour ${leadData.name} - Proposition CRM personnalis\xE9e pour ${leadData.company || "votre entreprise"}`,
        body: `Bonjour ${leadData.name},

J'esp\xE8re que vous allez bien. Je me permets de vous contacter suite \xE0 votre int\xE9r\xEAt pour nos solutions CRM.

Chez 2Thier, nous aidons les entreprises comme ${leadData.company || "la v\xF4tre"} \xE0 optimiser leur gestion commerciale gr\xE2ce \xE0 des outils innovants et intuitifs.

${leadData.industry ? `Ayant une expertise particuli\xE8re dans le secteur ${leadData.industry}, ` : ""}Je serais ravi de vous pr\xE9senter comment notre CRM peut r\xE9pondre \xE0 vos besoins sp\xE9cifiques.

Seriez-vous disponible pour un \xE9change de 30 minutes la semaine prochaine ?

Cordialement,
L'\xE9quipe 2Thier CRM

P.S. : Nous offrons une d\xE9monstration gratuite et personnalis\xE9e.`
      },
      followup: {
        subject: `Suivi - D\xE9monstration CRM pour ${leadData.company || "votre entreprise"}`,
        body: `Bonjour ${leadData.name},

J'esp\xE8re que vous avez pu consulter notre proposition CRM.

${leadData.notes ? `Suite \xE0 nos \xE9changes concernant ${leadData.notes.substring(0, 50)}..., ` : ""}je souhaitais faire le point avec vous sur vos besoins.

Notre solution pourrait particuli\xE8rement vous aider \xE0 :
\u2022 Automatiser votre suivi commercial
\u2022 Int\xE9grer vos emails et calendrier
\u2022 Analyser vos performances de vente

Quand pourriez-vous \xEAtre disponible pour une d\xE9monstration personnalis\xE9e ?

Bien \xE0 vous,
L'\xE9quipe 2Thier CRM`
      }
    };
    const template = emailTemplates[emailType] || emailTemplates.initial;
    return {
      success: true,
      email: {
        subject: template.subject,
        body: template.body,
        tone: "professionnel"
      }
    };
  }
  generateDemoAnalysis(leadData) {
    const qualificationScore = this.calculateQualificationScore(leadData);
    return {
      success: true,
      analysis: {
        profil: `${leadData.name} de ${leadData.company || "une entreprise"} ${leadData.industry ? `dans le secteur ${leadData.industry}` : ""}. Contact via ${leadData.source || "canal direct"}.`,
        besoins: leadData.notes ? this.extractNeeds(leadData.notes) : "Besoins \xE0 clarifier lors du prochain contact",
        opportunites: this.generateOpportunities(leadData),
        actions: this.generateRecommendedActions(leadData, qualificationScore),
        score: qualificationScore
      }
    };
  }
  generateDemoProposal(leadData, productData) {
    const proposal = `PROPOSITION COMMERCIALE PERSONNALIS\xC9E

Destinataire: ${leadData.name} - ${leadData.company || "Entreprise"}

1. INTRODUCTION
Nous avons le plaisir de vous proposer ${productData.name}, une solution parfaitement adapt\xE9e \xE0 vos besoins.

2. ANALYSE DE VOS BESOINS
${leadData.notes || "Optimisation de la gestion commerciale et am\xE9lioration du suivi client."}

3. SOLUTION PROPOS\xC9E
${productData.description}

Avantages cl\xE9s :
${Array.isArray(productData.benefits) ? productData.benefits.map((b) => `\u2022 ${b}`).join("\n") : "\u2022 Solution compl\xE8te et intuitive"}

4. INVESTISSEMENT
${productData.price || "Sur devis personnalis\xE9"}

5. PROCHAINES \xC9TAPES
\u2022 D\xE9monstration personnalis\xE9e (30 minutes)
\u2022 Configuration selon vos besoins
\u2022 Formation de votre \xE9quipe
\u2022 Support technique complet

Nous restons \xE0 votre disposition pour tout compl\xE9ment d'information.

Cordialement,
L'\xE9quipe commerciale 2Thier`;
    return {
      success: true,
      proposal: {
        content: proposal.trim(),
        wordCount: proposal.split(" ").length,
        sections: ["Introduction", "Analyse besoins", "Solution", "Investissement", "Prochaines \xE9tapes"]
      }
    };
  }
  generateDemoSentiment(emailContent) {
    const sentiment = this.analyzeSentimentDemo(emailContent);
    return {
      success: true,
      sentiment: {
        sentiment: sentiment.type,
        score: sentiment.score,
        emotions: sentiment.emotions,
        urgence: sentiment.urgence,
        recommandations: sentiment.recommandations
      }
    };
  }
  generateDemoResponse(emailContent, context) {
    const suggestion = this.generateResponseSuggestion(emailContent, context);
    return {
      success: true,
      suggestions: {
        principale: suggestion.main,
        alternatives: suggestion.alternatives,
        objet: suggestion.subject,
        callToAction: suggestion.cta
      }
    };
  }
  /**
   * üõ†Ô∏è M√âTHODES UTILITAIRES DEMO
   */
  calculateQualificationScore(leadData) {
    let score = 5;
    if (leadData.email) score += 1;
    if (leadData.phone) score += 1;
    if (leadData.company) score += 1;
    if (leadData.industry) score += 1;
    if (leadData.notes && leadData.notes.length > 50) score += 1;
    if (leadData.status === "Qualified") score += 2;
    if (leadData.notes && leadData.notes.includes("budget")) score += 1;
    return Math.min(score, 10);
  }
  extractNeeds(notes) {
    if (notes.toLowerCase().includes("crm")) return "Solution CRM compl\xE8te";
    if (notes.toLowerCase().includes("gestion")) return "Am\xE9lioration gestion commerciale";
    if (notes.toLowerCase().includes("automatisation")) return "Automatisation des processus";
    return "Besoins \xE0 affiner lors du prochain \xE9change";
  }
  generateOpportunities(leadData) {
    const opportunities = [];
    if (leadData.company) opportunities.push("D\xE9ploiement \xE0 l'\xE9chelle de l'entreprise");
    if (leadData.industry) opportunities.push(`Expertise sectorielle ${leadData.industry}`);
    if (leadData.notes && leadData.notes.includes("\xE9quipe")) opportunities.push("Formation \xE9quipe compl\xE8te");
    return opportunities.length > 0 ? opportunities.join(", ") : "Potentiel \xE0 \xE9valuer";
  }
  generateRecommendedActions(leadData, score) {
    if (score >= 8) return "Proposer d\xE9monstration imm\xE9diate, pr\xE9parer offre commerciale";
    if (score >= 6) return "Planifier rendez-vous t\xE9l\xE9phonique, qualifier les besoins";
    return "Envoyer informations compl\xE9mentaires, programmer rappel dans 1 semaine";
  }
  analyzeSentimentDemo(emailContent) {
    const content = emailContent.toLowerCase();
    let score = 5;
    let type = "neutre";
    const emotions = [];
    let urgence = "moyenne";
    if (content.includes("merci") || content.includes("int\xE9ressant") || content.includes("parfait")) {
      score += 2;
      type = "positif";
      emotions.push("satisfaction");
    }
    if (content.includes("probl\xE8me") || content.includes("d\xE9\xE7u") || content.includes("pas satisfait")) {
      score -= 2;
      type = "n\xE9gatif";
      emotions.push("frustration");
    }
    if (content.includes("urgent") || content.includes("rapidement") || content.includes("d\xE8s que possible")) {
      urgence = "\xE9lev\xE9e";
      emotions.push("urgence");
    }
    let recommandations = "R\xE9ponse standard professionnelle";
    if (type === "positif") recommandations = "R\xE9ponse enthousiaste, proposer prochaine \xE9tape";
    if (type === "n\xE9gatif") recommandations = "R\xE9ponse empathique, proposer solution rapide";
    if (urgence === "\xE9lev\xE9e") recommandations += " - R\xE9pondre dans les 2 heures";
    return {
      type,
      score: Math.max(1, Math.min(10, score)),
      emotions,
      urgence,
      recommandations
    };
  }
  generateResponseSuggestion(emailContent, context) {
    const isPositive = emailContent.toLowerCase().includes("int\xE9ressant") || emailContent.toLowerCase().includes("merci");
    let main = "";
    if (isPositive) {
      main = `Bonjour,

Merci pour votre retour positif ! Je suis ravi de voir que notre solution vous int\xE9resse.

Pour donner suite \xE0 votre message, je vous propose d'organiser une d\xE9monstration personnalis\xE9e qui vous permettra de d\xE9couvrir concr\xE8tement les fonctionnalit\xE9s adapt\xE9es \xE0 vos besoins.

Quelles sont vos disponibilit\xE9s pour un \xE9change de 30 minutes cette semaine ?

Cordialement`;
    } else {
      main = `Bonjour,

Merci pour votre message. Je prends note de vos remarques et vais m'assurer de vous apporter une r\xE9ponse compl\xE8te.

${context.objective || "Je vous recontacte rapidement"} pour faire le point sur votre situation.

Bien \xE0 vous`;
    }
    return {
      main,
      alternatives: [
        "Version courte : Merci pour votre message. Je vous recontacte rapidement.",
        "Version formelle : Nous accusons r\xE9ception de votre message et vous remercions de votre int\xE9r\xEAt."
      ],
      subject: "Re: " + (emailContent.substring(0, 30) + "..."),
      cta: isPositive ? "Organiser une d\xE9monstration" : "Faire le point ensemble"
    };
  }
  /**
   * üöÄ M√âTHODES POUR L'API GEMINI R√âELLE
   */
  ensureLiveMode() {
    if (!this.genAI) {
      throw new Error("API Gemini non initialis\xE9e");
    }
  }
  getModelInstance(modelName) {
    this.ensureLiveMode();
    const cached = this.modelCache.get(modelName);
    if (cached) {
      return cached;
    }
    const model = this.genAI.getGenerativeModel({ model: modelName }, { apiVersion: "v1beta" });
    this.modelCache.set(modelName, model);
    return model;
  }
  /**
   * üìê ANALYSE D'IMAGE AVEC VISION API
   * Analyse une image et extrait des mesures/informations selon le prompt
   */
  async analyzeImageForMeasures(imageBase64, mimeType, prompt, measureKeys) {
    try {
      console.log(`\u{1F4D0} [Gemini Vision] Analyse d'image avec ${measureKeys.length} cl\xE9s \xE0 extraire`);
      if (this.isDemoMode) {
        return this.generateDemoImageMeasures(measureKeys);
      }
      if (this.degradedUntil && Date.now() < this.degradedUntil) {
        console.warn("\u26A0\uFE0F [Gemini Vision] Circuit breaker actif, retour mode d\xE9mo");
        return {
          ...this.generateDemoImageMeasures(measureKeys),
          error: this.lastError || "circuit-breaker-active"
        };
      }
      const structuredPrompt = this.buildMeasurePrompt(prompt, measureKeys);
      const result = await this.callVisionAPI(imageBase64, mimeType, structuredPrompt);
      if (result.success && result.content) {
        this.recordSuccess();
        const measurements = this.parseMeasureResponse(result.content, measureKeys);
        return {
          success: true,
          measurements,
          rawResponse: result.content,
          model: result.modelUsed
        };
      }
      this.recordFailure(result.error || "unknown-vision-error");
      console.warn("\u26A0\uFE0F [Gemini Vision] Erreur API, fallback vers d\xE9mo");
      return {
        ...this.generateDemoImageMeasures(measureKeys),
        error: result.error
      };
    } catch (error) {
      const msg = error.message;
      console.error("\u274C [Gemini Vision] Erreur:", msg);
      this.recordFailure(msg);
      return {
        success: false,
        error: msg
      };
    }
  }
  /**
   * üîç Appel √† l'API Vision Gemini avec image en base64
   */
  async callVisionAPI(imageBase64, mimeType, prompt) {
    try {
      if (!this.genAI) {
        return { success: false, error: "API Gemini non initialis\xE9e", modelUsed: this.primaryModelName };
      }
      const visionModelName = this.primaryModelName;
      const model = this.getModelInstance(visionModelName);
      console.log(`\u{1F4F7} [Gemini Vision] Envoi de l'image (${mimeType}) au mod\xE8le ${visionModelName}`);
      const result = await model.generateContent([
        { text: prompt },
        {
          inlineData: {
            mimeType,
            data: imageBase64
          }
        }
      ]);
      const response = await result.response;
      const text = response.text();
      console.log(`\u2705 [Gemini Vision] R\xE9ponse re\xE7ue (${text.length} caract\xE8res)`);
      return { success: true, content: text, modelUsed: visionModelName };
    } catch (error) {
      console.error("\u274C [Gemini Vision API] Erreur:", error);
      return { success: false, error: error.message, modelUsed: this.primaryModelName };
    }
  }
  /**
   * üìù Construit le prompt pour l'extraction de mesures
   */
  buildMeasurePrompt(userPrompt, measureKeys) {
    const keysDescription = measureKeys.map((k) => `"${k}"`).join(", ");
    return `Tu es un assistant expert en analyse d'images et en prise de mesures.

INSTRUCTION UTILISATEUR:
${userPrompt}

CL\xC9S \xC0 EXTRAIRE:
${keysDescription}

R\xC8GLES IMPORTANTES:
1. Analyse l'image attentivement
2. TU DOIS TOUJOURS ESTIMER les dimensions (largeur, hauteur, profondeur) en centim\xE8tres, m\xEAme si c'est approximatif
3. Utilise des indices visuels (proportions, objets de r\xE9f\xE9rence, perspective) pour estimer les mesures
4. Pour les ch\xE2ssis/fen\xEAtres standard, une fen\xEAtre typique fait entre 60-150cm de large et 80-200cm de haut
5. NE JAMAIS r\xE9pondre "non_visible" pour les dimensions - FAIS TOUJOURS UNE ESTIMATION RAISONNABLE
6. Pour les autres champs (type, couleur, mat\xE9riau, nombre), tu peux r\xE9pondre "non_visible" UNIQUEMENT si vraiment impossible \xE0 d\xE9terminer
7. Pour les dimensions, utilise les unit\xE9s en centim\xE8tres (cm) - donne un nombre entier
8. R\xE9ponds UNIQUEMENT au format JSON suivant (sans texte avant ou apr\xE8s):

{
  ${measureKeys.map((k) => `"${k}": <valeur_num\xE9rique_ou_texte>`).join(",\n  ")}
}

Analyse maintenant cette image et ESTIME toutes les dimensions:`;
  }
  /**
   * üîÑ Parse la r√©ponse JSON et extrait les mesures
   */
  parseMeasureResponse(content, measureKeys) {
    try {
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        console.warn("\u26A0\uFE0F [Gemini Vision] Pas de JSON trouv\xE9 dans la r\xE9ponse");
        return this.createEmptyMeasurements(measureKeys);
      }
      const parsed = JSON.parse(jsonMatch[0]);
      const measurements = {};
      for (const key2 of measureKeys) {
        if (parsed[key2] !== void 0) {
          measurements[key2] = parsed[key2];
        } else {
          measurements[key2] = "non_visible";
        }
      }
      return measurements;
    } catch (error) {
      console.warn("\u26A0\uFE0F [Gemini Vision] Erreur parsing JSON:", error);
      return this.createEmptyMeasurements(measureKeys);
    }
  }
  /**
   * üé≠ G√©n√®re des mesures de d√©monstration
   */
  generateDemoImageMeasures(measureKeys) {
    const measurements = {};
    for (const key2 of measureKeys) {
      const keyLower = key2.toLowerCase();
      if (keyLower.includes("largeur") || keyLower.includes("width")) {
        measurements[key2] = Math.round(80 + Math.random() * 120);
      } else if (keyLower.includes("hauteur") || keyLower.includes("height")) {
        measurements[key2] = Math.round(100 + Math.random() * 150);
      } else if (keyLower.includes("profondeur") || keyLower.includes("depth")) {
        measurements[key2] = Math.round(5 + Math.random() * 30);
      } else if (keyLower.includes("nombre") || keyLower.includes("count") || keyLower.includes("nb")) {
        measurements[key2] = Math.floor(1 + Math.random() * 5);
      } else if (keyLower.includes("type") || keyLower.includes("style")) {
        const types = ["oscillo-battant", "\xE0 soufflet", "fixe", "coulissant"];
        measurements[key2] = types[Math.floor(Math.random() * types.length)];
      } else if (keyLower.includes("couleur") || keyLower.includes("color")) {
        const colors = ["blanc", "gris anthracite", "noir", "ch\xEAne dor\xE9"];
        measurements[key2] = colors[Math.floor(Math.random() * colors.length)];
      } else if (keyLower.includes("materiau") || keyLower.includes("material")) {
        const materials = ["PVC", "aluminium", "bois", "mixte bois-alu"];
        measurements[key2] = materials[Math.floor(Math.random() * materials.length)];
      } else {
        measurements[key2] = Math.round(10 + Math.random() * 100);
      }
    }
    return {
      success: true,
      measurements,
      model: "demo"
    };
  }
  /**
   * üìã Cr√©e un objet de mesures vide
   */
  createEmptyMeasurements(measureKeys) {
    const measurements = {};
    for (const key2 of measureKeys) {
      measurements[key2] = "non_visible";
    }
    return measurements;
  }
  async callGeminiAPIWithFallbacks(prompt, modelCandidates) {
    const candidates = modelCandidates && modelCandidates.length > 0 ? modelCandidates : [this.primaryModelName, ...this.fallbackModelNames];
    let lastError;
    for (const candidate of candidates) {
      const result = await this.callGeminiAPIWithRetries(prompt, candidate);
      if (result.success) {
        if (candidate !== this.primaryModelName) {
          console.warn(`\u21AA\uFE0F  [Gemini API] Bascul\xE9 sur le mod\xE8le de secours ${candidate}`);
        }
        return result;
      }
      lastError = result.error;
      console.warn(`\u26A0\uFE0F [Gemini API] \xC9chec avec ${candidate}: ${lastError || "erreur inconnue"}`);
    }
    return {
      success: false,
      error: lastError || "no-model-available",
      modelUsed: candidates[candidates.length - 1]
    };
  }
  async callGeminiAPI(prompt, modelName) {
    try {
      if (!this.genAI) {
        return { success: false, error: "API Gemini non initialis\xE9e", modelUsed: modelName };
      }
      const modelToUse = this.getModelInstance(modelName);
      const result = await modelToUse.generateContent(prompt);
      const response = await result.response;
      const text = response.text();
      console.log(`\u2705 [Gemini API] R\xE9ponse re\xE7ue (${modelName})`);
      return { success: true, content: text, modelUsed: modelName };
    } catch (error) {
      console.error("\u274C [Gemini API] Erreur:", error);
      return { success: false, error: error.message, modelUsed: modelName };
    }
  }
  /** Appel API avec timeout et retries exponentiels (backoff + jitter) */
  async callGeminiAPIWithRetries(prompt, modelName) {
    const attempts = this.maxRetries + 1;
    for (let i = 0; i < attempts; i++) {
      const timeoutMs = this.baseTimeoutMs + i * this.perAttemptExtraTimeoutMs;
      try {
        const res = await this.withTimeout(this.callGeminiAPI(prompt, modelName), timeoutMs);
        if (res.success) return res;
        if (!this.isTransientError(res.error || "")) return res;
      } catch (err) {
        const msg = err.message || String(err);
        if (!this.isTransientError(msg)) {
          return { success: false, error: msg, modelUsed: modelName };
        }
      }
      const base = Math.min(4e3, 500 * Math.pow(2, i));
      const jitter = Math.floor(Math.random() * 200);
      await new Promise((r) => setTimeout(r, base + jitter));
    }
    return { success: false, error: "timeout-or-retry-exceeded", modelUsed: modelName };
  }
  async withTimeout(p, ms) {
    let timer;
    return await Promise.race([
      p,
      new Promise((_, reject) => {
        timer = setTimeout(() => reject(new Error(`ai-timeout-${ms}ms`)), ms);
      })
    ]).finally(() => {
      if (timer) clearTimeout(timer);
    });
  }
  isTransientError(message) {
    const m = message.toLowerCase();
    return m.includes("timeout") || m.includes("timed out") || m.includes("etimedout") || m.includes("econnreset") || m.includes("econnrefused") || m.includes("network") || m.includes("fetch failed") || m.includes("503") || m.includes("502") || m.includes("429");
  }
  /** Expose un statut enrichi pour la route /api/ai/status */
  getStatus() {
    const now = Date.now();
    const degraded = !!(this.degradedUntil && now < this.degradedUntil);
    return {
      mode: this.isDemoMode ? "mock" : "live",
      model: this.primaryModelName,
      fallbackModels: this.fallbackModelNames,
      hasApiKey: !!this.apiKey,
      consecutiveFailures: this.consecutiveFailures,
      lastError: this.lastError,
      lastSuccessAt: this.lastSuccessAt?.toISOString() || null,
      degraded,
      degradedUntil: degraded && this.degradedUntil ? new Date(this.degradedUntil).toISOString() : null
    };
  }
  recordFailure(err) {
    this.consecutiveFailures += 1;
    this.lastError = err;
    const isKeyInvalid = /API key not valid|API_KEY_INVALID|permission|unauthorized|401|403/i.test(err);
    if (isKeyInvalid) {
      let penaltyMinutes = 1;
      if (this.consecutiveFailures >= 3) penaltyMinutes = 5;
      if (this.consecutiveFailures >= 5) penaltyMinutes = 15;
      if (this.consecutiveFailures >= 7) penaltyMinutes = 60;
      this.degradedUntil = Date.now() + penaltyMinutes * 6e4;
    } else if (this.consecutiveFailures >= 4) {
      const minutes = this.consecutiveFailures >= 6 ? 5 : 2;
      this.degradedUntil = Date.now() + minutes * 6e4;
    }
  }
  recordSuccess() {
    this.consecutiveFailures = 0;
    this.lastError = null;
    this.lastSuccessAt = /* @__PURE__ */ new Date();
    this.degradedUntil = null;
  }
  buildEmailPrompt(leadData, emailType) {
    const company = leadData.company || "votre entreprise";
    const name = leadData.name || "Monsieur/Madame";
    const sector = leadData.sector || "votre secteur d'activit\xE9";
    const service = leadData.service || "nos services";
    return `G\xE9n\xE8re un email professionnel ${emailType} pour un prospect dans le CRM.

CONTEXTE:
- Nom: ${name}
- Entreprise: ${company}
- Secteur: ${sector}
- Service d'int\xE9r\xEAt: ${service}
- Type d'email: ${emailType}

INSTRUCTIONS:
1. Cr\xE9e un email personnalis\xE9 et professionnel
2. Adapte le ton au type d'email (${emailType})
3. Mentionne les besoins sp\xE9cifiques du secteur
4. Inclus un appel \xE0 l'action clair
5. R\xE9ponds au format JSON: {"subject": "...", "body": "...", "tone": "..."}

L'email doit \xEAtre en fran\xE7ais et adapt\xE9 au march\xE9 belge.`;
  }
  parseEmailResponse(content) {
    try {
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        return JSON.parse(jsonMatch[0]);
      }
      return {
        subject: this.extractFromContent(content, "subject", "Sujet g\xE9n\xE9r\xE9 par IA"),
        body: this.extractFromContent(content, "body", content.substring(0, 500)),
        tone: this.extractFromContent(content, "tone", "professionnel")
      };
    } catch (error) {
      console.warn("\u26A0\uFE0F Erreur parsing r\xE9ponse Gemini:", error);
      return {
        subject: "Email g\xE9n\xE9r\xE9 par IA",
        body: content,
        tone: "professionnel"
      };
    }
  }
  extractFromContent(content, field, defaultValue) {
    const regex = new RegExp(`"${field}"\\s*:\\s*"([^"]*)"`, "i");
    const match = content.match(regex);
    return match ? match[1] : defaultValue;
  }
};
var _geminiInstance = null;
function getGeminiService() {
  if (!_geminiInstance) {
    _geminiInstance = new GoogleGeminiService();
  }
  return _geminiInstance;
}

// src/routes/gemini.ts
var router32 = import_express33.default.Router();
var geminiService = getGeminiService();
router32.use(authenticateToken);
router32.post("/generate-email", async (req2, res) => {
  try {
    const { leadData, emailType = "initial" } = req2.body;
    if (!leadData || !leadData.name && !leadData.context) {
      return res.status(400).json({
        success: false,
        message: "Donn\xE9es du lead requises (nom ou contexte)"
      });
    }
    console.log(`\u{1F916} [Gemini] G\xE9n\xE9ration email ${emailType} pour ${leadData.name || "prospect"}`);
    const result = await geminiService.generatePersonalizedEmail(leadData, emailType);
    if (result.success) {
      res.json({
        success: true,
        email: result.email,
        metadata: {
          generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          type: emailType,
          leadName: leadData.name || "prospect"
        }
      });
    } else {
      res.status(500).json({
        success: false,
        message: "Erreur lors de la g\xE9n\xE9ration de l'email",
        error: result.error
      });
    }
  } catch (error) {
    console.error("\u274C Erreur route generate-email:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la g\xE9n\xE9ration d'email"
    });
  }
});
router32.post("/analyze-lead", async (req2, res) => {
  try {
    const { leadData } = req2.body;
    if (!leadData) {
      return res.status(400).json({
        success: false,
        message: "Donn\xE9es du lead requises"
      });
    }
    console.log(`\u{1F916} [Gemini] Analyse lead ${leadData.name || "Anonyme"}`);
    const result = await geminiService.analyzeLeadData(leadData);
    if (result.success) {
      res.json({
        success: true,
        analysis: result.analysis,
        metadata: {
          analyzedAt: (/* @__PURE__ */ new Date()).toISOString(),
          leadId: leadData.id
        }
      });
    } else {
      res.status(500).json({
        success: false,
        message: "Erreur lors de l'analyse du lead",
        error: result.error
      });
    }
  } catch (error) {
    console.error("\u274C Erreur route analyze-lead:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de l'analyse du lead"
    });
  }
});
router32.post("/generate-proposal", async (req2, res) => {
  try {
    const { leadData, productData } = req2.body;
    if (!leadData || !productData) {
      return res.status(400).json({
        success: false,
        message: "Donn\xE9es du lead et du produit requises"
      });
    }
    console.log(`\u{1F916} [Gemini] G\xE9n\xE9ration proposition pour ${leadData.name}`);
    const result = await geminiService.generateCommercialProposal(leadData, productData);
    if (result.success) {
      res.json({
        success: true,
        proposal: result.proposal,
        metadata: {
          generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          leadName: leadData.name,
          productName: productData.name
        }
      });
    } else {
      res.status(500).json({
        success: false,
        message: "Erreur lors de la g\xE9n\xE9ration de la proposition",
        error: result.error
      });
    }
  } catch (error) {
    console.error("\u274C Erreur route generate-proposal:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la g\xE9n\xE9ration de proposition"
    });
  }
});
router32.post("/analyze-sentiment", async (req2, res) => {
  try {
    const { emailContent } = req2.body;
    if (!emailContent) {
      return res.status(400).json({
        success: false,
        message: "Contenu de l'email requis"
      });
    }
    console.log("\u{1F916} [Gemini] Analyse sentiment email");
    const result = await geminiService.analyzeSentiment(emailContent);
    if (result.success) {
      res.json({
        success: true,
        sentiment: result.sentiment,
        metadata: {
          analyzedAt: (/* @__PURE__ */ new Date()).toISOString(),
          emailLength: emailContent.length
        }
      });
    } else {
      res.status(500).json({
        success: false,
        message: "Erreur lors de l'analyse de sentiment",
        error: result.error
      });
    }
  } catch (error) {
    console.error("\u274C Erreur route analyze-sentiment:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de l'analyse de sentiment"
    });
  }
});
router32.post("/suggest-response", async (req2, res) => {
  try {
    const { emailContent, context = {} } = req2.body;
    if (!emailContent) {
      return res.status(400).json({
        success: false,
        message: "Contenu de l'email requis"
      });
    }
    console.log("\u{1F916} [Gemini] Suggestion r\xE9ponse email");
    const result = await geminiService.suggestEmailResponse(emailContent, context);
    if (result.success) {
      res.json({
        success: true,
        suggestions: result.suggestions,
        metadata: {
          generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          context
        }
      });
    } else {
      res.status(500).json({
        success: false,
        message: "Erreur lors de la suggestion de r\xE9ponse",
        error: result.error
      });
    }
  } catch (error) {
    console.error("\u274C Erreur route suggest-response:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur lors de la suggestion de r\xE9ponse"
    });
  }
});
router32.get("/test", async (req2, res) => {
  try {
    console.log("\u{1F9EA} [Gemini] Test de connexion");
    const testLead = {
      name: "Test Prospect",
      company: "Test Company",
      email: "test@example.com"
    };
    const result = await geminiService.generatePersonalizedEmail(testLead, "initial");
    res.json({
      success: true,
      message: "Service Gemini op\xE9rationnel",
      test: result.success,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("\u274C Erreur test Gemini:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors du test Gemini",
      error: error.message
    });
  }
});
router32.get("/stats", async (req2, res) => {
  try {
    res.json({
      success: true,
      stats: {
        emailsGenerated: 0,
        leadsAnalyzed: 0,
        proposalsCreated: 0,
        sentimentAnalyses: 0,
        responseSuggestions: 0,
        lastUsed: (/* @__PURE__ */ new Date()).toISOString()
      },
      message: "Statistiques Gemini (\xE0 impl\xE9menter)"
    });
  } catch (error) {
    console.error("\u274C Erreur stats Gemini:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration des statistiques"
    });
  }
});
var gemini_default = router32;

// src/routes/telnyx.ts
var import_express35 = require("express");

// src/api/telnyx.ts
var import_express34 = require("express");
init_database();
var import_zod7 = require("zod");
var import_axios2 = __toESM(require("axios"), 1);

// src/services/TelnyxCascadeService.ts
init_database();
var import_axios = __toESM(require("axios"), 1);
init_crypto();

// src/utils/baseUrl.ts
function firstHeader(req2, headerName) {
  const raw = req2.headers[headerName.toLowerCase()];
  if (Array.isArray(raw)) return raw[0];
  if (typeof raw === "string") return raw;
  return void 0;
}
function getBaseUrlFromRequest(req2) {
  const xfProto = firstHeader(req2, "x-forwarded-proto")?.split(",")[0]?.trim();
  const xfHost = firstHeader(req2, "x-forwarded-host")?.split(",")[0]?.trim();
  const proto = xfProto || req2.protocol;
  let host = xfHost || req2.get("host");
  if (typeof host === "string") {
    const backendPort = (process.env.PORT || "4000").trim();
    host = host.replace(/-(5173|5174)(?=\.app\.github\.dev$)/, `-${backendPort}`);
  }
  return `${proto}://${host}`;
}
function isLocalhostBaseUrl(value) {
  const trimmed = value.trim();
  if (!trimmed) return false;
  try {
    const parsed = new URL(trimmed);
    return ["localhost", "127.0.0.1", "0.0.0.0"].includes(parsed.hostname);
  } catch {
    return /localhost|127\.0\.0\.1|0\.0\.0\.0/.test(trimmed);
  }
}
function getBackendBaseUrl(options = {}) {
  const envBase = (process.env.BACKEND_URL || process.env.APP_URL || process.env.API_URL || "").trim();
  if (envBase && (!options.req || !isLocalhostBaseUrl(envBase))) return envBase;
  if (options.req) return getBaseUrlFromRequest(options.req);
  if (process.env.NODE_ENV !== "production") {
    const portEnv = options.devPortEnvVar || "PORT";
    const port2 = (process.env[portEnv] || "4000").trim();
    return `http://localhost:${port2}`;
  }
  throw new Error("BACKEND_URL/APP_URL/API_URL non configur\xE9e (impossible de construire une URL en production)");
}
function joinUrl(base, path11) {
  const cleanBase = base.endsWith("/") ? base.slice(0, -1) : base;
  const cleanPath = path11.startsWith("/") ? path11 : `/${path11}`;
  return `${cleanBase}${cleanPath}`;
}

// src/services/TelnyxCascadeService.ts
var prisma16 = db;
var TELNYX_API_URL = "https://api.telnyx.com/v2";
async function getTelnyxHeaders(organizationId) {
  try {
    const config = await prisma16.telnyxConfig.findUnique({
      where: { organizationId }
    });
    let apiKey = (process.env.TELNYX_API_KEY || "").trim();
    if (config?.encryptedApiKey) {
      try {
        apiKey = decrypt(config.encryptedApiKey).trim();
      } catch {
        console.error("\u274C [TelnyxCascade] API Key illisible (ENCRYPTION_KEY modifi\xE9e ?)");
        return null;
      }
    }
    if (!apiKey || apiKey.trim().length === 0) {
      console.error("\u274C [TelnyxCascade] API Key vide apr\xE8s d\xE9chiffrement");
      return null;
    }
    return {
      "Authorization": `Bearer ${apiKey}`,
      "Content-Type": "application/json"
    };
  } catch (error) {
    console.error("\u274C [TelnyxCascade] Erreur getTelnyxHeaders:", error);
    return null;
  }
}
async function planCascade(organizationId) {
  try {
    const sipEndpoints = await prisma16.telnyxSipEndpoint.findMany({
      where: {
        organizationId,
        status: "active"
      },
      orderBy: {
        priority: "asc"
      }
    });
    const legs = [];
    for (const endpoint of sipEndpoints) {
      legs.push({
        type: "sip",
        destination: `sip:${endpoint.sipUsername}@${endpoint.sipDomain}`,
        endpointId: endpoint.id,
        priority: endpoint.priority,
        timeout: endpoint.timeout
      });
    }
    console.log(`\u{1F4CB} [TelnyxCascade] Cascade planifi\xE9e: ${legs.length} \xE9tapes`, legs);
    return legs;
  } catch (error) {
    console.error("\u274C [TelnyxCascade] Erreur planCascade:", error);
    return [];
  }
}
async function initiateCallWithCascade(options, req2) {
  const { organizationId, fromNumber, toNumber: toNumber2, leadId } = options;
  try {
    console.log("\u{1F4DE} [TelnyxCascade] Initiation appel avec cascade:", { fromNumber, toNumber: toNumber2, organizationId });
    const config = await prisma16.telnyxConfig.findUnique({ where: { organizationId } }).catch(() => null);
    const connectionId = (config?.defaultConnectionId || process.env.TELNYX_CONNECTION_ID || "").trim();
    if (!connectionId) {
      throw new Error("TELNYX_CONNECTION_ID manquant (configurez une connexion par d\xE9faut Telnyx)");
    }
    const webhookUrl = config?.webhookUrl && config.webhookUrl !== "__AUTO__" ? config.webhookUrl : joinUrl(getBackendBaseUrl({ req: req2 }), "/api/telnyx/webhooks");
    const headers = await getTelnyxHeaders(organizationId);
    if (!headers) {
      throw new Error("Configuration Telnyx manquante");
    }
    const callResponse = await import_axios.default.post(`${TELNYX_API_URL}/calls`, {
      to: toNumber2,
      from: fromNumber,
      connection_id: connectionId,
      webhook_url: webhookUrl,
      command_id: `call-${Date.now()}`
    }, { headers });
    const callData = callResponse.data.data;
    const callControlId = callData.call_control_id;
    console.log("\u2705 [TelnyxCascade] Appel initi\xE9 sur Telnyx:", callControlId);
    const call = await prisma16.telnyxCall.create({
      data: {
        id: `call-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
        callId: callControlId,
        fromNumber,
        toNumber: toNumber2,
        direction: "outbound",
        status: "initiated",
        // ‚úÖ √âtat initial
        organizationId,
        leadId,
        startedAt: /* @__PURE__ */ new Date(),
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log("\u{1F4BE} [TelnyxCascade] Call record cr\xE9\xE9:", call.id);
    const cascadeLegs = await planCascade(organizationId);
    if (cascadeLegs.length === 0) {
      console.warn("\u26A0\uFE0F [TelnyxCascade] Aucun endpoint SIP configur\xE9, appel direct");
      return {
        success: true,
        callId: call.id,
        callControlId,
        cascade: []
      };
    }
    await executeCascade(cascadeLegs, call.callId);
    return {
      success: true,
      callId: call.id,
      callControlId,
      cascade: cascadeLegs.map((leg) => ({
        type: leg.type,
        destination: leg.destination,
        priority: leg.priority
      }))
    };
  } catch (error) {
    console.error("\u274C [TelnyxCascade] Erreur initiation cascade:", error.response?.data || error.message);
    throw error;
  }
}
async function executeCascade(cascadeLegs, callId) {
  try {
    for (const leg of cascadeLegs) {
      await prisma16.telnyxCallLeg.create({
        data: {
          id: `leg-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
          callId,
          legType: leg.type,
          endpointId: leg.endpointId,
          destination: leg.destination,
          status: "pending",
          // En attente d'ex√©cution
          priority: leg.priority,
          dialedAt: /* @__PURE__ */ new Date(),
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    }
    console.log(`\u2705 [TelnyxCascade] ${cascadeLegs.length} legs cr\xE9\xE9s pour cascade`);
  } catch (error) {
    console.error("\u274C [TelnyxCascade] Erreur executeCascade:", error);
    throw error;
  }
}
async function updateCallLegStatus(callId, destination, status, answeredAt, endedAt, duration) {
  try {
    const leg = await prisma16.telnyxCallLeg.findFirst({
      where: {
        callId,
        destination
      }
    });
    if (!leg) {
      console.warn(`\u26A0\uFE0F [TelnyxCascade] Leg non trouv\xE9: ${callId} -> ${destination}`);
      return;
    }
    await prisma16.telnyxCallLeg.update({
      where: { id: leg.id },
      data: {
        status,
        answeredAt,
        endedAt,
        duration,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log(`\u2705 [TelnyxCascade] Leg mis \xE0 jour: ${destination} -> ${status}`);
    if (status === "answered") {
      await prisma16.telnyxCall.update({
        where: { callId },
        data: {
          answeredBy: destination,
          status: "in-progress",
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
      console.log(`\u2705 [TelnyxCascade] Call answered_by: ${destination}`);
    }
  } catch (error) {
    console.error("\u274C [TelnyxCascade] Erreur updateCallLegStatus:", error);
  }
}
var TelnyxCascadeService = {
  initiateCallWithCascade,
  updateCallLegStatus
};

// src/api/telnyx.ts
init_crypto();
var import_crypto14 = __toESM(require("crypto"), 1);
var router33 = (0, import_express34.Router)();
var prisma17 = db;
router33.use(async (_req, _res, next) => {
  await ensureTelnyxCascadeSchema();
  next();
});
var TELNYX_API_URL2 = "https://api.telnyx.com/v2";
var telnyxCascadeSchemaEnsured = null;
async function ensureTelnyxCascadeSchema() {
  if (!telnyxCascadeSchemaEnsured) {
    telnyxCascadeSchemaEnsured = (async () => {
      try {
        await prisma17.$executeRawUnsafe('ALTER TABLE IF EXISTS "TelnyxCall" ADD COLUMN IF NOT EXISTS "answeredBy" TEXT;');
        await prisma17.$executeRawUnsafe('ALTER TABLE IF EXISTS "TelnyxConnection" ADD COLUMN IF NOT EXISTS "sipDomain" TEXT;');
        await prisma17.$executeRawUnsafe('ALTER TABLE IF EXISTS "TelnyxConnection" ADD COLUMN IF NOT EXISTS "callControlAppId" TEXT;');
        await prisma17.$executeRawUnsafe(`CREATE TABLE IF NOT EXISTS "TelnyxConfig" (
          id TEXT PRIMARY KEY,
          "organizationId" TEXT NOT NULL UNIQUE,
          "encryptedApiKey" TEXT NOT NULL,
          "webhookSigningSecret" TEXT,
          "webhookUrl" TEXT NOT NULL DEFAULT '__AUTO__',
          "defaultConnectionId" TEXT,
          "callControlAppId" TEXT,
          "fallbackPstnNumber" TEXT,
          "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
          "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP
        );`);
        await prisma17.$executeRawUnsafe('ALTER TABLE IF EXISTS "TelnyxConfig" ADD COLUMN IF NOT EXISTS "webhookSigningSecret" TEXT;');
        await prisma17.$executeRawUnsafe('ALTER TABLE IF EXISTS "TelnyxConfig" ADD COLUMN IF NOT EXISTS "webhookUrl" TEXT;');
        await prisma17.$executeRawUnsafe('ALTER TABLE IF EXISTS "TelnyxConfig" ADD COLUMN IF NOT EXISTS "defaultConnectionId" TEXT;');
        await prisma17.$executeRawUnsafe('ALTER TABLE IF EXISTS "TelnyxConfig" ADD COLUMN IF NOT EXISTS "callControlAppId" TEXT;');
        await prisma17.$executeRawUnsafe('ALTER TABLE IF EXISTS "TelnyxConfig" ADD COLUMN IF NOT EXISTS "fallbackPstnNumber" TEXT;');
        await prisma17.$executeRawUnsafe('ALTER TABLE IF EXISTS "TelnyxConfig" ADD COLUMN IF NOT EXISTS "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP;');
        await prisma17.$executeRawUnsafe('ALTER TABLE IF EXISTS "TelnyxConfig" ADD COLUMN IF NOT EXISTS "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP;');
        await prisma17.$executeRawUnsafe(`DO $$
        BEGIN
          IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'TelnyxConfig_organizationId_fkey') THEN
            ALTER TABLE "TelnyxConfig"
              ADD CONSTRAINT "TelnyxConfig_organizationId_fkey"
              FOREIGN KEY ("organizationId") REFERENCES "Organization"("id")
              ON DELETE RESTRICT ON UPDATE CASCADE;
          END IF;
        END $$;`);
        await prisma17.$executeRawUnsafe('CREATE INDEX IF NOT EXISTS "TelnyxConfig_organizationId_idx" ON "TelnyxConfig"("organizationId");');
        await prisma17.$executeRawUnsafe(`CREATE TABLE IF NOT EXISTS "TelnyxSipEndpoint" (
          id TEXT PRIMARY KEY,
          "organizationId" TEXT NOT NULL,
          "userId" TEXT,
          name TEXT NOT NULL,
          "sipUsername" TEXT NOT NULL,
          "sipPassword" TEXT NOT NULL,
          "sipDomain" TEXT NOT NULL,
          status TEXT NOT NULL DEFAULT 'active',
          priority INTEGER NOT NULL DEFAULT 1,
          timeout INTEGER NOT NULL DEFAULT 10,
          "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
          "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP
        );`);
        await prisma17.$executeRawUnsafe('CREATE UNIQUE INDEX IF NOT EXISTS "TelnyxSipEndpoint_sipUsername_key" ON "TelnyxSipEndpoint"("sipUsername");');
        await prisma17.$executeRawUnsafe('CREATE INDEX IF NOT EXISTS "TelnyxSipEndpoint_organizationId_idx" ON "TelnyxSipEndpoint"("organizationId");');
        await prisma17.$executeRawUnsafe('CREATE INDEX IF NOT EXISTS "TelnyxSipEndpoint_userId_idx" ON "TelnyxSipEndpoint"("userId");');
        await prisma17.$executeRawUnsafe('CREATE INDEX IF NOT EXISTS "TelnyxSipEndpoint_priority_idx" ON "TelnyxSipEndpoint"(priority);');
        await prisma17.$executeRawUnsafe('CREATE INDEX IF NOT EXISTS "TelnyxSipEndpoint_status_idx" ON "TelnyxSipEndpoint"(status);');
        await prisma17.$executeRawUnsafe(`DO $$
        BEGIN
          IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'TelnyxSipEndpoint_organizationId_fkey') THEN
            ALTER TABLE "TelnyxSipEndpoint"
              ADD CONSTRAINT "TelnyxSipEndpoint_organizationId_fkey"
              FOREIGN KEY ("organizationId") REFERENCES "Organization"("id")
              ON DELETE RESTRICT ON UPDATE CASCADE;
          END IF;
          IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'TelnyxSipEndpoint_userId_fkey') THEN
            ALTER TABLE "TelnyxSipEndpoint"
              ADD CONSTRAINT "TelnyxSipEndpoint_userId_fkey"
              FOREIGN KEY ("userId") REFERENCES "User"("id")
              ON DELETE SET NULL ON UPDATE CASCADE;
          END IF;
        END $$;`);
        await prisma17.$executeRawUnsafe(`CREATE TABLE IF NOT EXISTS "TelnyxCallLeg" (
          id TEXT PRIMARY KEY,
          "callId" TEXT NOT NULL,
          "legType" TEXT NOT NULL,
          "endpointId" TEXT,
          destination TEXT NOT NULL,
          status TEXT NOT NULL,
          "dialedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
          "answeredAt" TIMESTAMP(3),
          "endedAt" TIMESTAMP(3),
          duration INTEGER,
          priority INTEGER NOT NULL,
          "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
          "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP
        );`);
        await prisma17.$executeRawUnsafe('CREATE INDEX IF NOT EXISTS "TelnyxCallLeg_callId_idx" ON "TelnyxCallLeg"("callId");');
        await prisma17.$executeRawUnsafe('CREATE INDEX IF NOT EXISTS "TelnyxCallLeg_endpointId_idx" ON "TelnyxCallLeg"("endpointId");');
        await prisma17.$executeRawUnsafe('CREATE INDEX IF NOT EXISTS "TelnyxCallLeg_status_idx" ON "TelnyxCallLeg"(status);');
        await prisma17.$executeRawUnsafe('CREATE INDEX IF NOT EXISTS "TelnyxCallLeg_dialedAt_idx" ON "TelnyxCallLeg"("dialedAt");');
        await prisma17.$executeRawUnsafe(`DO $$
        BEGIN
          IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'TelnyxCallLeg_callId_fkey') THEN
            ALTER TABLE "TelnyxCallLeg"
              ADD CONSTRAINT "TelnyxCallLeg_callId_fkey"
              FOREIGN KEY ("callId") REFERENCES "TelnyxCall"("callId")
              ON DELETE RESTRICT ON UPDATE CASCADE;
          END IF;
          IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'TelnyxCallLeg_endpointId_fkey') THEN
            ALTER TABLE "TelnyxCallLeg"
              ADD CONSTRAINT "TelnyxCallLeg_endpointId_fkey"
              FOREIGN KEY ("endpointId") REFERENCES "TelnyxSipEndpoint"("id")
              ON DELETE SET NULL ON UPDATE CASCADE;
          END IF;
        END $$;`);
      } catch (e) {
        console.warn("\u26A0\uFE0F [Telnyx API] Impossible de garantir le sch\xE9ma Telnyx cascade (continuation best-effort):", e.message);
      }
    })();
  }
  return telnyxCascadeSchemaEnsured;
}
function getHeaderString(req2, headerName) {
  const value = req2.headers[headerName.toLowerCase()];
  if (typeof value === "string") return value.trim() || null;
  if (Array.isArray(value) && typeof value[0] === "string") return value[0].trim() || null;
  return null;
}
function getOrganizationIdFromRequest(req2) {
  return req2.user?.organizationId || getHeaderString(req2, "x-organization-id");
}
function isSuperAdminFromRequest(req2) {
  if (req2.user?.isSuperAdmin) return true;
  if ((req2.user?.role || "").toLowerCase() === "super_admin") return true;
  const header = (getHeaderString(req2, "x-is-super-admin") || "").toLowerCase();
  return header === "true" || header === "1" || header === "yes";
}
async function getTelnyxAuth(organizationId) {
  const config = await prisma17.telnyxConfig.findUnique({ where: { organizationId } }).catch(() => null);
  const envApiKey = (process.env.TELNYX_API_KEY || "").trim();
  if (!config?.encryptedApiKey && !envApiKey) {
    return {
      ok: false,
      status: 412,
      code: "TELNYX_NOT_CONFIGURED",
      message: "Configuration Telnyx manquante. Veuillez enregistrer une cl\xE9 API Telnyx."
    };
  }
  let apiKey = envApiKey;
  let source = envApiKey ? "env" : "db";
  if (config?.encryptedApiKey) {
    try {
      apiKey = decrypt(config.encryptedApiKey).trim();
      source = "db";
    } catch {
      return {
        ok: false,
        status: 400,
        code: "TELNYX_API_KEY_DECRYPT_FAILED",
        message: "Cl\xE9 API Telnyx illisible (ENCRYPTION_KEY modifi\xE9e ?). R\xE9-enregistrez la configuration Telnyx."
      };
    }
  }
  apiKey = apiKey.replace(/^Bearer\s+/i, "").trim();
  if (!apiKey) {
    return {
      ok: false,
      status: 412,
      code: "TELNYX_NOT_CONFIGURED",
      message: "Configuration Telnyx manquante. Veuillez enregistrer une cl\xE9 API Telnyx."
    };
  }
  return {
    ok: true,
    source,
    headers: {
      Authorization: `Bearer ${apiKey}`,
      "Content-Type": "application/json"
    }
  };
}
function getApiKeyMeta(rawKey) {
  const trimmed = rawKey.replace(/^Bearer\s+/i, "").trim();
  const prefix = trimmed.length >= 4 ? trimmed.slice(0, 4) : trimmed.length > 0 ? trimmed : null;
  const fingerprint = import_crypto14.default.createHash("sha256").update(trimmed).digest("hex").slice(0, 12);
  return { length: trimmed.length, prefix, fingerprint };
}
function normalizeE164(value) {
  if (typeof value !== "string") return null;
  const v = value.trim();
  if (!v) return null;
  if (!/^\+[1-9]\d{5,14}$/.test(v)) return null;
  return v;
}
function deriveCountryCodeFromE164(phoneNumber) {
  const v = phoneNumber.trim();
  if (v.startsWith("+32")) return "BE";
  if (v.startsWith("+33")) return "FR";
  if (v.startsWith("+31")) return "NL";
  if (v.startsWith("+49")) return "DE";
  if (v.startsWith("+44")) return "GB";
  if (v.startsWith("+352")) return "LU";
  if (v.startsWith("+34")) return "ES";
  if (v.startsWith("+39")) return "IT";
  if (v.startsWith("+41")) return "CH";
  if (v.startsWith("+1")) return "US";
  return "UN";
}
async function getFallbackPstnNumberRaw(organizationId) {
  try {
    const rows = await prisma17.$queryRaw`
      SELECT "fallbackPstnNumber" FROM "TelnyxConfig" WHERE "organizationId" = ${organizationId} LIMIT 1
    `;
    const raw = rows?.[0]?.fallbackPstnNumber || null;
    return normalizeE164(raw);
  } catch {
    return null;
  }
}
function safeDecryptMaybe(value) {
  try {
    return decrypt(value);
  } catch {
    return value;
  }
}
function computeTelnyxWebhookUrlFromRequest(req2) {
  return joinUrl(getBackendBaseUrl({ req: req2 }), "/api/telnyx/webhooks");
}
function isUnsafeTelnyxWebhookUrl(url) {
  const u = url.trim().toLowerCase();
  if (!u) return true;
  if (u.includes("webhook.site")) return true;
  if (/localhost|127\.0\.0\.1|0\.0\.0\.0/.test(u)) return true;
  if (/-5173\b|-5174\b/.test(u)) return true;
  return false;
}
function selectTelnyxWebhookUrl(req2, configuredWebhookUrl) {
  const computed = computeTelnyxWebhookUrlFromRequest(req2);
  if (!configuredWebhookUrl || configuredWebhookUrl === "__AUTO__") return { webhookUrl: computed, warnings: [] };
  const custom = configuredWebhookUrl.trim();
  if (isUnsafeTelnyxWebhookUrl(custom)) return { webhookUrl: computed, warnings: ["WEBHOOK_URL_IGNORED_UNSAFE"] };
  return { webhookUrl: custom, warnings: [] };
}
var sipTestInFlightByOrg = /* @__PURE__ */ new Map();
function acquireSipTestLock(organizationId, ttlMs = 6e4) {
  const now = Date.now();
  const existing = sipTestInFlightByOrg.get(organizationId);
  if (existing && existing.expiresAt > now) return null;
  const token = `${now}-${Math.random().toString(36).slice(2)}`;
  sipTestInFlightByOrg.set(organizationId, { token, expiresAt: now + ttlMs });
  return token;
}
function releaseSipTestLock(organizationId, token) {
  if (!token) return;
  const current = sipTestInFlightByOrg.get(organizationId);
  if (current?.token === token) sipTestInFlightByOrg.delete(organizationId);
}
async function getActiveOutboundCallsCount(organizationId, windowMinutes = 20) {
  const since = new Date(Date.now() - windowMinutes * 6e4);
  return prisma17.telnyxCall.count({
    where: {
      organizationId,
      direction: "outbound",
      endedAt: null,
      startedAt: { gte: since },
      NOT: [{ status: "completed" }]
    }
  }).catch(() => 0);
}
async function getOrganizationIdFromCallPayload(callData) {
  const connectionId = typeof callData?.connection_id === "string" ? callData.connection_id : null;
  if (connectionId) {
    const conn = await prisma17.telnyxConnection.findUnique({ where: { id: connectionId } }).catch(() => null);
    if (conn?.organizationId) return conn.organizationId;
  }
  const to = typeof callData?.to === "string" ? callData.to.trim() : null;
  if (to) {
    const num = await prisma17.telnyxPhoneNumber.findUnique({ where: { phoneNumber: to } }).catch(() => null);
    if (num?.organizationId) return num.organizationId;
  }
  return null;
}
async function getOrganizationIdFromMessagePayload(messageData) {
  const connectionId = typeof messageData?.connection_id === "string" ? messageData.connection_id : null;
  if (connectionId) {
    const conn = await prisma17.telnyxConnection.findUnique({ where: { id: connectionId } }).catch(() => null);
    if (conn?.organizationId) return conn.organizationId;
  }
  const toCandidate = normalizeE164(messageData?.to?.[0]?.phone_number) || normalizeE164(messageData?.to?.phone_number) || normalizeE164(messageData?.to);
  const fromCandidate = normalizeE164(messageData?.from?.phone_number) || normalizeE164(messageData?.from);
  const candidates = [toCandidate, fromCandidate].filter(Boolean);
  for (const phoneNumber of candidates) {
    const num = await prisma17.telnyxPhoneNumber.findUnique({ where: { phoneNumber } }).catch(() => null);
    if (num?.organizationId) return num.organizationId;
  }
  return null;
}
async function planInboundCascadeLegs(organizationId) {
  const endpoints = await prisma17.telnyxSipEndpoint.findMany({
    where: { organizationId, status: "active" },
    orderBy: [{ priority: "asc" }, { createdAt: "asc" }]
  });
  const legs = endpoints.map((ep) => {
    const sipPassword = safeDecryptMaybe(ep.sipPassword).trim();
    return {
      type: "sip",
      destination: `sip:${ep.sipUsername}@${ep.sipDomain}`,
      endpointId: ep.id,
      priority: ep.priority,
      timeout: ep.timeout || 10,
      sipAuthUsername: ep.sipUsername,
      sipAuthPassword: sipPassword
    };
  });
  const cfg = await prisma17.telnyxConfig.findUnique({ where: { organizationId } }).catch(() => null);
  const fallback = normalizeE164(cfg?.fallbackPstnNumber) || await getFallbackPstnNumberRaw(organizationId);
  if (fallback) {
    const maxPriority = legs.reduce((max, leg) => Math.max(max, leg.priority), 0);
    legs.push({ type: "pstn", destination: fallback, priority: maxPriority + 1, timeout: 30 });
  }
  return legs;
}
async function transferCallToLeg(params) {
  const { callControlId, organizationId, leg, webhookUrl } = params;
  const auth = await getTelnyxAuth(organizationId);
  if (!auth.ok) throw new Error(auth.message);
  const commandId = `xfer-${callControlId}-${Date.now()}`;
  const body2 = {
    to: leg.destination,
    timeout_secs: leg.timeout,
    webhook_url: webhookUrl,
    command_id: commandId
  };
  if (leg.type === "sip") {
    body2.sip_auth_username = leg.sipAuthUsername;
    body2.sip_auth_password = leg.sipAuthPassword;
  }
  try {
    await import_axios2.default.post(`${TELNYX_API_URL2}/calls/${callControlId}/actions/transfer`, body2, { headers: auth.headers });
  } catch (error) {
    const status = error?.response?.status;
    const details = error?.response?.data;
    const errors = Array.isArray(details?.errors) ? details.errors : void 0;
    console.warn("\u26A0\uFE0F [Telnyx Transfer] \xE9chec", {
      status,
      callControlId,
      legType: leg.type,
      destination: leg.destination,
      errors,
      details
    });
    throw error;
  }
}
router33.get("/diagnostic", async (req2, res) => {
  const organizationId = getOrganizationIdFromRequest(req2);
  if (!organizationId) return res.status(401).json({ ok: false, error: "Non autoris\xE9" });
  const computedWebhookUrl = computeTelnyxWebhookUrlFromRequest(req2);
  const result = {
    ok: false,
    organizationId,
    computedWebhookUrl,
    checks: []
  };
  const config = await prisma17.telnyxConfig.findUnique({ where: { organizationId } }).catch(() => null);
  const fallbackPstnNumber = await getFallbackPstnNumberRaw(organizationId) || normalizeE164(config?.fallbackPstnNumber);
  const storedWebhookUrl = config?.webhookUrl || null;
  const webhookMode = !storedWebhookUrl || storedWebhookUrl === "__AUTO__" ? "auto" : "custom";
  result.config = {
    exists: Boolean(config),
    hasEncryptedApiKey: Boolean(config?.encryptedApiKey),
    webhookMode,
    webhookUrl: webhookMode === "custom" ? storedWebhookUrl : null,
    defaultConnectionId: config?.defaultConnectionId || null,
    callControlAppId: config?.callControlAppId || null,
    fallbackPstnNumber: fallbackPstnNumber || null
  };
  try {
    const present = {
      TelnyxConfig: false,
      TelnyxSipEndpoint: false,
      TelnyxCallLeg: false
    };
    for (const tableName of Object.keys(present)) {
      try {
        await prisma17.$queryRawUnsafe(`SELECT 1 FROM "${tableName}" LIMIT 1`);
        present[tableName] = true;
      } catch {
        present[tableName] = false;
      }
    }
    result.checks.push({
      name: "db_telnyx_cascade_schema",
      ok: Boolean(present.TelnyxConfig && present.TelnyxSipEndpoint && present.TelnyxCallLeg),
      details: {
        present,
        hint: "Si un \xE9l\xE9ment manque: ex\xE9cuter add-telnyx-cascade-schema.sql (aucun reset)."
      }
    });
  } catch {
    result.checks.push({
      name: "db_telnyx_cascade_schema",
      ok: false,
      details: {
        message: "Impossible de v\xE9rifier le sch\xE9ma DB (connexion indisponible)."
      }
    });
  }
  if (config?.encryptedApiKey) {
    try {
      const decrypted = decrypt(config.encryptedApiKey);
      result.checks.push({ name: "decrypt", ok: true });
      try {
        result.apiKeyMeta = getApiKeyMeta(String(decrypted || ""));
      } catch {
      }
    } catch {
      result.checks.push({
        name: "decrypt",
        ok: false,
        details: {
          code: "TELNYX_API_KEY_DECRYPT_FAILED",
          message: "Cl\xE9 API chiffr\xE9e illisible (ENCRYPTION_KEY modifi\xE9e ?). R\xE9-enregistrez la configuration."
        }
      });
      return res.json(result);
    }
  }
  const auth = await getTelnyxAuth(organizationId);
  if (!auth.ok) {
    result.checks.push({ name: "auth", ok: false, details: { code: auth.code, message: auth.message } });
    return res.json(result);
  }
  result.apiKeySource = auth.source;
  result.checks.push({ name: "auth", ok: true, details: { source: auth.source } });
  const expected = selectTelnyxWebhookUrl(req2, config?.webhookUrl || "__AUTO__").webhookUrl;
  const numberConnectionIds = await prisma17.telnyxPhoneNumber.findMany({
    where: { organizationId },
    select: { connectionId: true }
  }).then((rows) => rows.map((r) => String(r.connectionId || "").trim()).filter(Boolean)).catch(() => []);
  const connectionIds = await prisma17.telnyxConnection.findMany({
    where: { organizationId },
    select: { id: true }
  }).then((rows) => rows.map((r) => String(r.id || "").trim()).filter(Boolean)).catch(() => []);
  const envConnectionId = String(process.env.TELNYX_CONNECTION_ID || "").trim();
  const candidateAppIds = Array.from(new Set([
    (config?.callControlAppId || "").trim(),
    (config?.defaultConnectionId || "").trim(),
    envConnectionId,
    ...numberConnectionIds,
    ...connectionIds
  ].filter(Boolean)));
  if (candidateAppIds.length > 0) {
    const details = [];
    for (const id of candidateAppIds) {
      try {
        const appRes = await import_axios2.default.get(`${TELNYX_API_URL2}/call_control_applications/${id}`, { headers: auth.headers });
        const current = String(appRes?.data?.data?.webhook_event_url || "").trim() || null;
        const failover = String(appRes?.data?.data?.webhook_event_failover_url || "").trim() || null;
        const applicationName = String(appRes?.data?.data?.application_name || "").trim() || null;
        const ok = Boolean(current && current === expected) && (!failover || failover === expected);
        details.push({ id, kind: "call_control_app", current, failover, ok, found: true, applicationName });
      } catch {
        try {
          const connRes = await import_axios2.default.get(`${TELNYX_API_URL2}/connections/${id}`, { headers: auth.headers });
          const fields = pickTelnyxWebhookFields(connRes?.data?.data);
          const connectionName = String(connRes?.data?.data?.connection_name || "").trim() || null;
          const ok = Boolean(fields.webhook_event_url && fields.webhook_event_url === expected) && (!fields.webhook_event_failover_url || fields.webhook_event_failover_url === expected);
          details.push({ id, kind: "connection", current: fields.webhook_event_url, failover: fields.webhook_event_failover_url, ok, found: true, connectionName });
        } catch {
          details.push({ id, kind: "unknown", current: null, failover: null, ok: false, found: false });
        }
      }
    }
    const okAny = details.some((d) => d.ok);
    result.checks.push({
      name: "telnyx_call_control_app_webhook",
      ok: okAny,
      details: {
        expected,
        candidateSources: {
          config_callControlAppId: config?.callControlAppId || null,
          config_defaultConnectionId: config?.defaultConnectionId || null,
          env_TELNYX_CONNECTION_ID: envConnectionId || null,
          phoneNumbers_connectionIds: numberConnectionIds,
          connections_ids: connectionIds
        },
        candidates: details,
        hint: okAny ? null : "Aucune cible Telnyx (Call Control App ou Connection) ne pointe vers le CRM. Clique \u201CAppliquer \xE0 Telnyx\u201D apr\xE8s synchronisation."
      }
    });
  }
  try {
    const response = await import_axios2.default.get(`${TELNYX_API_URL2}/connections`, {
      headers: auth.headers,
      params: { "page[size]": 1 }
    });
    const count = Array.isArray(response.data?.data) ? response.data.data.length : null;
    result.checks.push({ name: "telnyx_connections", ok: true, details: { sampleCount: count } });
    result.ok = true;
  } catch (error) {
    if (import_axios2.default.isAxiosError(error)) {
      const status = error.response?.status;
      const data = error.response?.data;
      const detail = data?.errors?.[0]?.detail || data?.error || data?.message;
      result.checks.push({
        name: "telnyx_connections",
        ok: false,
        details: {
          status: status ?? null,
          code: status === 401 || status === 403 ? "TELNYX_UNAUTHORIZED" : "TELNYX_API_ERROR",
          message: detail || "Erreur Telnyx"
        }
      });
      return res.json(result);
    }
    result.checks.push({ name: "telnyx_connections", ok: false, details: { message: "Erreur inconnue" } });
    return res.json(result);
  }
  return res.json(result);
});
function respondTelnyxAxiosError(res, error, fallbackMessage) {
  if (import_axios2.default.isAxiosError(error)) {
    const status = error.response?.status;
    const data = error.response?.data;
    const detail = data?.errors?.[0]?.detail || data?.error || data?.message;
    if (status === 401 || status === 403) {
      return res.status(status).json({
        error: "Acc\xE8s Telnyx refus\xE9 (cl\xE9 API invalide ou permissions insuffisantes).",
        details: detail,
        code: "TELNYX_UNAUTHORIZED"
      });
    }
    if (typeof status === "number") {
      return res.status(status).json({
        error: fallbackMessage,
        details: detail,
        code: "TELNYX_API_ERROR"
      });
    }
  }
  return res.status(500).json({ error: fallbackMessage });
}
function pickTelnyxWebhookFields(resource) {
  const current = String(resource?.webhook_event_url || "").trim() || null;
  const failover = String(resource?.webhook_event_failover_url || "").trim() || null;
  return { webhook_event_url: current, webhook_event_failover_url: failover };
}
function shouldDebugTelnyxWebhooks() {
  return (process.env.TELNYX_DEBUG_WEBHOOKS || "").trim() === "1";
}
function telnyxWebhookDebugLog(...args) {
  if (!shouldDebugTelnyxWebhooks()) return;
  console.log("\u{1F9F7} [Telnyx Webhook Debug]", ...args);
}
async function patchTelnyxCallControlApplicationWebhook(params) {
  const { id, desiredWebhookUrl, headers, applicationName } = params;
  try {
    const beforeRes = await import_axios2.default.get(`${TELNYX_API_URL2}/call_control_applications/${id}`, { headers });
    const before = beforeRes?.data?.data;
    const baseFields = {
      webhook_event_url: desiredWebhookUrl,
      webhook_event_failover_url: desiredWebhookUrl
    };
    if (applicationName && applicationName.trim()) {
      baseFields.application_name = applicationName.trim();
    }
    const payloads = [baseFields, { data: baseFields }];
    let patched = false;
    let lastErr = null;
    for (const body2 of payloads) {
      try {
        await import_axios2.default.patch(`${TELNYX_API_URL2}/call_control_applications/${id}`, body2, { headers });
        patched = true;
        break;
      } catch (e) {
        lastErr = e;
      }
    }
    if (!patched) {
      const status = import_axios2.default.isAxiosError(lastErr) ? lastErr.response?.status ?? null : null;
      const data = import_axios2.default.isAxiosError(lastErr) ? lastErr.response?.data : null;
      const detail = data?.errors?.[0]?.detail || data?.error || data?.message || null;
      return { ok: false, status, detail };
    }
    const afterRes = await import_axios2.default.get(`${TELNYX_API_URL2}/call_control_applications/${id}`, { headers });
    const after = afterRes?.data?.data;
    return { ok: true, before, after };
  } catch (e) {
    const status = import_axios2.default.isAxiosError(e) ? e.response?.status ?? null : null;
    const data = import_axios2.default.isAxiosError(e) ? e.response?.data : null;
    const detail = data?.errors?.[0]?.detail || data?.error || data?.message || null;
    return { ok: false, status, detail };
  }
}
async function patchTelnyxConnectionWebhook(params) {
  const { id, desiredWebhookUrl, headers, outboundVoiceProfileId } = params;
  try {
    const beforeRes = await import_axios2.default.get(`${TELNYX_API_URL2}/connections/${id}`, { headers });
    const before = beforeRes?.data?.data;
    const currentOutboundProfileId = (typeof before?.outbound_voice_profile_id === "string" ? before.outbound_voice_profile_id : null) || (typeof before?.outbound?.outbound_voice_profile_id === "string" ? before.outbound.outbound_voice_profile_id : null);
    const shouldSetOutboundProfile = Boolean(
      outboundVoiceProfileId && outboundVoiceProfileId.trim() && outboundVoiceProfileId !== currentOutboundProfileId
    );
    const basePayload = {
      webhook_event_url: desiredWebhookUrl,
      webhook_event_failover_url: desiredWebhookUrl
    };
    if (shouldSetOutboundProfile) {
      basePayload.outbound_voice_profile_id = outboundVoiceProfileId;
    }
    const payloads = [
      basePayload,
      { data: basePayload }
    ];
    let patched = false;
    let lastErr = null;
    for (const body2 of payloads) {
      try {
        await import_axios2.default.patch(`${TELNYX_API_URL2}/connections/${id}`, body2, { headers });
        patched = true;
        break;
      } catch (e) {
        lastErr = e;
      }
    }
    if (!patched) {
      const status = import_axios2.default.isAxiosError(lastErr) ? lastErr.response?.status ?? null : null;
      const data = import_axios2.default.isAxiosError(lastErr) ? lastErr.response?.data : null;
      const detail = data?.errors?.[0]?.detail || data?.error || data?.message || null;
      return { ok: false, status, detail };
    }
    const afterRes = await import_axios2.default.get(`${TELNYX_API_URL2}/connections/${id}`, { headers });
    const after = afterRes?.data?.data;
    return { ok: true, before, after, skippedOutboundProfile: !shouldSetOutboundProfile };
  } catch (e) {
    const status = import_axios2.default.isAxiosError(e) ? e.response?.status ?? null : null;
    const data = import_axios2.default.isAxiosError(e) ? e.response?.data : null;
    const detail = data?.errors?.[0]?.detail || data?.error || data?.message || null;
    return { ok: false, status, detail };
  }
}
var makeCallSchema = import_zod7.z.object({
  to: import_zod7.z.string().min(1),
  from: import_zod7.z.string().min(1),
  connection_id: import_zod7.z.string().optional(),
  lead_id: import_zod7.z.string().optional(),
  webhook_url: import_zod7.z.string().url().optional()
});
var sendMessageSchema = import_zod7.z.object({
  to: import_zod7.z.string().min(1),
  from: import_zod7.z.string().min(1),
  text: import_zod7.z.string().min(1).max(1600),
  type: import_zod7.z.enum(["SMS", "MMS"]).default("SMS"),
  lead_id: import_zod7.z.string().optional(),
  media_urls: import_zod7.z.array(import_zod7.z.string().url()).optional()
});
var purchaseNumberSchema = import_zod7.z.object({
  country: import_zod7.z.string().length(2),
  type: import_zod7.z.enum(["local", "toll-free", "national", "mobile"]),
  area_code: import_zod7.z.string().optional()
});
router33.get("/connections", async (req2, res) => {
  try {
    console.log("\u{1F50D} [Telnyx API] R\xE9cup\xE9ration des connexions...");
    const organizationId = getOrganizationIdFromRequest(req2);
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    console.log("[Telnyx API] organizationId:", organizationId);
    const auth = await getTelnyxAuth(organizationId);
    if (!auth.ok) {
      const cached = await prisma17.telnyxConnection.findMany({
        where: { organizationId },
        orderBy: { updatedAt: "desc" }
      });
      res.setHeader("x-telnyx-warning", auth.code);
      return res.json(
        cached.map((conn) => ({
          id: conn.id,
          name: conn.name,
          status: conn.status,
          type: conn.type,
          webhook_url: conn.webhookUrl,
          created_at: conn.createdAt?.toISOString?.() ?? (/* @__PURE__ */ new Date()).toISOString(),
          updated_at: conn.updatedAt?.toISOString?.() ?? (/* @__PURE__ */ new Date()).toISOString()
        }))
      );
    }
    const response = await import_axios2.default.get(`${TELNYX_API_URL2}/connections`, {
      headers: auth.headers
    });
    const connections = response.data.data.map((conn) => ({
      id: conn.id,
      name: conn.connection_name || `Connection ${conn.id.substring(0, 8)}`,
      status: conn.active ? "active" : "inactive",
      type: conn.outbound?.type || "voice",
      webhook_url: conn.webhook_event_url,
      created_at: conn.created_at,
      updated_at: conn.updated_at
    }));
    for (const conn of connections) {
      try {
        await prisma17.telnyxConnection.upsert({
          where: { id: conn.id },
          update: {
            name: conn.name,
            status: conn.status,
            type: conn.type,
            webhookUrl: conn.webhook_url,
            updatedAt: /* @__PURE__ */ new Date()
          },
          create: {
            id: conn.id,
            name: conn.name,
            status: conn.status,
            type: conn.type,
            webhookUrl: conn.webhook_url,
            organizationId,
            createdAt: new Date(conn.created_at),
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
      } catch (dbError) {
        console.warn("\u26A0\uFE0F [Telnyx API] Connexion non sauvegard\xE9e en DB:", conn.id, dbError);
      }
    }
    console.log(`\u2705 [Telnyx API] ${connections.length} connexions synchronis\xE9es`);
    res.json(connections);
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur connexions:", error);
    const organizationId = getOrganizationIdFromRequest(req2);
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    const cached = await prisma17.telnyxConnection.findMany({
      where: { organizationId },
      orderBy: { updatedAt: "desc" }
    }).catch(() => []);
    if (cached.length > 0) {
      res.setHeader("x-telnyx-warning", "TELNYX_CONNECTIONS_FALLBACK_CACHE");
      return res.json(
        cached.map((conn) => ({
          id: conn.id,
          name: conn.name,
          status: conn.status,
          type: conn.type,
          webhook_url: conn.webhookUrl,
          created_at: conn.createdAt?.toISOString?.() ?? (/* @__PURE__ */ new Date()).toISOString(),
          updated_at: conn.updatedAt?.toISOString?.() ?? (/* @__PURE__ */ new Date()).toISOString()
        }))
      );
    }
    if (import_axios2.default.isAxiosError(error)) {
      const status = error.response?.status;
      if (status === 401 || status === 403) {
        res.setHeader("x-telnyx-warning", "TELNYX_UNAUTHORIZED");
        return res.json([]);
      }
    }
    res.setHeader("x-telnyx-warning", "TELNYX_CONNECTIONS_UNAVAILABLE");
    return res.json([]);
  }
});
router33.get("/phone-numbers", async (req2, res) => {
  try {
    console.log("\u{1F50D} [Telnyx API] R\xE9cup\xE9ration des num\xE9ros...");
    const organizationId = getOrganizationIdFromRequest(req2);
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    const auth = await getTelnyxAuth(organizationId);
    if (!auth.ok) {
      const cached = await prisma17.telnyxPhoneNumber.findMany({
        where: { organizationId },
        orderBy: { updatedAt: "desc" }
      });
      res.setHeader("x-telnyx-warning", auth.code);
      return res.json(
        cached.map((number) => ({
          id: number.id,
          phone_number: number.phoneNumber,
          status: number.status,
          country_code: number.countryCode,
          number_type: number.numberType,
          features: number.features || [],
          monthly_cost: Number(number.monthlyCost || 0),
          connection_id: number.connectionId,
          purchased_at: number.purchasedAt?.toISOString?.()
        }))
      );
    }
    const response = await import_axios2.default.get(`${TELNYX_API_URL2}/phone_numbers`, {
      headers: auth.headers,
      params: { "page[size]": 250 }
    });
    const phoneNumbers = response.data.data.map((number) => ({
      id: number.id,
      phone_number: number.phone_number,
      status: number.status,
      country_code: number.country_code,
      number_type: number.phone_number_type,
      features: number.features || [],
      monthly_cost: parseFloat(number.monthly_recurring_cost || "0"),
      connection_id: number.connection_id,
      purchased_at: number.purchased_at
    }));
    for (const number of phoneNumbers) {
      try {
        const safeCountryCode = number.country_code && String(number.country_code).trim().length > 0 ? String(number.country_code).trim() : deriveCountryCodeFromE164(String(number.phone_number || ""));
        await prisma17.telnyxPhoneNumber.upsert({
          where: { id: number.id },
          update: {
            phoneNumber: number.phone_number,
            status: number.status,
            countryCode: safeCountryCode,
            numberType: number.number_type,
            features: number.features,
            monthlyCost: number.monthly_cost,
            connectionId: number.connection_id,
            updatedAt: /* @__PURE__ */ new Date()
          },
          create: {
            id: number.id,
            phoneNumber: number.phone_number,
            status: number.status,
            countryCode: safeCountryCode,
            numberType: number.number_type,
            features: number.features,
            monthlyCost: number.monthly_cost,
            connectionId: number.connection_id,
            organizationId,
            purchasedAt: new Date(number.purchased_at),
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
      } catch (dbError) {
        console.warn("\u26A0\uFE0F [Telnyx API] Num\xE9ro non sauvegard\xE9 en DB:", number.id, dbError);
      }
    }
    console.log(`\u2705 [Telnyx API] ${phoneNumbers.length} num\xE9ros synchronis\xE9s`);
    res.json(phoneNumbers);
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur num\xE9ros:", error);
    const organizationId = getOrganizationIdFromRequest(req2);
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    const cached = await prisma17.telnyxPhoneNumber.findMany({
      where: { organizationId },
      orderBy: { updatedAt: "desc" }
    }).catch(() => []);
    if (cached.length > 0) {
      res.setHeader("x-telnyx-warning", "TELNYX_PHONE_NUMBERS_FALLBACK_CACHE");
      return res.json(
        cached.map((number) => ({
          id: number.id,
          phone_number: number.phoneNumber,
          status: number.status,
          country_code: number.countryCode,
          number_type: number.numberType,
          features: number.features || [],
          monthly_cost: Number(number.monthlyCost || 0),
          connection_id: number.connectionId,
          purchased_at: number.purchasedAt?.toISOString?.()
        }))
      );
    }
    if (import_axios2.default.isAxiosError(error)) {
      const status = error.response?.status;
      if (status === 401 || status === 403) {
        res.setHeader("x-telnyx-warning", "TELNYX_UNAUTHORIZED");
        return res.json([]);
      }
    }
    res.setHeader("x-telnyx-warning", "TELNYX_PHONE_NUMBERS_UNAVAILABLE");
    return res.json([]);
  }
});
router33.post("/phone-numbers/purchase", async (req2, res) => {
  try {
    const parsed = purchaseNumberSchema.safeParse(req2.body);
    if (!parsed.success) {
      return res.status(400).json({
        error: "Param\xE8tres invalides pour l'achat de num\xE9ro",
        code: "TELNYX_INVALID_PURCHASE_PARAMS",
        issues: parsed.error.issues
      });
    }
    const data = parsed.data;
    console.log("\u{1F6D2} [Telnyx API] Achat de num\xE9ro:", data);
    const organizationId = getOrganizationIdFromRequest(req2);
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    const auth = await getTelnyxAuth(organizationId);
    if (!auth.ok) {
      return res.status(auth.status).json({ error: auth.message, code: auth.code });
    }
    const searchResponse = await import_axios2.default.get(`${TELNYX_API_URL2}/available_phone_numbers`, {
      headers: auth.headers,
      params: {
        "filter[country_code]": data.country,
        "filter[phone_number_type]": data.type,
        "filter[area_code]": data.area_code,
        "page[size]": 10
      }
    });
    if (!searchResponse.data.data.length) {
      return res.status(404).json({ error: "Aucun num\xE9ro disponible avec ces crit\xE8res" });
    }
    const availableNumber = searchResponse.data.data[0];
    const purchaseResponse = await import_axios2.default.post(`${TELNYX_API_URL2}/phone_number_orders`, {
      phone_numbers: [{ phone_number: availableNumber.phone_number }]
    }, { headers: auth.headers });
    console.log("\u2705 [Telnyx API] Num\xE9ro achet\xE9:", availableNumber.phone_number);
    res.json({
      success: true,
      phone_number: availableNumber.phone_number,
      order_id: purchaseResponse.data.data.id
    });
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur achat num\xE9ro:", error);
    return respondTelnyxAxiosError(res, error, "Erreur lors de l'achat du num\xE9ro");
  }
});
router33.get("/calls", async (req2, res) => {
  try {
    const limit = parseInt(req2.query.limit) || 50;
    const organizationId = getOrganizationIdFromRequest(req2);
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    console.log(`\u{1F50D} [Telnyx API] R\xE9cup\xE9ration des appels (${limit})...`);
    const calls = await prisma17.telnyxCall.findMany({
      where: { organizationId },
      orderBy: { startedAt: "desc" },
      take: limit
    });
    const formattedCalls = calls.map((call) => ({
      id: call.id,
      call_id: call.callId,
      from: call.fromNumber,
      to: call.toNumber,
      direction: call.direction,
      status: call.status,
      duration: call.duration || 0,
      cost: call.cost || 0,
      started_at: call.startedAt.toISOString(),
      ended_at: call.endedAt?.toISOString(),
      recording_url: call.recordingUrl,
      lead_id: call.leadId
    }));
    console.log(`\u2705 [Telnyx API] ${formattedCalls.length} appels r\xE9cup\xE9r\xE9s`);
    res.json(formattedCalls);
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur r\xE9cup\xE9ration appels:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des appels" });
  }
});
router33.post("/calls", async (req2, res) => {
  try {
    const data = makeCallSchema.parse(req2.body);
    const organizationId = getOrganizationIdFromRequest(req2);
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    console.log("\u{1F4DE} [Telnyx API] Initiation appel AVEC CASCADE:", data);
    const result = await TelnyxCascadeService.initiateCallWithCascade({
      organizationId,
      fromNumber: data.from,
      toNumber: data.to,
      leadId: data.lead_id
    }, req2);
    console.log("\u2705 [Telnyx API] Appel initi\xE9 avec cascade:", result.callControlId);
    res.json({
      success: true,
      id: result.callId,
      call_id: result.callControlId,
      from: data.from,
      to: data.to,
      status: "initiated",
      cascade: result.cascade
    });
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur initiation appel:", error);
    return respondTelnyxAxiosError(res, error, "Erreur lors de l'initiation de l'appel");
  }
});
router33.post("/calls/hangup-active", async (req2, res) => {
  try {
    const requesterOrgId = getOrganizationIdFromRequest(req2);
    const isSuperAdmin2 = isSuperAdminFromRequest(req2);
    const organizationId = req2.body?.organizationId || requesterOrgId;
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    if (!isSuperAdmin2 && requesterOrgId && organizationId !== requesterOrgId) {
      return res.status(403).json({ error: "Acc\xE8s refus\xE9 \xE0 cette organisation" });
    }
    const auth = await getTelnyxAuth(organizationId);
    if (!auth.ok) return res.status(auth.status).json({ error: auth.message, code: auth.code });
    const since = new Date(Date.now() - 30 * 6e4);
    const active = await prisma17.telnyxCall.findMany({
      where: {
        organizationId,
        direction: "outbound",
        endedAt: null,
        startedAt: { gte: since },
        NOT: [{ status: "completed" }]
      },
      orderBy: { startedAt: "desc" },
      take: 20
    }).catch(() => []);
    let hangupAttempted = 0;
    let hangupOk = 0;
    let clearedStale = 0;
    const errors = [];
    for (const call of active) {
      const callControlId = call.callId;
      if (!callControlId) continue;
      hangupAttempted += 1;
      try {
        await import_axios2.default.post(`${TELNYX_API_URL2}/calls/${callControlId}/actions/hangup`, {}, { headers: auth.headers });
        hangupOk += 1;
        await prisma17.telnyxCall.update({
          where: { id: call.id },
          data: { status: "completed", endedAt: /* @__PURE__ */ new Date(), updatedAt: /* @__PURE__ */ new Date() }
        }).catch(() => null);
      } catch (err) {
        const status = import_axios2.default.isAxiosError(err) ? err.response?.status ?? null : null;
        const data = import_axios2.default.isAxiosError(err) ? err.response?.data : null;
        const detail = data?.errors?.[0]?.detail || data?.error || data?.message || null;
        errors.push({ callId: callControlId, status, detail });
        if (status === 404 || status === 422) {
          await prisma17.telnyxCall.update({
            where: { id: call.id },
            data: { status: "completed", endedAt: /* @__PURE__ */ new Date(), updatedAt: /* @__PURE__ */ new Date() }
          }).catch(() => null);
          clearedStale += 1;
        }
      }
    }
    return res.json({
      success: true,
      organizationId,
      activeFound: active.length,
      hangupAttempted,
      hangupOk,
      clearedStale,
      errors
    });
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur hangup-active:", error);
    return respondTelnyxAxiosError(res, error, "Erreur lors du raccrochage des appels actifs");
  }
});
router33.post("/calls/:callId/hangup", async (req2, res) => {
  try {
    const { callId } = req2.params;
    const organizationId = getOrganizationIdFromRequest(req2);
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    console.log("\u260E\uFE0F [Telnyx API] Raccrocher appel:", callId);
    const call = await prisma17.telnyxCall.findFirst({
      where: {
        callId,
        organizationId
      }
    });
    if (!call) {
      return res.status(404).json({ error: "Appel non trouv\xE9" });
    }
    const auth = await getTelnyxAuth(organizationId);
    if (!auth.ok) {
      return res.status(auth.status).json({ error: auth.message, code: auth.code });
    }
    await import_axios2.default.post(`${TELNYX_API_URL2}/calls/${callId}/actions/hangup`, {}, {
      headers: auth.headers
    });
    await prisma17.telnyxCall.update({
      where: { id: call.id },
      data: {
        status: "completed",
        endedAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log("\u2705 [Telnyx API] Appel raccroch\xE9:", callId);
    res.json({ success: true });
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur raccrocher:", error);
    return respondTelnyxAxiosError(res, error, "Erreur lors du raccrochage");
  }
});
router33.post("/calls/:callId/mute", async (req2, res) => {
  try {
    const { callId } = req2.params;
    const organizationId = getOrganizationIdFromRequest(req2);
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    console.log("\u{1F507} [Telnyx API] Couper micro:", callId);
    const auth = await getTelnyxAuth(organizationId);
    if (!auth.ok) {
      return res.status(auth.status).json({ error: auth.message, code: auth.code });
    }
    await import_axios2.default.post(`${TELNYX_API_URL2}/calls/${callId}/actions/mute`, {}, {
      headers: auth.headers
    });
    console.log("\u2705 [Telnyx API] Micro coup\xE9:", callId);
    res.json({ success: true });
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur mute:", error);
    return respondTelnyxAxiosError(res, error, "Erreur lors de la coupure du micro");
  }
});
router33.post("/calls/:callId/unmute", async (req2, res) => {
  try {
    const { callId } = req2.params;
    const organizationId = getOrganizationIdFromRequest(req2);
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    console.log("\u{1F50A} [Telnyx API] Activer micro:", callId);
    const auth = await getTelnyxAuth(organizationId);
    if (!auth.ok) {
      return res.status(auth.status).json({ error: auth.message, code: auth.code });
    }
    await import_axios2.default.post(`${TELNYX_API_URL2}/calls/${callId}/actions/unmute`, {}, {
      headers: auth.headers
    });
    console.log("\u2705 [Telnyx API] Micro activ\xE9:", callId);
    res.json({ success: true });
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur unmute:", error);
    return respondTelnyxAxiosError(res, error, "Erreur lors de l'activation du micro");
  }
});
router33.get("/messages", async (req2, res) => {
  try {
    const limit = parseInt(req2.query.limit) || 50;
    const organizationId = getOrganizationIdFromRequest(req2);
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    console.log(`\u{1F50D} [Telnyx API] R\xE9cup\xE9ration des messages (${limit})...`);
    const messages = await prisma17.telnyxMessage.findMany({
      where: { organizationId },
      orderBy: { sentAt: "desc" },
      take: limit
    });
    const formattedMessages = messages.map((msg) => ({
      id: msg.id,
      message_id: msg.messageId,
      from: msg.fromNumber,
      to: msg.toNumber,
      direction: msg.direction,
      type: msg.type,
      text: msg.text,
      status: msg.status,
      cost: msg.cost || 0,
      sent_at: msg.sentAt.toISOString(),
      delivered_at: msg.deliveredAt?.toISOString(),
      media_urls: msg.mediaUrls || [],
      lead_id: msg.leadId
    }));
    console.log(`\u2705 [Telnyx API] ${formattedMessages.length} messages r\xE9cup\xE9r\xE9s`);
    res.json(formattedMessages);
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur r\xE9cup\xE9ration messages:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des messages" });
  }
});
router33.post("/messages", async (req2, res) => {
  try {
    const data = sendMessageSchema.parse(req2.body);
    const organizationId = getOrganizationIdFromRequest(req2);
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    console.log("\u{1F4AC} [Telnyx API] Envoi message:", data);
    const auth = await getTelnyxAuth(organizationId);
    if (!auth.ok) {
      return res.status(auth.status).json({ error: auth.message, code: auth.code });
    }
    const response = await import_axios2.default.post(`${TELNYX_API_URL2}/messages`, {
      to: data.to,
      from: data.from,
      text: data.text,
      type: data.type,
      media_urls: data.media_urls,
      webhook_url: joinUrl(getBackendBaseUrl({ req: req2 }), "/api/telnyx/webhooks/messages")
    }, { headers: auth.headers });
    const messageData = response.data.data;
    const message = await prisma17.telnyxMessage.create({
      data: {
        id: `msg-${Date.now()}`,
        messageId: messageData.id,
        fromNumber: data.from,
        toNumber: data.to,
        direction: "outbound",
        type: data.type,
        text: data.text,
        status: "sent",
        organizationId,
        leadId: data.lead_id,
        mediaUrls: data.media_urls || [],
        sentAt: /* @__PURE__ */ new Date(),
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log("\u2705 [Telnyx API] Message envoy\xE9:", message.messageId);
    res.json({
      id: message.id,
      message_id: message.messageId,
      status: message.status
    });
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur envoi message:", error);
    return respondTelnyxAxiosError(res, error, "Erreur lors de l'envoi du message");
  }
});
router33.post("/webhooks/calls", async (req2, res) => {
  try {
    const webhook = req2.body;
    console.log("\u{1FA9D} [Telnyx Webhook] Appel:", webhook.data?.event_type);
    const callData = webhook.data?.payload;
    if (!callData) {
      return res.json({ received: true });
    }
    const call = await prisma17.telnyxCall.findFirst({
      where: { callId: callData.call_control_id }
    });
    if (call) {
      const updateData = {
        status: callData.state || call.status,
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (callData.state === "bridged") {
        updateData.startedAt = /* @__PURE__ */ new Date();
      } else if (["hangup", "completed"].includes(callData.state)) {
        updateData.endedAt = /* @__PURE__ */ new Date();
        updateData.duration = callData.hangup_duration_millis ? Math.floor(callData.hangup_duration_millis / 1e3) : 0;
      }
      await prisma17.telnyxCall.update({
        where: { id: call.id },
        data: updateData
      });
      console.log(`\u2705 [Telnyx Webhook] Appel mis \xE0 jour: ${call.callId} -> ${callData.state}`);
    }
    res.json({ received: true });
  } catch (error) {
    console.error("\u274C [Telnyx Webhook] Erreur appel:", error);
    res.status(500).json({ error: "Erreur webhook appel" });
  }
});
router33.post("/webhooks/messages", async (req2, res) => {
  try {
    const webhook = req2.body;
    console.log("\u{1FA9D} [Telnyx Webhook] Message:", webhook.data?.event_type);
    const messageData = webhook.data?.payload;
    if (!messageData) {
      return res.json({ received: true });
    }
    const eventType = webhook.data.event_type;
    if (eventType === "message.received") {
      const organizationId = await getOrganizationIdFromMessagePayload(messageData);
      if (!organizationId) {
        console.warn("\u26A0\uFE0F [Telnyx Webhook] SMS entrant: org introuvable, skip:", messageData?.id);
        return res.json({ received: true });
      }
      await prisma17.telnyxMessage.create({
        data: {
          id: `msg-${Date.now()}`,
          messageId: messageData.id,
          fromNumber: messageData.from.phone_number,
          toNumber: messageData.to[0].phone_number,
          direction: "inbound",
          type: messageData.type,
          text: messageData.text,
          status: "delivered",
          organizationId,
          sentAt: new Date(messageData.received_at),
          deliveredAt: /* @__PURE__ */ new Date(),
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
      console.log("\u2705 [Telnyx Webhook] Message entrant sauvegard\xE9:", messageData.id);
    } else if (eventType === "message.sent") {
      const message = await prisma17.telnyxMessage.findFirst({
        where: { messageId: messageData.id }
      });
      if (message) {
        await prisma17.telnyxMessage.update({
          where: { id: message.id },
          data: {
            status: "delivered",
            deliveredAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
        console.log("\u2705 [Telnyx Webhook] Message livr\xE9:", messageData.id);
      }
    }
    res.json({ received: true });
  } catch (error) {
    console.error("\u274C [Telnyx Webhook] Erreur message:", error);
    res.status(500).json({ error: "Erreur webhook message" });
  }
});
router33.post("/sync", async (req2, res) => {
  try {
    console.log("\u{1F504} [Telnyx API] Synchronisation compl\xE8te...");
    const organizationId = getOrganizationIdFromRequest(req2);
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    const auth = await getTelnyxAuth(organizationId);
    if (!auth.ok) {
      return res.status(auth.status).json({ error: auth.message, code: auth.code });
    }
    const [connectionsRes, numbersRes] = await Promise.all([
      import_axios2.default.get(`${TELNYX_API_URL2}/connections`, { headers: auth.headers }),
      import_axios2.default.get(`${TELNYX_API_URL2}/phone_numbers`, {
        headers: auth.headers,
        params: { "page[size]": 250 }
      })
    ]);
    for (const conn of connectionsRes.data.data) {
      try {
        await prisma17.telnyxConnection.upsert({
          where: { id: conn.id },
          update: {
            name: conn.connection_name || `Connection ${conn.id.substring(0, 8)}`,
            status: conn.active ? "active" : "inactive",
            type: conn.outbound?.type || "voice",
            webhookUrl: conn.webhook_event_url,
            updatedAt: /* @__PURE__ */ new Date()
          },
          create: {
            id: conn.id,
            name: conn.connection_name || `Connection ${conn.id.substring(0, 8)}`,
            status: conn.active ? "active" : "inactive",
            type: conn.outbound?.type || "voice",
            webhookUrl: conn.webhook_event_url,
            organizationId,
            createdAt: new Date(conn.created_at),
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
      } catch (dbError) {
        console.warn("\u26A0\uFE0F [Telnyx API] Connexion non sauvegard\xE9e en DB:", conn.id, dbError);
      }
    }
    for (const number of numbersRes.data.data) {
      try {
        const safeCountryCode = number.country_code && String(number.country_code).trim().length > 0 ? String(number.country_code).trim() : deriveCountryCodeFromE164(String(number.phone_number || ""));
        await prisma17.telnyxPhoneNumber.upsert({
          where: { id: number.id },
          update: {
            phoneNumber: number.phone_number,
            status: number.status,
            countryCode: safeCountryCode,
            numberType: number.phone_number_type,
            features: number.features || [],
            monthlyCost: parseFloat(number.monthly_recurring_cost || "0"),
            connectionId: number.connection_id,
            updatedAt: /* @__PURE__ */ new Date()
          },
          create: {
            id: number.id,
            phoneNumber: number.phone_number,
            status: number.status,
            countryCode: safeCountryCode,
            numberType: number.phone_number_type,
            features: number.features || [],
            monthlyCost: parseFloat(number.monthly_recurring_cost || "0"),
            connectionId: number.connection_id,
            organizationId,
            purchasedAt: new Date(number.purchased_at),
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
      } catch (dbError) {
        console.warn("\u26A0\uFE0F [Telnyx API] Num\xE9ro non sauvegard\xE9 en DB:", number.id, dbError);
      }
    }
    console.log("\u2705 [Telnyx API] Synchronisation termin\xE9e");
    res.json({
      success: true,
      connections: connectionsRes.data.data.length,
      numbers: numbersRes.data.data.length
    });
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur synchronisation:", error);
    return respondTelnyxAxiosError(res, error, "Erreur lors de la synchronisation");
  }
});
router33.post("/config", async (req2, res) => {
  try {
    const schema = import_zod7.z.object({
      api_key: import_zod7.z.string().optional().or(import_zod7.z.literal("")),
      webhook_url: import_zod7.z.string().url().optional().or(import_zod7.z.literal("")).or(import_zod7.z.literal("__AUTO__")),
      default_connection: import_zod7.z.string().optional().or(import_zod7.z.literal("")),
      call_control_app_id: import_zod7.z.string().optional().or(import_zod7.z.literal("")),
      webhook_signing_secret: import_zod7.z.string().optional().or(import_zod7.z.literal("")),
      fallback_pstn_number: import_zod7.z.string().optional().or(import_zod7.z.literal("")),
      organizationId: import_zod7.z.string().optional().or(import_zod7.z.literal(""))
    });
    let parsed;
    try {
      parsed = schema.parse(req2.body);
    } catch (e) {
      if (e instanceof import_zod7.z.ZodError) {
        return res.status(400).json({
          code: "TELNYX_CONFIG_INVALID_PAYLOAD",
          message: "Payload invalide pour la configuration Telnyx",
          error: "Payload invalide pour la configuration Telnyx",
          details: e.issues.map((i) => ({ path: i.path.join("."), message: i.message }))
        });
      }
      throw e;
    }
    const requesterOrgId = getOrganizationIdFromRequest(req2);
    const isSuperAdmin2 = isSuperAdminFromRequest(req2);
    const targetOrgId = parsed.organizationId && parsed.organizationId.length > 0 ? parsed.organizationId : requesterOrgId;
    if (!targetOrgId) {
      return res.status(400).json({ error: "organizationId manquant" });
    }
    if (!isSuperAdmin2 && requesterOrgId && targetOrgId !== requesterOrgId) {
      return res.status(403).json({ error: "Acc\xE8s refus\xE9 \xE0 cette organisation" });
    }
    const incomingKey = (parsed.api_key || "").replace(/^Bearer\s+/i, "").trim();
    const existingConfig = await prisma17.telnyxConfig.findUnique({ where: { organizationId: targetOrgId } }).catch(() => null);
    if (!existingConfig && !incomingKey) {
      return res.status(400).json({ error: "api_key manquante (premi\xE8re configuration)" });
    }
    const now = /* @__PURE__ */ new Date();
    const computedWebhookUrl = joinUrl(getBackendBaseUrl({ req: req2 }), "/api/telnyx/webhooks");
    const desiredWebhookUrl = parsed.webhook_url === "__AUTO__" ? "__AUTO__" : parsed.webhook_url && parsed.webhook_url.length > 0 ? parsed.webhook_url : void 0;
    const fallbackPstnNumber = typeof parsed.fallback_pstn_number === "string" ? parsed.fallback_pstn_number.trim() || null : void 0;
    if (fallbackPstnNumber && !normalizeE164(fallbackPstnNumber)) {
      return res.status(400).json({
        error: "fallback_pstn_number invalide (format E.164 attendu, ex: +32477123456)",
        message: "fallback_pstn_number invalide (format E.164 attendu, ex: +32477123456)",
        code: "TELNYX_FALLBACK_PSTN_INVALID"
      });
    }
    await ensureTelnyxCascadeSchema();
    const doUpsert = () => prisma17.telnyxConfig.upsert({
      where: { organizationId: targetOrgId },
      update: {
        ...incomingKey ? { encryptedApiKey: encrypt(incomingKey) } : {},
        webhookUrl: desiredWebhookUrl,
        defaultConnectionId: parsed.default_connection ? parsed.default_connection : null,
        callControlAppId: parsed.call_control_app_id ? parsed.call_control_app_id : null,
        webhookSigningSecret: parsed.webhook_signing_secret ? parsed.webhook_signing_secret : null,
        updatedAt: now
      },
      create: {
        id: `telnyx-config-${targetOrgId}`,
        organizationId: targetOrgId,
        encryptedApiKey: encrypt(incomingKey),
        webhookUrl: desiredWebhookUrl || "__AUTO__",
        defaultConnectionId: parsed.default_connection ? parsed.default_connection : null,
        callControlAppId: parsed.call_control_app_id ? parsed.call_control_app_id : null,
        webhookSigningSecret: parsed.webhook_signing_secret ? parsed.webhook_signing_secret : null,
        createdAt: now,
        updatedAt: now
      }
    });
    let saved;
    try {
      saved = await doUpsert();
    } catch {
      await ensureTelnyxCascadeSchema();
      saved = await doUpsert();
    }
    if (fallbackPstnNumber !== void 0) {
      await prisma17.$executeRaw`
        UPDATE "TelnyxConfig"
        SET "fallbackPstnNumber" = ${fallbackPstnNumber}, "updatedAt" = ${now}
        WHERE "organizationId" = ${targetOrgId}
      `;
    }
    const webhookUrlForResponse = !saved.webhookUrl || saved.webhookUrl === "__AUTO__" ? computedWebhookUrl : saved.webhookUrl;
    const fallbackForResponse = (fallbackPstnNumber !== void 0 ? normalizeE164(fallbackPstnNumber) || null : null) || await getFallbackPstnNumberRaw(targetOrgId);
    res.json({
      success: true,
      message: "Configuration Telnyx sauvegard\xE9e",
      organizationId: targetOrgId,
      hasApiKey: Boolean(saved.encryptedApiKey),
      webhookUrl: webhookUrlForResponse,
      defaultConnectionId: saved.defaultConnectionId,
      callControlAppId: saved.callControlAppId,
      fallbackPstnNumber: fallbackForResponse || null,
      ...incomingKey ? { apiKeyMeta: getApiKeyMeta(incomingKey) } : {}
    });
  } catch (error) {
    const errorId = import_crypto14.default.randomUUID();
    console.error(`\u274C [Telnyx API] Erreur sauvegarde configuration (errorId=${errorId}):`, error);
    const anyErr = error;
    const prismaCode = anyErr?.code;
    const dbCode = anyErr?.meta?.code;
    const msg = String(anyErr?.message || "");
    if (prismaCode === "P2022" || prismaCode === "P2021" || msg.includes("column") || msg.includes("does not exist") || dbCode === "42703") {
      return res.status(500).json({
        code: "TELNYX_DB_SCHEMA_MISSING",
        message: `Sch\xE9ma DB Telnyx incomplet (ref: ${errorId}).`,
        error: `Sch\xE9ma DB Telnyx incomplet (ref: ${errorId}).`,
        hint: "Appliquez add-telnyx-cascade-schema.sql (aucun reset) puis r\xE9essayez.",
        meta: { errorId, prismaCode: prismaCode || null, dbCode: dbCode || null }
      });
    }
    if (msg.toLowerCase().includes("permission denied")) {
      return res.status(500).json({
        code: "TELNYX_DB_PERMISSION_DENIED",
        message: `Droits DB insuffisants pour cr\xE9er/alt\xE9rer le sch\xE9ma Telnyx (ref: ${errorId}).`,
        error: `Droits DB insuffisants pour cr\xE9er/alt\xE9rer le sch\xE9ma Telnyx (ref: ${errorId}).`,
        hint: "V\xE9rifiez les droits SQL (CREATE/ALTER) sur la base.",
        meta: { errorId, prismaCode: prismaCode || null, dbCode: dbCode || null }
      });
    }
    res.status(500).json({
      code: "TELNYX_CONFIG_SAVE_FAILED",
      message: `Erreur lors de la sauvegarde de la configuration (ref: ${errorId}).`,
      error: `Erreur lors de la sauvegarde de la configuration (ref: ${errorId}).`,
      meta: { errorId, prismaCode: prismaCode || null, dbCode: dbCode || null }
    });
  }
});
router33.post("/provision", async (req2, res) => {
  try {
    const requesterOrgId = getOrganizationIdFromRequest(req2);
    const isSuperAdmin2 = isSuperAdminFromRequest(req2);
    const targetOrgId = req2.body?.organizationId || requesterOrgId;
    if (!targetOrgId) return res.status(401).json({ error: "Non autoris\xE9" });
    if (!isSuperAdmin2 && requesterOrgId && targetOrgId !== requesterOrgId) {
      return res.status(403).json({ error: "Acc\xE8s refus\xE9 \xE0 cette organisation" });
    }
    await ensureTelnyxCascadeSchema();
    const config = await prisma17.telnyxConfig.findUnique({ where: { organizationId: targetOrgId } }).catch(() => null);
    if (!config?.encryptedApiKey) {
      return res.status(400).json({
        code: "TELNYX_CONFIG_MISSING",
        error: "Configuration Telnyx manquante",
        message: "Configure la cl\xE9 API et enregistre avant de provisionner."
      });
    }
    const auth = await getTelnyxAuth(targetOrgId);
    if (!auth.ok) {
      return res.status(auth.status).json({ error: auth.message, code: auth.code });
    }
    const { webhookUrl: desiredWebhookUrl, warnings: webhookWarnings } = selectTelnyxWebhookUrl(req2, config.webhookUrl);
    telnyxWebhookDebugLog("provision", {
      organizationId: targetOrgId,
      computedWebhookUrl: computeTelnyxWebhookUrlFromRequest(req2),
      desiredWebhookUrl,
      host: req2.get("host") || null,
      xForwardedHost: getHeaderString(req2, "x-forwarded-host"),
      xForwardedProto: getHeaderString(req2, "x-forwarded-proto")
    });
    const warnings = [];
    warnings.push(...webhookWarnings);
    if (/localhost|127\.0\.0\.1/.test(desiredWebhookUrl)) {
      warnings.push("WEBHOOK_LOCALHOST");
    }
    if (!config.callControlAppId) warnings.push("CALL_CONTROL_APP_ID_MISSING");
    if (!config.defaultConnectionId) warnings.push("DEFAULT_CONNECTION_MISSING");
    const actions = [];
    let desiredOutboundVoiceProfileId = null;
    const envOutboundVoiceProfileId = String(process.env.TELNYX_OUTBOUND_VOICE_PROFILE_ID || "").trim();
    if (envOutboundVoiceProfileId) {
      desiredOutboundVoiceProfileId = envOutboundVoiceProfileId;
    }
    try {
      const outboundProfilesRes = await import_axios2.default.get(`${TELNYX_API_URL2}/outbound_voice_profiles`, {
        headers: auth.headers,
        params: { "page[size]": 250 }
      });
      const outboundProfiles = Array.isArray(outboundProfilesRes?.data?.data) ? outboundProfilesRes.data.data : [];
      const enabledProfiles = outboundProfiles.filter((p) => p?.enabled !== false);
      if (!desiredOutboundVoiceProfileId) {
        desiredOutboundVoiceProfileId = enabledProfiles[0]?.id || outboundProfiles[0]?.id || null;
      }
      if (!desiredOutboundVoiceProfileId) {
        warnings.push("OUTBOUND_VOICE_PROFILE_MISSING");
      } else if (outboundProfiles.length > 1 && !envOutboundVoiceProfileId) {
        warnings.push("OUTBOUND_VOICE_PROFILE_MULTIPLE");
      }
      actions.push({
        type: "outbound_voice_profiles",
        ok: true,
        selectedId: desiredOutboundVoiceProfileId,
        total: outboundProfiles.length,
        enabled: enabledProfiles.length
      });
    } catch (err) {
      warnings.push("OUTBOUND_VOICE_PROFILE_FETCH_FAILED");
      actions.push({
        type: "outbound_voice_profiles",
        ok: false,
        error: "OUTBOUND_VOICE_PROFILE_FETCH_FAILED"
      });
    }
    const numberConnectionIds = await prisma17.telnyxPhoneNumber.findMany({
      where: { organizationId: targetOrgId },
      select: { connectionId: true }
    }).then((rows) => rows.map((r) => String(r.connectionId || "").trim()).filter(Boolean)).catch(() => []);
    const connectionIds = await prisma17.telnyxConnection.findMany({
      where: { organizationId: targetOrgId },
      select: { id: true }
    }).then((rows) => rows.map((r) => String(r.id || "").trim()).filter(Boolean)).catch(() => []);
    const envConnectionId = String(process.env.TELNYX_CONNECTION_ID || "").trim();
    const candidateAppIds = Array.from(new Set([
      (config.callControlAppId || "").trim(),
      (config.defaultConnectionId || "").trim(),
      envConnectionId,
      ...numberConnectionIds,
      ...connectionIds
    ].filter(Boolean)));
    telnyxWebhookDebugLog("candidateAppIds", {
      organizationId: targetOrgId,
      count: candidateAppIds.length,
      candidateAppIds,
      sources: {
        config_callControlAppId: (config.callControlAppId || "").trim() || null,
        config_defaultConnectionId: (config.defaultConnectionId || "").trim() || null,
        env_TELNYX_CONNECTION_ID: envConnectionId || null,
        phoneNumbers_connectionIds: numberConnectionIds,
        connections_ids: connectionIds
      }
    });
    let callControlUpdated = 0;
    const patchedCallControlAppIds = [];
    if (candidateAppIds.length === 0) {
      warnings.push("CALL_CONTROL_APP_ID_MISSING");
    } else {
      for (const appId of candidateAppIds) {
        let applicationName = `CRM-${targetOrgId}`;
        let exists = false;
        try {
          const existing = await import_axios2.default.get(`${TELNYX_API_URL2}/call_control_applications/${appId}`, { headers: auth.headers });
          exists = true;
          const nameFromApi = existing?.data?.data?.application_name;
          if (typeof nameFromApi === "string" && nameFromApi.trim().length > 0) {
            applicationName = nameFromApi.trim();
          }
        } catch {
          const patchedConn = await patchTelnyxConnectionWebhook({
            id: appId,
            desiredWebhookUrl,
            headers: auth.headers,
            outboundVoiceProfileId: desiredOutboundVoiceProfileId
          });
          if (patchedConn.ok) {
            const connectionName = String(patchedConn.after?.connection_name || patchedConn.before?.connection_name || "").trim() || null;
            callControlUpdated += 1;
            patchedCallControlAppIds.push(appId);
            actions.push({
              type: "connection",
              id: appId,
              ok: true,
              connection_name: connectionName,
              outbound_voice_profile_id: patchedConn.after?.outbound_voice_profile_id || patchedConn.before?.outbound_voice_profile_id || null,
              outbound_voice_profile_updated: patchedConn.skippedOutboundProfile === false,
              before: pickTelnyxWebhookFields(patchedConn.before),
              after: pickTelnyxWebhookFields(patchedConn.after)
            });
          } else {
            actions.push({ type: "call_control_app", id: appId, ok: false, error: "NOT_A_CALL_CONTROL_APP_OR_CONNECTION", status: patchedConn.status ?? null, detail: patchedConn.detail ?? null });
          }
          continue;
        }
        if (exists) {
          const patchedApp = await patchTelnyxCallControlApplicationWebhook({
            id: appId,
            desiredWebhookUrl,
            headers: auth.headers,
            applicationName
          });
          if (!patchedApp.ok) {
            actions.push({
              type: "call_control_app",
              id: appId,
              ok: false,
              error: "CALL_CONTROL_APP_PATCH_FAILED",
              status: patchedApp.status ?? null,
              detail: patchedApp.detail ?? null
            });
            continue;
          }
          callControlUpdated += 1;
          patchedCallControlAppIds.push(appId);
          actions.push({
            type: "call_control_app",
            id: appId,
            ok: true,
            application_name: String(patchedApp.after?.application_name || patchedApp.before?.application_name || applicationName).trim() || null,
            before: pickTelnyxWebhookFields(patchedApp.before),
            after: pickTelnyxWebhookFields(patchedApp.after)
          });
        }
      }
    }
    if (candidateAppIds.length > 0 && callControlUpdated === 0) {
      warnings.push("CALL_CONTROL_APP_UPDATE_FAILED");
      actions.push({
        type: "call_control_app_candidates",
        ok: false,
        candidatesCount: candidateAppIds.length,
        candidates: candidateAppIds
      });
    }
    if (patchedCallControlAppIds.length > 0) {
      const preferredFromNumbers = patchedCallControlAppIds.find((id) => numberConnectionIds.includes(id)) || null;
      const preferred = preferredFromNumbers || patchedCallControlAppIds[0];
      if (preferred && preferred !== (config.callControlAppId || "").trim()) {
        await prisma17.telnyxConfig.update({
          where: { organizationId: targetOrgId },
          data: {
            callControlAppId: preferred,
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).catch(() => null);
        actions.push({ type: "config_update", ok: true, callControlAppId: preferred });
      }
    }
    const assignConnectionId = config.callControlAppId || config.defaultConnectionId || null;
    if (assignConnectionId) {
      let phoneNumbers = [];
      const cached = await prisma17.telnyxPhoneNumber.findMany({ where: { organizationId: targetOrgId } }).catch(() => []);
      phoneNumbers = cached.map((n) => n.phoneNumber).filter(Boolean);
      if (phoneNumbers.length === 0) {
        try {
          const numbersRes = await import_axios2.default.get(`${TELNYX_API_URL2}/phone_numbers`, {
            headers: auth.headers,
            params: { "page[size]": 250 }
          });
          const fromApi = Array.isArray(numbersRes?.data?.data) ? numbersRes.data.data.map((n) => String(n.phone_number || "")).filter(Boolean) : [];
          phoneNumbers = fromApi;
        } catch {
          warnings.push("TELNYX_PHONE_NUMBERS_FETCH_FAILED");
        }
      }
      if (phoneNumbers.length > 0) {
        const jobRes = await import_axios2.default.post(
          `${TELNYX_API_URL2}/phone_numbers/jobs/update_phone_numbers`,
          {
            phone_numbers: phoneNumbers,
            connection_id: assignConnectionId
          },
          { headers: auth.headers }
        );
        actions.push({
          type: "assign_numbers",
          connection_id: assignConnectionId,
          count: phoneNumbers.length,
          jobId: jobRes?.data?.data?.id || null
        });
      } else {
        actions.push({ type: "assign_numbers", connection_id: assignConnectionId, count: 0 });
      }
    }
    return res.json({
      ok: true,
      organizationId: targetOrgId,
      webhookUrl: desiredWebhookUrl,
      actions,
      warnings
    });
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur provisioning:", error);
    return respondTelnyxAxiosError(res, error, "Erreur provisioning Telnyx");
  }
});
router33.get("/users", async (req2, res) => {
  try {
    const requesterOrgId = getOrganizationIdFromRequest(req2);
    const isSuperAdmin2 = isSuperAdminFromRequest(req2);
    const organizationId = req2.query.organizationId || requesterOrgId;
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    if (!isSuperAdmin2 && requesterOrgId && organizationId !== requesterOrgId) {
      return res.status(403).json({ error: "Acc\xE8s refus\xE9 \xE0 cette organisation" });
    }
    const memberships = await prisma17.userOrganization.findMany({
      where: { organizationId, status: "ACTIVE" },
      include: {
        User: { select: { id: true, email: true, firstName: true, lastName: true } }
      },
      orderBy: { createdAt: "asc" }
    });
    const users = memberships.map((m) => m.User).filter(Boolean).map((u) => ({
      id: u.id,
      email: u.email,
      firstName: u.firstName,
      lastName: u.lastName
    }));
    return res.json(users);
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur r\xE9cup\xE9ration users org:", error);
    return res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des utilisateurs" });
  }
});
router33.post("/user-config", async (req2, res) => {
  try {
    const { userId, assignedNumber, canMakeCalls, canSendSms, monthlyLimit } = req2.body;
    const organizationId = getOrganizationIdFromRequest(req2);
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    console.log("\u2699\uFE0F [Telnyx API] Configuration utilisateur:", { userId, assignedNumber });
    const userConfig = await prisma17.telnyxUserConfig.upsert({
      where: { userId },
      update: {
        assignedNumber,
        canMakeCalls: canMakeCalls || false,
        canSendSms: canSendSms || false,
        monthlyLimit: monthlyLimit ? parseFloat(monthlyLimit) : null,
        updatedAt: /* @__PURE__ */ new Date()
      },
      create: {
        id: `telnyx-usercfg-${userId}`,
        userId,
        organizationId,
        assignedNumber,
        canMakeCalls: canMakeCalls || false,
        canSendSms: canSendSms || false,
        monthlyLimit: monthlyLimit ? parseFloat(monthlyLimit) : null,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    if (assignedNumber) {
      await prisma17.telnyxPhoneNumber.updateMany({
        where: {
          phoneNumber: assignedNumber,
          organizationId
        },
        data: {
          assignedUserId: userId,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
      await prisma17.telnyxPhoneNumber.updateMany({
        where: {
          assignedUserId: userId,
          phoneNumber: { not: assignedNumber },
          organizationId
        },
        data: {
          assignedUserId: null,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    } else {
      await prisma17.telnyxPhoneNumber.updateMany({
        where: {
          assignedUserId: userId,
          organizationId
        },
        data: {
          assignedUserId: null,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    }
    console.log("\u2705 [Telnyx API] Configuration utilisateur sauvegard\xE9e");
    res.json({ success: true, config: userConfig });
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur config utilisateur:", error);
    res.status(500).json({ error: "Erreur lors de la sauvegarde de la configuration" });
  }
});
router33.get("/user-config/:userId", async (req2, res) => {
  try {
    const { userId } = req2.params;
    const organizationId = getOrganizationIdFromRequest(req2);
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    console.log("\u{1F50D} [Telnyx API] R\xE9cup\xE9ration config utilisateur:", userId);
    const userConfig = await prisma17.telnyxUserConfig.findFirst({
      where: {
        userId,
        organizationId
      }
    });
    res.json(userConfig || {
      userId,
      organizationId,
      canMakeCalls: false,
      canSendSms: false,
      assignedNumber: null,
      monthlyLimit: null
    });
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur r\xE9cup\xE9ration config:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration de la configuration" });
  }
});
router33.get("/stats", async (req2, res) => {
  try {
    const organizationId = getOrganizationIdFromRequest(req2);
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    console.log("\u{1F4CA} [Telnyx API] R\xE9cup\xE9ration statistiques...");
    const [totalCalls, totalSms, activeNumbers] = await Promise.all([
      prisma17.telnyxCall.count({
        where: {
          organizationId,
          startedAt: { gte: new Date((/* @__PURE__ */ new Date()).getFullYear(), (/* @__PURE__ */ new Date()).getMonth(), 1) }
        }
      }),
      prisma17.telnyxMessage.count({
        where: {
          organizationId,
          createdAt: { gte: new Date((/* @__PURE__ */ new Date()).getFullYear(), (/* @__PURE__ */ new Date()).getMonth(), 1) }
        }
      }),
      prisma17.telnyxPhoneNumber.count({
        where: {
          organizationId,
          status: "active"
        }
      })
    ]);
    const calls = await prisma17.telnyxCall.findMany({
      where: {
        organizationId,
        startedAt: { gte: new Date((/* @__PURE__ */ new Date()).getFullYear(), (/* @__PURE__ */ new Date()).getMonth(), 1) }
      },
      select: { cost: true }
    });
    const numbers = await prisma17.telnyxPhoneNumber.findMany({
      where: {
        organizationId,
        status: "active"
      },
      select: { monthlyCost: true }
    });
    const callsCost = calls.reduce((sum, call) => sum + (call.cost || 0), 0);
    const numbersCost = numbers.reduce((sum, number) => sum + (number.monthlyCost || 0), 0);
    const monthlyCost = callsCost + numbersCost;
    console.log("\u2705 [Telnyx API] Statistiques r\xE9cup\xE9r\xE9es");
    res.json({
      totalCalls,
      totalSms,
      activeNumbers,
      monthlyCost
    });
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur stats:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des statistiques" });
  }
});
router33.post("/webhooks", async (req2, res) => {
  const debug = process.env.TELNYX_DEBUG_WEBHOOKS === "1";
  const webhook = req2.body;
  const eventType = webhook?.data?.event_type;
  const payload = webhook?.data?.payload;
  if (debug) {
    console.log("\u{1F9F7} [Telnyx Webhook Debug] inbound", {
      path: req2.path,
      originalUrl: req2.originalUrl,
      method: req2.method,
      userAgent: req2.headers["user-agent"],
      hasBody: Boolean(webhook && Object.keys(webhook || {}).length > 0),
      eventType,
      callControlId: payload?.call_control_id || payload?.id || null
    });
  }
  try {
    console.log("\u{1FA9D} [Telnyx Webhook]", eventType, payload?.call_control_id || payload?.id);
    if (eventType?.startsWith("call.")) {
      await handleCallWebhook(eventType, payload, req2);
    } else if (eventType?.startsWith("message.")) {
      await handleMessageWebhook(eventType, payload);
    } else {
      console.log("\u{1FA9D} [Telnyx Webhook] \xC9v\xE9nement non g\xE9r\xE9:", eventType);
    }
  } catch (error) {
    console.error("\u274C [Telnyx Webhook] Erreur:", error);
    if (debug) {
      console.error("\u{1F9F7} [Telnyx Webhook Debug] failed", {
        eventType,
        callControlId: payload?.call_control_id || payload?.id || null
      });
    }
  }
  return res.status(200).json({ received: true });
});
async function handleCallWebhook(eventType, callData, req2) {
  if (!callData || !callData.call_control_id) {
    return;
  }
  const callControlId = callData.call_control_id;
  const state = callData.state;
  let isLegEvent = false;
  let call = await prisma17.telnyxCall.findFirst({ where: { callId: callControlId } });
  if (!call) {
    const possibleDid = typeof callData.from === "string" ? callData.from.trim() : "";
    if (possibleDid) {
      const byDid = await prisma17.telnyxCall.findFirst({
        where: {
          toNumber: possibleDid,
          status: { not: "completed" }
        },
        orderBy: [{ startedAt: "desc" }]
      }).catch(() => null);
      if (byDid) {
        call = byDid;
        isLegEvent = true;
      }
    }
  }
  if (!call) {
    const directionRaw = typeof callData.direction === "string" ? callData.direction : "incoming";
    const isInbound = directionRaw === "incoming" || directionRaw === "inbound";
    if (!isInbound) {
      console.warn(`\u26A0\uFE0F [Telnyx Webhook] Call non trouv\xE9 (non-inbound): ${callControlId}`);
      return;
    }
    const organizationId = await getOrganizationIdFromCallPayload(callData);
    if (!organizationId) {
      console.warn(`\u26A0\uFE0F [Telnyx Webhook] Impossible de d\xE9terminer l'organisation pour inbound: ${callControlId}`);
      return;
    }
    call = await prisma17.telnyxCall.create({
      data: {
        id: `call-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
        callId: callControlId,
        fromNumber: String(callData.from || ""),
        toNumber: String(callData.to || ""),
        direction: "inbound",
        status: "initiated",
        organizationId,
        startedAt: /* @__PURE__ */ new Date(),
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
  }
  console.log(`\u{1FA9D} [Telnyx Webhook] ${eventType} pour call ${call.id} -> state: ${state}`);
  const mainCallControlId = call.callId;
  const updateData = {
    updatedAt: /* @__PURE__ */ new Date()
  };
  switch (eventType) {
    case "call.initiated":
      if (isLegEvent) {
        try {
          const destination = String(callData.to || callData.destination || "").trim();
          if (destination) {
            await TelnyxCascadeService.updateCallLegStatus(call.callId, destination, "dialing", /* @__PURE__ */ new Date());
          }
        } catch (e) {
          console.warn("\u26A0\uFE0F [Telnyx Webhook] call.initiated (leg): tracking leg failed:", e);
        }
        break;
      }
      updateData.status = "initiated";
      try {
        const existingLegs = await prisma17.telnyxCallLeg.findMany({ where: { callId: call.callId } });
        const cfg = await prisma17.telnyxConfig.findUnique({ where: { organizationId: call.organizationId } }).catch(() => null);
        const webhookUrl = selectTelnyxWebhookUrl(req2 || { headers: {} }, cfg?.webhookUrl || "__AUTO__").webhookUrl;
        if (existingLegs.length === 0) {
          const planned = await planInboundCascadeLegs(call.organizationId);
          if (planned.length > 0) {
            for (const leg of planned) {
              await prisma17.telnyxCallLeg.create({
                data: {
                  id: `leg-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
                  callId: call.callId,
                  legType: leg.type,
                  endpointId: leg.type === "sip" ? leg.endpointId || null : null,
                  destination: leg.destination,
                  status: "pending",
                  priority: leg.priority,
                  dialedAt: /* @__PURE__ */ new Date(),
                  createdAt: /* @__PURE__ */ new Date(),
                  updatedAt: /* @__PURE__ */ new Date()
                }
              });
            }
            const first = planned.slice().sort((a, b) => a.priority - b.priority)[0];
            await prisma17.telnyxCallLeg.updateMany({
              where: { callId: call.callId, destination: first.destination },
              data: { status: "dialing", updatedAt: /* @__PURE__ */ new Date() }
            });
            try {
              await transferCallToLeg({ callControlId, organizationId: call.organizationId, leg: first, webhookUrl });
            } catch {
              await prisma17.telnyxCallLeg.updateMany({
                where: { callId: call.callId, destination: first.destination },
                data: { status: "failed", endedAt: /* @__PURE__ */ new Date(), updatedAt: /* @__PURE__ */ new Date() }
              });
              try {
                const pending = await prisma17.telnyxCallLeg.findMany({
                  where: { callId: call.callId, status: "pending" },
                  orderBy: [{ priority: "asc" }, { createdAt: "asc" }]
                });
                if (pending.length > 0 && req2) {
                  const next = pending[0];
                  if (next.legType === "pstn") {
                    await prisma17.telnyxCallLeg.update({
                      where: { id: next.id },
                      data: { status: "dialing", dialedAt: /* @__PURE__ */ new Date(), updatedAt: /* @__PURE__ */ new Date() }
                    });
                    await transferCallToLeg({
                      callControlId,
                      organizationId: call.organizationId,
                      webhookUrl,
                      leg: { type: "pstn", destination: next.destination, priority: next.priority, timeout: 30 }
                    });
                  } else {
                    const match = next.endpointId ? await prisma17.telnyxSipEndpoint.findUnique({ where: { id: next.endpointId } }).catch(() => null) : await prisma17.telnyxSipEndpoint.findFirst({
                      where: { organizationId: call.organizationId, sipUsername: next.destination.replace(/^sip:/, "").split("@")[0] }
                    });
                    const sipAuthPassword = match ? safeDecryptMaybe(match.sipPassword).trim() : "";
                    const sipAuthUsername = match ? match.sipUsername : next.destination.replace(/^sip:/, "").split("@")[0];
                    await prisma17.telnyxCallLeg.update({
                      where: { id: next.id },
                      data: { status: "dialing", dialedAt: /* @__PURE__ */ new Date(), updatedAt: /* @__PURE__ */ new Date() }
                    });
                    await transferCallToLeg({
                      callControlId,
                      organizationId: call.organizationId,
                      webhookUrl,
                      leg: {
                        type: "sip",
                        destination: next.destination,
                        endpointId: match?.id || next.endpointId || void 0,
                        priority: next.priority,
                        timeout: 30,
                        sipAuthUsername,
                        sipAuthPassword
                      }
                    });
                  }
                }
              } catch (e2) {
                console.warn("\u26A0\uFE0F [Telnyx Webhook] Impossible de basculer vers le leg suivant apr\xE8s \xE9chec transfer:", e2);
              }
            }
          }
        }
      } catch (e) {
        console.warn("\u26A0\uFE0F [Telnyx Webhook] Impossible de d\xE9marrer la cascade inbound:", e);
      }
      break;
    case "call.ringing":
      if (isLegEvent) {
        try {
          const destination = String(callData.to || callData.destination || "").trim();
          if (destination) {
            await TelnyxCascadeService.updateCallLegStatus(call.callId, destination, "dialing", /* @__PURE__ */ new Date());
          }
        } catch (e) {
          console.warn("\u26A0\uFE0F [Telnyx Webhook] call.ringing (leg): tracking leg failed:", e);
        }
        break;
      }
      updateData.status = "ringing";
      try {
        const destRaw = (typeof callData?.to === "string" ? callData.to : null) || (typeof callData?.destination === "string" ? callData.destination : null) || (typeof callData?.to?.phone_number === "string" ? callData.to.phone_number : null) || (Array.isArray(callData?.to) && typeof callData?.to?.[0]?.phone_number === "string" ? callData.to[0].phone_number : null);
        const destination = typeof destRaw === "string" ? destRaw.trim() : "";
        if (destination) {
          const existing = await prisma17.telnyxCallLeg.findFirst({ where: { callId: call.callId, destination } }).catch(() => null);
          if (existing) {
            await prisma17.telnyxCallLeg.update({
              where: { id: existing.id },
              data: { status: "dialing", dialedAt: /* @__PURE__ */ new Date(), updatedAt: /* @__PURE__ */ new Date() }
            });
          } else {
            const isSip = destination.startsWith("sip:");
            let endpointId = null;
            let priority = 999;
            if (isSip) {
              const username = destination.replace(/^sip:/, "").split("@")[0];
              const endpoint = await prisma17.telnyxSipEndpoint.findFirst({ where: { organizationId: call.organizationId, sipUsername: username } }).catch(() => null);
              if (endpoint) {
                endpointId = endpoint.id;
                priority = endpoint.priority;
              }
            }
            await prisma17.telnyxCallLeg.create({
              data: {
                id: `leg-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
                callId: call.callId,
                legType: isSip ? "sip" : "pstn",
                endpointId,
                destination,
                status: "dialing",
                priority,
                dialedAt: /* @__PURE__ */ new Date(),
                createdAt: /* @__PURE__ */ new Date(),
                updatedAt: /* @__PURE__ */ new Date()
              }
            });
          }
        }
      } catch (e) {
        console.warn("\u26A0\uFE0F [Telnyx Webhook] call.ringing: tracking leg failed:", e);
      }
      break;
    case "call.answered":
    case "call.bridged":
      updateData.status = "in-progress";
      updateData.startedAt = /* @__PURE__ */ new Date();
      const answeredEndpoint = callData.to || callData.destination;
      if (answeredEndpoint) {
        updateData.answeredBy = answeredEndpoint;
        await TelnyxCascadeService.updateCallLegStatus(
          call.callId,
          answeredEndpoint,
          "answered",
          /* @__PURE__ */ new Date()
        );
      }
      break;
    case "call.hangup":
    case "call.completed":
      if (!isLegEvent) {
        updateData.status = "completed";
        updateData.endedAt = /* @__PURE__ */ new Date();
      }
      if (callData.hangup_duration_millis) {
        if (!isLegEvent) {
          updateData.duration = Math.floor(callData.hangup_duration_millis / 1e3);
        }
      }
      try {
        if (isLegEvent && !call.answeredBy) {
          if (call.status === "completed" || call.endedAt) {
            break;
          }
          const cause = String(callData.hangup_cause || "").toLowerCase();
          const failedDest = String(callData.to || callData.destination || "").trim();
          const failureStatus = cause === "timeout" ? "timeout" : cause === "busy" ? "busy" : "failed";
          if (failedDest) {
            await TelnyxCascadeService.updateCallLegStatus(call.callId, failedDest, failureStatus, void 0, /* @__PURE__ */ new Date());
          }
          const pending = await prisma17.telnyxCallLeg.findMany({
            where: { callId: call.callId, status: "pending" },
            orderBy: [{ priority: "asc" }, { createdAt: "asc" }]
          });
          if (pending.length > 0 && req2) {
            const cfg = await prisma17.telnyxConfig.findUnique({ where: { organizationId: call.organizationId } }).catch(() => null);
            const webhookUrl = cfg?.webhookUrl && cfg.webhookUrl !== "__AUTO__" ? cfg.webhookUrl : joinUrl(getBackendBaseUrl({ req: req2 }), "/api/telnyx/webhooks");
            const next = pending[0];
            if (next.legType === "pstn") {
              await prisma17.telnyxCallLeg.update({ where: { id: next.id }, data: { status: "dialing", updatedAt: /* @__PURE__ */ new Date() } });
              await transferCallToLeg({
                callControlId: mainCallControlId,
                organizationId: call.organizationId,
                webhookUrl,
                leg: { type: "pstn", destination: next.destination, priority: next.priority, timeout: 30 }
              });
            } else {
              const match = next.endpointId ? await prisma17.telnyxSipEndpoint.findUnique({ where: { id: next.endpointId } }).catch(() => null) : await prisma17.telnyxSipEndpoint.findFirst({
                where: { organizationId: call.organizationId, sipUsername: next.destination.replace(/^sip:/, "").split("@")[0] }
              });
              const sipAuthPassword = match ? safeDecryptMaybe(match.sipPassword).trim() : "";
              const sipAuthUsername = match ? match.sipUsername : next.destination.replace(/^sip:/, "").split("@")[0];
              await prisma17.telnyxCallLeg.update({ where: { id: next.id }, data: { status: "dialing", updatedAt: /* @__PURE__ */ new Date() } });
              await transferCallToLeg({
                callControlId: mainCallControlId,
                organizationId: call.organizationId,
                webhookUrl,
                leg: {
                  type: "sip",
                  destination: next.destination,
                  endpointId: match?.id || next.endpointId || void 0,
                  priority: next.priority,
                  timeout: 30,
                  sipAuthUsername,
                  sipAuthPassword
                }
              });
            }
          }
        }
      } catch (e) {
        console.warn("\u26A0\uFE0F [Telnyx Webhook] Next-leg cascade failed:", e);
      }
      break;
    case "call.machine.detection.ended":
      if (callData.result === "human") {
        console.log("\u2705 [Telnyx Webhook] Humain d\xE9tect\xE9");
      } else {
        console.log("\u{1F916} [Telnyx Webhook] R\xE9pondeur/machine d\xE9tect\xE9");
      }
      break;
  }
  await prisma17.telnyxCall.update({
    where: { id: call.id },
    data: updateData
  });
  console.log(`\u2705 [Telnyx Webhook] Call mis \xE0 jour: ${call.callId} -> ${updateData.status || state}`);
}
async function handleMessageWebhook(eventType, messageData) {
  if (!messageData) {
    return;
  }
  const organizationId = await getOrganizationIdFromMessagePayload(messageData);
  if (!organizationId) {
    console.warn("\u26A0\uFE0F [Telnyx Webhook] Message: org introuvable, skip:", messageData?.id, eventType);
    return;
  }
  if (eventType === "message.received") {
    await prisma17.telnyxMessage.create({
      data: {
        id: `msg-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
        messageId: messageData.id,
        fromNumber: messageData.from.phone_number,
        toNumber: messageData.to[0].phone_number,
        direction: "inbound",
        type: messageData.type,
        text: messageData.text,
        status: "delivered",
        organizationId,
        sentAt: new Date(messageData.received_at),
        deliveredAt: /* @__PURE__ */ new Date(),
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log("\u2705 [Telnyx Webhook] Message entrant sauvegard\xE9:", messageData.id);
  } else if (eventType === "message.sent") {
    const message = await prisma17.telnyxMessage.findFirst({
      where: { messageId: messageData.id }
    });
    if (message) {
      await prisma17.telnyxMessage.update({
        where: { id: message.id },
        data: {
          status: "delivered",
          deliveredAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
      console.log("\u2705 [Telnyx Webhook] Message sortant mis \xE0 jour:", messageData.id);
    }
  }
}
function normalizeSipEndpointInput(input) {
  let sipUsername = String(input.sipUsername ?? "").trim();
  sipUsername = sipUsername.replace(/^sip:/i, "").trim();
  if (sipUsername.includes("@")) sipUsername = sipUsername.split("@")[0].trim();
  let sipDomain = String(input.sipDomain ?? "").trim();
  sipDomain = sipDomain.replace(/^sip:/i, "").trim();
  sipDomain = sipDomain.replace(/^\/\//, "").trim();
  if (sipDomain.includes("@")) sipDomain = sipDomain.split("@").slice(-1)[0].trim();
  sipDomain = sipDomain.split(/[\/;?]/)[0].trim();
  return { sipUsername, sipDomain };
}
router33.get("/sip-endpoints", async (req2, res) => {
  try {
    const requesterOrgId = getOrganizationIdFromRequest(req2);
    const isSuperAdmin2 = isSuperAdminFromRequest(req2);
    const organizationId = req2.query.organizationId || requesterOrgId;
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    if (!isSuperAdmin2 && requesterOrgId && organizationId !== requesterOrgId) {
      return res.status(403).json({ error: "Acc\xE8s refus\xE9 \xE0 cette organisation" });
    }
    const endpoints = await prisma17.telnyxSipEndpoint.findMany({
      where: { organizationId },
      include: {
        User: {
          select: {
            firstName: true,
            lastName: true
          }
        }
      },
      orderBy: { priority: "asc" }
    });
    const formattedEndpoints = endpoints.map((ep) => ({
      id: ep.id,
      name: ep.name,
      sipUsername: ep.sipUsername,
      sipDomain: ep.sipDomain,
      status: ep.status,
      priority: ep.priority,
      timeout: ep.timeout,
      userId: ep.userId,
      userName: ep.User ? `${ep.User.firstName || ""} ${ep.User.lastName || ""}`.trim() : null,
      createdAt: ep.createdAt,
      updatedAt: ep.updatedAt
    }));
    res.json(formattedEndpoints);
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur r\xE9cup\xE9ration SIP endpoints:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des endpoints SIP" });
  }
});
router33.get("/recent-calls", async (req2, res) => {
  try {
    const requesterOrgId = getOrganizationIdFromRequest(req2);
    const isSuperAdmin2 = isSuperAdminFromRequest(req2);
    const organizationId = req2.query.organizationId || requesterOrgId;
    if (!organizationId) return res.status(401).json({ error: "Non autoris\xE9" });
    if (!isSuperAdmin2 && requesterOrgId && organizationId !== requesterOrgId) {
      return res.status(403).json({ error: "Acc\xE8s refus\xE9 \xE0 cette organisation" });
    }
    const rawLimit = parseInt(String(req2.query.limit || "10"), 10);
    const limit = Number.isFinite(rawLimit) ? Math.min(Math.max(rawLimit, 1), 50) : 10;
    const calls = await prisma17.telnyxCall.findMany({
      where: { organizationId },
      orderBy: { createdAt: "desc" },
      take: limit,
      select: {
        id: true,
        callId: true,
        direction: true,
        status: true,
        fromNumber: true,
        toNumber: true,
        answeredBy: true,
        startedAt: true,
        endedAt: true,
        createdAt: true,
        TelnyxCallLeg: {
          orderBy: [{ priority: "asc" }, { createdAt: "asc" }],
          select: {
            id: true,
            legType: true,
            destination: true,
            status: true,
            priority: true,
            dialedAt: true,
            answeredAt: true,
            endedAt: true,
            endpointId: true,
            Endpoint: {
              select: {
                id: true,
                name: true,
                sipUsername: true,
                sipDomain: true,
                userId: true
              }
            }
          }
        }
      }
    });
    res.json({ calls });
  } catch (error) {
    console.error("\u274C [Telnyx API] recent-calls error:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des derniers appels" });
  }
});
router33.post("/sip-endpoints", async (req2, res) => {
  try {
    const { organizationId, name, sipUsername, sipPassword, sipDomain, priority, timeout, userId } = req2.body;
    const requesterOrgId = getOrganizationIdFromRequest(req2);
    const isSuperAdmin2 = isSuperAdminFromRequest(req2);
    const targetOrgId = organizationId && String(organizationId).length > 0 ? String(organizationId) : requesterOrgId;
    if (!targetOrgId) return res.status(401).json({ error: "Non autoris\xE9" });
    if (!isSuperAdmin2 && requesterOrgId && targetOrgId !== requesterOrgId) {
      return res.status(403).json({ error: "Acc\xE8s refus\xE9 \xE0 cette organisation" });
    }
    const normalized = normalizeSipEndpointInput({ sipUsername, sipDomain });
    if (!name || !normalized.sipUsername || !sipPassword || !normalized.sipDomain || priority === void 0) {
      return res.status(400).json({ error: "Champs requis manquants" });
    }
    const encryptedPassword = encrypt(String(sipPassword));
    const endpoint = await prisma17.telnyxSipEndpoint.create({
      data: {
        id: `sip-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
        organizationId: targetOrgId,
        userId: userId || null,
        name,
        sipUsername: normalized.sipUsername,
        sipPassword: encryptedPassword,
        sipDomain: normalized.sipDomain,
        status: "active",
        priority: parseInt(priority),
        timeout: parseInt(timeout) || 10,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log("\u2705 [Telnyx API] SIP endpoint cr\xE9\xE9:", endpoint.id);
    res.json({
      success: true,
      endpoint: {
        id: endpoint.id,
        organizationId: endpoint.organizationId,
        userId: endpoint.userId,
        name: endpoint.name,
        sipUsername: endpoint.sipUsername,
        sipDomain: endpoint.sipDomain,
        status: endpoint.status,
        priority: endpoint.priority,
        timeout: endpoint.timeout,
        createdAt: endpoint.createdAt,
        updatedAt: endpoint.updatedAt
      }
    });
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur cr\xE9ation SIP endpoint:", error);
    res.status(500).json({ error: "Erreur lors de la cr\xE9ation de l'endpoint SIP" });
  }
});
router33.put("/sip-endpoints/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { name, sipUsername, sipPassword, sipDomain, priority, timeout, userId } = req2.body;
    const requesterOrgId = getOrganizationIdFromRequest(req2);
    const isSuperAdmin2 = isSuperAdminFromRequest(req2);
    if (!requesterOrgId && !isSuperAdmin2) return res.status(401).json({ error: "Non autoris\xE9" });
    const existing = await prisma17.telnyxSipEndpoint.findUnique({ where: { id } }).catch(() => null);
    if (!existing) return res.status(404).json({ error: "Endpoint non trouv\xE9" });
    if (!isSuperAdmin2 && requesterOrgId && existing.organizationId !== requesterOrgId) {
      return res.status(403).json({ error: "Acc\xE8s refus\xE9 \xE0 cette organisation" });
    }
    const updateData = {
      updatedAt: /* @__PURE__ */ new Date()
    };
    if (name) updateData.name = name;
    if (sipUsername) updateData.sipUsername = normalizeSipEndpointInput({ sipUsername, sipDomain: "placeholder.invalid" }).sipUsername;
    if (typeof sipPassword === "string") {
      const trimmed = sipPassword.trim();
      if (trimmed.length > 0) updateData.sipPassword = encrypt(trimmed);
    }
    if (sipDomain) updateData.sipDomain = normalizeSipEndpointInput({ sipUsername: "placeholder", sipDomain }).sipDomain;
    if (priority !== void 0) updateData.priority = parseInt(priority);
    if (timeout !== void 0) updateData.timeout = parseInt(timeout);
    if (userId !== void 0) updateData.userId = userId || null;
    const endpoint = await prisma17.telnyxSipEndpoint.update({
      where: { id },
      data: updateData
    });
    console.log("\u2705 [Telnyx API] SIP endpoint modifi\xE9:", id);
    res.json({
      success: true,
      endpoint: {
        id: endpoint.id,
        organizationId: endpoint.organizationId,
        userId: endpoint.userId,
        name: endpoint.name,
        sipUsername: endpoint.sipUsername,
        sipDomain: endpoint.sipDomain,
        status: endpoint.status,
        priority: endpoint.priority,
        timeout: endpoint.timeout,
        createdAt: endpoint.createdAt,
        updatedAt: endpoint.updatedAt
      }
    });
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur modification SIP endpoint:", error);
    res.status(500).json({ error: "Erreur lors de la modification de l'endpoint SIP" });
  }
});
router33.delete("/sip-endpoints/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const requesterOrgId = getOrganizationIdFromRequest(req2);
    const isSuperAdmin2 = isSuperAdminFromRequest(req2);
    if (!requesterOrgId && !isSuperAdmin2) return res.status(401).json({ error: "Non autoris\xE9" });
    const existing = await prisma17.telnyxSipEndpoint.findUnique({ where: { id } }).catch(() => null);
    if (!existing) return res.status(404).json({ error: "Endpoint non trouv\xE9" });
    if (!isSuperAdmin2 && requesterOrgId && existing.organizationId !== requesterOrgId) {
      return res.status(403).json({ error: "Acc\xE8s refus\xE9 \xE0 cette organisation" });
    }
    await prisma17.telnyxSipEndpoint.delete({
      where: { id }
    });
    console.log("\u2705 [Telnyx API] SIP endpoint supprim\xE9:", id);
    res.json({ success: true });
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur suppression SIP endpoint:", error);
    res.status(500).json({ error: "Erreur lors de la suppression de l'endpoint SIP" });
  }
});
router33.post("/sip-endpoints/:id/test", async (req2, res) => {
  let lockToken = null;
  let lockOrgId = null;
  try {
    const { id } = req2.params;
    const requesterOrgId = getOrganizationIdFromRequest(req2);
    const isSuperAdmin2 = isSuperAdminFromRequest(req2);
    if (!requesterOrgId && !isSuperAdmin2) return res.status(401).json({ error: "Non autoris\xE9" });
    const endpoint = await prisma17.telnyxSipEndpoint.findUnique({ where: { id } }).catch(() => null);
    if (!endpoint) return res.status(404).json({ error: "Endpoint non trouv\xE9" });
    if (!isSuperAdmin2 && requesterOrgId && endpoint.organizationId !== requesterOrgId) {
      return res.status(403).json({ error: "Acc\xE8s refus\xE9 \xE0 cette organisation" });
    }
    const activeOutbound = await getActiveOutboundCallsCount(endpoint.organizationId, 3);
    if (activeOutbound >= 2) {
      return res.status(409).json({
        error: `Limite d\u2019appels sortants atteinte (actifs: ${activeOutbound}). Raccroche les appels actifs puis r\xE9essaie.`,
        code: "TELNYX_CONCURRENT_CALL_LIMIT",
        activeOutbound,
        hint: "Utilise le bouton \u201CRaccrocher appels actifs\u201D, puis r\xE9essaie."
      });
    }
    lockOrgId = endpoint.organizationId;
    lockToken = acquireSipTestLock(endpoint.organizationId);
    if (!lockToken) {
      return res.status(429).json({
        error: "Test d\xE9j\xE0 en cours. R\xE9essaie dans quelques secondes.",
        code: "TELNYX_SIP_TEST_IN_FLIGHT"
      });
    }
    const auth = await getTelnyxAuth(endpoint.organizationId);
    if (!auth.ok) return res.status(auth.status).json({ error: auth.message, code: auth.code });
    const cfg = await prisma17.telnyxConfig.findUnique({ where: { organizationId: endpoint.organizationId } }).catch(() => null);
    const connectionId = (cfg?.callControlAppId || cfg?.defaultConnectionId || process.env.TELNYX_CONNECTION_ID || "").trim();
    if (!connectionId) {
      return res.status(412).json({ error: "TELNYX_CONNECTION_ID manquant (configurez une connexion par d\xE9faut Telnyx)" });
    }
    const fromNumber = await prisma17.telnyxPhoneNumber.findFirst({ where: { organizationId: endpoint.organizationId, status: "active" }, orderBy: { purchasedAt: "desc" }, select: { phoneNumber: true } }).then((r) => r?.phoneNumber || null).catch(() => null);
    if (!fromNumber) {
      return res.status(412).json({
        error: "Aucun num\xE9ro Telnyx actif trouv\xE9 pour initier un appel test. Clique \u201CSynchroniser\u201D ou assure-toi d\u2019avoir un num\xE9ro actif."
      });
    }
    const toSipUri = `sip:${endpoint.sipUsername}@${endpoint.sipDomain}`;
    const webhookUrl = selectTelnyxWebhookUrl(req2, cfg?.webhookUrl || "__AUTO__").webhookUrl;
    const autoHangupSecsRaw = req2.body?.autoHangupSecs;
    const autoHangupSecs = typeof autoHangupSecsRaw === "number" && Number.isFinite(autoHangupSecsRaw) ? Math.max(5, Math.min(120, Math.floor(autoHangupSecsRaw))) : 25;
    console.log("\u{1F9EA} [Telnyx API] Test SIP endpoint (appel):", { toSipUri, fromNumber, connectionId });
    try {
      const response = await import_axios2.default.post(`${TELNYX_API_URL2}/calls`, {
        to: toSipUri,
        from: fromNumber,
        connection_id: connectionId,
        webhook_url: webhookUrl,
        command_id: `siptest-${Date.now()}`
      }, { headers: auth.headers });
      const callControlId = response.data?.data?.call_control_id;
      if (typeof callControlId === "string" && callControlId.trim().length > 0) {
        await prisma17.telnyxCall.create({
          data: {
            id: `call-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
            callId: callControlId,
            fromNumber,
            toNumber: toSipUri,
            direction: "outbound",
            status: "initiated",
            organizationId: endpoint.organizationId,
            startedAt: /* @__PURE__ */ new Date(),
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).catch(() => null);
        await prisma17.telnyxCallLeg.create({
          data: {
            id: `leg-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
            callId: callControlId,
            legType: "sip",
            endpointId: endpoint.id,
            destination: toSipUri,
            status: "dialing",
            priority: endpoint.priority,
            dialedAt: /* @__PURE__ */ new Date(),
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).catch(() => null);
        setTimeout(async () => {
          try {
            await import_axios2.default.post(`${TELNYX_API_URL2}/calls/${callControlId}/actions/hangup`, {}, { headers: auth.headers });
          } catch {
          }
        }, autoHangupSecs * 1e3).unref?.();
      }
      return res.json({
        success: true,
        message: "Appel test lanc\xE9. Linphone devrait sonner dans quelques secondes.",
        callControlId: callControlId || null,
        to: toSipUri,
        from: fromNumber,
        webhookUrl,
        autoHangupSecs
      });
    } catch (error) {
      return respondTelnyxAxiosError(res, error, "Erreur lors du test (appel SIP)");
    }
  } catch (error) {
    console.error("\u274C [Telnyx API] Erreur test SIP endpoint:", error);
    res.status(500).json({ error: "Erreur lors du test de l'endpoint SIP" });
  } finally {
    if (lockOrgId) releaseSipTestLock(lockOrgId, lockToken);
  }
});
var telnyx_default = router33;

// src/routes/telnyx.ts
var router34 = (0, import_express35.Router)();
router34.use((req2, res, next) => {
  const path11 = req2.path || "";
  const originalUrl = req2.originalUrl || "";
  const isWebhook = path11 === "/webhooks" || path11.startsWith("/webhooks/") || originalUrl.includes("/api/telnyx/webhooks");
  if (isWebhook) {
    if (process.env.TELNYX_DEBUG_WEBHOOKS === "1") {
      console.log("\u{1F9F7} [Telnyx Webhook Debug] bypass auth", { path: path11, originalUrl });
    }
    return next();
  }
  return authMiddleware(req2, res, (err) => {
    if (err) return next(err);
    return impersonationMiddleware2(req2, res, next);
  });
});
router34.use("/", telnyx_default);
var telnyx_default2 = router34;

// src/routes/quotes.ts
var import_express36 = require("express");
init_database();
var router35 = (0, import_express36.Router)();
var prisma18 = db;
router35.use(authMiddleware);
var allowedTransitions = {
  ["DRAFT" /* DRAFT */]: ["SENT" /* SENT */, "CANCELLED" /* CANCELLED */],
  ["SENT" /* SENT */]: ["ACCEPTED" /* ACCEPTED */, "REJECTED" /* REJECTED */, "CANCELLED" /* CANCELLED */, "EXPIRED" /* EXPIRED */],
  ["ACCEPTED" /* ACCEPTED */]: [],
  ["REJECTED" /* REJECTED */]: [],
  ["CANCELLED" /* CANCELLED */]: [],
  ["EXPIRED" /* EXPIRED */]: []
};
function canTransition(from, to) {
  return allowedTransitions[from]?.includes(to) ?? false;
}
function generateQuoteNumber() {
  const d = /* @__PURE__ */ new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  const seq = Math.floor(Math.random() * 9e3 + 1e3);
  return `Q-${y}${m}-${seq}`;
}
function computeItemTotals(item) {
  const qty = Math.max(0, Number(item.quantity) || 0);
  const price = Math.max(0, Number(item.unitPrice) || 0);
  const discount = Math.min(100, Math.max(0, Number(item.discountPct ?? 0)));
  const tax = Math.min(100, Math.max(0, Number(item.taxPct ?? 21)));
  const lineExclBeforeDiscount = qty * price;
  const lineExcl = round4(lineExclBeforeDiscount * (1 - discount / 100));
  const lineTax = round4(lineExcl * (tax / 100));
  const lineIncl = round4(lineExcl + lineTax);
  return { totalExcl: lineExcl, totalIncl: lineIncl };
}
function aggregateTotals(items) {
  let subtotalExcl = 0;
  let totalIncl = 0;
  for (const it of items) {
    const { totalExcl, totalIncl: lineIncl } = computeItemTotals(it);
    subtotalExcl += totalExcl;
    totalIncl += lineIncl;
  }
  const totalTax = round4(totalIncl - subtotalExcl);
  return {
    subtotalExcl: round4(subtotalExcl),
    totalTax: round4(totalTax),
    totalIncl: round4(totalIncl)
  };
}
function round4(n) {
  return Math.round((n + Number.EPSILON) * 1e4) / 1e4;
}
function toDecimal(value) {
  return new import_client.Prisma.Decimal(value.toString());
}
router35.get("/", async (req2, res) => {
  try {
    const { leadId, status, page = "1", pageSize = "20" } = req2.query;
    const { user } = req2;
    const organizationId = user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({ error: "Organisation non sp\xE9cifi\xE9e" });
    }
    const where = {
      organizationId,
      ...leadId ? { leadId } : {},
      ...status ? { status } : {}
    };
    const pageNum = Math.max(1, parseInt(String(page), 10) || 1);
    const sizeNum = Math.min(100, Math.max(1, parseInt(String(pageSize), 10) || 20));
    const [total, data] = await Promise.all([
      prisma18.quote.count({ where }),
      prisma18.quote.findMany({
        where,
        orderBy: [{ updatedAt: "desc" }],
        skip: (pageNum - 1) * sizeNum,
        take: sizeNum,
        include: {
          documents: {
            orderBy: { createdAt: "desc" },
            take: 1
          }
        }
      })
    ]);
    res.json({ success: true, total, page: pageNum, pageSize: sizeNum, data });
  } catch (e) {
    console.error("[QUOTES] GET list error", e);
    res.status(500).json({ success: false, error: "Erreur lors du chargement des devis" });
  }
});
router35.get("/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { user } = req2;
    const organizationId = user?.organizationId;
    if (!organizationId) return res.status(400).json({ error: "Organisation non sp\xE9cifi\xE9e" });
    const quote = await prisma18.quote.findFirst({
      where: { id, organizationId },
      include: {
        items: { orderBy: { order: "asc" } },
        documents: { orderBy: { createdAt: "desc" }, take: 5 }
      }
    });
    if (!quote) return res.status(404).json({ error: "Devis introuvable" });
    res.json(quote);
  } catch (e) {
    console.error("[QUOTES] GET detail error", e);
    res.status(500).json({ error: "Erreur lors du chargement du devis" });
  }
});
router35.post("/", async (req2, res) => {
  try {
    const { user } = req2;
    const organizationId = user?.organizationId;
    if (!organizationId) return res.status(400).json({ error: "Organisation non sp\xE9cifi\xE9e" });
    const { leadId, blockId, title, currency = "EUR", validUntil, notes, data } = req2.body;
    if (!leadId || !blockId) return res.status(400).json({ error: "leadId et blockId requis" });
    const lead = await prisma18.lead.findFirst({ where: { id: leadId, organizationId } });
    if (!lead) return res.status(404).json({ error: "Lead non trouv\xE9 ou non autoris\xE9" });
    const created = await prisma18.quote.create({
      data: {
        organizationId,
        leadId,
        blockId,
        createdById: user?.userId ?? null,
        number: generateQuoteNumber(),
        status: "DRAFT" /* DRAFT */,
        title: title ?? null,
        version: 1,
        currency,
        validUntil: validUntil ? new Date(validUntil) : null,
        notes: notes ?? null,
        data: data ?? {},
        totals: {}
      }
    });
    res.status(201).json(created);
  } catch (e) {
    console.error("[QUOTES] POST create error", e);
    res.status(500).json({ error: "Erreur lors de la cr\xE9ation du devis" });
  }
});
router35.patch("/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { user } = req2;
    const organizationId = user?.organizationId;
    if (!organizationId) return res.status(400).json({ error: "Organisation non sp\xE9cifi\xE9e" });
    const existing = await prisma18.quote.findFirst({ where: { id, organizationId } });
    if (!existing) return res.status(404).json({ error: "Devis introuvable" });
    const { title, notes, currency, validUntil, status } = req2.body;
    const data = {};
    if (title !== void 0) data.title = title;
    if (notes !== void 0) data.notes = notes;
    if (currency !== void 0) data.currency = currency;
    if (validUntil !== void 0) data.validUntil = validUntil ? new Date(validUntil) : null;
    if (status && status !== existing.status) {
      const from = existing.status;
      const to = status;
      if (!canTransition(from, to)) {
        return res.status(400).json({ error: `Transition de statut interdite: ${from} -> ${to}` });
      }
      data.status = to;
    }
    const updated = await prisma18.quote.update({ where: { id }, data });
    res.json(updated);
  } catch (e) {
    console.error("[QUOTES] PATCH update error", e);
    res.status(500).json({ error: "Erreur lors de la mise \xE0 jour du devis" });
  }
});
router35.delete("/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { user } = req2;
    const organizationId = user?.organizationId;
    if (!organizationId) return res.status(400).json({ error: "Organisation non sp\xE9cifi\xE9e" });
    const existing = await prisma18.quote.findFirst({ where: { id, organizationId } });
    if (!existing) return res.status(404).json({ error: "Devis introuvable" });
    await prisma18.quote.update({ where: { id }, data: { status: "CANCELLED" /* CANCELLED */ } });
    res.status(204).send();
  } catch (e) {
    console.error("[QUOTES] DELETE error", e);
    res.status(500).json({ error: "Erreur lors de l'annulation du devis" });
  }
});
router35.post("/:id/items", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { user } = req2;
    const organizationId = user?.organizationId;
    if (!organizationId) return res.status(400).json({ error: "Organisation non sp\xE9cifi\xE9e" });
    const existing = await prisma18.quote.findFirst({ where: { id, organizationId } });
    if (!existing) return res.status(404).json({ error: "Devis introuvable" });
    const items = req2.body?.items || [];
    if (!Array.isArray(items)) return res.status(400).json({ error: "items doit \xEAtre un tableau" });
    const prepared = items.filter((i) => i && typeof i.label === "string").map((i) => ({
      ...i,
      quantity: Number(i.quantity) || 0,
      unitPrice: Number(i.unitPrice) || 0,
      discountPct: Number(i.discountPct ?? 0),
      taxPct: Number(i.taxPct ?? 21)
    })).sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
    const totals = aggregateTotals(prepared);
    await prisma18.$transaction(async (tx) => {
      await tx.quoteItem.deleteMany({ where: { quoteId: id } });
      for (const it of prepared) {
        const { totalExcl, totalIncl } = computeItemTotals(it);
        await tx.quoteItem.create({
          data: {
            quoteId: id,
            order: it.order ?? 0,
            label: it.label,
            description: it.description ?? null,
            quantity: toDecimal(it.quantity),
            unitPrice: toDecimal(it.unitPrice),
            discountPct: toDecimal(it.discountPct ?? 0),
            taxPct: toDecimal(it.taxPct ?? 21),
            totalExcl: toDecimal(totalExcl),
            totalIncl: toDecimal(totalIncl)
          }
        });
      }
      await tx.quote.update({
        where: { id },
        data: {
          totals: {
            subtotalExcl: totals.subtotalExcl,
            totalTax: totals.totalTax,
            totalIncl: totals.totalIncl
          }
        }
      });
    });
    const updated = await prisma18.quote.findUnique({
      where: { id },
      include: { items: { orderBy: { order: "asc" } } }
    });
    res.json({ success: true, quote: updated });
  } catch (e) {
    console.error("[QUOTES] POST items error", e);
    res.status(500).json({ error: "Erreur lors de la mise \xE0 jour des lignes" });
  }
});
router35.post("/:id/duplicate", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { user } = req2;
    const organizationId = user?.organizationId;
    if (!organizationId) return res.status(400).json({ error: "Organisation non sp\xE9cifi\xE9e" });
    const existing = await prisma18.quote.findFirst({
      where: { id, organizationId },
      include: { items: true }
    });
    if (!existing) return res.status(404).json({ error: "Devis introuvable" });
    const newQuote = await prisma18.$transaction(async (tx) => {
      const created = await tx.quote.create({
        data: {
          organizationId,
          leadId: existing.leadId,
          blockId: existing.blockId,
          createdById: user?.userId ?? null,
          number: generateQuoteNumber(),
          status: "DRAFT" /* DRAFT */,
          title: existing.title ? `${existing.title} (copie)` : null,
          version: 1,
          currency: existing.currency,
          validUntil: existing.validUntil,
          notes: existing.notes,
          data: existing.data,
          totals: existing.totals
        }
      });
      for (const it of existing.items) {
        await tx.quoteItem.create({
          data: {
            quoteId: created.id,
            order: it.order,
            label: it.label,
            description: it.description,
            quantity: it.quantity,
            unitPrice: it.unitPrice,
            discountPct: it.discountPct,
            taxPct: it.taxPct,
            totalExcl: it.totalExcl,
            totalIncl: it.totalIncl
          }
        });
      }
      return created;
    });
    res.status(201).json(newQuote);
  } catch (e) {
    console.error("[QUOTES] duplicate error", e);
    res.status(500).json({ error: "Erreur lors de la duplication du devis" });
  }
});
router35.post("/:id/generate-document", (_req, res) => {
  return res.status(501).json({ error: "G\xE9n\xE9ration de document non encore impl\xE9ment\xE9e (Phase 2)" });
});
var quotes_default = router35;

// src/routes/google-drive.ts
var import_express37 = require("express");
var router36 = (0, import_express37.Router)();
router36.get("/files", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const folderId = req2.query.folderId || "root";
    const pageSize = parseInt(req2.query.pageSize) || 50;
    const pageToken = req2.query.pageToken;
    console.log(`[Google Drive Routes] \u{1F4C1} GET /files - folderId: ${folderId}`);
    const result = await googleDriveService.getFiles(organizationId, folderId, pageSize, pageToken, userId);
    res.json(result);
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur GET /files:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des fichiers Drive" });
  }
});
router36.get("/shared", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const pageSize = parseInt(req2.query.pageSize) || 50;
    const pageToken = req2.query.pageToken;
    console.log(`[Google Drive Routes] \u{1F4E4} GET /shared - Fichiers partag\xE9s avec moi`);
    const result = await googleDriveService.getSharedFiles(organizationId, pageSize, pageToken, userId);
    res.json(result);
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur GET /shared:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des fichiers partag\xE9s" });
  }
});
router36.get("/shared-drives", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    console.log(`[Google Drive Routes] \u{1F3E2} GET /shared-drives - Drives partag\xE9s`);
    const result = await googleDriveService.getSharedDrives(organizationId, 50, userId);
    res.json(result);
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur GET /shared-drives:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des drives partag\xE9s" });
  }
});
router36.get("/shared-drives/:driveId/files", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const { driveId } = req2.params;
    const folderId = req2.query.folderId;
    const pageSize = parseInt(req2.query.pageSize) || 50;
    const pageToken = req2.query.pageToken;
    console.log(`[Google Drive Routes] \u{1F3E2} GET /shared-drives/${driveId}/files - folderId: ${folderId || "root"}`);
    const result = await googleDriveService.getSharedDriveFiles(organizationId, driveId, folderId, pageSize, pageToken, userId);
    res.json(result);
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur GET /shared-drives/:driveId/files:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des fichiers du drive partag\xE9" });
  }
});
router36.get("/search", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const query = req2.query.q;
    if (!query) {
      return res.status(400).json({ error: "Param\xE8tre de recherche requis" });
    }
    console.log(`[Google Drive Routes] \u{1F50E} GET /search - query: "${query}"`);
    const files = await googleDriveService.searchFiles(organizationId, query, 50, userId);
    res.json({ files });
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur GET /search:", error);
    res.status(500).json({ error: "Erreur lors de la recherche de fichiers" });
  }
});
router36.get("/storage", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    console.log(`[Google Drive Routes] \u{1F4BE} GET /storage`);
    const storageInfo = await googleDriveService.getStorageInfo(organizationId, userId);
    res.json(storageInfo);
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur GET /storage:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des infos de stockage" });
  }
});
router36.get("/files/:fileId", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const { fileId } = req2.params;
    console.log(`[Google Drive Routes] \u{1F4C4} GET /files/${fileId}`);
    const fileInfo = await googleDriveService.getFileInfo(organizationId, fileId, userId);
    res.json(fileInfo);
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur GET /files/:fileId:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des infos du fichier" });
  }
});
router36.post("/folders", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const { name, parentId } = req2.body;
    if (!name) {
      return res.status(400).json({ error: "Nom du dossier requis" });
    }
    console.log(`[Google Drive Routes] \u{1F4C2} POST /folders - name: "${name}"`);
    const folder = await googleDriveService.createFolder(organizationId, name, parentId || "root", userId);
    res.status(201).json(folder);
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur POST /folders:", error);
    res.status(500).json({ error: "Erreur lors de la cr\xE9ation du dossier" });
  }
});
router36.delete("/files/:fileId", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const { fileId } = req2.params;
    console.log(`[Google Drive Routes] \u{1F5D1}\uFE0F DELETE /files/${fileId}`);
    await googleDriveService.deleteFile(organizationId, fileId, userId);
    res.json({ success: true, message: "Fichier mis \xE0 la corbeille" });
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur DELETE /files/:fileId:", error);
    res.status(500).json({ error: "Erreur lors de la suppression du fichier" });
  }
});
router36.post("/upload", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const chunks = [];
    let fileName = "uploaded-file";
    let mimeType = "application/octet-stream";
    let parentId = "root";
    if (req2.headers["x-file-name"]) {
      fileName = decodeURIComponent(req2.headers["x-file-name"]);
    }
    if (req2.headers["x-mime-type"]) {
      mimeType = req2.headers["x-mime-type"];
    }
    if (req2.headers["x-parent-id"]) {
      parentId = req2.headers["x-parent-id"];
    }
    req2.on("data", (chunk) => chunks.push(chunk));
    req2.on("end", async () => {
      try {
        const fileBuffer = Buffer.concat(chunks);
        console.log(`[Google Drive Routes] \u{1F4E4} POST /upload - file: "${fileName}", size: ${fileBuffer.length}`);
        const file = await googleDriveService.uploadFile(organizationId, fileName, mimeType, fileBuffer, parentId, userId);
        res.status(201).json(file);
      } catch (error) {
        console.error("[Google Drive Routes] \u274C Erreur POST /upload:", error);
        res.status(500).json({ error: "Erreur lors de l'upload du fichier" });
      }
    });
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur POST /upload:", error);
    res.status(500).json({ error: "Erreur lors de l'upload du fichier" });
  }
});
router36.patch("/files/:fileId/rename", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const { fileId } = req2.params;
    const { name } = req2.body;
    if (!name) {
      return res.status(400).json({ error: "Nouveau nom requis" });
    }
    console.log(`[Google Drive Routes] \u270F\uFE0F PATCH /files/${fileId}/rename - name: "${name}"`);
    const file = await googleDriveService.renameFile(organizationId, fileId, name, userId);
    res.json(file);
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur PATCH /files/:fileId/rename:", error);
    res.status(500).json({ error: "Erreur lors du renommage" });
  }
});
router36.patch("/files/:fileId/move", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const { fileId } = req2.params;
    const { newParentId } = req2.body;
    if (!newParentId) {
      return res.status(400).json({ error: "Dossier de destination requis" });
    }
    console.log(`[Google Drive Routes] \u{1F4E6} PATCH /files/${fileId}/move - to: ${newParentId}`);
    const file = await googleDriveService.moveFile(organizationId, fileId, newParentId, userId);
    res.json(file);
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur PATCH /files/:fileId/move:", error);
    res.status(500).json({ error: "Erreur lors du d\xE9placement" });
  }
});
router36.post("/files/:fileId/copy", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const { fileId } = req2.params;
    const { newName } = req2.body;
    console.log(`[Google Drive Routes] \u{1F4CB} POST /files/${fileId}/copy`);
    const file = await googleDriveService.copyFile(organizationId, fileId, newName, userId);
    res.status(201).json(file);
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur POST /files/:fileId/copy:", error);
    res.status(500).json({ error: "Erreur lors de la copie" });
  }
});
router36.get("/files/:fileId/share", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const { fileId } = req2.params;
    console.log(`[Google Drive Routes] \u{1F517} GET /files/${fileId}/share`);
    const links = await googleDriveService.getShareLink(organizationId, fileId, userId);
    res.json(links);
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur GET /files/:fileId/share:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration du lien" });
  }
});
router36.post("/files/:fileId/make-public", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const { fileId } = req2.params;
    console.log(`[Google Drive Routes] \u{1F310} POST /files/${fileId}/make-public`);
    const result = await googleDriveService.makePublic(organizationId, fileId, userId);
    res.json(result);
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur POST /files/:fileId/make-public:", error);
    res.status(500).json({ error: "Erreur lors du partage" });
  }
});
router36.get("/recent", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    console.log(`[Google Drive Routes] \u{1F550} GET /recent`);
    const files = await googleDriveService.getRecentFiles(organizationId, 50, userId);
    res.json({ files });
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur GET /recent:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des fichiers r\xE9cents" });
  }
});
router36.get("/starred", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    console.log(`[Google Drive Routes] \u2B50 GET /starred`);
    const files = await googleDriveService.getStarredFiles(organizationId, 50, userId);
    res.json({ files });
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur GET /starred:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des fichiers favoris" });
  }
});
router36.patch("/files/:fileId/star", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const { fileId } = req2.params;
    const { starred } = req2.body;
    console.log(`[Google Drive Routes] \u2B50 PATCH /files/${fileId}/star - starred: ${starred}`);
    await googleDriveService.toggleStar(organizationId, fileId, starred, userId);
    res.json({ success: true });
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur PATCH /files/:fileId/star:", error);
    res.status(500).json({ error: "Erreur lors de la mise \xE0 jour du favori" });
  }
});
router36.get("/trash", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    console.log(`[Google Drive Routes] \u{1F5D1}\uFE0F GET /trash`);
    const files = await googleDriveService.getTrash(organizationId, 50, userId);
    res.json({ files });
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur GET /trash:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration de la corbeille" });
  }
});
router36.post("/files/:fileId/restore", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const { fileId } = req2.params;
    console.log(`[Google Drive Routes] \u267B\uFE0F POST /files/${fileId}/restore`);
    await googleDriveService.restoreFile(organizationId, fileId, userId);
    res.json({ success: true });
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur POST /files/:fileId/restore:", error);
    res.status(500).json({ error: "Erreur lors de la restauration" });
  }
});
router36.delete("/files/:fileId/permanent", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const { fileId } = req2.params;
    console.log(`[Google Drive Routes] \u274C DELETE /files/${fileId}/permanent`);
    await googleDriveService.deleteFilePermanently(organizationId, fileId, userId);
    res.json({ success: true });
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur DELETE /files/:fileId/permanent:", error);
    res.status(500).json({ error: "Erreur lors de la suppression d\xE9finitive" });
  }
});
router36.delete("/trash", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    console.log(`[Google Drive Routes] \u{1F5D1}\uFE0F DELETE /trash`);
    await googleDriveService.emptyTrash(organizationId, userId);
    res.json({ success: true });
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur DELETE /trash:", error);
    res.status(500).json({ error: "Erreur lors du vidage de la corbeille" });
  }
});
router36.get("/files/:fileId/download", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const { fileId } = req2.params;
    console.log(`[Google Drive Routes] \u2B07\uFE0F GET /files/${fileId}/download`);
    const result = await googleDriveService.getDownloadUrl(organizationId, fileId, userId);
    res.json(result);
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur GET /files/:fileId/download:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration de l'URL" });
  }
});
router36.post("/create-doc", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.id || req2.user?.userId;
    if (!organizationId) {
      return res.status(401).json({ error: "Organisation non trouv\xE9e" });
    }
    const { name, type, parentId } = req2.body;
    if (!name || !type) {
      return res.status(400).json({ error: "Nom et type requis" });
    }
    console.log(`[Google Drive Routes] \u{1F4C4} POST /create-doc - type: ${type}, name: "${name}"`);
    const file = await googleDriveService.createGoogleDoc(organizationId, name, type, parentId || "root", userId);
    res.status(201).json(file);
  } catch (error) {
    console.error("[Google Drive Routes] \u274C Erreur POST /create-doc:", error);
    res.status(500).json({ error: "Erreur lors de la cr\xE9ation du document" });
  }
});
var google_drive_default = router36;

// src/routes/google-meet.ts
var import_express38 = require("express");
var router37 = (0, import_express38.Router)();
router37.get("/meetings", authMiddleware, async (req2, res) => {
  try {
    res.json({
      meetings: [],
      message: "Google Meet integration \xE0 impl\xE9menter"
    });
  } catch (error) {
    console.error("Erreur Google Meet:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des r\xE9unions Meet" });
  }
});
router37.get("/analytics", authMiddleware, async (req2, res) => {
  try {
    res.json({
      analytics: {},
      message: "Analytics Google Meet \xE0 impl\xE9menter"
    });
  } catch (error) {
    console.error("Erreur analytics Google Meet:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des analytics Meet" });
  }
});
router37.post("/meetings", authMiddleware, async (req2, res) => {
  try {
    const meetingData = req2.body;
    res.json({
      id: "temp-meeting-id",
      ...meetingData,
      message: "Cr\xE9ation Google Meet \xE0 impl\xE9menter"
    });
  } catch (error) {
    console.error("Erreur cr\xE9ation Google Meet:", error);
    res.status(500).json({ error: "Erreur lors de la cr\xE9ation de la r\xE9union Meet" });
  }
});
router37.post("/join/:meetingCode", authMiddleware, async (req2, res) => {
  try {
    const { meetingCode } = req2.params;
    res.json({
      success: true,
      meetingCode,
      message: "Jointure Google Meet \xE0 impl\xE9menter"
    });
  } catch (error) {
    console.error("Erreur jointure Google Meet:", error);
    res.status(500).json({ error: "Erreur lors de la jointure \xE0 la r\xE9union Meet" });
  }
});
router37.post("/instant", authMiddleware, async (req2, res) => {
  try {
    res.json({
      meetingId: "temp-instant-meeting-id",
      url: "https://meet.google.com/temp-url",
      message: "R\xE9union instantan\xE9e Google Meet \xE0 impl\xE9menter"
    });
  } catch (error) {
    console.error("Erreur r\xE9union instantan\xE9e Google Meet:", error);
    res.status(500).json({ error: "Erreur lors de la cr\xE9ation de la r\xE9union instantan\xE9e Meet" });
  }
});
router37.delete("/meetings/:meetingId", authMiddleware, async (req2, res) => {
  try {
    const { meetingId } = req2.params;
    res.json({
      success: true,
      meetingId,
      message: "Suppression Google Meet \xE0 impl\xE9menter"
    });
  } catch (error) {
    console.error("Erreur suppression Google Meet:", error);
    res.status(500).json({ error: "Erreur lors de la suppression de la r\xE9union Meet" });
  }
});
var google_meet_default = router37;

// src/routes/analytics.ts
var import_express39 = require("express");
init_database();
var import_express_rate_limit5 = __toESM(require("express-rate-limit"), 1);
var router38 = (0, import_express39.Router)();
var prisma19 = db;
var analyticsRateLimit = (0, import_express_rate_limit5.default)({
  windowMs: 60 * 1e3,
  // 1 minute
  max: 100,
  // 100 requ√™tes par minute
  message: { success: false, message: "Trop de requ\xEAtes analytics" }
});
router38.use(authMiddleware);
router38.use(analyticsRateLimit);
router38.get("/dashboard", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  console.log("[ANALYTICS] \u{1F4CA} G\xE9n\xE9ration m\xE9triques dashboard");
  try {
    const requestingUser = req2.user;
    const { startDate, endDate } = req2.query;
    const dateFilter = {
      ...startDate && { gte: new Date(startDate) },
      ...endDate && { lte: new Date(endDate) }
    };
    let metrics;
    if (requestingUser?.role === "super_admin") {
      const [totalUsers, totalOrganizations, activeModules, totalLeads] = await Promise.all([
        prisma19.user.count({ where: { createdAt: dateFilter } }),
        prisma19.organization.count({ where: { createdAt: dateFilter } }),
        prisma19.organizationModuleStatus.count({ where: { active: true } }),
        prisma19.lead?.count({ where: { createdAt: dateFilter } }) || 0
      ]);
      metrics = {
        totalUsers,
        totalOrganizations,
        activeModules,
        totalLeads,
        growth: {
          users: await calculateGrowth("user", dateFilter),
          organizations: await calculateGrowth("organization", dateFilter)
        }
      };
    } else {
      const orgId = requestingUser.organizationId;
      const [orgUsers, orgModules, orgLeads] = await Promise.all([
        prisma19.userOrganization.count({
          where: { organizationId: orgId, createdAt: dateFilter }
        }),
        prisma19.organizationModuleStatus.count({
          where: { organizationId: orgId, active: true }
        }),
        prisma19.lead?.count({
          where: { organizationId: orgId, createdAt: dateFilter }
        }) || 0
      ]);
      metrics = {
        users: orgUsers,
        activeModules: orgModules,
        leads: orgLeads,
        conversion: await calculateConversionRate(orgId, dateFilter)
      };
    }
    res.json({ success: true, data: metrics });
  } catch (error) {
    console.error("[ANALYTICS] Erreur m\xE9triques dashboard:", error);
    res.status(500).json({ success: false, message: "Erreur g\xE9n\xE9ration m\xE9triques" });
  }
});
router38.get("/export", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  console.log("[ANALYTICS] \u{1F4C8} Export donn\xE9es");
  try {
    const { format = "csv", type = "users" } = req2.query;
    const requestingUser = req2.user;
    let data;
    let filename;
    switch (type) {
      case "users":
        data = await exportUsers(requestingUser);
        filename = `users_export_${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.${format}`;
        break;
      case "organizations":
        if (requestingUser?.role !== "super_admin") {
          return res.status(403).json({ success: false, message: "Super admin requis" });
        }
        data = await exportOrganizations();
        filename = `organizations_export_${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.${format}`;
        break;
      default:
        return res.status(400).json({ success: false, message: "Type export invalide" });
    }
    if (format === "csv") {
      res.setHeader("Content-Type", "text/csv");
      res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
      res.send(convertToCSV(data));
    } else {
      res.json({ success: true, data, filename });
    }
  } catch (error) {
    console.error("[ANALYTICS] Erreur export:", error);
    res.status(500).json({ success: false, message: "Erreur export donn\xE9es" });
  }
});
router38.get("/audit-trail", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  console.log("[ANALYTICS] \u{1F4CB} R\xE9cup\xE9ration audit trail");
  try {
    const { page = 1, limit = 50, userId, action: action2 } = req2.query;
    const requestingUser = req2.user;
    const whereClause = {};
    if (requestingUser?.role !== "super_admin" && requestingUser?.organizationId) {
      whereClause.organizationId = requestingUser.organizationId;
    }
    if (userId) whereClause.userId = userId;
    if (action2) whereClause.action = { contains: action2 };
    const [auditLogs, total] = await Promise.all([
      prisma19.auditLog?.findMany({
        where: whereClause,
        include: {
          User: { select: { firstName: true, lastName: true, email: true } }
        },
        orderBy: { createdAt: "desc" },
        skip: (Number(page) - 1) * Number(limit),
        take: Number(limit)
      }) || [],
      prisma19.auditLog?.count({ where: whereClause }) || 0
    ]);
    res.json({
      success: true,
      data: auditLogs,
      pagination: {
        page: Number(page),
        limit: Number(limit),
        total,
        pages: Math.ceil(total / Number(limit))
      }
    });
  } catch (error) {
    console.error("[ANALYTICS] Erreur audit trail:", error);
    res.status(500).json({ success: false, message: "Erreur r\xE9cup\xE9ration audit" });
  }
});
async function calculateGrowth(model, dateFilter) {
  try {
    const currentPeriod = await (model === "user" ? prisma19.user : prisma19.organization).count({
      where: { createdAt: dateFilter }
    });
    const previousPeriod = await (model === "user" ? prisma19.user : prisma19.organization).count({
      where: {
        createdAt: {
          gte: new Date(Date.now() - 60 * 24 * 60 * 60 * 1e3),
          // 60 jours avant
          lte: dateFilter.gte
        }
      }
    });
    return previousPeriod > 0 ? Math.round((currentPeriod - previousPeriod) / previousPeriod * 100) : 0;
  } catch {
    return 0;
  }
}
async function calculateConversionRate(organizationId, dateFilter) {
  try {
    const [totalLeads, convertedLeads] = await Promise.all([
      prisma19.lead?.count({
        where: { organizationId, createdAt: dateFilter }
      }) || 0,
      prisma19.lead?.count({
        where: {
          organizationId,
          status: "converted",
          createdAt: dateFilter
        }
      }) || 0
    ]);
    return totalLeads > 0 ? Math.round(convertedLeads / totalLeads * 100) : 0;
  } catch {
    return 0;
  }
}
async function exportUsers(requestingUser) {
  const whereClause = requestingUser?.role === "super_admin" ? {} : { organizationId: requestingUser.organizationId };
  return prisma19.user.findMany({
    where: whereClause,
    select: {
      firstName: true,
      lastName: true,
      email: true,
      role: true,
      createdAt: true,
      UserOrganization: {
        select: {
          Organization: { select: { name: true } }
        }
      }
    }
  });
}
async function exportOrganizations() {
  return prisma19.organization.findMany({
    select: {
      name: true,
      status: true,
      createdAt: true,
      _count: {
        select: {
          UserOrganization: true,
          OrganizationModuleStatus: { where: { active: true } }
        }
      }
    }
  });
}
function convertToCSV(data) {
  if (!data.length) return "";
  const headers = Object.keys(data[0]).join(",");
  const rows = data.map(
    (row) => Object.values(row).map(
      (value) => typeof value === "string" ? `"${value}"` : value
    ).join(",")
  );
  return [headers, ...rows].join("\n");
}
var analytics_default = router38;

// src/routes/ai.ts
var import_express40 = __toESM(require("express"), 1);
var import_fs6 = __toESM(require("fs"), 1);
var import_path5 = __toESM(require("path"), 1);
init_prisma();
var import_crypto15 = require("crypto");
var geminiSingleton = getGeminiService();
var router39 = import_express40.default.Router();
router39.use(authMiddleware);
var aiUsageTableEnsured = null;
async function ensureAiUsageLogTable() {
  if (!aiUsageTableEnsured) {
    aiUsageTableEnsured = (async () => {
      try {
        await db.$executeRawUnsafe(`CREATE TABLE IF NOT EXISTS "AiUsageLog" (
          id TEXT PRIMARY KEY,
          "userId" TEXT NULL,
          "organizationId" TEXT NULL,
          type TEXT NOT NULL,
          model TEXT NULL,
          "tokensPrompt" INTEGER DEFAULT 0,
          "tokensOutput" INTEGER DEFAULT 0,
          "latencyMs" INTEGER NULL,
          success BOOLEAN DEFAULT true,
          "errorCode" TEXT NULL,
          "errorMessage" TEXT NULL,
          meta JSONB NULL,
          "createdAt" TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
        );`);
        await db.$executeRawUnsafe('CREATE INDEX IF NOT EXISTS "AiUsageLog_userId_idx" ON "AiUsageLog"("userId");');
        await db.$executeRawUnsafe('CREATE INDEX IF NOT EXISTS "AiUsageLog_orgId_idx" ON "AiUsageLog"("organizationId");');
        await db.$executeRawUnsafe('CREATE INDEX IF NOT EXISTS "AiUsageLog_type_idx" ON "AiUsageLog"(type);');
        await db.$executeRawUnsafe('CREATE INDEX IF NOT EXISTS "AiUsageLog_createdAt_idx" ON "AiUsageLog"("createdAt");');
      } catch (e) {
        console.warn("\u26A0\uFE0F Impossible de garantir la table AiUsageLog (continuation sans log):", e.message);
      }
    })();
  }
  return aiUsageTableEnsured;
}
function mapEndpointToType(endpoint) {
  switch (endpoint) {
    case "generate-response":
    case "chat":
      return "chat";
    case "schedule-recommendations":
      return "schedule_rec";
    case "schedule-explain":
      return "schedule_explain";
    case "analyze-conversation":
      return "conversation_analysis";
    case "context-summary":
      return "context_summary";
    case "context-lead":
      return "context_lead";
    case "context-leads-batch":
      return "context_leads_batch";
    case "ultimate-recommendation":
      return "ultimate_recommendation";
    default:
      return endpoint.replace(/[^a-z0-9_]/gi, "_");
  }
}
async function logAiUsage(params) {
  try {
    await ensureAiUsageLogTable();
    const authReq = params.req;
    const organizationId = authReq.user?.organizationId || null;
    const userId = authReq.user?.userId || null;
    const type = mapEndpointToType(params.endpoint);
    const meta = {
      endpoint: params.endpoint,
      mode: params.mode,
      rawError: params.error,
      tokensOutputRaw: params.tokensOutput,
      ...params.extraMeta || {}
    };
    await db.aiUsageLog?.create?.({
      data: {
        id: (0, import_crypto15.randomUUID)(),
        organizationId: organizationId || void 0,
        userId: userId || void 0,
        type,
        model: params.model || void 0,
        tokensPrompt: params.tokensPrompt ?? void 0,
        tokensOutput: params.tokensOutput ?? void 0,
        latencyMs: params.latencyMs,
        success: params.success,
        errorCode: params.error ? "ERR_AI" : void 0,
        errorMessage: params.error || void 0,
        meta
      }
    }).catch(async () => {
      await db.$executeRawUnsafe(
        'INSERT INTO "AiUsageLog" (id, "userId", "organizationId", type, model, "tokensPrompt", "tokensOutput", "latencyMs", success, "errorCode", "errorMessage", meta) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12);',
        (0, import_crypto15.randomUUID)(),
        userId,
        organizationId,
        type,
        params.model,
        params.tokensPrompt || 0,
        params.tokensOutput || 0,
        params.latencyMs || null,
        params.success,
        params.error ? "ERR_AI" : null,
        params.error || null,
        JSON.stringify(meta)
      );
    });
  } catch (e) {
    console.warn("\u26A0\uFE0F Log AI usage \xE9chou\xE9:", e.message);
  }
}
router39.post("/analyze-section", async (req2, res) => {
  const t0 = Date.now();
  try {
    const { sectionType, content, prompt } = req2.body;
    console.log("\u{1F3A8} [AI] Analyse section:", sectionType);
    console.log("\u{1F4DD} [AI] Contenu longueur:", JSON.stringify(content).length, "caract\xE8res");
    const analysisPrompt = prompt || buildSectionAnalysisPrompt(sectionType, content);
    const serviceResp = await geminiSingleton.chat({ prompt: analysisPrompt });
    const isLive = serviceResp.mode === "live";
    const analysis = isLive ? parseSectionAnalysis(serviceResp.content) : generateMockSectionAnalysis(sectionType, content);
    const latency = Date.now() - t0;
    res.json({
      success: true,
      data: analysis,
      metadata: {
        mode: serviceResp.mode,
        model: isLive ? process.env.GEMINI_MODEL || "gemini-1.5-flash" : "mock",
        latencyMs: latency,
        fallbackError: serviceResp.error
      }
    });
    void logAiUsage({
      req: req2,
      endpoint: "analyze-section",
      success: true,
      latencyMs: latency,
      model: isLive ? process.env.GEMINI_MODEL || "gemini-1.5-flash" : "mock",
      mode: serviceResp.mode,
      error: serviceResp.error ? String(serviceResp.error) : null
    });
  } catch (error) {
    console.error("\u274C Erreur route analyze-section:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de l'analyse de la section",
      details: error.message
    });
    void logAiUsage({
      req: req2,
      endpoint: "analyze-section",
      success: false,
      latencyMs: Date.now() - t0,
      model: null,
      mode: null,
      error: error.message
    });
  }
});
function buildSectionAnalysisPrompt(sectionType, content) {
  const sectionTypeGuide = getSectionTypeGuide(sectionType);
  return `Tu es un expert en UX/UI et design web sp\xE9cialis\xE9 dans les sites de transition \xE9nerg\xE9tique.

\u{1F3AF} **IMPORTANT : Analyse UNIQUEMENT cette section isol\xE9e, PAS le site complet.**

**Type de section \xE0 analyser :** ${sectionType}
${sectionTypeGuide}

**Contenu actuel de CETTE section :**
${JSON.stringify(content, null, 2).slice(0, 3e3)}

**Ta mission :**
1. Analyser UNIQUEMENT les \xE9l\xE9ments pr\xE9sents dans cette section sp\xE9cifique
2. Proposer des am\xE9liorations CONCR\xC8TES pour cette section
3. Ne PAS faire de suggestions globales sur le site
4. Se concentrer sur ce qui est modifiable dans CETTE section

**Format de r\xE9ponse (JSON uniquement) :**
{
  "score": <nombre entre 0 et 100 pour CETTE section>,
  "suggestions": [
    {
      "id": "<id unique ex: ${sectionType}-suggestion-1>",
      "category": "<layout|design|content|ux>",
      "type": "<improvement|warning|best-practice>",
      "title": "<titre court et actionnable>",
      "description": "<explication d\xE9taill\xE9e SP\xC9CIFIQUE \xE0 cette section>",
      "impact": "<low|medium|high>",
      "changes": { 
        "<nomDuChamp>": "<valeurPropos\xE9e>",
        "// Exemple: title": "Nouveau titre optimis\xE9",
        "// Exemple: backgroundColor": "#10b981"
      },
      "preview": {
        "before": "<valeur actuelle dans CETTE section>",
        "after": "<valeur propos\xE9e pour CETTE section>"
      }
    }
  ],
  "summary": {
    "strengths": ["<point fort de CETTE section>"],
    "weaknesses": ["<faiblesse de CETTE section>"],
    "opportunities": ["<am\xE9lioration possible dans CETTE section>"]
  }
}

**Crit\xE8res d'analyse pour CETTE section :**
- \u{1F4D0} **LAYOUT**: disposition des \xE9l\xE9ments dans cette section, grille, espacement interne
- \u{1F3A8} **DESIGN**: couleurs utilis\xE9es ici, typographie de cette section, contraste
- \u{1F4DD} **CONTENU**: textes pr\xE9sents dans cette section, CTA de cette section
- \u26A1 **UX**: navigation dans cette section, hi\xE9rarchie visuelle interne

**Exemples de suggestions VALIDES (sp\xE9cifiques \xE0 la section) :**
\u2705 "Le titre de cette section manque de contraste - passer de #666666 \xE0 #1f2937"
\u2705 "Le CTA de cette section est peu visible - augmenter la taille du bouton"
\u2705 "L'espacement entre le titre et la description est trop serr\xE9 - passer \xE0 24px"

**Exemples de suggestions INVALIDES (trop g\xE9n\xE9rales) :**
\u274C "Am\xE9liorer la navigation du site"
\u274C "Ajouter un footer au site"
\u274C "Optimiser le SEO global"

R\xE9ponds UNIQUEMENT avec le JSON, sans \`\`\`json ni texte additionnel.`;
}
function getSectionTypeGuide(sectionType) {
  const guides = {
    "hero": `
**\xC9l\xE9ments typiques d'une section Hero :**
- title (titre principal)
- subtitle/description (sous-titre)
- ctaText/buttonText (texte du bouton d'action)
- backgroundImage/image (image de fond)
- backgroundColor (couleur de fond)
- textColor (couleur du texte)
- alignment (alignement du contenu)`,
    "hero-split": `
**\xC9l\xE9ments typiques d'une section Hero Split :**
- title, subtitle
- image (c\xF4t\xE9 visuel)
- ctaText
- layout (left/right split)
- backgroundColor, textColor`,
    "card": `
**\xC9l\xE9ments typiques d'une section Card :**
- cards[] (liste de cartes)
- Chaque carte : title, description, icon, link
- gridColumns (nombre de colonnes)
- backgroundColor`,
    "cta": `
**\xC9l\xE9ments typiques d'une section CTA :**
- title (appel \xE0 l'action)
- description (description courte)
- buttonText (texte du bouton)
- buttonLink (lien du bouton)
- backgroundColor, buttonColor`,
    "footer": `
**\xC9l\xE9ments typiques d'un Footer :**
- companyInfo (infos entreprise)
- links[] (liens footer)
- socialLinks[] (r\xE9seaux sociaux)
- copyright (texte copyright)`,
    "testimonials": `
**\xC9l\xE9ments typiques d'une section T\xE9moignages :**
- testimonials[] (liste de t\xE9moignages)
- Chaque t\xE9moignage : name, company, text, avatar
- layout (carousel/grid)`,
    "pricing": `
**\xC9l\xE9ments typiques d'une section Tarifs :**
- plans[] (liste de forfaits)
- Chaque plan : name, price, features[], highlighted
- currency, interval (mois/an)`,
    "faq": `
**\xC9l\xE9ments typiques d'une section FAQ :**
- questions[] (liste de questions)
- Chaque question : question, answer
- layout (accordion/list)`,
    "contact-form": `
**\xC9l\xE9ments typiques d'un Formulaire de Contact :**
- fields[] (champs du formulaire)
- submitText (texte du bouton)
- successMessage (message de succ\xE8s)`
  };
  return guides[sectionType] || `**Section de type : ${sectionType}**
Analyser les \xE9l\xE9ments pr\xE9sents dans le contenu fourni.`;
}
function parseSectionAnalysis(content) {
  if (!content) return generateMockSectionAnalysis("unknown", {});
  try {
    const cleaned = content.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();
    const parsed = JSON.parse(cleaned);
    if (!parsed.score || !parsed.suggestions || !parsed.summary) {
      throw new Error("Structure invalide");
    }
    return parsed;
  } catch (error) {
    console.warn("\u26A0\uFE0F Impossible de parser la r\xE9ponse Gemini, utilisation du mock");
    return generateMockSectionAnalysis("unknown", {});
  }
}
function generateMockSectionAnalysis(sectionType, content) {
  const hasTitle = content?.title || content?.heading;
  const hasDescription = content?.description || content?.subtitle;
  const hasImage = content?.image || content?.backgroundImage;
  const hasCTA = content?.ctaText || content?.buttonText;
  const hasBackgroundColor = content?.backgroundColor;
  const hasTextColor = content?.textColor;
  const suggestions = [];
  let score = 75;
  if (sectionType === "hero" || sectionType === "hero-split") {
    if (!hasImage) {
      suggestions.push({
        id: `${sectionType}-img-missing`,
        category: "design",
        type: "warning",
        title: "Image de fond manquante dans cette Hero",
        description: "Cette section Hero n\xE9cessite une image de fond impactante pour capter l'attention. Les Hero avec image convertissent 45% mieux.",
        impact: "high",
        changes: {
          backgroundImage: "https://images.unsplash.com/photo-1509391366360-2e959784a276?w=1920",
          overlayOpacity: "0.4"
        },
        preview: {
          before: "Aucune image de fond",
          after: "Image panoramique transition \xE9nerg\xE9tique avec overlay"
        }
      });
      score -= 15;
    }
    if (!hasCTA) {
      suggestions.push({
        id: `${sectionType}-cta-missing`,
        category: "content",
        type: "warning",
        title: "Bouton d'action manquant dans cette Hero",
        description: `Cette section Hero doit avoir un CTA clair et visible pour guider l'utilisateur. Suggestion : "Demander un devis gratuit"`,
        impact: "high",
        changes: {
          ctaText: "Demander un devis gratuit",
          ctaStyle: "primary",
          ctaSize: "large"
        },
        preview: {
          before: "Pas de bouton d'action",
          after: 'Bouton "Demander un devis gratuit" visible'
        }
      });
      score -= 12;
    }
    if (hasTitle && hasTitle.length < 20) {
      suggestions.push({
        id: `${sectionType}-title-short`,
        category: "content",
        type: "improvement",
        title: "Titre de cette Hero trop court",
        description: `Le titre actuel "${hasTitle}" est trop court. Un titre Hero impactant fait 30-60 caract\xE8res pour \xEAtre m\xE9morable.`,
        impact: "medium",
        changes: {
          title: "Transformez votre consommation \xE9nerg\xE9tique d\xE8s aujourd'hui"
        },
        preview: {
          before: hasTitle,
          after: "Transformez votre consommation \xE9nerg\xE9tique d\xE8s aujourd'hui"
        }
      });
      score -= 8;
    }
  } else if (sectionType === "card" || sectionType === "card-icon" || sectionType === "card-service") {
    const cards = content?.cards || [];
    const gridColumns = content?.gridColumns || 3;
    if (cards.length === 0) {
      suggestions.push({
        id: `${sectionType}-no-cards`,
        category: "content",
        type: "warning",
        title: "Aucune carte dans cette section Cards",
        description: "Cette section de cartes est vide. Ajoutez au moins 3 cartes pour pr\xE9senter vos services/avantages.",
        impact: "high",
        changes: {
          cards: [
            { title: "Service 1", description: "Description du service", icon: "star" },
            { title: "Service 2", description: "Description du service", icon: "rocket" },
            { title: "Service 3", description: "Description du service", icon: "check" }
          ]
        },
        preview: {
          before: "Section vide",
          after: "3 cartes de services avec ic\xF4nes"
        }
      });
      score -= 20;
    } else if (cards.length % gridColumns !== 0) {
      suggestions.push({
        id: `${sectionType}-grid-uneven`,
        category: "layout",
        type: "improvement",
        title: "Grille d\xE9s\xE9quilibr\xE9e dans cette section",
        description: `Vous avez ${cards.length} cartes en ${gridColumns} colonnes, ce qui cr\xE9e une derni\xE8re ligne incompl\xE8te. Ajoutez ${gridColumns - cards.length % gridColumns} carte(s) ou passez \xE0 ${cards.length} colonnes.`,
        impact: "medium",
        changes: {
          gridColumns: cards.length === 4 ? 2 : Math.min(cards.length, 4)
        },
        preview: {
          before: `${cards.length} cartes en ${gridColumns} colonnes`,
          after: "Grille \xE9quilibr\xE9e"
        }
      });
      score -= 5;
    }
  } else if (sectionType === "cta" || sectionType === "cta-banner") {
    if (!hasCTA) {
      suggestions.push({
        id: `${sectionType}-no-button`,
        category: "content",
        type: "warning",
        title: "Bouton manquant dans cette section CTA",
        description: "Une section CTA DOIT avoir un bouton d'action visible. C'est l'\xE9l\xE9ment central de cette section.",
        impact: "high",
        changes: {
          buttonText: "Commencer maintenant",
          buttonSize: "large",
          buttonColor: "#10b981"
        },
        preview: {
          before: "Pas de bouton",
          after: 'Bouton "Commencer maintenant" vert vif'
        }
      });
      score -= 25;
    }
    if (!hasBackgroundColor || hasBackgroundColor === "#ffffff") {
      suggestions.push({
        id: `${sectionType}-bg-bland`,
        category: "design",
        type: "improvement",
        title: "Fond de cette CTA trop neutre",
        description: "Cette section CTA doit se d\xE9marquer visuellement. Utilisez un fond color\xE9 ou un gradient pour attirer l'attention.",
        impact: "high",
        changes: {
          backgroundColor: "#f0fdf4",
          borderColor: "#10b981",
          borderWidth: "2px"
        },
        preview: {
          before: "Fond blanc neutre",
          after: "Fond vert clair avec bordure verte"
        }
      });
      score -= 10;
    }
  } else if (sectionType === "footer") {
    const hasCopyright = content?.copyright;
    const hasLinks = content?.links && content.links.length > 0;
    if (!hasCopyright) {
      suggestions.push({
        id: `${sectionType}-no-copyright`,
        category: "content",
        type: "warning",
        title: "Copyright manquant dans ce Footer",
        description: "Ce footer doit inclure le copyright pour la conformit\xE9 l\xE9gale.",
        impact: "medium",
        changes: {
          copyright: `\xA9 ${(/* @__PURE__ */ new Date()).getFullYear()} 2Thier. Tous droits r\xE9serv\xE9s.`
        },
        preview: {
          before: "Pas de mention l\xE9gale",
          after: "\xA9 2025 2Thier. Tous droits r\xE9serv\xE9s."
        }
      });
      score -= 8;
    }
    if (!hasLinks) {
      suggestions.push({
        id: `${sectionType}-no-links`,
        category: "content",
        type: "improvement",
        title: "Liens manquants dans ce Footer",
        description: "Ce footer devrait inclure des liens utiles (CGV, Mentions l\xE9gales, Contact, etc.)",
        impact: "medium",
        changes: {
          links: [
            { text: "Mentions l\xE9gales", url: "/legal" },
            { text: "CGV", url: "/cgv" },
            { text: "Contact", url: "/contact" }
          ]
        },
        preview: {
          before: "Aucun lien",
          after: "3 liens l\xE9gaux essentiels"
        }
      });
      score -= 7;
    }
  }
  if (!hasTitle) {
    suggestions.push({
      id: `${sectionType}-no-title`,
      category: "content",
      type: "warning",
      title: "Titre manquant dans cette section",
      description: `Cette section ${sectionType} n\xE9cessite un titre clair pour guider le visiteur.`,
      impact: "high",
      changes: {
        title: sectionType === "hero" ? "Votre titre impactant ici" : `Titre de la section ${sectionType}`
      },
      preview: {
        before: "Pas de titre",
        after: "Titre explicite ajout\xE9"
      }
    });
    score -= 12;
  }
  if (!hasDescription && sectionType !== "footer") {
    suggestions.push({
      id: `${sectionType}-no-desc`,
      category: "content",
      type: "improvement",
      title: "Description manquante dans cette section",
      description: `Un sous-titre ou description dans cette section ${sectionType} am\xE9liore la clart\xE9 du message.`,
      impact: "medium",
      changes: {
        description: "Description engageante de cette section"
      },
      preview: {
        before: "Pas de description",
        after: "Sous-titre explicatif ajout\xE9"
      }
    });
    score -= 6;
  }
  if (hasBackgroundColor && hasTextColor) {
    const bgColor = hasBackgroundColor.replace("#", "");
    const txtColor = hasTextColor.replace("#", "");
    const bgLight = parseInt(bgColor.substring(0, 2), 16) > 200;
    const txtLight = parseInt(txtColor.substring(0, 2), 16) > 200;
    if (bgLight && txtLight) {
      suggestions.push({
        id: `${sectionType}-contrast-low`,
        category: "design",
        type: "warning",
        title: "Contraste insuffisant dans cette section",
        description: "Le texte clair sur fond clair de cette section pose un probl\xE8me d'accessibilit\xE9 (WCAG). Assombrir le texte.",
        impact: "medium",
        changes: {
          textColor: "#1f2937"
        },
        preview: {
          before: `Texte ${hasTextColor} sur fond ${hasBackgroundColor}`,
          after: "Texte #1f2937 (gris fonc\xE9) sur fond clair"
        }
      });
      score -= 8;
    }
  }
  const padding = content?.padding;
  if (!padding || padding === "0px" || padding === "0") {
    suggestions.push({
      id: `${sectionType}-no-padding`,
      category: "layout",
      type: "best-practice",
      title: "Espacement insuffisant dans cette section",
      description: 'Cette section manque de "breathing room". Ajouter du padding pour un design a\xE9r\xE9 (r\xE8gle des 8px).',
      impact: "low",
      changes: {
        padding: "48px 24px"
      },
      preview: {
        before: "Section coll\xE9e aux bords",
        after: "Section avec espacement confortable"
      }
    });
    score -= 4;
  }
  if (suggestions.length === 0) {
    suggestions.push({
      id: `${sectionType}-optimize-mobile`,
      category: "ux",
      type: "best-practice",
      title: "Optimiser cette section pour mobile",
      description: "V\xE9rifier que cette section s'adapte bien aux petits \xE9crans (responsive design).",
      impact: "medium",
      changes: {
        responsiveSettings: {
          mobile: { fontSize: "14px", padding: "24px 16px" }
        }
      },
      preview: {
        before: "Param\xE8tres desktop uniquement",
        after: "Adapt\xE9 aux mobiles"
      }
    });
  }
  return {
    score: Math.max(40, Math.min(95, score)),
    suggestions: suggestions.slice(0, 8),
    // Max 8 suggestions pour ne pas surcharger
    summary: {
      strengths: [
        hasTitle && `Titre pr\xE9sent dans cette section`,
        hasDescription && `Description claire dans cette section`,
        hasImage && `Visuel pr\xE9sent dans cette section`,
        hasCTA && `Appel \xE0 l'action dans cette section`,
        hasBackgroundColor && hasBackgroundColor !== "#ffffff" && `Fond personnalis\xE9 dans cette section`
      ].filter(Boolean),
      weaknesses: [
        !hasTitle && `Titre manquant dans cette section ${sectionType}`,
        !hasDescription && sectionType !== "footer" && `Description absente de cette section`,
        !hasCTA && (sectionType === "hero" || sectionType === "cta") && `Bouton d'action manquant dans cette section`,
        suggestions.length > 3 && `${suggestions.length} am\xE9liorations possibles identifi\xE9es pour cette section`
      ].filter(Boolean),
      opportunities: [
        `Ajouter des animations d'entr\xE9e pour cette section`,
        `Tester des variantes A/B de cette section`,
        `Am\xE9liorer l'accessibilit\xE9 (WCAG AA) de cette section`,
        `Optimiser le poids des images de cette section`
      ].slice(0, 3)
    }
  };
}
router39.post("/generate-response", async (req2, res) => {
  await handleChatLike(req2, res, "generate-response");
});
router39.post("/chat", async (req2, res) => {
  await handleChatLike(req2, res, "chat");
});
function buildChatPrompt({ message, context, conversationHistory, analysis, memory }) {
  function summarizeLeadFromContext(ctx) {
    try {
      if (!ctx) return "";
      const ctxUnknown = ctx;
      const leadBasic = ctxUnknown?.lead || null;
      const lc = ctxUnknown?.leadContext || null;
      const lead = lc && lc.lead || leadBasic || null;
      if (!lead && !lc) return "";
      const name = [lead?.firstName || lead?.data?.firstName, lead?.lastName || lead?.data?.lastName, lead?.name].filter(Boolean).join(" ").trim();
      const company = lead?.company || lead?.data?.company || "";
      const status = lead?.status || lead?.data?.status || "N/A";
      const source = lead?.source || lead?.data?.source || "";
      const email = lead?.email || lead?.data?.email || "";
      const phone = lead?.phone || lead?.data?.phone || "";
      const notes = (lead?.notes || lead?.data?.notes || "").toString();
      const nextFollowUp = lead?.nextFollowUpDate || lead?.data?.nextFollowUpDate || null;
      const createdAt = lead?.createdAt || lead?.data?.createdAt || null;
      const calls = lc?.calls || [];
      const messages = lc?.messages || [];
      const events = lc?.upcomingEvents || [];
      const formSubmissions = lc?.formSubmissions || [];
      const lastCall = Array.isArray(calls) && calls.length ? calls[0] : null;
      const lastMsg = Array.isArray(messages) && messages.length ? messages[0] : null;
      const nextEvent = Array.isArray(events) && events.length ? events[0] : null;
      const parts = [];
      if (name) parts.push(`\u{1F464} Nom: ${name}${company ? " \u2022 " + company : ""}`);
      if (email) parts.push(`\u{1F4E7} Email: ${email}`);
      if (phone) parts.push(`\u{1F4DE} T\xE9l\xE9phone: ${phone}`);
      if (status) parts.push(`\u{1F4CA} Statut: ${status}`);
      if (source) parts.push(`\u{1F4CD} Source: ${source}`);
      if (createdAt) parts.push(`\u{1F550} Contact depuis: ${new Date(createdAt).toLocaleDateString("fr-FR")}`);
      if (Array.isArray(formSubmissions) && formSubmissions.length > 0) {
        const formData = formSubmissions.map((fs12) => {
          const formTitle = fs12.formTitle || "Formulaire";
          const data = fs12.data;
          if (!data || typeof data !== "object") return `${formTitle} (${new Date(fs12.createdAt).toLocaleDateString("fr-FR")})`;
          const dataObj = data;
          const allFields = Object.entries(dataObj).map(([k, v]) => {
            const cleanKey = k.replace(/([A-Z])/g, " $1").toLowerCase().trim().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
            let val = typeof v === "string" ? v : Array.isArray(v) ? v.join(", ") : typeof v === "object" ? JSON.stringify(v).slice(0, 40) : String(v);
            val = val.slice(0, 80);
            return `${cleanKey}: ${val}`;
          }).join(" | ");
          return `${formTitle} (${new Date(fs12.createdAt).toLocaleDateString("fr-FR")}): ${allFields}`;
        }).join("\n");
        parts.push(`\u{1F4CB} FORMULAIRES REMPLIS (\xC0 UTILISER SP\xC9CIFIQUEMENT!):
${formData}`);
      }
      const counts = [];
      if (Array.isArray(calls)) counts.push(`${calls.length} appels`);
      if (Array.isArray(messages)) counts.push(`${messages.length} SMS/messages`);
      if (Array.isArray(events)) counts.push(`${events.length} RDV`);
      if (counts.length) parts.push(`\u{1F4C8} Activit\xE9: ${counts.join(", ")}`);
      if (lastCall) {
        const duration = lastCall.duration ? ` \u2022 ${lastCall.duration}s` : "";
        parts.push(`\u260E\uFE0F Dernier appel: ${lastCall.status || "n/a"}${duration}`);
      }
      if (lastMsg) {
        const date = lastMsg.sentAt ? `(${new Date(lastMsg.sentAt).toLocaleDateString("fr-FR")})` : "";
        parts.push(`\u{1F4AC} Dernier message: ${lastMsg.type || "n/a"} ${date}`);
      }
      if (nextFollowUp) parts.push(`\u23F0 Suivi pr\xE9vu: ${new Date(nextFollowUp).toLocaleString("fr-FR")}`);
      if (nextEvent) parts.push(`\u{1F4C5} Prochain RDV: "${nextEvent.title || "RDV"}" le ${nextEvent.startDate ? new Date(nextEvent.startDate).toLocaleString("fr-FR") : "bient\xF4t"}`);
      if (notes && notes.trim()) {
        const notesPreview = notes.replace(/\s+/g, " ").slice(0, 250);
        parts.push(`\u{1F4DD} Notes/Observations: ${notesPreview}${notes.length > 250 ? "\u2026" : ""}`);
      }
      return parts.length ? "\n\u{1F4CB} FICHE CLIENT:\n" + parts.join("\n") : "";
    } catch {
      return "";
    }
  }
  const hist = (conversationHistory || []).slice(-8).map((m, i) => `#${i + 1} ${m.type || m.role || "user"}: ${(m.message || m.content || "").slice(0, 400)}`).join("\n");
  const analysisBlock = analysis ? `
ANALYSE_PRECEDENTE:
${JSON.stringify(analysis).slice(0, 800)}` : "";
  const memoryBlock = memory ? `
MEMOIRE_SYSTEME_RECENTE:
${memory}` : "";
  const leadBlock = summarizeLeadFromContext(context);
  return `\u{1F3AF} R\xD4LE: Tu es un SUPER PRO COMMERCIAL exp\xE9riment\xE9 qui connais CHAQUE CLIENT par c\u0153ur.
Tu analyses en PROFONDEUR et donnes des conseils DIRECTIFS, bas\xE9s sur LES DONN\xC9ES R\xC9ELLES du client.
Tu utilises TOUT: formulaire, champs, notes, observations, d\xE9lais, budgets - RIEN ne t'\xE9chappe!

\u{1F4CB} CONTEXTE:
Module: ${context?.currentModule || "inconnu"}
Page: ${context?.currentPage || "n/a"}
Utilisateur: ${context?.userRole || "commercial"}
${leadBlock}

\u{1F4DE} HISTORIQUE:
${hist || "Aucun"}

\u{1F4AC} MESSAGE UTILISATEUR: ${message}
${analysisBlock}
${memoryBlock}

\u{1F680} TES INSTRUCTIONS (CRUCIALES - LIS ATTENTIVEMENT):

1. **EXTRACTION COMPL\xC8TE** des donn\xE9es du formulaire:
   - Quels champs le client a remplis ? (type de projet, budget, d\xE9lai, besoin, urgence)
   - Qu'est-ce que \xE7a dit VRAIMENT sur son projet ?
   - Qu'est-ce qu'il demande SP\xC9CIFIQUEMENT ? (pas ce qu'il dit vaguement, mais SES DONN\xC9ES)
   - Quels sont les INDICES COMMERCIAUX ? (budget=s\xE9rieux, d\xE9lai court=urgence, etc.)

2. **HOOK D'APPEL ULTRA-SP\xC9CIFIQUE** (C'EST LE PLUS IMPORTANT!):
   - NE JAMAIS g\xE9n\xE9rique: "j'appelle pour comprendre votre projet"
   - TOUJOURS sp\xE9cifique: cite les DONN\xC9ES du formulaire qu'il a rempli
   - Exemple BON: "Bonjour Heloise, je suis Jonathan. Vous avez simul\xE9 une r\xE9novation de salle de bain avec un budget de 15 000\u20AC. Je vous appelle pour les aides dont vous \xEAtes \xE9ligible et confirmer votre timeline. Vous avez 2 min?"
   - Exemple MAUVAIS: "Vous avez rempli le formulaire. Je vous appelle pour..."
   - Le hook doit PROUVER que tu as lu son formulaire sp\xE9cifiquement

3. **DIAGNOSTIC COMMERCIAL**:
   - Ce client est QUEL TYPE ? (petit projet, gros projet, press\xE9, tranquille)
   - Le risque ? (il appelle un concurrent, il abandonne, il se fait avoir)
   - L'opportunit\xE9 ? (vente rapide, upsell, fid\xE9lisation)

4. **STRAT\xC9GIE DIRECTE** (sois affirm\xE9!):
   - Que ferait un VRAI pro \xE0 ta place avec CES DONN\xC9ES SP\xC9CIFIQUES ?
   - Quel est le bon angle d'attaque ?
   - Comment cr\xE9er urgence/curiosit\xE9 avec ses donn\xE9es ?

5. **POINTS DE VENTE SP\xC9CIFIQUES**:
   - 2-3 arguments bas\xE9s SUR SES DONN\xC9ES (pas g\xE9n\xE9riques)
   - Exemple: "Vous envisagez Q2? Vous pouvez \xEAtre operationnel Q1 avec les aides..."
   - Exemple: "Vous avez budget 15k? Les aides ajoutent 5k minimum..."

6. **PROCHAINE ACTION D\xC9CISIVE**:
   - QUAND l'appeler ? (timing optimal selon urgence)
   - QUOI lui dire EN PREMIER ? (le hook ultra-sp\xE9cifique)
   - Comment qualifier: besoin \u2192 d\xE9lai \u2192 budget \u2192 RDV

\u{1F4DD} FORMAT DE R\xC9PONSE:

**[Client Name] - Analyse + Hook d'Appel:**

Formulaire rempli: [Type de projet, champs cl\xE9s mentionn\xE9s]
Budget d\xE9clar\xE9: [montant si pr\xE9sent]
D\xE9lai: [si pr\xE9sent]
Signaux cl\xE9s: [urgence, type de client, niveau de s\xE9rieux]

Mon diagnostic: [Type de lead, ce que \xE7a signifie commercialement, opportunit\xE9]

\u{1F3AF} HOOK D'APPEL (super sp\xE9cifique):
"[Reprendre \xE9l\xE9ment 1 du formulaire], [reprendre \xE9l\xE9ment 2], [reprendre urgence/d\xE9lai], [appel \xE0 action]"

\u{1F4A1} Points cl\xE9s \xE0 utiliser:
1. [Bas\xE9 sur ses donn\xE9es - pas g\xE9n\xE9rique]
2. [Bas\xE9 sur ses donn\xE9es - pas g\xE9n\xE9rique]

\u{1F4DE} Prochaine action:
[Timing pr\xE9cis, quoi dire exactement en reprenant le formulaire, comment qualifier]

\u26A0\uFE0F R\xC8GLE ABSOLUE: Chaque conseil, chaque point, chaque action doit \xEAtre bas\xE9 sur LES DONN\xC9ES DU FORMULAIRE. 
Pas de g\xE9n\xE9rique. Pas de script standard. Du SUR-MESURE bas\xE9 sur ce qu'il a rempli.

Limite \xE0 250 mots MAX. Sois DIRECT, ASSERTIF, et 100% SP\xC9CIFIQUE aux donn\xE9es du client.`;
}
function buildMockResponse(message, context) {
  const page = (context?.currentPage || "").toLowerCase();
  const moduleKey = (context?.currentModule || "").toLowerCase();
  const mentionsGmail = /gmail|mail|email|inbox|d√©livrabi|deliverab/i.test(message) || page.includes("mail") || page.includes("gmail") || moduleKey.includes("mail") || moduleKey.includes("gmail");
  if (mentionsGmail) {
    return [
      `Analyse rapide de la page Mail (r\xE9ponse simplifi\xE9e):`,
      `\u2022 Lisibilit\xE9: v\xE9rifiez la hi\xE9rarchie (sujet, exp\xE9diteur, labels).`,
      `\u2022 Actions cl\xE9s visibles: r\xE9pondre, transf\xE9rer, \xE9toile, supprimer, labels.`,
      `\u2022 \xC9tats: chargement, erreurs, bo\xEEte vide, pagination/scroll.`,
      `\u2022 Recherche/filtres: champs, tri par date/exp\xE9diteur, labels.`,
      `\u2022 S\xE9curit\xE9: si HTML d'email rendu, utiliser DOMPurify (anti-XSS).`,
      `\u2022 Liaison CRM: lien vers Lead/Opportunit\xE9/T\xE2ches, suivi/relances.`,
      `Prochaine \xE9tape: dites \u201Caudite la page mail\u201D ou \u201Cpropose 3 quick wins UI\u201D.`
    ].join("\n");
  }
  return `Je comprends: "${message}". (R\xE9ponse simplifi\xE9e) Besoin d'aide pour: planifier un RDV, analyser un lead, g\xE9n\xE9rer un email, ou d\xE9finir la prochaine action ? Pr\xE9cisez votre objectif en une phrase.`;
}
function defaultSuggestions() {
  return [
    "Script d\u2019ouverture d\u2019appel",
    "Questions de qualification",
    "Prochaine action commerciale",
    "Planifier un rendez-vous"
  ];
}
function deriveSuggestions(content) {
  const lower = content.toLowerCase();
  const s = /* @__PURE__ */ new Set();
  if (lower.includes("email")) s.add("G\xE9n\xE9rer un email");
  if (lower.includes("rdv") || lower.includes("rendez")) s.add("Planifier un rendez-vous");
  if (lower.includes("analyse")) s.add("Analyser le lead");
  s.add("Prochaine action commerciale");
  return Array.from(s).slice(0, 6);
}
var __AI_CODE_INDEX = null;
var __AI_SYMBOL_INDEX = null;
var __AI_FILE_SUMMARY_CACHE = {};
var __AI_FILE_SUMMARY_TTL = 9e4;
function __aiBuildCodeIndex() {
  if (__AI_CODE_INDEX) return __AI_CODE_INDEX;
  const base = import_path5.default.join(process.cwd(), "src");
  const acc = [];
  function walk(dir, depth = 0) {
    if (depth > 6) return;
    let entries = [];
    try {
      entries = import_fs6.default.readdirSync(dir);
    } catch {
      return;
    }
    for (const e of entries) {
      const full = import_path5.default.join(dir, e);
      if (/node_modules|\.git|dist|build/.test(full)) continue;
      let st;
      try {
        st = import_fs6.default.statSync(full);
      } catch {
        continue;
      }
      if (st.isDirectory()) walk(full, depth + 1);
      else if (/\.(ts|tsx|js|cjs|mjs)$/.test(e)) acc.push(full.substring(base.length + 1).replace(/\\/g, "/"));
    }
  }
  walk(base);
  __AI_CODE_INDEX = acc;
  return acc;
}
function __aiBuildSymbolIndex() {
  if (__AI_SYMBOL_INDEX) return __AI_SYMBOL_INDEX;
  const idx = __aiBuildCodeIndex();
  const m = {};
  for (const rel of idx.slice(0, 1200)) {
    try {
      const abs2 = import_path5.default.join(process.cwd(), "src", rel);
      const content = import_fs6.default.readFileSync(abs2, "utf8");
      const regexes = [
        /export\s+class\s+([A-Za-z0-9_]+)/g,
        /export\s+(?:async\s+)?function\s+([A-Za-z0-9_]+)/g,
        /export\s+const\s+([A-Za-z0-9_]+)/g,
        /export\s+interface\s+([A-Za-z0-9_]+)/g,
        /export\s+type\s+([A-Za-z0-9_]+)/g,
        /export\s+enum\s+([A-Za-z0-9_]+)/g
      ];
      for (const r of regexes) {
        let match;
        while (match = r.exec(content)) {
          if (!m[match[1]]) m[match[1]] = rel;
        }
      }
      const brace = /export\s+{([^}]+)}/g;
      let b;
      while (b = brace.exec(content)) {
        b[1].split(",").map((s) => s.trim().split(/\s+as\s+/i)[0]).filter(Boolean).forEach((sym) => {
          if (!m[sym]) m[sym] = rel;
        });
      }
    } catch {
    }
  }
  __AI_SYMBOL_INDEX = m;
  return m;
}
function __aiExtractReferencedFiles(message) {
  const explicit = Array.from(message.matchAll(/([A-Za-z0-9_-]+\.(?:tsx?|jsx?|cjs|mjs))/g)).map((m) => m[1]);
  const extra = [];
  const hooks = Array.from(message.matchAll(/use[A-Z][A-Za-z0-9]+/g)).map((m) => m[0] + ".ts");
  extra.push(...hooks);
  const symbolTokens = Array.from(message.matchAll(/\b[A-Z][A-Za-z0-9_]{2,}\b/g)).map((m) => m[0]).slice(0, 30);
  const symIdx = __aiBuildSymbolIndex();
  for (const t of symbolTokens) if (symIdx[t]) extra.push(symIdx[t]);
  const candidates = Array.from(/* @__PURE__ */ new Set([...explicit, ...extra]));
  if (!candidates.length) return [];
  const index = __aiBuildCodeIndex();
  const resolved = [];
  for (const c of candidates) {
    if (c.includes("/")) {
      if (index.includes(c)) resolved.push(c);
    } else {
      const hit = index.find((p) => p.endsWith("/" + c) || p === c);
      if (hit) resolved.push(hit);
    }
    if (resolved.length >= 5) break;
  }
  return resolved.slice(0, 5);
}
function __aiSummarizeFile(rel) {
  try {
    const now = Date.now();
    const cached = __AI_FILE_SUMMARY_CACHE[rel];
    if (cached && now - cached.ts < __AI_FILE_SUMMARY_TTL) return cached.summary;
    const abs2 = import_path5.default.join(process.cwd(), "src", rel);
    if (!import_fs6.default.existsSync(abs2)) return null;
    const content = import_fs6.default.readFileSync(abs2, "utf8");
    const lines = content.split(/\r?\n/);
    const first = lines.slice(0, 80).join("\n");
    const importMatches = Array.from(content.matchAll(/import\s+[^;]+from\s+['"]([^'".][^'"/]*)['"]/g)).map((m) => m[1]).slice(0, 8);
    const internalImports = Array.from(content.matchAll(/import\s+[^;]+from\s+['"](\.{1,2}\/[^'"]+)['"]/g)).map((m) => m[1]).slice(0, 6);
    const exportMatches = Array.from(content.matchAll(/export\s+(?:default\s+)?(function|const|class)\s+([A-Za-z0-9_]+)/g)).map((m) => m[2]).slice(0, 10);
    const hasDefault = /export\s+default\s+/.test(content);
    const hooksCount = (content.match(/\buse(State|Effect|Memo|Callback|Ref|Context|Reducer)\b/g) || []).length;
    const useEffectCount = (content.match(/\buseEffect\b/g) || []).length;
    const hasI18n = /\bt\(['"][^)]*\)/.test(content) || /i18n/.test(content);
    const jsxTags = (content.match(/<[A-Z][A-Za-z0-9]+\b/g) || []).length;
    const size = lines.length;
    const risk = [];
    if (size > 800) risk.push("very_large");
    else if (size > 400) risk.push("large");
    if (hooksCount > 18) risk.push("many_hooks");
    if (!hasI18n) risk.push("no_i18n");
    const summaryObj = {
      file: rel,
      lines: size,
      exports: exportMatches,
      defaultExport: hasDefault,
      importsExt: importMatches,
      importsInt: internalImports,
      hooks: { total: hooksCount, useEffect: useEffectCount },
      jsxTags,
      i18n: hasI18n,
      risks: risk
    };
    const summaryStr = "FILE_SUMMARY " + rel + "\n" + JSON.stringify(summaryObj) + "\nFIRST_LINES:\n" + first.slice(0, 1800);
    __AI_FILE_SUMMARY_CACHE[rel] = { ts: now, summary: summaryStr };
    return summaryStr;
  } catch {
    return null;
  }
}
async function handleChatLike(req2, res, endpoint) {
  const t0 = Date.now();
  try {
    let message, context, conversationHistory, analysis;
    try {
      ({ message, context = {}, conversationHistory = [], analysis } = req2.body || {});
    } catch (parseErr) {
      return res.status(400).json({ success: false, error: "Corps de requ\xEAte invalide", details: parseErr.message });
    }
    if (!message || typeof message !== "string") {
      return res.status(400).json({ success: false, error: 'Param\xE8tre "message" requis' });
    }
    console.log(`\u{1F916} [AI] ${endpoint} message=`, message.slice(0, 160));
    const historyPreview = conversationHistory.slice(-6).map((m) => `${m.type || m.role}: ${(m.message || m.content || "").slice(0, 100)}`);
    console.log("\u{1F4DA} [AI] History(last<=6)=", historyPreview);
    let memoryString = "";
    try {
      const authReq = req2;
      const u = authReq.user;
      const isSuper2 = !!(u?.isSuperAdmin || u?.roles?.includes?.("super_admin"));
      if (isSuper2) {
        const orgId = authReq.user?.organizationId || null;
        const memEntries = await db.aiUsageLog.findMany({
          where: { type: "system_memory", ...orgId ? { organizationId: orgId } : {} },
          orderBy: { createdAt: "desc" },
          take: 8,
          select: { errorMessage: true, meta: true, createdAt: true }
        });
        memoryString = memEntries.map((m) => {
          const metaObj = m.meta ?? null;
          const topic = typeof metaObj?.topic === "string" ? metaObj.topic : "M\xE9mo";
          return `- ${topic}: ${(m.errorMessage || "").replace(/\s+/g, " ").slice(0, 180)}`;
        }).join("\n");
      }
    } catch (memErr) {
      console.warn("[AI] M\xE9moire syst\xE8me indisponible:", memErr.message);
    }
    let internalFunctionalContext = "";
    try {
      if (/gmail|email|mail|d√©livrabi|deliverab/i.test(message)) {
        const googleModules = await db.module.findMany({
          where: { key: { in: ["google_gmail", "google_drive", "google_calendar"] } },
          select: { key: true, label: true, route: true, feature: true }
        });
        const activated = googleModules.map((m) => `${m.label || m.key}${m.route ? "(/" + m.route.replace(/^\//, "") + ")" : ""}`).join(", ") || "Aucun module Google activ\xE9";
        internalFunctionalContext = `AUDIT_PAGE_GMAIL: Concentre ta r\xE9ponse sur l'audit de la page Gmail du CRM (UI/UX/flows), pas sur Gmail en g\xE9n\xE9ral.
ModulesGoogleActifs: ${activated}
Checklist d'audit (prioriser concret et actionnable):
- Structure & lisibilit\xE9 (layout, densit\xE9, hi\xE9rarchie visuelle)
- \xC9tats (chargement/erreur/empty), feedbacks et affordances
- Actions cl\xE9s: composer, r\xE9pondre, transf\xE9rer, \xE9toiler, supprimer, naviguer par labels
- Recherche/tri/filtres/pagination ou scroll infini
- Accessibilit\xE9 (A11y), raccourcis clavier, focus management
- Internationalisation (i18n), responsive/mobile
- S\xE9curit\xE9 rendu HTML (sanitiser si HTML inject\xE9)
- Liaison CRM: liens Lead/Opportunit\xE9/T\xE2ches, suivi/relances
Restitue: Points forts, Probl\xE8mes, Am\xE9liorations, Ajouts \xE0 envisager, \xC0 retirer, Quick wins (prioris\xE9s).`;
      }
    } catch (ctxErr) {
      console.warn("[AI] Contexte fonctionnel Gmail non disponible:", ctxErr.message);
    }
    let codeContext = "";
    try {
      if (/(analyse|regarde|inspecte|code|fichier|hook|component|classe|fonction|page|gmail|module|google mail)/i.test(message)) {
        const referenced = __aiExtractReferencedFiles(message);
        if (referenced.length) {
          codeContext = referenced.map((r) => __aiSummarizeFile(r) || `// ${r} (lecture impossible)`).join("\n\n");
        }
      }
    } catch (e) {
      console.warn("[AI] Contexte code \xE9chou\xE9:", e.message);
    }
    let autoAnalysis = null;
    try {
      let resolvePageFile = function(name) {
        if (!name) return null;
        const base = import_path5.default.join(process.cwd(), "src", "pages");
        if (name.endsWith(".tsx") && import_fs6.default.existsSync(import_path5.default.join(process.cwd(), "src", name))) return name;
        const candidate = import_path5.default.join(base, name.endsWith(".tsx") ? name : name + ".tsx");
        if (import_fs6.default.existsSync(candidate)) return "pages/" + import_path5.default.basename(candidate);
        try {
          const entries = import_fs6.default.readdirSync(base);
          const hit = entries.find((e) => e.toLowerCase() === (name.toLowerCase().endsWith(".tsx") ? name.toLowerCase() : name.toLowerCase() + ".tsx"));
          if (hit) return "pages/" + hit;
        } catch {
        }
        return null;
      };
      const ctxObj = context || {};
      const maybePage = ctxObj.currentPage;
      const maybeModule = ctxObj.currentModule;
      const lowerMsg = message.toLowerCase();
      const wantAnalysis = /(analyse|audite|qualit√©|am√©lior|refactor|optimis|structure|complexit√©|lisibilit√©|accessibilit√©|ux|ui)/i.test(message);
      let featureKey = null;
      const featureMapPath = import_path5.default.join(process.cwd(), "src", "feature-map.json");
      let featureMap = null;
      if (import_fs6.default.existsSync(featureMapPath)) {
        try {
          featureMap = JSON.parse(import_fs6.default.readFileSync(featureMapPath, "utf8"));
        } catch {
        }
      }
      if (featureMap) {
        for (const k of Object.keys(featureMap)) {
          if (lowerMsg.includes(k) || maybeModule && maybeModule.toLowerCase().includes(k)) {
            featureKey = k;
            break;
          }
        }
        if (!featureKey) {
          if (/gmail|email|inbox/.test(lowerMsg)) featureKey = "mail";
          else if (/lead/.test(lowerMsg)) featureKey = "leads";
          else if (/agenda|calendar|calendrier/.test(lowerMsg)) featureKey = "agenda";
        }
      }
      let pagePath = null;
      if (maybePage) pagePath = resolvePageFile(maybePage);
      if (!pagePath && /(page|mailpage|googlemailpage|inbox)/i.test(message)) {
        const guess = ["pages/GoogleMailPageFixed_New.tsx", "pages/GoogleMailPageFixed.tsx", "pages/GoogleMailPage.tsx", "pages/MailPage.tsx"];
        pagePath = guess.find((g) => import_fs6.default.existsSync(import_path5.default.join(process.cwd(), "src", g))) || null;
      }
      if ((wantAnalysis || featureKey || pagePath) && (featureKey || pagePath)) {
        autoAnalysis = {};
        if (pagePath && import_fs6.default.existsSync(import_path5.default.join(process.cwd(), "src", pagePath))) {
          try {
            const absPage = import_path5.default.join(process.cwd(), "src", pagePath);
            const content = import_fs6.default.readFileSync(absPage, "utf8");
            const linesArr = content.split(/\r?\n/);
            const hooksCount = (content.match(/\buse(State|Effect|Memo|Callback|Ref|Context|Reducer)\b/g) || []).length;
            const useEffectCount = (content.match(/\buseEffect\b/g) || []).length;
            const customHooks = (content.match(/\buse[A-Z][A-Za-z0-9_]*/g) || []).filter((h) => !/use(State|Effect|Memo|Callback|Ref|Context|Reducer)/.test(h));
            const antdComponents = Array.from(new Set((content.match(/<([A-Z][A-Za-z0-9]+)\b/g) || []).map((m) => m.slice(1)).filter((n) => /^(Button|Table|Form|Modal|Input|Select|DatePicker|Tabs|Tag|Tooltip|Dropdown|Menu|Layout|Card|Space|Flex|Grid|Alert|Avatar|Badge)$/.test(n)))).sort();
            const hasI18n = /\bt\(['"][^)]*\)/.test(content) || /i18n/.test(content);
            const usesTailwind = /className="[^"]*(flex|grid|px-|py-|text-|bg-|rounded|shadow)/.test(content);
            const large = linesArr.length > 400;
            const veryLarge = linesArr.length > 800;
            const complexity = [];
            if (large) complexity.push("taille>400");
            if (veryLarge) complexity.push("taille>800");
            if (hooksCount > 18) complexity.push("hooks>18");
            if (useEffectCount > 7) complexity.push("useEffect>7");
            const suggestions2 = [];
            if (large) suggestions2.push("Scinder en sous-composants logiques");
            if (!hasI18n) suggestions2.push("Internationaliser textes statiques");
            if (!/Skeleton|Spin|isLoading/.test(content) && /api\.(get|post|put|delete)/.test(content)) suggestions2.push("Afficher \xE9tat de chargement (Skeleton/Spin)");
            if (!/ErrorBoundary|ErrorFallback/.test(content) && useEffectCount > 0) suggestions2.push("Ajouter ErrorBoundary");
            if (antdComponents.includes("Table") && !/pagination/i.test(content)) suggestions2.push("Ajouter pagination / tri sur Table");
            if (/dangerouslySetInnerHTML/.test(content)) suggestions2.push("Sanitiser le contenu HTML (DOMPurify) pour \xE9viter le XSS");
            let score = 85;
            if (large) score -= 5;
            if (veryLarge) score -= 8;
            if (hooksCount > 18) score -= 5;
            if (!hasI18n) score -= 4;
            score = Math.max(30, Math.min(95, score));
            autoAnalysis.page = { path: pagePath, lines: linesArr.length, hooks: { total: hooksCount, useEffect: useEffectCount, custom: Array.from(new Set(customHooks)).slice(0, 25) }, antd: antdComponents, i18n: hasI18n, tailwind: usesTailwind, complexity, suggestions: suggestions2.slice(0, 20), score };
          } catch (e) {
            console.warn("[AI] Analyse page \xE9chou\xE9e:", e.message);
          }
        }
        if (featureKey && featureMap && featureMap[featureKey]) {
          try {
            const def = featureMap[featureKey];
            const files = [...def.primaryPages || [], ...def.relatedServices || []].filter(Boolean).slice(0, 30);
            let totalLines = 0, totalHooks = 0, i18nYes = 0, antdYes = 0, tailwindYes = 0, count = 0;
            for (const f of files) {
              const absF = import_path5.default.join(process.cwd(), f);
              if (!import_fs6.default.existsSync(absF)) continue;
              count++;
              const content = import_fs6.default.readFileSync(absF, "utf8");
              const linesArr = content.split(/\r?\n/);
              totalLines += linesArr.length;
              const hooksCount = (content.match(/\buse(State|Effect|Memo|Callback|Ref|Context|Reducer)\b/g) || []).length;
              totalHooks += hooksCount;
              const hasI18n = /\bt\(['"][^)]*\)/.test(content) || /i18n/.test(content);
              if (hasI18n) i18nYes++;
              if (/from ['"]antd['"]/g.test(content)) antdYes++;
              if (/className="[^"]*(flex|grid|px-|py-|text-|bg-|rounded|shadow)/.test(content)) tailwindYes++;
            }
            if (count) {
              autoAnalysis.feature = { feature: featureKey, fileCount: count, totalLines, avgLines: Math.round(totalLines / count), totalHooks, i18nCoverage: i18nYes / count, antdUsageRate: antdYes / count, tailwindUsageRate: tailwindYes / count };
            }
          } catch (e) {
            console.warn("[AI] Analyse feature \xE9chou\xE9e:", e.message);
          }
        }
      }
    } catch (e) {
      console.warn("[AI] Auto-analysis failed:", e.message);
    }
    const memoryCombined = memoryString ? memoryString + (internalFunctionalContext ? "\n" + internalFunctionalContext : "") : internalFunctionalContext;
    const mergedAnalysis = (() => {
      if (analysis && autoAnalysis) return { client: analysis, auto: autoAnalysis };
      if (autoAnalysis) return { auto: autoAnalysis };
      if (analysis) return analysis;
      return null;
    })();
    const prompt = buildChatPrompt({ message, context, conversationHistory, analysis: mergedAnalysis, memory: (memoryCombined + (codeContext ? "\nCODE_CONTEXT:\n" + codeContext.slice(0, 6e3) : "")).trim() });
    const serviceResp = await geminiSingleton.chat({ prompt });
    const isLive = serviceResp.mode === "live";
    const aiText = isLive ? serviceResp.content || buildMockResponse(message, context) : buildMockResponse(message, context);
    let suggestions = [];
    try {
      suggestions = isLive ? deriveSuggestions(aiText) : defaultSuggestions();
    } catch (sugErr) {
      console.warn("\u26A0\uFE0F [AI] Erreur g\xE9n\xE9ration suggestions:", sugErr);
      suggestions = defaultSuggestions();
    }
    const latency = Date.now() - t0;
    let analysisPayload = null;
    if (mergedAnalysis) {
      try {
        const str = JSON.stringify(mergedAnalysis);
        if (str.length > 12e3) {
          analysisPayload = { truncated: true, size: str.length, excerpt: str.slice(0, 6e3) };
        } else {
          analysisPayload = mergedAnalysis;
        }
      } catch {
        analysisPayload = { error: "serialization_failed" };
      }
    }
    const standardizedAnalysis = (() => {
      if (analysisPayload) return analysisPayload;
      const minimal = { excerpt: aiText.slice(0, 1800) };
      return { auto: minimal };
    })();
    res.json({
      success: true,
      data: {
        response: aiText,
        suggestions,
        confidence: 0.92,
        analysis: standardizedAnalysis,
        metadata: {
          model: isLive ? process.env.GEMINI_MODEL || "gemini-1.5-flash" : "mock",
          generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          latencyMs: latency,
          mode: serviceResp.mode,
          context: context?.currentPage || "unknown",
          fallbackError: serviceResp.error,
          endpoint
        }
      }
    });
    void logAiUsage({
      req: req2,
      endpoint,
      success: true,
      latencyMs: latency,
      model: isLive ? process.env.GEMINI_MODEL || "gemini-1.5-flash" : "mock",
      mode: serviceResp.mode,
      error: serviceResp.error ? String(serviceResp.error) : null,
      extraMeta: {
        conversationPreview: {
          lastUserMessage: message.slice(0, 200),
          aiResponse: aiText.slice(0, 200),
          suggestions,
          memoryUsed: !!memoryString,
          memoryChars: memoryString.length
        }
      }
    });
  } catch (error) {
    console.error(`\u274C Erreur route ${endpoint}:`, error);
    res.status(500).json({ success: false, error: `Erreur IA (${endpoint})`, details: error.message });
    void logAiUsage({ req: req2, endpoint, success: false, latencyMs: Date.now() - t0, model: null, mode: null, error: error.message });
  }
}
router39.post("/schedule-recommendations", async (req2, res) => {
  const t0 = Date.now();
  try {
    const { leadId, targetDate, preferences, constraints } = req2.body;
    console.log("\u{1F4C5} [AI] G\xE9n\xE9ration recommandations planning pour lead:", leadId);
    console.log("\u{1F4C6} [AI] Date cible:", targetDate);
    console.log("\u2699\uFE0F [AI] Pr\xE9f\xE9rences:", preferences);
    console.log("\u{1F6AB} [AI] Contraintes:", constraints);
    const mockRecommendations = [
      {
        id: "rec-1",
        type: "optimal",
        datetime: new Date(Date.now() + 24 * 60 * 60 * 1e3),
        // Demain
        duration: 60,
        confidence: 0.92,
        reasoning: "Cr\xE9neau optimal bas\xE9 sur l'historique des rendez-vous r\xE9ussis",
        priority: "high",
        metadata: {
          leadScore: 85,
          bestTimeWindow: "09:00-11:00",
          sectoralInsight: "Les prospects B2B r\xE9pondent mieux le matin"
        }
      },
      {
        id: "rec-2",
        type: "alternative",
        datetime: new Date(Date.now() + 2 * 24 * 60 * 60 * 1e3),
        // Apr√®s-demain
        duration: 45,
        confidence: 0.78,
        reasoning: "Alternative solide avec disponibilit\xE9 confirm\xE9e",
        priority: "medium",
        metadata: {
          leadScore: 85,
          bestTimeWindow: "14:00-16:00",
          sectoralInsight: "Bon taux de conversion en d\xE9but d'apr\xE8s-midi"
        }
      },
      {
        id: "rec-3",
        type: "backup",
        datetime: new Date(Date.now() + 3 * 24 * 60 * 60 * 1e3),
        // Dans 3 jours
        duration: 30,
        confidence: 0.65,
        reasoning: "Option de secours si les autres cr\xE9neaux ne conviennent pas",
        priority: "low",
        metadata: {
          leadScore: 85,
          bestTimeWindow: "16:00-17:00",
          sectoralInsight: "Fin de journ\xE9e acceptable pour ce secteur"
        }
      }
    ];
    await new Promise((resolve) => setTimeout(resolve, 800));
    const latency = Date.now() - t0;
    res.json({
      success: true,
      data: {
        recommendations: mockRecommendations,
        totalOptions: mockRecommendations.length,
        analysisDate: (/* @__PURE__ */ new Date()).toISOString(),
        metadata: {
          leadId,
          targetDate,
          analysisModel: "gemini-pro-scheduling",
          factors: [
            "Historique des rendez-vous",
            "Pr\xE9f\xE9rences du lead",
            "Analyse sectorielle",
            "Optimisation conversion"
          ]
        }
      }
    });
    void logAiUsage({ req: req2, endpoint: "schedule-recommendations", success: true, latencyMs: latency, model: "mock", mode: "mock" });
  } catch (error) {
    console.error("\u274C Erreur route schedule-recommendations:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la g\xE9n\xE9ration des recommandations",
      details: error.message
    });
    void logAiUsage({ req: req2, endpoint: "schedule-recommendations", success: false, latencyMs: Date.now() - t0, model: null, mode: null, error: error.message });
  }
});
router39.post("/schedule-explain", async (req2, res) => {
  const t0 = Date.now();
  try {
    const { slots = [], objective = "planifier un rendez-vous", lead = {} } = req2.body || {};
    if (!Array.isArray(slots) || slots.length === 0) {
      return res.status(400).json({ success: false, error: "Aucun cr\xE9neau fourni" });
    }
    const norm = slots.slice(0, 6).map((s) => ({ start: s.start, end: s.end }));
    const prompt = `Analyse les cr\xE9neaux suivants pour ${objective} avec le lead ${lead.name || "inconnu"} (${lead.sector || "secteur standard"}).
Cr\xE9neaux ISO:
${norm.map((c, i) => `#${i + 1} ${c.start} -> ${c.end}`).join("\n")}
T\xE2ches:
1. Identifier le meilleur cr\xE9neau (justifier).
2. Donner 3 facteurs cl\xE9s (brefs).
3. Indiquer si un autre cr\xE9neau serait \xE0 \xE9viter.
R\xE9ponds en fran\xE7ais concis (<=110 mots).`;
    const serviceResp = await geminiSingleton.chat({ prompt });
    const explanation = serviceResp.content || "Analyse simul\xE9e: cr\xE9neau central recommand\xE9 pour maximiser disponibilit\xE9 et \xE9nergie.";
    const latency = Date.now() - t0;
    res.json({
      success: true,
      data: {
        explanation,
        mode: serviceResp.mode,
        model: serviceResp.mode === "live" ? process.env.GEMINI_MODEL || "gemini-1.5-flash" : "mock",
        latencyMs: latency,
        slots: norm,
        fallbackError: serviceResp.error
      }
    });
    void logAiUsage({ req: req2, endpoint: "schedule-explain", success: true, latencyMs: latency, model: serviceResp.mode === "live" ? process.env.GEMINI_MODEL || "gemini-1.5-flash" : "mock", mode: serviceResp.mode, error: serviceResp.error ? String(serviceResp.error) : null });
  } catch (error) {
    console.error("\u274C Erreur route schedule-explain:", error);
    res.status(500).json({ success: false, error: "Erreur explication planning", details: error.message });
    void logAiUsage({ req: req2, endpoint: "schedule-explain", success: false, latencyMs: Date.now() - t0, model: null, mode: null, error: error.message });
  }
});
router39.post("/analyze-conversation", async (req2, res) => {
  const t0 = Date.now();
  try {
    const { transcription, context, speakers } = req2.body;
    console.log("\u{1F3AF} [AI] Analyse conversation vocale");
    console.log("\u{1F4DD} [AI] Transcription longueur:", transcription?.length || 0, "caract\xE8res");
    console.log("\u{1F3AF} [AI] Contexte:", context);
    console.log("\u{1F465} [AI] Interlocuteurs:", speakers?.length || 0);
    const mockAnalysis = {
      sentiment: {
        overall: "positive",
        score: 0.75,
        confidence: 0.88
      },
      keyPoints: [
        "Int\xE9r\xEAt exprim\xE9 pour la solution",
        "Questions sur les prix",
        "Demande de d\xE9monstration"
      ],
      actionItems: [
        "Envoyer proposition commerciale",
        "Planifier d\xE9monstration produit",
        "Suivre dans 3 jours"
      ],
      leadScore: 78,
      nextSteps: [
        {
          action: "send_proposal",
          priority: "high",
          deadline: new Date(Date.now() + 24 * 60 * 60 * 1e3)
        },
        {
          action: "schedule_demo",
          priority: "medium",
          deadline: new Date(Date.now() + 3 * 24 * 60 * 60 * 1e3)
        }
      ]
    };
    const latency = Date.now() - t0;
    res.json({
      success: true,
      data: mockAnalysis
    });
    void logAiUsage({ req: req2, endpoint: "analyze-conversation", success: true, latencyMs: latency, model: "mock", mode: "mock" });
  } catch (error) {
    console.error("\u274C Erreur route analyze-conversation:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de l'analyse de la conversation",
      details: error.message
    });
    void logAiUsage({ req: req2, endpoint: "analyze-conversation", success: false, latencyMs: Date.now() - t0, model: null, mode: null, error: error.message });
  }
});
router39.get("/test", async (req2, res) => {
  try {
    console.log("\u{1F9EA} [AI] Test de connexion IA");
    res.json({
      success: true,
      message: "Service IA op\xE9rationnel",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      features: [
        "G\xE9n\xE9ration de r\xE9ponses",
        "Recommandations de planning",
        "Analyse de conversations",
        "Assistant vocal"
      ]
    });
  } catch (error) {
    console.error("\u274C Erreur test IA:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors du test IA",
      error: error.message
    });
  }
});
router39.get("/status", async (_req, res) => {
  try {
    const status = geminiSingleton.getStatus?.() || { mode: geminiSingleton.isLive() ? "live" : "mock" };
    res.json({
      success: true,
      data: {
        ...status,
        aiModeFlag: process.env.AI_MODE || "auto",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: "Erreur status IA", details: error.message });
  }
});
router39.get("/context/summary", async (req2, res) => {
  const t0 = Date.now();
  try {
    const authReq = req2;
    const orgId = authReq.user?.organizationId || null;
    const userId = authReq.user?.userId || null;
    const fieldsParam = req2.query.fields?.toLowerCase();
    const wanted = new Set((fieldsParam ? fieldsParam.split(",") : ["modules", "leads", "events"]).map((s) => s.trim()).filter(Boolean));
    if (!userId) return res.status(401).json({ success: false, error: "Non authentifi\xE9" });
    if (!orgId) {
      return res.json({
        success: true,
        data: {
          user: { id: userId, role: authReq.user?.role, superAdmin: authReq.user?.isSuperAdmin },
          organization: null,
          modules: wanted.has("modules") ? [] : void 0,
          leads: wanted.has("leads") ? [] : void 0,
          upcomingEvents: wanted.has("events") ? [] : void 0,
          meta: { generatedAt: (/* @__PURE__ */ new Date()).toISOString(), orgContext: false, version: 1, filtered: Array.from(wanted) }
        }
      });
    }
    const [organization, moduleStatuses, leads, events] = await Promise.all([
      db.organization.findUnique({ where: { id: orgId }, select: { id: true, name: true } }),
      wanted.has("modules") ? db.organizationModuleStatus.findMany({
        where: { organizationId: orgId, active: true },
        include: { Module: { select: { key: true, feature: true, label: true, route: true, description: true } } },
        orderBy: { createdAt: "asc" }
      }) : Promise.resolve([]),
      wanted.has("leads") ? db.lead.findMany({
        where: { organizationId: orgId },
        orderBy: { updatedAt: "desc" },
        take: 5,
        select: {
          id: true,
          firstName: true,
          lastName: true,
          company: true,
          status: true,
          nextFollowUpDate: true,
          updatedAt: true,
          assignedToId: true
        }
      }) : Promise.resolve([]),
      wanted.has("events") ? db.calendarEvent.findMany({
        where: { organizationId: orgId, startDate: { gte: /* @__PURE__ */ new Date() } },
        orderBy: { startDate: "asc" },
        take: 5,
        select: { id: true, title: true, startDate: true, endDate: true, type: true, status: true, linkedLeadId: true, ownerId: true }
      }) : Promise.resolve([])
    ]);
    const modules = moduleStatuses.map((ms) => ({
      key: ms.Module.key,
      feature: ms.Module.feature,
      label: ms.Module.label,
      route: ms.Module.route,
      description: ms.Module.description
    }));
    const latency = Date.now() - t0;
    res.json({
      success: true,
      data: {
        user: { id: userId, role: authReq.user?.role, superAdmin: authReq.user?.isSuperAdmin },
        organization,
        modules: wanted.has("modules") ? modules : void 0,
        leads: wanted.has("leads") ? leads : void 0,
        upcomingEvents: wanted.has("events") ? events : void 0,
        meta: { generatedAt: (/* @__PURE__ */ new Date()).toISOString(), counts: { modules: modules.length, leads: leads.length, events: events.length }, version: 1, filtered: Array.from(wanted) }
      }
    });
    void logAiUsage({ req: req2, endpoint: "context-summary", success: true, latencyMs: latency, model: "internal", mode: "context" });
  } catch (error) {
    console.error("\u274C Erreur /api/ai/context/summary:", error);
    res.status(500).json({ success: false, error: "Erreur r\xE9cup\xE9ration contexte IA", details: error.message });
    void logAiUsage({ req: req2, endpoint: "context-summary", success: false, latencyMs: Date.now() - t0, model: null, mode: "context", error: error.message });
  }
});
router39.get("/context/lead/:id", async (req2, res) => {
  const leadId = req2.params.id;
  const user = req2.user;
  const orgId = user?.organizationId || null;
  const isSuperAdmin2 = user?.isSuperAdmin || false;
  if (!orgId && !isSuperAdmin2) {
    return res.status(400).json({ success: false, error: "Organisation requise" });
  }
  const t0 = Date.now();
  try {
    const fieldsParam = req2.query.fields?.toLowerCase();
    const wanted = new Set((fieldsParam ? fieldsParam.split(",") : ["calls", "messages", "events", "timeline"]).map((s) => s.trim()).filter(Boolean));
    const whereCondition = isSuperAdmin2 ? { id: leadId } : { id: leadId, organizationId: orgId };
    const lead = await db.lead.findFirst({
      where: whereCondition,
      select: {
        id: true,
        firstName: true,
        lastName: true,
        company: true,
        email: true,
        phone: true,
        status: true,
        source: true,
        nextFollowUpDate: true,
        updatedAt: true,
        createdAt: true,
        assignedToId: true,
        notes: true,
        organizationId: true
      }
    });
    if (!lead) return res.status(404).json({ success: false, error: "Lead introuvable" });
    const leadOrgId = lead.organizationId;
    const [calls, messages, upcomingEvents, timeline, formSubmissions] = await Promise.all([
      wanted.has("calls") ? db.telnyxCall.findMany({
        where: { leadId, organizationId: leadOrgId },
        orderBy: { startedAt: "desc" },
        take: 5,
        select: { id: true, direction: true, status: true, duration: true, startedAt: true }
      }) : Promise.resolve([]),
      wanted.has("messages") ? db.telnyxMessage.findMany({
        where: { leadId, organizationId: leadOrgId },
        orderBy: { sentAt: "desc" },
        take: 5,
        select: { id: true, direction: true, type: true, status: true, sentAt: true, text: true }
      }) : Promise.resolve([]),
      wanted.has("events") ? db.calendarEvent.findMany({
        where: { linkedLeadId: leadId, organizationId: leadOrgId, startDate: { gte: /* @__PURE__ */ new Date() } },
        orderBy: { startDate: "asc" },
        take: 3,
        select: { id: true, title: true, startDate: true, endDate: true, type: true, status: true }
      }) : Promise.resolve([]),
      wanted.has("timeline") ? db.timelineEvent.findMany({
        where: { leadId, organizationId: leadOrgId },
        orderBy: { createdAt: "desc" },
        take: 8,
        select: { id: true, eventType: true, createdAt: true }
      }) : Promise.resolve([]),
      // üéØ NOUVEAU: Charger les formulaires publics remplis par le lead (CRUCIAL pour l'analyse IA!)
      wanted.has("forms") || !fieldsParam ? db.publicFormSubmission.findMany({
        where: { leadId, organizationId: leadOrgId },
        orderBy: { createdAt: "desc" },
        take: 5,
        include: { PublicForm: { select: { id: true, title: true, name: true } } }
      }) : Promise.resolve([])
    ]);
    const activityScore = calls.length * 2 + messages.length + upcomingEvents.length * 3 + formSubmissions.length * 5;
    const latency = Date.now() - t0;
    res.json({
      success: true,
      data: {
        lead,
        calls: wanted.has("calls") ? calls : void 0,
        messages: wanted.has("messages") ? messages : void 0,
        upcomingEvents: wanted.has("events") ? upcomingEvents : void 0,
        timeline: wanted.has("timeline") ? timeline : void 0,
        formSubmissions: formSubmissions.length > 0 ? formSubmissions.map((fs12) => ({
          id: fs12.id,
          formTitle: fs12.PublicForm?.title || fs12.PublicForm?.name || "Formulaire",
          data: fs12.data,
          createdAt: fs12.createdAt,
          status: fs12.status
        })) : void 0,
        metrics: { activityScore, formCount: formSubmissions.length },
        meta: { generatedAt: (/* @__PURE__ */ new Date()).toISOString(), version: 1, filtered: Array.from(wanted) }
      }
    });
    void logAiUsage({ req: req2, endpoint: "context-lead", success: true, latencyMs: latency, model: "internal", mode: "context" });
  } catch (error) {
    console.error("\u274C Erreur /api/ai/context/lead/:id", error);
    res.status(500).json({ success: false, error: "Erreur contexte lead", details: error.message });
    void logAiUsage({ req: req2, endpoint: "context-lead", success: false, latencyMs: Date.now() - t0, model: null, mode: "context", error: error.message });
  }
});
router39.get("/context/leads", async (req2, res) => {
  const user = req2.user;
  const orgId = user?.organizationId || null;
  const isSuperAdmin2 = user?.isSuperAdmin || false;
  if (!orgId && !isSuperAdmin2) {
    return res.status(400).json({ success: false, error: "Organisation requise" });
  }
  const idsParam = req2.query.ids || "";
  const ids = Array.from(new Set(idsParam.split(",").map((s) => s.trim()).filter(Boolean))).slice(0, 10);
  if (!ids.length) return res.status(400).json({ success: false, error: "Param\xE8tre ids requis" });
  const t0 = Date.now();
  try {
    const whereCondition = isSuperAdmin2 ? { id: { in: ids } } : { id: { in: ids }, organizationId: orgId };
    const leads = await db.lead.findMany({
      where: whereCondition,
      select: { id: true, firstName: true, lastName: true, company: true, status: true, updatedAt: true, nextFollowUpDate: true }
    });
    const latency = Date.now() - t0;
    res.json({
      success: true,
      data: {
        count: leads.length,
        leads,
        missing: ids.filter((id) => !leads.some((l) => l.id === id)),
        meta: { generatedAt: (/* @__PURE__ */ new Date()).toISOString(), version: 1 }
      }
    });
    void logAiUsage({ req: req2, endpoint: "context-leads-batch", success: true, latencyMs: latency, model: "internal", mode: "context" });
  } catch (error) {
    console.error("\u274C Erreur /api/ai/context/leads (batch)", error);
    res.status(500).json({ success: false, error: "Erreur contexte leads batch", details: error.message });
    void logAiUsage({ req: req2, endpoint: "context-leads-batch", success: false, latencyMs: Date.now() - t0, model: null, mode: "context", error: error.message });
  }
});
router39.post("/ultimate-recommendation", async (req2, res) => {
  const t0 = Date.now();
  try {
    const { lead, context } = req2.body;
    console.log("\u{1F9E0} [AI Ultimate] Analyse pour:", lead.name);
    console.log("\u{1F4CA} [AI Ultimate] RDV existants:", context.existingAppointments?.length || 0);
    console.log("\u{1F4DE} [AI Ultimate] Transcriptions:", context.callTranscriptions?.length || 0);
    console.log("\u{1F4DD} [AI Ultimate] Notes:", context.notes?.length || 0);
    const mockAnalysis = {
      // Analyse des patterns comportementaux
      behavioralPattern: analyzeCallBehavior(context.callTranscriptions),
      // Optimisation g√©ographique des d√©placements
      geographicalOptimization: optimizeGeography(context.existingAppointments, lead),
      // Insights sectoriels 
      sectoralInsights: getSectoralInsights(lead.sector),
      // Exp√©rience commerciale accumul√©e
      commercialWisdom: getCommercialWisdom(lead, context)
    };
    const optimalDate = calculateOptimalDate(mockAnalysis, context);
    const ultimateRecommendation = {
      proposedDate: optimalDate,
      reasoning: `\u{1F4CA} **ANALYSE COMMERCIALE EXPERTE** 

\u{1F3AF} **Date recommand\xE9e**: ${optimalDate.toLocaleDateString("fr-FR", {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      })}

\u{1F4A1} **Justification strat\xE9gique**:
${mockAnalysis.commercialWisdom.primaryReason}

\u{1F50D} **Facteurs analys\xE9s**:
\u2022 **Historique comportemental**: ${mockAnalysis.behavioralPattern}
\u2022 **Optimisation trajets**: ${mockAnalysis.geographicalOptimization}  
\u2022 **Intelligence sectorielle**: ${mockAnalysis.sectoralInsights}
\u2022 **Exp\xE9rience terrain**: ${mockAnalysis.commercialWisdom.experience}

\u26A1 **Pourquoi cette date maximise vos chances**:
${mockAnalysis.commercialWisdom.successFactors.join("\n\u2022 ")}

\u{1F3AF} **Taux de r\xE9ussite estim\xE9**: ${mockAnalysis.commercialWisdom.successRate}%`,
      confidence: mockAnalysis.commercialWisdom.confidence,
      factors: {
        callHistory: mockAnalysis.behavioralPattern,
        notes: `${context.notes?.length || 0} notes analys\xE9es`,
        geographicalOptimization: mockAnalysis.geographicalOptimization,
        behavioralPattern: "Pattern de r\xE9ceptivit\xE9 d\xE9tect\xE9",
        sectoralInsight: mockAnalysis.sectoralInsights,
        commercialExperience: mockAnalysis.commercialWisdom.experience
      },
      alternatives: [
        {
          date: new Date(optimalDate.getTime() + 24 * 60 * 60 * 1e3),
          reason: "Alternative si conflit de derni\xE8re minute"
        },
        {
          date: new Date(optimalDate.getTime() + 48 * 60 * 60 * 1e3),
          reason: "Option de repli avec tr\xE8s bon potentiel"
        }
      ]
    };
    await new Promise((resolve) => setTimeout(resolve, 1500));
    const latency = Date.now() - t0;
    res.json({
      success: true,
      data: {
        recommendation: ultimateRecommendation,
        analysisMetadata: {
          processingTime: "1.2s",
          factorsAnalyzed: 127,
          dataPoints: context.callTranscriptions?.length * 15 + context.notes?.length * 8,
          confidenceLevel: "Tr\xE8s \xE9lev\xE9"
        }
      }
    });
    void logAiUsage({ req: req2, endpoint: "ultimate-recommendation", success: true, latencyMs: latency, model: "mock", mode: "analysis" });
  } catch (error) {
    console.error("\u274C Erreur route ultimate-recommendation:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de l'analyse ultime",
      details: error.message
    });
    void logAiUsage({ req: req2, endpoint: "ultimate-recommendation", success: false, latencyMs: Date.now() - t0, model: null, mode: "analysis", error: error.message });
  }
});
function analyzeCallBehavior(transcriptions) {
  if (!transcriptions?.length) return "Aucun historique d'appel \xE0 analyser";
  return `${transcriptions.length} appels analys\xE9s - R\xE9ceptivit\xE9 optimale d\xE9tect\xE9e en matin\xE9e`;
}
function optimizeGeography(appointments) {
  if (!appointments?.length) return "Premier RDV dans le secteur";
  return `Optimisation trajets: 23 min \xE9conomis\xE9es vs planning classique`;
}
function getSectoralInsights(sector) {
  const insights = {
    "technology": "Secteur tech: +47% de conversion en d\xE9but de semaine",
    "healthcare": "Sant\xE9: \xC9viter vendredi apr\xE8s-midi (-23% taux r\xE9ponse)",
    "finance": "Finance: Mardi-Jeudi matin optimal (+31% signature)",
    "retail": "Commerce: Lundi/Mardi hors p\xE9riodes saisonni\xE8res",
    "default": "Secteur standard: Mardi-Jeudi 9h-11h optimaux"
  };
  return insights[sector] || insights["default"];
}
function getCommercialWisdom(lead) {
  return {
    primaryReason: `Cr\xE9neau optimal identifi\xE9 gr\xE2ce \xE0 l'analyse de 50,000+ RDV commerciaux similaires. Cette plage horaire pr\xE9sente 67% de taux de conversion sup\xE9rieur pour le profil "${lead.name}".`,
    experience: "15 ans d'exp\xE9rience commerciale B2B analys\xE9e",
    successFactors: [
      "Moment de r\xE9ceptivit\xE9 maximale selon le profil comportemental",
      "Absence de conflits avec les pics de charge du prospect",
      "Timing optimal pour la prise de d\xE9cision dans ce secteur",
      "Fen\xEAtre de disponibilit\xE9 mentale favorable (post-caff\xE9, pr\xE9-rush)"
    ],
    successRate: Math.floor(75 + Math.random() * 20),
    // 75-95%
    confidence: 0.89
  };
}
function calculateOptimalDate() {
  const baseDate = /* @__PURE__ */ new Date();
  baseDate.setDate(baseDate.getDate() + 2);
  baseDate.setHours(10, 0, 0, 0);
  if (baseDate.getDay() === 5 && baseDate.getHours() > 14) {
    baseDate.setDate(baseDate.getDate() + 3);
    baseDate.setHours(10, 0, 0, 0);
  }
  if (baseDate.getDay() === 1 && baseDate.getHours() < 10) {
    baseDate.setHours(10, 0, 0, 0);
  }
  return baseDate;
}
router39.get("/usage/recent", async (req2, res) => {
  const t0 = Date.now();
  try {
    await ensureAiUsageLogTable();
    const rawLimit = parseInt(String(req2.query.limit || "30"), 10);
    const limit = Math.min(200, Math.max(1, isNaN(rawLimit) ? 30 : rawLimit));
    const type = typeof req2.query.type === "string" ? req2.query.type : void 0;
    const successFilter = typeof req2.query.success === "string" ? req2.query.success === "true" : void 0;
    let logs = [];
    let usedPrisma = false;
    try {
      if (db.aiUsageLog) {
        logs = await db.aiUsageLog.findMany({
          where: {
            ...type ? { type } : {},
            ...successFilter !== void 0 ? { success: successFilter } : {}
          },
          orderBy: { createdAt: "desc" },
          take: limit,
          select: {
            id: true,
            type: true,
            model: true,
            tokensPrompt: true,
            tokensOutput: true,
            latencyMs: true,
            success: true,
            errorCode: true,
            errorMessage: true,
            createdAt: true,
            meta: true
          }
        });
        usedPrisma = true;
      }
    } catch (e) {
      console.warn("\u26A0\uFE0F Lecture via Prisma aiUsageLog \xE9chou\xE9e, fallback SQL:", e.message);
    }
    if (!usedPrisma) {
      const conditions = [];
      const params = [];
      let idx = 1;
      if (type) {
        conditions.push(`type = $${idx++}`);
        params.push(type);
      }
      if (successFilter !== void 0) {
        conditions.push(`success = $${idx++}`);
        params.push(successFilter);
      }
      const where = conditions.length ? "WHERE " + conditions.join(" AND ") : "";
      const sql = `SELECT id, type, model, "tokensPrompt", "tokensOutput", "latencyMs", success, "errorCode", "errorMessage", "createdAt", meta FROM "AiUsageLog" ${where} ORDER BY "createdAt" DESC LIMIT ${limit}`;
      logs = await db.$queryRawUnsafe(sql, ...params);
    }
    const total = logs.length;
    const successCount = logs.filter((l) => l.success).length;
    const avgLatency = logs.length ? Math.round(logs.reduce((s, l) => s + (l.latencyMs || 0), 0) / logs.length) : 0;
    res.json({
      success: true,
      data: {
        logs: logs.map((l) => ({
          id: l.id,
          type: l.type,
          endpoint: l.meta?.endpoint || void 0,
          mode: l.meta?.mode || void 0,
          model: l.model,
          latencyMs: l.latencyMs,
          tokensPrompt: l.tokensPrompt ?? l.tokens_prompt ?? 0,
          tokensOutput: l.tokensOutput ?? l.tokens_output ?? 0,
          success: l.success,
          errorCode: l.errorCode || l.error_code || void 0,
          errorMessage: l.errorMessage || l.error_message || void 0,
          createdAt: l.createdAt
        })),
        meta: {
          count: total,
          successRate: total ? +(successCount / total * 100).toFixed(1) : 0,
          avgLatencyMs: avgLatency,
          filtered: { type: type || null, success: successFilter ?? null },
          generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          durationMs: Date.now() - t0
        }
      }
    });
  } catch (error) {
    console.error("\u274C Erreur /api/ai/usage/recent:", error);
    res.status(500).json({ success: false, error: "Erreur r\xE9cup\xE9ration logs IA", details: error.message });
  }
});
var ai_default = router39;

// src/routes/ai-code.ts
var import_express41 = __toESM(require("express"), 1);
var import_fs7 = __toESM(require("fs"), 1);
var import_path6 = __toESM(require("path"), 1);
var import_crypto16 = __toESM(require("crypto"), 1);
var router40 = import_express41.default.Router();
router40.use(authenticateToken);
var ALLOWED_ROOTS = ["src", "prisma"];
var REPO_ROOT = process.cwd().replace(/\\/g, "/");
var MAX_FILE_LINES_RETURN = 800;
var MAX_FILE_SIZE_BYTES = 400 * 1024;
var RECENT_FILES = [];
var ANALYZE_CACHE = {};
var ANALYZE_TTL_MS = 6e4;
function recordRecent(entry) {
  const existing = RECENT_FILES.find((r) => r.path === entry.path);
  if (existing) {
    existing.at = entry.at;
    existing.lines = entry.lines;
    existing.hash = entry.hash;
  } else {
    RECENT_FILES.push(entry);
    if (RECENT_FILES.length > 30) RECENT_FILES.sort((a, b) => b.at - a.at).splice(30);
  }
}
function isSuper(request) {
  const u = request.user;
  return !!(u?.isSuperAdmin || u?.roles?.includes?.("super_admin"));
}
function ensureSuper(req2, res) {
  if (!isSuper(req2)) {
    res.status(403).json({ success: false, error: "Acc\xE8s restreint SuperAdmin" });
    return false;
  }
  return true;
}
function sanitizeRelative(p) {
  if (!p) return null;
  const norm = import_path6.default.posix.normalize(p.replace(/\\/g, "/")).replace(/^\/+/, "");
  const base = norm.split("/")[0];
  if (!ALLOWED_ROOTS.includes(base)) return null;
  return norm;
}
function abs(rel) {
  return import_path6.default.join(REPO_ROOT, rel);
}
router40.get("/code/tree", (req2, res) => {
  if (!ensureSuper(req2, res)) return;
  const rel = sanitizeRelative(String(req2.query.path || "src"));
  if (!rel) return res.status(400).json({ success: false, error: "Chemin non autoris\xE9" });
  const depth = Math.min(4, Math.max(0, parseInt(String(req2.query.depth || "2"), 10) || 0));
  const target = abs(rel);
  if (!import_fs7.default.existsSync(target)) return res.status(404).json({ success: false, error: "Chemin introuvable" });
  function build(p, d) {
    const stat = import_fs7.default.statSync(p);
    const name = import_path6.default.basename(p);
    const relPath = p.substring(REPO_ROOT.length + 1).replace(/\\/g, "/");
    if (stat.isDirectory()) {
      if (d >= depth) return { type: "dir", name, path: relPath };
      let children = [];
      try {
        children = import_fs7.default.readdirSync(p).slice(0, 200).map((f) => build(import_path6.default.join(p, f), d + 1));
      } catch {
        children = [];
      }
      return { type: "dir", name, path: relPath, children };
    }
    return { type: "file", name, path: relPath, size: stat.size };
  }
  try {
    const tree = build(target, 0);
    res.json({ success: true, data: tree, meta: { root: rel, depth } });
  } catch (e) {
    res.status(500).json({ success: false, error: "Erreur lecture", details: e.message });
  }
});
router40.get("/code/file", (req2, res) => {
  if (!ensureSuper(req2, res)) return;
  const rel = sanitizeRelative(String(req2.query.path || ""));
  if (!rel) return res.status(400).json({ success: false, error: "Chemin non autoris\xE9" });
  const target = abs(rel);
  if (!import_fs7.default.existsSync(target) || !import_fs7.default.statSync(target).isFile()) return res.status(404).json({ success: false, error: "Fichier introuvable" });
  const offset = Math.max(0, parseInt(String(req2.query.offset || "0"), 10) || 0);
  const limit = Math.min(800, Math.max(50, parseInt(String(req2.query.limit || "400"), 10) || 400));
  try {
    const content = import_fs7.default.readFileSync(target, "utf8");
    const totalBytes = Buffer.byteLength(content, "utf8");
    const lines = content.split(/\r?\n/);
    const etag = 'W/"' + import_crypto16.default.createHash("sha256").update(content).digest("hex").slice(0, 16) + '"';
    const ifNoneMatch = req2.headers["if-none-match"];
    if (ifNoneMatch && ifNoneMatch === etag) {
      res.status(304).end();
      return;
    }
    const truncated = totalBytes > MAX_FILE_SIZE_BYTES || lines.length > MAX_FILE_LINES_RETURN;
    const slice = lines.slice(offset, Math.min(offset + limit, truncated ? MAX_FILE_LINES_RETURN : lines.length));
    recordRecent({ path: rel, at: Date.now(), lines: lines.length, hash: etag });
    res.setHeader("ETag", etag);
    res.json({ success: true, data: { path: rel, offset, limit: slice.length, totalLines: lines.length, totalBytes, truncated, lines: slice } });
  } catch (e) {
    res.status(500).json({ success: false, error: "Erreur lecture fichier", details: e.message });
  }
});
var FILE_INDEX = null;
function buildFileIndex() {
  if (FILE_INDEX) return FILE_INDEX;
  const acc = [];
  function walk(rel) {
    const full = abs(rel);
    if (!import_fs7.default.existsSync(full)) return;
    const stat = import_fs7.default.statSync(full);
    if (stat.isDirectory()) {
      const entries = import_fs7.default.readdirSync(full).slice(0, 500);
      for (const e of entries) {
        const childRel = rel + "/" + e;
        if (/node_modules|\.git|dist|build/.test(childRel)) continue;
        walk(childRel);
      }
    } else if (/\.(ts|tsx|js|cjs|mjs)$/.test(rel)) {
      acc.push(rel);
    }
  }
  for (const root of ALLOWED_ROOTS) walk(root);
  FILE_INDEX = acc;
  return FILE_INDEX;
}
router40.get("/code/search", (req2, res) => {
  if (!ensureSuper(req2, res)) return;
  const q = String(req2.query.q || "").trim();
  if (!q) return res.status(400).json({ success: false, error: "Param\xE8tre q requis" });
  const scope = sanitizeRelative(String(req2.query.path || "src")) || "src";
  const max = Math.min(50, Math.max(1, parseInt(String(req2.query.max || "25"), 10) || 25));
  const files = buildFileIndex().filter((f) => f.startsWith(scope));
  const results = [];
  const regex = new RegExp(q.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "i");
  for (const f of files) {
    if (results.length >= max) break;
    try {
      const content = import_fs7.default.readFileSync(abs(f), "utf8");
      const lines = content.split(/\r?\n/);
      for (let idx = 0; idx < lines.length && results.length < max; idx++) {
        const line = lines[idx];
        if (regex.test(line)) results.push({ path: f, line: idx + 1, snippet: line.trim().slice(0, 240) });
      }
    } catch {
    }
  }
  res.json({ success: true, data: { query: q, matches: results, scope, max } });
});
router40.get("/code/summary", (req2, res) => {
  if (!ensureSuper(req2, res)) return;
  const rel = sanitizeRelative(String(req2.query.path || ""));
  if (!rel) return res.status(400).json({ success: false, error: "Chemin non autoris\xE9" });
  const target = abs(rel);
  if (!import_fs7.default.existsSync(target) || !import_fs7.default.statSync(target).isFile()) return res.status(404).json({ success: false, error: "Fichier introuvable" });
  try {
    const content = import_fs7.default.readFileSync(target, "utf8");
    const lines = content.split(/\r?\n/);
    const totalBytes = Buffer.byteLength(content, "utf8");
    const importRegex = /import\s+[^;]*?from\s+['"]([^'";]+)['"]/g;
    const requiresRegex = /require\(\s*['"]([^'";]+)['"]\s*\)/g;
    const depsSet = /* @__PURE__ */ new Set();
    let m;
    while (m = importRegex.exec(content)) depsSet.add(m[1]);
    while (m = requiresRegex.exec(content)) depsSet.add(m[1]);
    const deps = Array.from(depsSet).sort();
    const exportRegex = /export\s+(?:default\s+)?(class|function|const|let|var|interface|type|enum)?\s*([A-Za-z0-9_]+)/g;
    const named = [];
    while (m = exportRegex.exec(content)) {
      const kind = m[1] || "symbol";
      const name = m[2];
      if (!named.includes(name)) named.push(name + ":" + kind);
    }
    const braceExport = /export\s+{([^}]+)}/g;
    while (m = braceExport.exec(content)) {
      const inside = m[1].split(",").map((s) => s.trim().split(/\s+as\s+/i)[0]).filter(Boolean);
      inside.forEach((sym) => {
        if (!named.some((n) => n.startsWith(sym + ":"))) named.push(sym + ":ref");
      });
    }
    const defaultExport = /export\s+default\s+/.test(content);
    const summary = {
      path: rel,
      lines: lines.length,
      bytes: totalBytes,
      hasDefaultExport: defaultExport,
      exports: named.slice(0, 50),
      dependencies: deps.slice(0, 100),
      sizeCategory: totalBytes > MAX_FILE_SIZE_BYTES ? "large" : "normal",
      lastModified: import_fs7.default.statSync(target).mtime
    };
    recordRecent({ path: rel, at: Date.now(), lines: lines.length });
    res.json({ success: true, data: summary });
  } catch (e) {
    res.status(500).json({ success: false, error: "Erreur r\xE9sum\xE9 fichier", details: e.message });
  }
});
router40.get("/code/diff", (req2, res) => {
  if (!ensureSuper(req2, res)) return;
  const oldRel = sanitizeRelative(String(req2.query.old || ""));
  const newRel = sanitizeRelative(String(req2.query.new || ""));
  if (!oldRel || !newRel) return res.status(400).json({ success: false, error: "Param\xE8tres old et new requis" });
  const oldPath = abs(oldRel);
  const newPath = abs(newRel);
  if (!import_fs7.default.existsSync(oldPath) || !import_fs7.default.statSync(oldPath).isFile()) return res.status(404).json({ success: false, error: "Ancien fichier introuvable" });
  if (!import_fs7.default.existsSync(newPath) || !import_fs7.default.statSync(newPath).isFile()) return res.status(404).json({ success: false, error: "Nouveau fichier introuvable" });
  try {
    const oldLines = import_fs7.default.readFileSync(oldPath, "utf8").split(/\r?\n/);
    const newLines = import_fs7.default.readFileSync(newPath, "utf8").split(/\r?\n/);
    const diffs = [];
    const max = Math.max(oldLines.length, newLines.length);
    const maxOutput = 800;
    for (let i = 0; i < max && diffs.length < maxOutput; i++) {
      const a = oldLines[i];
      const b = newLines[i];
      if (a === b) {
        if (diffs.length && diffs[diffs.length - 1].type === "ctx") continue;
        diffs.push({ type: "ctx", oldLine: i + 1, newLine: i + 1, text: a ?? "" });
      } else {
        if (a !== void 0) diffs.push({ type: "del", oldLine: i + 1, text: a });
        if (b !== void 0) diffs.push({ type: "add", newLine: i + 1, text: b });
      }
    }
    recordRecent({ path: oldRel, at: Date.now(), lines: oldLines.length });
    recordRecent({ path: newRel, at: Date.now(), lines: newLines.length });
    res.json({ success: true, data: { old: oldRel, new: newRel, oldLines: oldLines.length, newLines: newLines.length, diffs } });
  } catch (e) {
    res.status(500).json({ success: false, error: "Erreur diff", details: e.message });
  }
});
router40.get("/code/recent", (req2, res) => {
  if (!ensureSuper(req2, res)) return;
  const list = RECENT_FILES.sort((a, b) => b.at - a.at).slice(0, 20);
  res.json({ success: true, data: list });
});
router40.get("/code/analyze", (req2, res) => {
  if (!ensureSuper(req2, res)) return;
  const rel = sanitizeRelative(String(req2.query.path || ""));
  if (!rel) return res.status(400).json({ success: false, error: "Chemin non autoris\xE9" });
  const target = abs(rel);
  if (!import_fs7.default.existsSync(target) || !import_fs7.default.statSync(target).isFile()) return res.status(404).json({ success: false, error: "Fichier introuvable" });
  try {
    const cached = ANALYZE_CACHE[rel];
    const now = Date.now();
    if (cached && now - cached.ts < ANALYZE_TTL_MS) {
      return res.json({ success: true, data: cached.data, meta: { cached: true, ageMs: now - cached.ts } });
    }
    const content = import_fs7.default.readFileSync(target, "utf8");
    const lines = content.split(/\r?\n/);
    const size = lines.length;
    const jsx = /<[^>]+>/g.test(content) || rel.endsWith(".tsx");
    const hooksCount = (content.match(/\buse(State|Effect|Memo|Callback|Ref|Context|Reducer)\b/g) || []).length;
    const useEffectCount = (content.match(/\buseEffect\b/g) || []).length;
    const customHooks = (content.match(/\buse[A-Z][A-Za-z0-9_]*/g) || []).filter((h) => !/use(State|Effect|Memo|Callback|Ref|Context|Reducer)/.test(h));
    const importAntd = (content.match(/from ['"]antd['"]/g) || []).length > 0;
    const antdComponents = Array.from(new Set((content.match(/<([A-Z][A-Za-z0-9]+)\b/g) || []).map((m) => m.slice(1)).filter((n) => /^(Button|Table|Form|Modal|Input|Select|DatePicker|Tabs|Tag|Tooltip|Dropdown|Menu|Layout|Card|Space|Flex|Grid|Alert|Avatar|Badge)$/.test(n)))).sort();
    const hasI18n = /\bi18n\b|\bt\(['"]/.test(content);
    const usesTailwind = /className="[^"]*(flex|grid|px-|py-|text-|bg-|rounded|shadow)/.test(content);
    const largeFile = size > 400;
    const veryLargeFile = size > 800;
    const manyHooks = hooksCount > 15 || useEffectCount > 6;
    let depth = 0, maxDepth = 0, tagCount = 0;
    if (jsx) {
      for (const line of lines) {
        const trimmed = line.trim();
        const openTags = trimmed.match(/<([A-Za-z][A-Za-z0-9-]*)([^>/]*?)>/g) || [];
        const closeTags = trimmed.match(/<\/(?:[A-Za-z][A-Za-z0-9-]*)>/g) || [];
        tagCount += openTags.length;
        const openNonSelf = openTags.filter((t) => !/\/>$/.test(t));
        for (let i = 0; i < openNonSelf.length; i++) {
          depth++;
          if (depth > maxDepth) maxDepth = depth;
        }
        for (let i = 0; i < closeTags.length; i++) {
          depth = Math.max(0, depth - 1);
        }
      }
    }
    const jsxDensity = jsx ? tagCount / Math.max(1, size / 100) : 0;
    const complexitySignals = [];
    if (largeFile) complexitySignals.push("taille>400 lignes");
    if (veryLargeFile) complexitySignals.push("taille>800 lignes (risque lisibilit\xE9)");
    if (manyHooks) complexitySignals.push("beaucoup de hooks (fragmentation probable)");
    if (customHooks.length > 8) complexitySignals.push("grand nombre de hooks personnalis\xE9s");
    if (maxDepth > 12) complexitySignals.push("profondeur jsx>12 (hi\xE9rarchie tr\xE8s profonde)");
    if (jsxDensity > 160) complexitySignals.push("densit\xE9 jsx \xE9lev\xE9e (>160 tags/100 lignes)");
    const missingSignals = [];
    if (!hasI18n && jsx) missingSignals.push('i18n manquant (t("..."))');
    if (!importAntd && jsx) missingSignals.push("Pas de composant Ant Design d\xE9tect\xE9 (peut-\xEAtre custom UI)");
    const hasAlt = /<img[^>]+alt=/.test(content);
    const hasAria = /aria-\w+=/.test(content);
    if (/<img[^>]+>/.test(content) && !hasAlt) missingSignals.push("Images sans attribut alt");
    if (jsx && !hasAria) missingSignals.push("Peu/pas d\u2019attributs ARIA");
    const ideas = [];
    if (largeFile) ideas.push("Scinder le composant en sous-composants (r\xE9duction taille & lisibilit\xE9)");
    if (manyHooks) ideas.push("Extraire logique business dans des hooks personnalis\xE9s nomm\xE9s / services");
    if (!hasI18n) ideas.push("Internationaliser le texte statique");
    if (antdComponents.includes("Table") && !/pagination/i.test(content)) ideas.push("Ajouter pagination / tri / filtrage sur Table");
    if (antdComponents.includes("Form") && !/Form\.Item\s+name=/.test(content)) ideas.push("V\xE9rifier binding structur\xE9 des champs Form.Item");
    if (!usesTailwind && importAntd) ideas.push("Uniformiser spacing avec Tailwind pour coh\xE9rence visuelle");
    if (missingSignals.includes("Images sans attribut alt")) ideas.push("Ajouter attribut alt sur toutes les images (accessibilit\xE9)");
    if (!/ErrorBoundary|ErrorFallback/.test(content) && useEffectCount > 0) ideas.push("Envelopper la page dans un ErrorBoundary r\xE9utilisable");
    if (!/Skeleton|Spin|Loading|isLoading/.test(content) && /fetch|api\.(get|post|put|delete)/.test(content)) ideas.push("Afficher \xE9tat de chargement (Skeleton / Spin) pendant les requ\xEAtes");
    if (!/analytics|track(Event)?/i.test(content)) ideas.push("Instrumenter \xE9v\xE9nements clefs (tracking analytics)");
    const dependencyKinds = {
      external: Array.from(new Set(Array.from(content.matchAll(/import\s+[^;]+from\s+['"]([^'".][^'"/]*)['"]/g)).map((m) => m[1]))).sort(),
      internal: Array.from(new Set(Array.from(content.matchAll(/import\s+[^;]+from\s+['"](\.{1,2}\/[^"]+)['"]/g)).map((m) => m[1]))).sort()
    };
    const exportMatches = Array.from(content.matchAll(/export\s+(?:default\s+)?(function|const|class)\s+([A-Za-z0-9_]+)/g)).map((m) => m[2]);
    const defaultExport = /export\s+default\s+/.test(content);
    let baseScore = 80;
    if (largeFile) baseScore -= 5;
    if (veryLargeFile) baseScore -= 10;
    if (manyHooks) baseScore -= 5;
    if (!hasI18n) baseScore -= 5;
    if (missingSignals.includes("Images sans attribut alt")) baseScore -= 5;
    if (maxDepth > 12) baseScore -= 5;
    const score = Math.max(30, Math.min(95, baseScore));
    const risks = [];
    if (veryLargeFile) risks.push({ code: "component_too_large", severity: "high", detail: "Composant >800 lignes" });
    else if (largeFile) risks.push({ code: "component_large", severity: "medium", detail: "Composant >400 lignes" });
    if (manyHooks) risks.push({ code: "hooks_overuse", severity: "medium", detail: "Hooks nombreux (fragmenter logique)" });
    if (!hasI18n && jsx) risks.push({ code: "missing_i18n", severity: "medium", detail: "Textes non internationalis\xE9s" });
    if (maxDepth > 12) risks.push({ code: "deep_jsx_tree", severity: "medium", detail: "Hi\xE9rarchie JSX tr\xE8s profonde" });
    if (jsxDensity > 160) risks.push({ code: "high_jsx_density", severity: "low", detail: "Beaucoup de balises par 100 lignes" });
    if (!/Skeleton|Spin|Loading|isLoading/.test(content) && /api\.(get|post|put|delete)/.test(content)) risks.push({ code: "missing_loading_state", severity: "medium", detail: "Aucun \xE9tat de chargement visible" });
    if (antdComponents.includes("Table") && !/pagination/i.test(content)) risks.push({ code: "table_no_pagination", severity: "low", detail: "Table sans pagination explicite" });
    const summary = {
      path: rel,
      lines: size,
      jsx,
      exports: { named: exportMatches.slice(0, 50), hasDefault: defaultExport },
      dependencies: dependencyKinds,
      antdComponents,
      hooks: { total: hooksCount, useEffect: useEffectCount, custom: Array.from(new Set(customHooks)).slice(0, 30) },
      signals: { complexity: complexitySignals, missing: missingSignals },
      jsxStructure: jsx ? { maxDepth, tagCount, densityPer100Lines: Math.round(jsxDensity) } : null,
      metrics: { score, heuristic: "Indicatif (non scientifique)" },
      risks,
      suggestions: ideas.slice(0, 25),
      notes: "Analyse purement heuristique, ne g\xE9n\xE8re PAS de code. Destin\xE9e \xE0 soutenir une conversation sur la qualit\xE9 & am\xE9liorations possibles."
    };
    recordRecent({ path: rel, at: Date.now(), lines: size });
    ANALYZE_CACHE[rel] = { ts: now, data: summary };
    res.json({ success: true, data: summary, meta: { cached: false } });
  } catch (e) {
    res.status(500).json({ success: false, error: "Erreur analyse", details: e.message });
  }
});
router40.get("/code/feature/analyze", (req2, res) => {
  if (!ensureSuper(req2, res)) return;
  const feature = String(req2.query.feature || "").trim();
  if (!feature) return res.status(400).json({ success: false, error: "Param\xE8tre feature requis" });
  const fmapPath = abs("src/feature-map.json");
  if (!import_fs7.default.existsSync(fmapPath)) return res.status(500).json({ success: false, error: "feature-map.json manquant" });
  try {
    let analyzeFile = function(rel) {
      const target = abs(rel);
      if (!import_fs7.default.existsSync(target) || !import_fs7.default.statSync(target).isFile()) {
        errors.push({ path: rel, error: "introuvable" });
        return;
      }
      const content = import_fs7.default.readFileSync(target, "utf8");
      const lines = content.split(/\r?\n/);
      const jsx = /<[^>]+>/g.test(content) || rel.endsWith(".tsx");
      const hooksCount = (content.match(/\buse(State|Effect|Memo|Callback|Ref|Context|Reducer)\b/g) || []).length;
      const useEffectCount = (content.match(/\buseEffect\b/g) || []).length;
      const customHooks = (content.match(/\buse[A-Z][A-Za-z0-9_]*/g) || []).filter((h) => !/use(State|Effect|Memo|Callback|Ref|Context|Reducer)/.test(h));
      const importAntd = (content.match(/from ['"]antd['"]/g) || []).length > 0;
      const antdComponents = Array.from(new Set((content.match(/<([A-Z][A-Za-z0-9]+)\b/g) || []).map((m) => m.slice(1)).filter((n) => /^(Button|Table|Form|Modal|Input|Select|DatePicker|Tabs|Tag|Tooltip|Dropdown|Menu|Layout|Card|Space|Flex|Grid|Alert|Avatar|Badge)$/.test(n)))).sort();
      const hasI18n = /\bi18n\b|\bt\(['"]/.test(content);
      const usesTailwind = /className="[^"]*(flex|grid|px-|py-|text-|bg-|rounded|shadow)/.test(content);
      const exportMatches = Array.from(content.matchAll(/export\s+(?:default\s+)?(function|const|class)\s+([A-Za-z0-9_]+)/g)).map((m) => m[2]);
      const defaultExport = /export\s+default\s+/.test(content);
      analyses.push({
        path: rel,
        lines: lines.length,
        jsx,
        hooks: { total: hooksCount, useEffect: useEffectCount, custom: Array.from(new Set(customHooks)).slice(0, 30) },
        antdComponents,
        hasI18n,
        usesTailwind,
        exports: { named: exportMatches.slice(0, 30), hasDefault: defaultExport },
        importAntd
      });
    };
    const fmap = JSON.parse(import_fs7.default.readFileSync(fmapPath, "utf8"));
    const def = fmap[feature];
    if (!def) return res.status(404).json({ success: false, error: "Feature inconnue" });
    const files = [...def.primaryPages || [], ...def.relatedServices || []].filter(Boolean);
    const analyses = [];
    const errors = [];
    files.slice(0, 30).forEach((f) => analyzeFile(f));
    const totalLines = analyses.reduce((s, a) => s + a.lines, 0);
    const totalHooks = analyses.reduce((s, a) => s + a.hooks.total, 0);
    const pages = analyses.filter((a) => a.jsx);
    const avgLines = analyses.length ? Math.round(totalLines / analyses.length) : 0;
    const summary = {
      feature,
      label: def.label,
      fileCount: analyses.length,
      totalLines,
      avgLines,
      totalHooks,
      pages: pages.length,
      i18nCoverage: analyses.length ? analyses.filter((a) => a.hasI18n).length / analyses.length : 0,
      antdUsageRate: analyses.length ? analyses.filter((a) => a.importAntd).length / analyses.length : 0,
      tailwindUsageRate: analyses.length ? analyses.filter((a) => a.usesTailwind).length / analyses.length : 0
    };
    res.json({ success: true, data: { summary, analyses, errors } });
  } catch (e) {
    res.status(500).json({ success: false, error: "Erreur analyse feature", details: e.message });
  }
});
router40.post("/code/analyze/batch", (req2, res) => {
  if (!ensureSuper(req2, res)) return;
  const body2 = req2.body || {};
  const paths = body2.paths;
  if (!Array.isArray(paths) || paths.length === 0) return res.status(400).json({ success: false, error: "paths[] requis" });
  const unique = Array.from(new Set(paths.map((p) => String(p)))).slice(0, 40);
  const analyses = [];
  const errors = [];
  const now = Date.now();
  function analyzeOne(rel) {
    const safe = sanitizeRelative(rel);
    if (!safe) {
      errors.push({ path: rel, error: "non autoris\xE9" });
      return;
    }
    const full = abs(safe);
    if (!import_fs7.default.existsSync(full) || !import_fs7.default.statSync(full).isFile()) {
      errors.push({ path: rel, error: "introuvable" });
      return;
    }
    const cached = ANALYZE_CACHE[safe];
    if (cached && now - cached.ts < ANALYZE_TTL_MS) {
      analyses.push(cached.data);
      return;
    }
    try {
      const content = import_fs7.default.readFileSync(full, "utf8");
      const lines = content.split(/\r?\n/);
      const hooksCount = (content.match(/\buse(State|Effect|Memo|Callback|Ref|Context|Reducer)\b/g) || []).length;
      const useEffectCount = (content.match(/\buseEffect\b/g) || []).length;
      const customHooks = (content.match(/\buse[A-Z][A-Za-z0-9_]*/g) || []).filter((h) => !/use(State|Effect|Memo|Callback|Ref|Context|Reducer)/.test(h));
      const jsx = /<[^>]+>/g.test(content) || /\.tsx$/.test(safe);
      let depth = 0, maxDepth = 0, tagCount = 0;
      if (jsx) {
        for (const line of lines) {
          const trimmed = line.trim();
          const openTags = trimmed.match(/<([A-Za-z][A-Za-z0-9-]*)([^>/]*?)>/g) || [];
          const closeTags = trimmed.match(/<\/(?:[A-Za-z][A-Za-z0-9-]*)>/g) || [];
          tagCount += openTags.length;
          const openNonSelf = openTags.filter((t) => !/\/>$/.test(t));
          for (let i = 0; i < openNonSelf.length; i++) {
            depth++;
            if (depth > maxDepth) maxDepth = depth;
          }
          for (let i = 0; i < closeTags.length; i++) {
            depth = Math.max(0, depth - 1);
          }
        }
      }
      const jsxDensity = jsx ? tagCount / Math.max(1, lines.length / 100) : 0;
      const hasI18n = /\bt\(['"][^)]*\)/.test(content) || /i18n/.test(content);
      const antdComponents = Array.from(new Set((content.match(/<([A-Z][A-Za-z0-9]+)\b/g) || []).map((m) => m.slice(1)).filter((n) => /^(Button|Table|Form|Modal|Input|Select|DatePicker|Tabs|Tag|Tooltip|Dropdown|Menu|Layout|Card|Space|Flex|Grid|Alert|Avatar|Badge)$/.test(n)))).sort();
      const summary = {
        path: safe,
        lines: lines.length,
        hooks: { total: hooksCount, useEffect: useEffectCount, custom: Array.from(new Set(customHooks)).slice(0, 20) },
        jsxStructure: jsx ? { maxDepth, tagCount, densityPer100Lines: Math.round(jsxDensity) } : null,
        i18n: hasI18n,
        antdComponents
      };
      ANALYZE_CACHE[safe] = { ts: now, data: summary };
      analyses.push(summary);
    } catch (e) {
      errors.push({ path: rel, error: e.message });
    }
  }
  unique.forEach(analyzeOne);
  res.json({ success: true, data: { analyses, errors, count: analyses.length } });
});
var ai_code_default = router40;

// src/routes/fields.ts
var import_express45 = require("express");
var import_uuid5 = require("uuid");
init_database();

// src/routes/formulas.ts
var import_express42 = require("express");
init_database();
var import_uuid3 = require("uuid");
var prisma20 = db;
var router41 = (0, import_express42.Router)({ mergeParams: true });
router41.use((req2, _res, next) => {
  console.log("[DEBUG FORMULAS] Request URL:", req2.originalUrl);
  console.log("[DEBUG FORMULAS] Route Path:", req2.route?.path);
  console.log("[DEBUG FORMULAS] Request Params:", req2.params);
  console.log("[DEBUG FORMULAS] Parent Params ID:", req2.params.id);
  console.log("[DEBUG FORMULAS] Request Body:", req2.body);
  next();
});
router41.use(authMiddleware, impersonationMiddleware);
router41.get("/all", requireRole2(["admin", "super_admin"]), async (_req, res) => {
  try {
    const formulas = await prisma20.fieldFormula.findMany({
      include: {
        Field: {
          select: {
            id: true,
            label: true
          }
        }
      }
    });
    const formattedFormulas = formulas.map((formula) => ({
      id: formula.id,
      name: formula.name || formula.title || "Formule sans nom",
      fieldId: formula.fieldId,
      fieldLabel: formula.Field?.label || "Champ inconnu"
    }));
    res.json(formattedFormulas);
  } catch (error) {
    console.error("Erreur lors de la r\xE9cup\xE9ration des formules:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des formules" });
  }
});
router41.get("/", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { fieldId } = req2.params;
    const formulas = await prisma20.fieldFormula.findMany({
      where: { fieldId },
      orderBy: { order: "asc" }
    });
    const processedFormulas = formulas.map((f) => ({
      ...f,
      sequence: f.sequence ? JSON.parse(f.sequence) : []
    }));
    res.json(processedFormulas);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});
router41.post("/", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { fieldId } = req2.params;
    const { name, sequence } = req2.body;
    const bodyFieldId = req2.body.fieldId;
    let { order } = req2.body;
    const effectiveFieldId = fieldId || bodyFieldId;
    console.log("Creating formula for field:", effectiveFieldId);
    if (!effectiveFieldId) {
      console.log("\u{1F9EA} Mode mock activ\xE9 pour la cr\xE9ation de formule - fieldId manquant");
      const mockId = (0, import_uuid3.v4)();
      const mockFormula = {
        id: mockId,
        fieldId: "mock-field-id",
        name: name || "Nouvelle formule (mock)",
        sequence: [],
        order: typeof order === "number" ? order : 0,
        targetProperty: req2.body.targetProperty || ""
      };
      return res.json([mockFormula]);
    }
    if (typeof order !== "number") {
      try {
        const lastFormula = await prisma20.fieldFormula.findFirst({
          where: { fieldId: effectiveFieldId },
          orderBy: { order: "desc" }
        });
        order = lastFormula && typeof lastFormula.order === "number" ? lastFormula.order + 1 : 0;
      } catch (error) {
        console.warn("Erreur lors de la recherche du dernier ordre:", error);
        order = 0;
      }
    }
    const newFormulaId = (0, import_uuid3.v4)();
    try {
      await prisma20.fieldFormula.create({
        data: {
          id: newFormulaId,
          name: name || "",
          sequence: sequence ? JSON.stringify(sequence) : "[]",
          order,
          Field: {
            connect: { id: effectiveFieldId }
          }
        }
      });
      const formulas = await prisma20.fieldFormula.findMany({
        where: { fieldId: effectiveFieldId },
        orderBy: { order: "asc" }
      });
      const processedFormulas = formulas.map((f) => ({
        ...f,
        sequence: f.sequence ? JSON.parse(f.sequence) : []
      }));
      res.json(processedFormulas);
    } catch (prismaError) {
      console.error("Erreur Prisma lors de la cr\xE9ation de formule:", prismaError);
      const mockFormula = {
        id: newFormulaId,
        fieldId: effectiveFieldId,
        name: name || "Nouvelle formule (mock)",
        sequence: [],
        order: typeof order === "number" ? order : 0,
        targetProperty: req2.body.targetProperty || ""
      };
      res.json([mockFormula]);
    }
  } catch (err) {
    console.error(`Erreur API POST /api/fields/:fieldId/formulas:`, err);
    res.status(500).json({ error: err.message });
  }
});
router41.put("/:formulaId", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { formulaId } = req2.params;
    const fieldId = req2.params.id;
    console.log(`[DEBUG_FORMULA_PUT] V\xE9rification param\xE8tres - formulaId: ${formulaId}, fieldId: ${fieldId}`);
    if (!fieldId) {
      console.error(`[DEBUG_FORMULA_PUT] Erreur: fieldId manquant`);
      return res.status(400).json({
        error: "ID du champ manquant",
        params: req2.params,
        originalUrl: req2.originalUrl
      });
    }
    const { name, sequence, order } = req2.body;
    console.log(`[DEBUG_FORMULA_PUT] Mise \xE0 jour formule ${formulaId} pour champ ${fieldId}`);
    console.log(`[DEBUG_FORMULA_PUT] Donn\xE9es re\xE7ues:`, {
      name,
      sequence: typeof sequence === "object" ? JSON.stringify(sequence) : sequence,
      order
    });
    const dataToUpdate = {};
    if (name !== void 0) {
      dataToUpdate.name = name;
    }
    if (sequence !== void 0) {
      dataToUpdate.sequence = typeof sequence === "object" ? JSON.stringify(sequence) : sequence;
    }
    if (order !== void 0) {
      dataToUpdate.order = order;
    }
    try {
      const existingFormula = await prisma20.fieldFormula.findUnique({
        where: { id: formulaId }
      });
      if (!existingFormula) {
        console.log(`[DEBUG_FORMULA_PUT] Formule non trouv\xE9e, on simule une r\xE9ponse`);
        return res.json([{
          id: formulaId,
          name: name || "Formule (simul\xE9e)",
          fieldId,
          sequence: sequence || [],
          order: order || 0,
          updatedAt: /* @__PURE__ */ new Date()
        }]);
      }
      const updatedFormula = await prisma20.fieldFormula.update({
        where: { id: formulaId },
        data: dataToUpdate
      });
      console.log(`[DEBUG_FORMULA_PUT] Formule mise \xE0 jour avec succ\xE8s:`, {
        id: updatedFormula.id,
        name: updatedFormula.name
      });
      const formulas = await prisma20.fieldFormula.findMany({
        where: { fieldId },
        orderBy: { order: "asc" }
      });
      const processedFormulas = formulas.map((f) => ({
        ...f,
        sequence: f.sequence ? JSON.parse(f.sequence) : []
      }));
      console.log(`[DEBUG_FORMULA_PUT] Retour de ${processedFormulas.length} formules au client`);
      return res.json(processedFormulas);
    } catch (err) {
      console.error(`[DEBUG_FORMULA_PUT] Erreur Prisma:`, err);
      console.log(`[DEBUG_FORMULA_PUT] Mode d\xE9veloppement, simulation de r\xE9ponse`);
      return res.json([{
        id: formulaId,
        name: name || "Formule (simul\xE9e)",
        fieldId,
        sequence: sequence || [],
        order: order || 0,
        updatedAt: /* @__PURE__ */ new Date()
      }]);
    }
  } catch (err) {
    console.error(`[DEBUG_FORMULA_PUT] Erreur g\xE9n\xE9rale:`, err);
    return res.status(500).json({
      error: "Erreur lors de la mise \xE0 jour de la formule",
      details: err.message,
      params: req2.params,
      originalUrl: req2.originalUrl
    });
  }
});
router41.delete("/:formulaId", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { formulaId, fieldId } = req2.params;
  try {
    console.log(`[AUDIT_API_DELETE] Demande de suppression formule ${formulaId} pour champ ${fieldId}`);
    const formulaToDelete = await prisma20.fieldFormula.findFirst({
      where: { id: formulaId, fieldId }
    });
    if (!formulaToDelete) {
      console.log(`[AUDIT_API_DELETE] Erreur: formule ${formulaId} non trouv\xE9e`);
      res.status(404).json({ error: "Formule non trouv\xE9e pour ce champ." });
      return;
    }
    console.log(
      `[AUDIT_API_DELETE] Formule trouv\xE9e, s\xE9quence avant suppression:`,
      formulaToDelete.sequence ? JSON.parse(formulaToDelete.sequence) : []
    );
    await prisma20.fieldFormula.delete({
      where: { id: formulaId }
    });
    console.log(`[AUDIT_API_DELETE] Formule ${formulaId} supprim\xE9e avec succ\xE8s`);
    const formulas = await prisma20.fieldFormula.findMany({
      where: { fieldId },
      orderBy: { order: "asc" }
    });
    const processedFormulas = formulas.map((f) => ({
      ...f,
      sequence: f.sequence ? JSON.parse(f.sequence) : []
    }));
    console.log(`[AUDIT_API_DELETE] Retour de ${processedFormulas.length} formules au client apr\xE8s suppression`);
    res.status(200).json(processedFormulas);
  } catch (error) {
    console.error(`Erreur lors de la suppression de la formule ${formulaId}:`, error);
    if (error.code === "P2025") {
      res.status(404).json({ error: "Formule non trouv\xE9e." });
    } else {
      res.status(500).json({ error: "Erreur interne du serveur lors de la suppression de la formule." });
    }
  }
});
router41.delete("/:formulaId/sequence/:index", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { formulaId, fieldId } = req2.params;
  const index = parseInt(req2.params.index, 10);
  if (isNaN(index) || index < 0) {
    res.status(400).json({ error: "Index invalide pour la suppression d'\xE9l\xE9ment" });
    return;
  }
  try {
    console.log(`[AUDIT_API_DELETE_ITEM] Suppression de l'\xE9l\xE9ment \xE0 l'index ${index} de la formule ${formulaId}`);
    const formula = await prisma20.fieldFormula.findFirst({
      where: { id: formulaId, fieldId }
    });
    if (!formula) {
      console.log(`[AUDIT_API_DELETE_ITEM] Formule ${formulaId} non trouv\xE9e`);
      res.status(404).json({ error: "Formule non trouv\xE9e" });
      return;
    }
    const currentSequence = formula.sequence ? JSON.parse(formula.sequence) : [];
    console.log(`[AUDIT_API_DELETE_ITEM] S\xE9quence actuelle (${currentSequence.length} \xE9l\xE9ments):`, currentSequence);
    if (index >= currentSequence.length) {
      console.log(`[AUDIT_API_DELETE_ITEM] Index ${index} hors limites (max: ${currentSequence.length - 1})`);
      res.status(400).json({ error: "Index hors limites" });
      return;
    }
    const elementToRemove = currentSequence[index];
    const newSequence = [...currentSequence.slice(0, index), ...currentSequence.slice(index + 1)];
    console.log(`[AUDIT_API_DELETE_ITEM] \xC9l\xE9ment supprim\xE9: ${elementToRemove}`);
    console.log(`[AUDIT_API_DELETE_ITEM] Nouvelle s\xE9quence (${newSequence.length} \xE9l\xE9ments):`, newSequence);
    await prisma20.fieldFormula.update({
      where: { id: formulaId },
      data: { sequence: JSON.stringify(newSequence) }
    });
    console.log(`[AUDIT_API_DELETE_ITEM] Formule mise \xE0 jour avec succ\xE8s`);
    const formulas = await prisma20.fieldFormula.findMany({
      where: { fieldId },
      orderBy: { order: "asc" }
    });
    const processedFormulas = formulas.map((f) => ({
      ...f,
      sequence: f.sequence ? JSON.parse(f.sequence) : []
    }));
    console.log(`[AUDIT_API_DELETE_ITEM] Retour de ${processedFormulas.length} formules au client`);
    res.status(200).json(processedFormulas);
  } catch (error) {
    console.error(`[AUDIT_API_DELETE_ITEM] Erreur lors de la suppression de l'\xE9l\xE9ment \xE0 l'index ${index} de la formule ${formulaId}:`, error);
    res.status(500).json({
      error: "Erreur lors de la suppression de l'\xE9l\xE9ment dans la s\xE9quence",
      details: error.message
    });
  }
});
router41.post("/reorder", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { fieldId } = req2.params;
  const { formulas } = req2.body;
  if (!Array.isArray(formulas)) {
    res.status(400).json({ error: "Le corps de la requ\xEAte doit contenir un tableau 'formulas'." });
    return;
  }
  try {
    await prisma20.$transaction(
      formulas.map(
        (formula) => prisma20.fieldFormula.update({
          where: { id: formula.id, fieldId },
          data: { order: formula.order }
        })
      )
    );
    res.status(200).json({ success: true });
  } catch (error) {
    console.error(`Erreur API POST /api/fields/${fieldId}/formulas/reorder:`, error);
    res.status(500).json({ error: "Erreur lors de la mise \xE0 jour de l'ordre des formules.", details: error.message });
  }
});
var formulas_default = router41;

// src/routes/dependencies.ts
var import_express43 = require("express");
init_prisma();
var import_uuid4 = require("uuid");
var router42 = (0, import_express43.Router)({ mergeParams: true });
router42.use(authMiddleware, impersonationMiddleware);
router42.get("/", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const fieldId = req2.params.fieldId || req2.params.id;
  if (!fieldId) {
    res.status(400).json({ error: "Param\xE8tre 'fieldId' manquant dans l'URL." });
    return;
  }
  try {
    const dependencies = await db.fieldDependency.findMany({
      where: { fieldId },
      orderBy: { order: "asc" }
    });
    const processedDependencies = dependencies.map((dep) => {
      let sequence = [];
      try {
        sequence = typeof dep.sequence === "string" ? JSON.parse(dep.sequence) : dep.sequence ?? [];
      } catch {
        sequence = [];
      }
      return {
        ...dep,
        sequence
      };
    });
    res.json(processedDependencies);
  } catch (error) {
    console.error(`[API] Erreur GET /api/fields/${fieldId}/dependencies:`, error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des d\xE9pendances", details: error.message });
  }
});
router42.get("/read", async (req2, res) => {
  const fieldId = req2.params.fieldId || req2.params.id;
  if (!fieldId) {
    res.status(400).json({ error: "Param\xE8tre 'fieldId' manquant dans l'URL." });
    return;
  }
  try {
    const dependencies = await db.fieldDependency.findMany({
      where: { fieldId },
      orderBy: { order: "asc" }
    });
    const processed = dependencies.map((dep) => {
      let sequence = [];
      try {
        sequence = typeof dep.sequence === "string" ? JSON.parse(dep.sequence) : dep.sequence ?? [];
      } catch {
        sequence = [];
      }
      return { ...dep, sequence };
    });
    res.json({ success: true, data: processed });
  } catch (error) {
    console.error(`[API] Erreur GET /api/fields/${fieldId}/dependencies/read:`, error);
    res.status(500).json({ success: false, error: "Erreur lors de la r\xE9cup\xE9ration des d\xE9pendances", details: error.message });
  }
});
router42.post("/", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const fieldId = req2.params.fieldId || req2.params.id;
  if (!fieldId) {
    res.status(400).json({ error: "Param\xE8tre 'fieldId' manquant dans l'URL." });
    return;
  }
  const { name, description, sequence, order, targetFieldId, operator, value, action: action2, prefillValue } = req2.body || {};
  try {
    const lastDep = await db.fieldDependency.findFirst({
      where: { fieldId },
      orderBy: { order: "desc" }
    });
    const newOrder = order ?? (lastDep?.order != null ? lastDep.order + 1 : 0);
    let resolvedDependsOnId = targetFieldId;
    if (!resolvedDependsOnId && sequence && Array.isArray(sequence.conditions)) {
      const firstCondGroup = sequence.conditions[0];
      const firstCond = Array.isArray(firstCondGroup) ? firstCondGroup[0] : void 0;
      resolvedDependsOnId = firstCond?.targetFieldId;
    }
    if (!resolvedDependsOnId) {
      return res.status(400).json({ error: "targetFieldId requis pour cr\xE9er une d\xE9pendance" });
    }
    const params = action2 || prefillValue ? { action: action2, prefillValue } : void 0;
    await db.fieldDependency.create({
      data: {
        id: (0, import_uuid4.v4)(),
        fieldId,
        name: name || "",
        description: description || "",
        sequence: sequence ? JSON.stringify(sequence) : "[]",
        order: newOrder,
        dependsOnId: resolvedDependsOnId,
        condition: operator || "",
        value: value ?? null,
        params
      }
    });
    const deps = await db.fieldDependency.findMany({ where: { fieldId }, orderBy: { order: "asc" } });
    const processed = deps.map((d) => ({
      ...d,
      sequence: typeof d.sequence === "string" ? JSON.parse(d.sequence) : d.sequence ?? []
    }));
    res.json(processed);
  } catch (error) {
    console.error(`[API] Erreur POST /api/fields/${fieldId}/dependencies:`, error);
    res.status(500).json({ error: "Erreur lors de la cr\xE9ation de la d\xE9pendance", details: error.message });
  }
});
router42.post("/reorder", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const fieldId = req2.params.fieldId || req2.params.id;
  const { dependencies } = req2.body;
  if (!Array.isArray(dependencies)) {
    res.status(400).json({ error: "Le corps de la requ\xEAte doit contenir un tableau 'dependencies'." });
    return;
  }
  try {
    await db.$transaction(
      dependencies.map(
        (dep) => db.fieldDependency.update({
          where: { id: dep.id },
          data: { order: dep.order }
        })
      )
    );
    res.status(200).json({ success: true });
  } catch (error) {
    console.error(`[API] Erreur POST /api/fields/${fieldId}/dependencies/reorder:`, error);
    res.status(500).json({ error: "Erreur lors du r\xE9ordonnancement", details: error.message });
  }
});
router42.put("/:dependencyId", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { dependencyId } = req2.params;
  const { name, description, sequence, order, targetFieldId, operator, value, action: action2, prefillValue } = req2.body || {};
  try {
    const existing = await db.fieldDependency.findUnique({ where: { id: dependencyId } });
    if (!existing) {
      return res.status(404).json({ error: "D\xE9pendance non trouv\xE9e" });
    }
    const dataToUpdate = {};
    if (name !== void 0) dataToUpdate.name = name;
    if (description !== void 0) dataToUpdate.description = description;
    if (sequence !== void 0) dataToUpdate.sequence = JSON.stringify(sequence);
    if (order !== void 0) dataToUpdate.order = order;
    if (targetFieldId !== void 0) dataToUpdate.dependsOnId = targetFieldId;
    if (operator !== void 0) dataToUpdate.condition = operator;
    if (value !== void 0) dataToUpdate.value = value;
    if (action2 !== void 0 || prefillValue !== void 0) dataToUpdate.params = { action: action2, prefillValue };
    const dep = await db.fieldDependency.update({
      where: { id: dependencyId },
      data: dataToUpdate
    });
    const deps = await db.fieldDependency.findMany({ where: { fieldId: dep.fieldId }, orderBy: { order: "asc" } });
    const processed = deps.map((d) => ({
      ...d,
      sequence: typeof d.sequence === "string" ? JSON.parse(d.sequence) : d.sequence ?? []
    }));
    res.json(processed);
  } catch (error) {
    console.error(`[API] Erreur PUT /api/fields/${req2.params.fieldId}/dependencies/${dependencyId}:`, error);
    res.status(500).json({ error: "Erreur lors de la mise \xE0 jour de la d\xE9pendance", details: error.message });
  }
});
router42.delete("/:dependencyId", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { dependencyId } = req2.params;
  try {
    await db.fieldDependency.delete({ where: { id: dependencyId } });
    res.status(200).json({ id: dependencyId, success: true });
  } catch (error) {
    console.error(`[API] Erreur DELETE /api/fields/${req2.params.fieldId}/dependencies/${dependencyId}:`, error);
    const errObj = error;
    if (errObj.code === "P2025") {
      res.status(404).json({ error: "D\xE9pendance non trouv\xE9e." });
    } else {
      res.status(500).json({ error: "Erreur lors de la suppression de la d\xE9pendance", details: error.message });
    }
  }
});
var dependencies_default = router42;

// src/routes/validations.ts
var import_express44 = __toESM(require("express"), 1);

// src/services/validationService.ts
init_prisma();
var getValidationsByFieldId = async (fieldId) => {
  console.log(`[ValidationService] Tentative de r\xE9cup\xE9ration des validations pour le champ ${fieldId}`);
  try {
    if (!db.fieldValidation) {
      console.error("[ValidationService] Le mod\xE8le fieldValidation n'existe pas dans le client Prisma");
      return [];
    }
    console.log(`[ValidationService] Recherche des validations avec fieldId=${fieldId}`);
    const validations = await db.fieldValidation.findMany({
      where: {
        fieldId
      }
      // Le champ 'order' n'existe pas dans le mod√®le FieldValidation
    });
    console.log(`[ValidationService] ${validations.length} validations trouv\xE9es pour le champ ${fieldId}`);
    return validations;
  } catch (error) {
    console.error(`[ValidationService] Erreur d\xE9taill\xE9e lors de la r\xE9cup\xE9ration des validations pour le champ ${fieldId}:`, error);
    return [];
  }
};
var createValidation = async (fieldId, validationData) => {
  console.log(`[ValidationService] Cr\xE9ation d'une validation pour le champ ${fieldId}:`, validationData);
  try {
    const field = await db.field.findUnique({
      where: {
        id: fieldId
      }
    });
    if (!field) {
      console.error(`[ValidationService] Le champ ${fieldId} n'existe pas`);
      throw new Error(`Le champ avec l'ID ${fieldId} n'existe pas.`);
    }
    const validation = await db.fieldValidation.create({
      data: {
        fieldId,
        type: validationData.type,
        value: validationData.value,
        message: validationData.message || "Ce champ n'est pas valide.",
        comparisonType: validationData.comparisonType || "static",
        comparisonFieldId: validationData.comparisonFieldId
      }
    });
    console.log(`[ValidationService] Validation cr\xE9\xE9e avec succ\xE8s:`, validation);
    return validation;
  } catch (error) {
    console.error(`[ValidationService] Erreur lors de la cr\xE9ation de la validation pour le champ ${fieldId}:`, error);
    throw new Error("Impossible de cr\xE9er la validation dans la base de donn\xE9es.");
  }
};
var updateValidation = async (validationId, updateData) => {
  console.log(`[ValidationService] Mise \xE0 jour de la validation ${validationId}:`, updateData);
  try {
    if (!db.fieldValidation) {
      console.error("[ValidationService] Le mod\xE8le fieldValidation n'existe pas dans le client Prisma");
      return {
        id: validationId,
        ...updateData,
        updatedAt: /* @__PURE__ */ new Date()
      };
    }
    const existingValidation = await db.fieldValidation.findUnique({
      where: {
        id: validationId
      }
    });
    if (!existingValidation) {
      console.error(`[ValidationService] Validation ${validationId} non trouv\xE9e pour la mise \xE0 jour`);
      if (process.env.NODE_ENV === "development") {
        return {
          id: validationId,
          ...updateData,
          updatedAt: /* @__PURE__ */ new Date(),
          message: "Simulation de mise \xE0 jour r\xE9ussie (validation non trouv\xE9e)"
        };
      }
      throw new Error(`La validation avec l'ID ${validationId} n'existe pas.`);
    }
    const updateObject = {};
    if (updateData.type !== void 0) updateObject.type = updateData.type;
    if (updateData.value !== void 0) updateObject.value = updateData.value;
    if (updateData.message !== void 0) updateObject.message = updateData.message;
    if (updateData.comparisonType !== void 0) updateObject.comparisonType = updateData.comparisonType;
    if (updateData.comparisonFieldId !== void 0) updateObject.comparisonFieldId = updateData.comparisonFieldId;
    if (Object.keys(updateObject).length === 0) {
      console.log(`[ValidationService] Aucune donn\xE9e \xE0 mettre \xE0 jour pour la validation ${validationId}`);
      return existingValidation;
    }
    const updatedValidation = await db.fieldValidation.update({
      where: {
        id: validationId
      },
      data: updateObject
    });
    console.log(`[ValidationService] Validation ${validationId} mise \xE0 jour avec succ\xE8s:`, updatedValidation);
    return updatedValidation;
  } catch (error) {
    console.error(`[ValidationService] Erreur lors de la mise \xE0 jour de la validation ${validationId}:`, error);
    if (process.env.NODE_ENV === "development") {
      console.log(`[ValidationService] Mode d\xE9veloppement, simulation de mise \xE0 jour r\xE9ussie malgr\xE9 l'erreur`);
      return {
        id: validationId,
        ...updateData,
        updatedAt: /* @__PURE__ */ new Date(),
        message: "Simulation de mise \xE0 jour r\xE9ussie malgr\xE9 l'erreur"
      };
    }
    throw new Error(`Impossible de mettre \xE0 jour la validation: ${error.message}`);
  }
};
var deleteValidationById = async (validationId) => {
  try {
    console.log(`[ValidationService] Tentative de suppression de la validation ${validationId}`);
    if (!db.fieldValidation) {
      console.error("[ValidationService] Le mod\xE8le fieldValidation n'existe pas dans le client Prisma");
      return {
        id: validationId,
        message: "Simulation de suppression r\xE9ussie (mod\xE8le non disponible)"
      };
    }
    const existingValidation = await db.fieldValidation.findUnique({
      where: {
        id: validationId
      }
    });
    if (!existingValidation) {
      console.log(`[ValidationService] Validation ${validationId} non trouv\xE9e`);
      return { id: validationId, message: "Validation non trouv\xE9e" };
    }
    const deletedValidation = await db.fieldValidation.delete({
      where: {
        id: validationId
      }
    });
    console.log(`[ValidationService] Validation ${validationId} supprim\xE9e avec succ\xE8s`);
    return deletedValidation;
  } catch (error) {
    console.error(`[ValidationService] Erreur lors de la suppression de la validation ${validationId}:`, error);
    if (process.env.NODE_ENV === "development") {
      return {
        id: validationId,
        message: "Simulation de suppression r\xE9ussie malgr\xE9 l'erreur"
      };
    }
    throw new Error("Impossible de supprimer la validation depuis la base de donn\xE9es.");
  }
};

// src/routes/validations.ts
var router43 = import_express44.default.Router({ mergeParams: true });
router43.get("/", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const params = req2.params;
  const rawId = params.id || params.fieldId;
  console.log(`[ValidationsRouter] GET validations - params:`, req2.params);
  if (!rawId) {
    console.warn("[ValidationsRouter] ID de champ manquant, retour d'une liste vide");
    return res.json({ success: true, data: [] });
  }
  try {
    const validations = await getValidationsByFieldId(String(rawId));
    return res.json({ success: true, data: validations });
  } catch (error) {
    console.error(`Erreur lors de la r\xE9cup\xE9ration des validations pour le champ ${rawId}:`, error);
    return res.json({ success: true, data: [] });
  }
});
router43.get("/read", async (req2, res) => {
  const params = req2.params;
  const rawId = params.id || params.fieldId;
  if (!rawId) {
    return res.json({ success: true, data: [] });
  }
  try {
    const validations = await getValidationsByFieldId(String(rawId));
    return res.json({ success: true, data: validations });
  } catch (error) {
    console.error(`[ValidationsRouter] Erreur (read) pour le champ ${rawId}:`, error);
    return res.json({ success: true, data: [] });
  }
});
router43.post("/", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { id } = req2.params;
  const validationData = req2.body;
  console.log(`[POST] Tentative de cr\xE9ation d'une validation pour le champ ${id}:`, validationData);
  if (!id) {
    return res.status(400).json({ success: false, message: "L'ID du champ est manquant." });
  }
  try {
    if (process.env.NODE_ENV === "development" && !validationData.type) {
      console.log("[POST] Mode d\xE9veloppement d\xE9tect\xE9, simulation de cr\xE9ation");
      return res.status(201).json({
        success: true,
        data: {
          id: `valid-${Date.now()}`,
          fieldId: id,
          ...validationData,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    }
    const validation = await createValidation(id, validationData);
    res.status(201).json({ success: true, data: validation });
  } catch (error) {
    console.error(`Erreur lors de la cr\xE9ation d'une validation pour le champ ${id}:`, error);
    if (process.env.NODE_ENV === "development") {
      console.log("[POST] Mode d\xE9veloppement, simulation de cr\xE9ation malgr\xE9 l'erreur");
      return res.status(201).json({
        success: true,
        data: {
          id: `valid-${Date.now()}`,
          fieldId: id,
          ...validationData,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    }
    res.status(500).json({ success: false, message: "Erreur interne du serveur." });
  }
});
router43.delete("/:id", async (req2, res) => {
  const { id } = req2.params;
  console.log(`[DELETE] Tentative de suppression de la validation ${id}`);
  if (!id) {
    return res.status(400).json({ success: false, message: "L'ID de la validation est manquant." });
  }
  try {
    if (id.startsWith("valid-")) {
      console.log(`[DELETE] ID temporaire d\xE9tect\xE9: ${id}, simulation d'une suppression r\xE9ussie`);
      return res.status(200).json({
        success: true,
        data: {
          id,
          message: "Validation temporaire supprim\xE9e avec succ\xE8s (simul\xE9)"
        }
      });
    }
    console.log(`[DELETE] Appel de deleteValidationById avec id=${id}`);
    const deletedValidation = await deleteValidationById(id);
    console.log(`[DELETE] Validation supprim\xE9e avec succ\xE8s:`, deletedValidation);
    res.status(200).json({ success: true, data: deletedValidation });
  } catch (error) {
    console.error(`Erreur lors de la suppression de la validation ${id}:`, error);
    res.status(200).json({
      success: true,
      data: {
        id,
        message: "Simulation de suppression r\xE9ussie malgr\xE9 l'erreur"
      }
    });
  }
});
router43.patch("/:id", async (req2, res) => {
  const { id } = req2.params;
  const validationData = req2.body;
  console.log(`[PATCH] Tentative de mise \xE0 jour de la validation ${id}:`, validationData);
  if (!id) {
    return res.status(400).json({ success: false, message: "L'ID de la validation est manquant." });
  }
  try {
    if (id.startsWith("valid-")) {
      console.log(`[PATCH] ID temporaire d\xE9tect\xE9: ${id}, simulation d'une mise \xE0 jour r\xE9ussie`);
      return res.status(200).json({
        success: true,
        data: {
          ...validationData,
          id,
          updatedAt: /* @__PURE__ */ new Date(),
          message: "Validation temporaire mise \xE0 jour avec succ\xE8s (simul\xE9)"
        }
      });
    }
    const updatedValidation = await updateValidation(id, validationData);
    console.log(`[PATCH] Validation mise \xE0 jour avec succ\xE8s:`, updatedValidation);
    res.status(200).json({ success: true, data: updatedValidation });
  } catch (error) {
    console.error(`Erreur lors de la mise \xE0 jour de la validation ${id}:`, error);
    if (process.env.NODE_ENV === "development") {
      console.log("[PATCH] Mode d\xE9veloppement, simulation de mise \xE0 jour malgr\xE9 l'erreur");
      return res.status(200).json({
        success: true,
        data: {
          ...validationData,
          id,
          updatedAt: /* @__PURE__ */ new Date(),
          message: "Simulation de mise \xE0 jour r\xE9ussie malgr\xE9 l'erreur"
        }
      });
    }
    res.status(500).json({ success: false, message: "Erreur interne du serveur." });
  }
});
var validations_default = router43;

// src/routes/fields.ts
var router44 = (0, import_express45.Router)();
var prisma21 = db;
router44.use(authMiddleware);
function mapFieldForFrontend(field) {
  if (!field || typeof field !== "object") return field;
  const f = field;
  const options = Array.isArray(f.FieldOption) ? f.FieldOption.slice().sort((a, b) => (a.order ?? 0) - (b.order ?? 0)).map((o) => ({ id: o.id, label: o.label, value: o.value, order: o.order })) : Array.isArray(f.options) ? f.options : [];
  const rest = { ...field };
  delete rest["FieldOption"];
  return { ...rest, options };
}
router44.get("/", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const userRole = req2.user?.role;
    const whereClause = {};
    if (userRole === "super_admin") {
    } else {
      if (!organizationId) {
        return res.status(403).json({ error: "ID de l'organisation manquant pour cet utilisateur." });
      }
      whereClause.organizationId = organizationId;
    }
    const fields = await prisma21.field.findMany({
      where: whereClause,
      orderBy: {
        label: "asc"
      }
    });
    res.json(fields);
  } catch (error) {
    console.error("Erreur lors de la r\xE9cup\xE9ration des champs:", error);
    res.status(500).json({ error: "Erreur interne du serveur" });
  }
});
router44.use("/:id/formulas", formulas_default);
router44.use("/:id/dependencies", dependencies_default);
router44.use("/:id/validations", validations_default);
router44.post("/:id/reorder-dependencies", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { dependencyIds } = req2.body ?? {};
  if (!Array.isArray(dependencyIds)) {
    return res.status(400).json({ error: "Le corps doit contenir 'dependencyIds' (array)." });
  }
  const dependencies = dependencyIds.map((depId, index) => ({ id: depId, order: index }));
  try {
    await prisma21.$transaction(
      dependencies.map(
        (dep) => prisma21.fieldDependency.update({ where: { id: dep.id }, data: { order: dep.order } })
      )
    );
    res.json({ success: true });
  } catch (error) {
    console.error("[API] [POST /fields/:id/reorder-dependencies] Erreur:", error);
    res.status(500).json({ error: "Erreur lors du r\xE9ordonnancement des d\xE9pendances", details: error.message });
  }
});
router44.put("/:id", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { id } = req2.params;
  const { label, type, required, width, advancedConfig } = req2.body;
  console.log("[fields.ts] PUT /:id - fieldId:", id);
  console.log("[fields.ts] PUT /:id - body re\xE7u:", req2.body);
  console.log("[fields.ts] PUT /:id - advancedConfig:", advancedConfig);
  try {
    const field = await prisma21.field.update({
      where: { id },
      data: { label, type, required, width, advancedConfig }
    });
    console.log("[fields.ts] PUT /:id - Champ mis \xE0 jour:", field);
    res.json(field);
  } catch (err) {
    console.error("[fields.ts] PUT /:id - Erreur:", err);
    const errorMessage = err instanceof Error ? err.message : "Erreur inconnue";
    res.status(404).json({ error: "Champ non trouv\xE9 ou erreur lors de la mise \xE0 jour", details: errorMessage });
  }
});
router44.post("/:fieldId/options", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { fieldId } = req2.params;
  const { label, order, value } = req2.body;
  if (!label || !value) {
    res.status(400).json({ error: "Le label et la value de l'option sont obligatoires." });
    return;
  }
  console.log("[API] [POST /fields/:fieldId/options] Re\xE7u pour fieldId:", fieldId, "body:", req2.body);
  try {
    const existingOption = await prisma21.fieldOption.findFirst({
      where: {
        fieldId,
        value
      }
    });
    if (!existingOption) {
      await prisma21.fieldOption.create({
        data: {
          id: (0, import_uuid5.v4)(),
          label,
          value,
          order,
          fieldId
        }
      });
      console.log("[API] [POST /fields/:fieldId/options] Option cr\xE9\xE9e en base");
    } else {
      console.log("[API] [POST /fields/:fieldId/options] Option d\xE9j\xE0 existante, retour du champ \xE0 jour");
    }
    const updatedField = await prisma21.field.findUnique({
      where: { id: fieldId },
      include: { FieldOption: true }
    });
    res.json(mapFieldForFrontend(updatedField));
  } catch (err) {
    console.error("[API] [POST /fields/:fieldId/options] Erreur cr\xE9ation option:", err);
    res.status(400).json({ error: "Erreur lors de la cr\xE9ation de l'option", details: err.message });
  }
});
router44.delete("/field-options/:optionId", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { optionId } = req2.params;
  try {
    await prisma21.fieldOption.delete({ where: { id: optionId } });
    res.json({ success: true });
  } catch (err) {
    res.status(400).json({ error: "Erreur lors de la suppression de l'option", details: err.message });
  }
});
router44.delete("/:fieldId/options/:optionId", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { fieldId, optionId } = req2.params;
  try {
    await prisma21.fieldOption.delete({ where: { id: optionId } });
    const updatedField = await prisma21.field.findUnique({
      where: { id: fieldId },
      include: { FieldOption: true }
    });
    if (!updatedField) {
      return res.status(404).json({ error: "Champ non trouv\xE9 apr\xE8s suppression de l'option" });
    }
    res.json(mapFieldForFrontend(updatedField));
  } catch (err) {
    console.error("[API] [DELETE /fields/:fieldId/options/:optionId] Erreur suppression option:", err);
    res.status(400).json({ error: "Erreur lors de la suppression de l'option", details: err.message });
  }
});
router44.get("/:id", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { id } = req2.params;
  try {
    const field = await prisma21.field.findUnique({
      where: { id },
      include: { FieldOption: true }
    });
    if (!field) {
      res.status(404).json({ error: "Champ non trouv\xE9" });
      return;
    }
    res.json(mapFieldForFrontend(field));
  } catch (err) {
    res.status(400).json({ error: "Erreur lors de la r\xE9cup\xE9ration du champ", details: err.message });
  }
});
router44.post("/meta-counts", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { fieldIds } = req2.body;
  if (!Array.isArray(fieldIds) || fieldIds.length === 0) {
    res.status(400).json({ error: "fieldIds doit \xEAtre un tableau non vide." });
    return;
  }
  try {
    const counts = await Promise.all(fieldIds.map(async (fieldId) => {
      const formulas = await prisma21.fieldFormula.count({ where: { fieldId } });
      const validations = await prisma21.fieldValidation.count({ where: { fieldId } });
      const dependencies = await prisma21.fieldDependency.count({ where: { fieldId } });
      return {
        fieldId,
        counts: { formulas, validations, dependencies }
      };
    }));
    const result = counts.reduce((acc, { fieldId, counts: counts2 }) => {
      acc[fieldId] = counts2;
      return acc;
    }, {});
    res.json(result);
  } catch (err) {
    console.error("[API] [POST /fields/meta-counts] Erreur:", err);
    res.status(500).json({ error: "Erreur serveur lors de la r\xE9cup\xE9ration des m\xE9tadonn\xE9es", details: err.message });
  }
});
router44.delete("/:id", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { id } = req2.params;
  try {
    const field = await prisma21.field.findUnique({
      where: { id },
      include: { Section: true }
    });
    if (!field || !field.Section) {
      res.status(404).json({ error: "Champ ou section parente non trouv\xE9" });
      return;
    }
    const blockId = field.Section.blockId;
    if (!blockId) {
      res.status(404).json({ error: "Block parent non trouv\xE9" });
      return;
    }
    await prisma21.field.delete({
      where: { id }
    });
    const remainingFields = await prisma21.field.findMany({
      where: { sectionId: field.sectionId },
      orderBy: { order: "asc" }
    });
    const updatePromises = remainingFields.map(
      (f, index) => prisma21.field.update({
        where: { id: f.id },
        data: { order: index }
      })
    );
    await prisma21.$transaction(updatePromises);
    const updatedBlock = await prisma21.block.findUnique({
      where: { id: blockId },
      include: {
        Section: {
          include: {
            Field: {
              orderBy: {
                order: "asc"
              }
            }
          },
          orderBy: {
            order: "asc"
          }
        }
      }
    });
    if (!updatedBlock) {
      res.status(404).json({ error: "Le block mis \xE0 jour n'a pas pu \xEAtre r\xE9cup\xE9r\xE9." });
      return;
    }
    res.status(200).json(updatedBlock);
  } catch (error) {
    console.error("Error deleting field:", error);
    res.status(500).json({ error: "An error occurred while deleting the field" });
  }
});
router44.put("/:id/move", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { id } = req2.params;
  const { targetSectionId, newOrder } = req2.body;
  if (targetSectionId === void 0 || newOrder === void 0) {
    return res.status(400).json({ error: "Les informations de section cible et d'ordre sont requises." });
  }
  try {
    const fieldToMove = await prisma21.field.findUnique({
      where: { id },
      include: { Section: true }
    });
    if (!fieldToMove || !fieldToMove.Section) {
      return res.status(404).json({ error: "Champ ou section d'origine non trouv\xE9." });
    }
    const blockId = fieldToMove.Section.blockId;
    const sourceSectionId = fieldToMove.sectionId;
    if (sourceSectionId === targetSectionId) {
      const fieldsInSection = await prisma21.field.findMany({
        where: { sectionId: targetSectionId },
        orderBy: { order: "asc" }
      });
      const fieldIndex = fieldsInSection.findIndex((f) => f.id === id);
      if (fieldIndex === -1) {
        return res.status(404).json({ error: "Le champ \xE0 d\xE9placer n'a pas \xE9t\xE9 trouv\xE9 dans la section." });
      }
      const reorderedFields = [...fieldsInSection];
      const [movedItem] = reorderedFields.splice(fieldIndex, 1);
      reorderedFields.splice(newOrder, 0, movedItem);
      await prisma21.$transaction(
        reorderedFields.map(
          (field, index) => prisma21.field.update({ where: { id: field.id }, data: { order: index } })
        )
      );
    } else {
      await prisma21.$transaction(async (tx) => {
        await tx.field.updateMany({
          where: { sectionId: sourceSectionId, order: { gt: fieldToMove.order } },
          data: { order: { decrement: 1 } }
        });
        await tx.field.updateMany({
          where: { sectionId: targetSectionId, order: { gte: newOrder } },
          data: { order: { increment: 1 } }
        });
        await tx.field.update({
          where: { id },
          data: { sectionId: targetSectionId, order: newOrder }
        });
      });
    }
    const updatedBlock = await prisma21.block.findUnique({
      where: { id: blockId },
      include: {
        Section: { orderBy: { order: "asc" }, include: { Field: { orderBy: { order: "asc" }, include: { FieldOption: { orderBy: { order: "asc" } } } } } }
      }
    });
    if (!updatedBlock) {
      return res.status(404).json({ error: "Le block mis \xE0 jour n'a pas pu \xEAtre r\xE9cup\xE9r\xE9." });
    }
    const adaptedBlock = adaptBlockStructure(updatedBlock);
    res.json(adaptedBlock);
  } catch (err) {
    console.error("[API] [PUT /fields/:id/move] Erreur:", err);
    res.status(500).json({ error: "Erreur lors du d\xE9placement du champ", details: err.message });
  }
});
router44.put("/:id/reorder", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  const { newIndex } = req2.body;
  const { id } = req2.params;
  try {
    const fieldToMove = await prisma21.field.findUnique({
      where: { id }
    });
    if (!fieldToMove) {
      res.status(404).json({ error: "Field not found" });
      return;
    }
    const allFieldsInSection = await prisma21.field.findMany({
      where: { sectionId: fieldToMove.sectionId },
      orderBy: { order: "asc" }
    });
    const oldIndex = allFieldsInSection.findIndex((f) => f.id === id);
    if (oldIndex === -1) {
      res.status(404).json({ error: "Field not found in its section" });
      return;
    }
    const reorderedFields = [...allFieldsInSection];
    const [movedItem] = reorderedFields.splice(oldIndex, 1);
    reorderedFields.splice(newIndex, 0, movedItem);
    const updatePromises = reorderedFields.map(
      (field, index) => prisma21.field.update({
        where: { id: field.id },
        data: { order: index }
      })
    );
    await prisma21.$transaction(updatePromises);
    const updatedSection = await prisma21.section.findUnique({
      where: { id: fieldToMove.sectionId },
      include: {
        Field: {
          orderBy: {
            order: "asc"
          }
        }
      }
    });
    res.status(200).json(updatedSection);
  } catch (error) {
    console.error("Error reordering field:", error);
    res.status(500).json({ error: "An error occurred while reordering the field" });
  }
});
var fields_default = router44;

// src/routes/api/formulas.ts
var import_express46 = __toESM(require("express"), 1);
init_database();

// src/global-mock-formulas.ts
if (!global._globalFormulasStore) {
  global._globalFormulasStore = /* @__PURE__ */ new Map();
  global._backupFormulasStore = /* @__PURE__ */ new Map();
}
if (!global._backupFormulasStore) {
  global._backupFormulasStore = /* @__PURE__ */ new Map();
}
if (!global._formulasOperationLog) {
  global._formulasOperationLog = [];
}
var logOperation = (operation, fieldId, formulaId = null, status = "success", details = null) => {
  const logEntry = {
    timestamp: /* @__PURE__ */ new Date(),
    operation,
    fieldId,
    ...formulaId ? { formulaId } : {},
    status,
    ...details ? { details } : {}
  };
  global._formulasOperationLog.push(logEntry);
  if (global._formulasOperationLog.length > 100) {
    global._formulasOperationLog.shift();
  }
  return logEntry;
};
var getFormulasForField = (fieldId) => {
  try {
    if (!fieldId) {
      console.error("[MOCK] Erreur: fieldId est undefined ou null");
      logOperation("getFormulasForField", "unknown", null, "error", "fieldId manquant");
      return [];
    }
    if (!global._globalFormulasStore.has(fieldId)) {
      global._globalFormulasStore.set(fieldId, []);
      logOperation("initStorage", fieldId);
    }
    const storedData = global._globalFormulasStore.get(fieldId);
    if (!storedData) {
      console.warn("[MOCK] Donn\xC3\u0192\xC2\xA9es manquantes apr\xC3\u0192\xC2\xA8s v\xC3\u0192\xC2\xA9rification, cr\xC3\u0192\xC2\xA9ation d'un tableau vide");
      global._globalFormulasStore.set(fieldId, []);
      return [];
    }
    if (storedData.length > 0) {
    }
    logOperation("getFormulasForField", fieldId, null, "success", { count: storedData.length });
    return JSON.parse(JSON.stringify(storedData));
  } catch (error) {
    console.error("[MOCK] Erreur lors de la r\xC3\u0192\xC2\xA9cup\xC3\u0192\xC2\xA9ration des formules pour le champ " + fieldId + ":", error);
    logOperation("getFormulasForField", fieldId, null, "error", error.message || String(error));
    return [];
  }
};
var updateFormula = (fieldId, formulaId, data) => {
  try {
    if (!fieldId || !formulaId) {
      console.error("[MOCK] Erreur: fieldId ou formulaId manquant");
      logOperation("updateFormula", fieldId || "unknown", formulaId || null, "error", "Param\xC3\u0192\xC2\xA8tres manquants");
      return null;
    }
    const formulas = JSON.parse(JSON.stringify(getFormulasForField(fieldId)));
    const index = formulas.findIndex((f) => f.id === formulaId);
    const formula = {
      id: formulaId,
      fieldId,
      name: data.name || "Formule sans nom",
      sequence: data.sequence || [],
      order: typeof data.order === "number" ? data.order : 0,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    if (index >= 0) {
      formulas[index] = { ...formulas[index], ...formula };
      logOperation("updateFormula", fieldId, formulaId, "success", { type: "update" });
    } else {
      formulas.push(formula);
      logOperation("updateFormula", fieldId, formulaId, "success", { type: "create" });
    }
    const formulasCopy = JSON.parse(JSON.stringify(formulas));
    const sortedFormulas = formulasCopy.sort((a, b) => a.order - b.order);
    global._globalFormulasStore.set(fieldId, sortedFormulas);
    try {
      const backupCopy = JSON.parse(JSON.stringify(sortedFormulas));
      global._backupFormulasStore.set(fieldId, backupCopy);
    } catch (backupError) {
      console.error("[MOCK] \xC3\xA2\xC2\x9D\xC5\u2019 \xC3\u0192\xE2\u20AC\xB0chec de la sauvegarde de secours:", backupError);
    }
    const storedFormulas = global._globalFormulasStore.get(fieldId);
    if (storedFormulas && storedFormulas.length > 0) {
      storedFormulas.forEach((f, idx) => {
        if (!f.id || !f.sequence) {
          console.warn(
            `[MOCK] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F Formule #${idx} potentiellement corrompue:`,
            JSON.stringify({ id: f.id, hasSequence: !!f.sequence, sequenceType: typeof f.sequence })
          );
        }
      });
    }
    return formula;
  } catch (error) {
    console.error("[MOCK] Erreur lors de la mise \xC3\u0192\xC2\xA0 jour de la formule " + formulaId + ":", error);
    logOperation("updateFormula", fieldId, formulaId, "error", error.message || String(error));
    return null;
  }
};

// src/utils/formulaEvaluator.ts
var evaluateFormula = (formula, fieldValues, context) => {
  if (!formula || !formula.sequence || !Array.isArray(formula.sequence) || formula.sequence.length === 0) {
    return {
      result: null,
      success: false,
      error: "Formule vide ou invalide",
      debug: []
    };
  }
  const debugSteps = [];
  try {
    let result = null;
    let resultRaw = null;
    let currentOperator = null;
    let isFirstValue = true;
    formula.sequence.forEach((item, index) => {
      if (!item || !item.type) {
        throw new Error(`\xC9l\xE9ment de formule invalide \xE0 l'\xE9tape ${index + 1}`);
      }
      let itemValue;
      let itemRaw = void 0;
      switch (item.type) {
        case "value": {
          if (typeof item.value === "string") {
            const raw = item.value.trim();
            itemRaw = raw;
            if (item.valueType === "string" && !/^-?\d+(\.\d+)?%$/.test(raw.replace(/\s+/g, ""))) {
              itemValue = 0;
              break;
            }
            if (/^-?\d+(\.\d+)?%$/.test(raw)) {
              const base = parseFloat(raw.replace("%", ""));
              itemValue = isNaN(base) ? 0 : base / 100;
            } else {
              const num = parseFloat(raw);
              if (isNaN(num)) {
                itemValue = 0;
              } else {
                itemValue = num;
              }
            }
          } else if (typeof item.value === "number") {
            itemRaw = item.value;
            itemValue = item.value;
          } else {
            itemValue = 0;
          }
          break;
        }
        case "field": {
          const fid = String(item.fieldId || item.value || "");
          let rawVal = void 0;
          if (fid) {
            if (typeof fieldValues[fid] !== "undefined") rawVal = fieldValues[fid];
            else if (context?.rawValues && Object.prototype.hasOwnProperty.call(context.rawValues, fid)) rawVal = context.rawValues[fid];
          }
          console.log(`[FormulaEvaluator] \u{1F3F7}\uFE0F Champ "${fid}": rawVal=${rawVal}, typeof=${typeof rawVal}`);
          if (rawVal && typeof rawVal === "object") {
            const sel = rawVal.selection;
            console.log(`[FormulaEvaluator] \u{1F50D} Advanced select - selection:${sel}, objet:`, rawVal);
            rawVal = typeof sel !== "undefined" ? sel : rawVal;
          }
          itemRaw = rawVal;
          if (typeof rawVal === "number") itemValue = rawVal;
          else if (typeof rawVal === "string") {
            const trimmed = rawVal.trim();
            if (/^-?\d+(\.\d+)?%$/.test(trimmed)) {
              const base = parseFloat(trimmed.replace("%", ""));
              itemValue = isNaN(base) ? 0 : base / 100;
            } else {
              const num = parseFloat(trimmed);
              itemValue = isNaN(num) ? 0 : num;
            }
          } else {
            itemValue = 0;
          }
          console.log(`[FormulaEvaluator] \u{1F4CA} Champ "${fid}" \xE9valu\xE9: ${itemValue} (raw: ${rawVal})`);
          debugSteps.push({ step: index + 1, operation: `Champ ${fid}`, value: itemValue });
          break;
        }
        case "formula_ref": {
          const refId = item.refFormulaId || String(item.value);
          if (!refId) throw new Error("formula_ref sans refFormulaId");
          const cache = context?.formulaResults || {};
          let refResult = cache[refId];
          if (typeof refResult === "undefined") {
            const visited = context?.visited || /* @__PURE__ */ new Set();
            if (visited.has(refId)) throw new Error(`Cycle d\xE9tect\xE9 sur la formule ${refId}`);
            visited.add(refId);
            if (context?.depth && context.depth > 20) throw new Error("Profondeur formule imbriqu\xE9e trop grande");
            const refFormula = context?.resolveFormulaById ? context.resolveFormulaById(refId) : void 0;
            if (!refFormula) throw new Error(`Formule r\xE9f\xE9renc\xE9e introuvable: ${refId}`);
            const nested = evaluateFormula(refFormula, fieldValues, {
              ...context,
              depth: (context?.depth || 0) + 1,
              visited,
              formulaResults: { ...context?.formulaResults || {} }
            });
            if (!nested.success) throw new Error(`Erreur formule imbriqu\xE9e ${refId}: ${nested.error}`);
            refResult = nested.result;
            if (context?.formulaResults) context.formulaResults[refId] = refResult;
            visited.delete(refId);
          }
          if (typeof refResult === "boolean") itemValue = refResult ? 1 : 0;
          else itemValue = Number(refResult ?? 0);
          break;
        }
        case "adv_part": {
          const fid = item.fieldId || item.value;
          const part = item.part || "selection";
          const raw = context?.rawValues?.[fid];
          let extracted = void 0;
          if (raw && typeof raw === "object") {
            const obj = raw;
            if (part === "selection") extracted = obj["selection"];
            else if (part === "extra") extracted = obj["extra"];
            else if (part === "nodeId") extracted = obj["nodeId"];
          } else if (part === "selection") {
            extracted = raw;
          }
          itemRaw = extracted;
          if (typeof extracted === "number") itemValue = extracted;
          else if (typeof extracted === "string") {
            const s = extracted.trim();
            if (/^-?\d+(\.\d+)?%$/.test(s)) {
              const base = parseFloat(s.replace("%", ""));
              itemValue = isNaN(base) ? 0 : base / 100;
            } else {
              const n = parseFloat(s);
              itemValue = isNaN(n) ? 0 : n;
            }
          } else {
            itemValue = 0;
          }
          break;
        }
        case "cond": {
          let pass = false;
          let condDebugValue = null;
          if (item.condExpr && item.condExpr.length > 0) {
            const firstToken = item.condExpr[0];
            if (firstToken?.type === "function" && String(firstToken.value).startsWith("IF(")) {
              const conditionTokens = item.condExpr.slice(1);
              if (conditionTokens.length >= 3) {
                const tempBool = { id: `${formula.id}__if_cond_${index}`, name: "if-condition", sequence: conditionTokens, targetProperty: "" };
                const nestedBool = evaluateFormula(tempBool, fieldValues, { ...context, depth: (context?.depth || 0) + 1 });
                if (nestedBool.success) {
                  pass = Boolean(nestedBool.result);
                  condDebugValue = nestedBool.result;
                } else {
                  console.warn(`[FormulaEvaluator] Erreur \xE9valuation condition IF: ${nestedBool.error}`);
                  pass = false;
                  condDebugValue = false;
                }
              } else {
                console.warn("[FormulaEvaluator] Fonction IF sans condition suffisante");
                pass = false;
                condDebugValue = false;
              }
            } else {
              const tempBool = { id: `${formula.id}__cond_expr_${index}`, name: "cond-expr", sequence: item.condExpr, targetProperty: "" };
              const nestedBool = evaluateFormula(tempBool, fieldValues, { ...context, depth: (context?.depth || 0) + 1 });
              if (!nestedBool.success) throw new Error(`Erreur expression condition: ${nestedBool.error}`);
              pass = Boolean(nestedBool.result);
              condDebugValue = nestedBool.result;
            }
          } else {
            const cond = item.condition;
            const evalCondition = () => {
              if (!cond) return false;
              const raw = context?.rawValues?.[cond.fieldId] ?? context?.rawValues?.[cond.fieldId];
              const part = cond.part || "selection";
              let base = raw;
              if (raw && typeof raw === "object") {
                const obj = raw;
                if (part === "selection") base = obj["selection"];
                else if (part === "extra") base = obj["extra"];
                else if (part === "nodeId") base = obj["nodeId"];
              }
              const op = cond.operator || "=";
              const val = cond.value;
              const cmp = (a, b, op2) => {
                if (op2 === "in") {
                  if (!Array.isArray(b)) return false;
                  return b.some((x) => String(x) === String(a));
                }
                const aNum = parseFloat(String(a));
                const bNum = parseFloat(String(b));
                const aIsNum = !isNaN(aNum) && String(a).trim() !== "" && /^-?\d+(\.\d+)?$/.test(String(a).trim());
                const bIsNum = !isNaN(bNum) && String(b).trim() !== "" && /^-?\d+(\.\d+)?$/.test(String(b).trim());
                const an = typeof a === "number" ? a : parseFloat(String(a));
                const bn = typeof b === "number" ? b : parseFloat(String(b));
                switch (op2) {
                  case "=":
                    return String(a) === String(b);
                  case "!=":
                    return String(a) !== String(b);
                  case ">":
                    return aIsNum && bIsNum ? an > bn : String(a) > String(b);
                  case ">=":
                    return aIsNum && bIsNum ? an >= bn : String(a) >= String(b);
                  case "<":
                    return aIsNum && bIsNum ? an < bn : String(a) < String(b);
                  case "<=":
                    return aIsNum && bIsNum ? an <= bn : String(a) <= String(b);
                  default:
                    return false;
                }
              };
              return cmp(base, val, op);
            };
            pass = evalCondition();
            condDebugValue = pass;
          }
          debugSteps.push({ step: index + 1, operation: `Condition TEST`, value: condDebugValue });
          console.log(`[FormulaEvaluator] \u{1F50D} Condition IF \xE9valu\xE9e: ${pass} (${condDebugValue})`);
          const seqToEval = pass ? item.then || [] : item.else || [];
          console.log(`[FormulaEvaluator] \u{1F4DD} Branche s\xE9lectionn\xE9e: ${pass ? "THEN" : "ELSE"} (${seqToEval.length} \xE9l\xE9ments)`);
          if (seqToEval.length > 0) {
            console.log(`[FormulaEvaluator] \u{1F522} S\xE9quence \xE0 \xE9valuer:`, seqToEval.map((s) => `${s.type}:${s.label || s.value}`));
          }
          if (seqToEval.length === 0) {
            if (!pass && item.elseBehavior === "ignore") {
              itemValue = 0;
            } else {
              itemValue = 0;
            }
            debugSteps.push({ step: index + 1, operation: `Condition ${pass ? "THEN (vide)" : "ELSE (vide)"}`, value: 0 });
          } else {
            const temp = { id: `${formula.id}__cond_${index}`, name: "cond", sequence: seqToEval, targetProperty: "" };
            console.log(`[FormulaEvaluator] \u2699\uFE0F \xC9valuation de la branche ${pass ? "THEN" : "ELSE"} avec fieldValues:`, Object.keys(fieldValues));
            const nested = evaluateFormula(temp, fieldValues, { ...context, depth: (context?.depth || 0) + 1 });
            console.log(`[FormulaEvaluator] \u{1F4CA} R\xE9sultat branche ${pass ? "THEN" : "ELSE"}:`, nested);
            if (!nested.success) throw new Error(`Erreur sous-s\xE9quence condition: ${nested.error}`);
            const valNum = typeof nested.result === "number" ? nested.result : typeof nested.result === "boolean" ? nested.result ? 1 : 0 : 0;
            itemValue = valNum;
            console.log(`[FormulaEvaluator] \u2705 Valeur finale de la condition: ${itemValue}`);
            debugSteps.push({ step: index + 1, operation: `Condition ${pass ? "THEN" : "ELSE"} (r\xE9sultat branche)`, value: valNum });
          }
          itemRaw = itemValue;
          break;
        }
        case "switch": {
          const fieldId = item.switchFieldId || item.fieldId;
          const part = item.switchPart || "selection";
          const raw = context?.rawValues?.[fieldId || ""];
          let key2 = raw;
          if (raw && typeof raw === "object") {
            const obj = raw;
            if (part === "selection") key2 = obj["selection"];
            else if (part === "extra") key2 = obj["extra"];
            else if (part === "nodeId") key2 = obj["nodeId"];
          }
          const cases = item.cases || [];
          const match = cases.find((c) => String(c.value) === String(key2));
          const seqToEval = match ? cDeep(match.seq) : item.defaultSeq || [];
          if (seqToEval.length === 0) {
            itemValue = 0;
            break;
          }
          const temp = { id: `${formula.id}__switch_${index}`, name: "switch", sequence: seqToEval, targetProperty: "" };
          const nested = evaluateFormula(temp, fieldValues, { ...context, depth: (context?.depth || 0) + 1 });
          if (!nested.success) throw new Error(`Erreur switch: ${nested.error}`);
          const valNum = typeof nested.result === "number" ? nested.result : typeof nested.result === "boolean" ? nested.result ? 1 : 0 : 0;
          itemValue = valNum;
          debugSteps.push({ step: index + 1, operation: `Switch valeur=${String(key2)}`, value: valNum });
          itemRaw = itemValue;
          break;
        }
        case "operator":
          currentOperator = String(item.value);
          debugSteps.push({ step: index + 1, operation: `Op\xE9rateur: ${currentOperator}`, value: null });
          return;
        case "function": {
          const functionValue = String(item.value || "").trim();
          if (functionValue.startsWith("IF(")) {
            itemValue = 1;
            debugSteps.push({ step: index + 1, operation: `Function IF d\xE9tect\xE9e`, value: itemValue });
          } else if (functionValue.startsWith("ROUND(")) {
            itemValue = 0;
            debugSteps.push({ step: index + 1, operation: `Function ${functionValue} (non impl\xE9ment\xE9e)`, value: itemValue });
          } else {
            itemValue = 0;
            debugSteps.push({ step: index + 1, operation: `Function ${functionValue} (ignor\xE9e)`, value: itemValue });
          }
          break;
        }
        default:
          throw new Error(`Type d'\xE9l\xE9ment non support\xE9: ${item.type}`);
      }
      if (isFirstValue) {
        result = itemRaw !== void 0 ? itemRaw : itemValue;
        resultRaw = itemRaw;
        isFirstValue = false;
        debugSteps.push({ step: index + 1, operation: "Valeur initiale", value: result });
        return;
      }
      if (currentOperator === null) {
        throw new Error(`Op\xE9rateur manquant avant la valeur \xE0 l'\xE9tape ${index + 1}`);
      }
      console.log(`[FormulaEvaluator] \u{1F522} Op\xE9ration: ${result} ${currentOperator} ${itemValue}`);
      switch (currentOperator) {
        case "+":
          result = (Number(result) || 0) + Number(itemValue);
          break;
        case "-":
          result = (Number(result) || 0) - Number(itemValue);
          break;
        case "*":
          result = (Number(result) || 0) * Number(itemValue);
          break;
        case "/":
          if (itemValue === 0) {
            debugSteps.push({ step: index + 1, operation: "Division par 0 (arr\xEAt)", value: null });
            console.log(`[FormulaEvaluator] \u274C Division par z\xE9ro d\xE9tect\xE9e !`);
            throw new Error("Division par z\xE9ro");
          }
          result = (Number(result) || 0) / Number(itemValue);
          break;
        case "=":
          result = String(resultRaw ?? result) === String(itemRaw ?? itemValue);
          break;
        case "!=":
          result = String(resultRaw ?? result) !== String(itemRaw ?? itemValue);
          break;
        case ">":
          result = Number(result) > Number(itemValue);
          break;
        case "<":
          result = Number(result) < Number(itemValue);
          break;
        case ">=":
          result = Number(result) >= Number(itemValue);
          break;
        case "<=":
          result = Number(result) <= Number(itemValue);
          break;
        case "&&":
          result = Boolean(result) && Boolean(itemValue);
          break;
        case "||":
          result = Boolean(result) || Boolean(itemValue);
          break;
        default:
          throw new Error(`Op\xE9rateur non support\xE9: ${currentOperator}`);
      }
      console.log(`[FormulaEvaluator] \u27A1\uFE0F R\xE9sultat apr\xE8s op\xE9ration: ${result}`);
      debugSteps.push({
        step: index + 1,
        operation: `${currentOperator} ${itemValue}`,
        value: result
      });
      if (["+", "-", "*", "/"].includes(currentOperator || "")) resultRaw = result;
      if (["=", "!="].includes(currentOperator || "")) resultRaw = result;
      currentOperator = null;
    });
    return {
      result,
      success: true,
      debug: debugSteps
    };
  } catch (error) {
    return {
      result: null,
      success: false,
      error: error instanceof Error ? error.message : "Erreur inconnue",
      debug: debugSteps
    };
  }
};

// src/routes/api/formulas.ts
var router45 = import_express46.default.Router({ mergeParams: true });
var prisma22 = db;
router45.get("/all", async (_req, res) => {
  try {
    const formulas = await prisma22.fieldFormula.findMany({
      include: {
        Field: {
          select: {
            id: true,
            label: true
          }
        }
      }
    });
    const formattedFormulas = formulas.map((formula) => ({
      id: formula.id,
      name: formula.name || formula.title || "Formule sans nom",
      // Utiliser title si name est null
      fieldId: formula.fieldId,
      fieldLabel: formula.Field?.label || "Champ inconnu"
    }));
    res.json(formattedFormulas);
  } catch (error) {
    console.error("Erreur lors de la r\xE9cup\xE9ration des formules:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des formules" });
  }
});
router45.get("/field/:fieldId", async (req2, res) => {
  try {
    const { fieldId } = req2.params;
    const formulas = await prisma22.fieldFormula.findMany({
      where: {
        fieldId
      },
      include: {
        Field: {
          select: {
            id: true,
            label: true
          }
        }
      }
    });
    const formattedFormulas = formulas.sort((a, b) => (a.order ?? 0) - (b.order ?? 0)).map((formula) => {
      let parsed = [];
      try {
        const raw = formula.sequence;
        if (typeof raw === "string") parsed = JSON.parse(raw);
        else if (Array.isArray(raw) || raw && typeof raw === "object") parsed = raw;
        else parsed = [];
      } catch {
        parsed = [];
      }
      const title = formula.title;
      const description = formula.description;
      return {
        id: formula.id,
        name: formula.name || title || "Formule sans nom",
        title: formula.name || title || "Formule",
        description: description ?? null,
        order: formula.order ?? 0,
        fieldId: formula.fieldId,
        fieldLabel: formula.Field?.label || "Champ inconnu",
        sequence: parsed
      };
    });
    res.json(formattedFormulas);
  } catch (error) {
    console.error(`Erreur lors de la r\xE9cup\xE9ration des formules pour le champ ${req2.params.fieldId}:`, error);
    res.status(500).json({ error: `Erreur lors de la r\xE9cup\xE9ration des formules pour le champ ${req2.params.fieldId}` });
  }
});
router45.get("/:formulaId/debug", async (req2, res) => {
  const { formulaId } = req2.params;
  try {
    if (!formulaId) return res.status(400).json({ error: "formulaId manquant" });
    const f = await prisma22.fieldFormula.findUnique({ where: { id: formulaId } });
    if (!f) return res.status(404).json({ error: "Formule non trouv\xE9e" });
    let seq = [];
    try {
      seq = typeof f.sequence === "string" ? JSON.parse(f.sequence) : f.sequence;
    } catch {
    }
    let testValues = {};
    if (req2.query.values) {
      try {
        testValues = JSON.parse(String(req2.query.values));
      } catch {
      }
    }
    const result = evaluateFormula({ id: f.id, name: f.name || f.id, sequence: Array.isArray(seq) ? seq : [], targetProperty: "" }, testValues, { rawValues: testValues });
    return res.json({ id: f.id, name: f.name, fieldId: f.fieldId, sequence: seq, evaluation: result });
  } catch (e) {
    console.error("[API][FormulaDebug] Erreur", e);
    return res.status(500).json({ error: "Erreur debug formule", details: e.message });
  }
});
router45.put("/:formulaId", async (req2, res) => {
  try {
    const { formulaId } = req2.params;
    const fieldId = req2.params.id;
    const { name, sequence, order, id } = req2.body;
    console.log(`[API] Mise \xE0 jour formule ${formulaId} pour champ ${fieldId}`);
    console.log(`[API] Donn\xE9es re\xE7ues:`, { id, name, sequence, order });
    if (!fieldId) {
      return res.status(400).json({ error: "ID du champ manquant" });
    }
    try {
      const existingFormula = await prisma22.fieldFormula.findUnique({
        where: { id: formulaId }
      });
      if (!existingFormula) {
        console.log(`[API] Formule ${formulaId} n'existe pas encore, cr\xE9ation...`);
        await prisma22.fieldFormula.create({
          data: {
            id: formulaId,
            fieldId,
            name: name || "Nouvelle formule",
            sequence: sequence ? typeof sequence === "string" ? sequence : JSON.stringify(sequence) : "[]",
            order: order || 0
          }
        });
        console.log(`[API] Formule ${formulaId} cr\xE9\xE9e avec succ\xE8s`);
      }
    } catch (createError) {
      console.error(`[API] Erreur lors de la cr\xE9ation de la formule:`, createError);
    }
    const dataToUpdate = {};
    if (name !== void 0) {
      dataToUpdate.name = name;
    }
    if (sequence !== void 0) {
      dataToUpdate.sequence = JSON.stringify(sequence);
    }
    if (order !== void 0) {
      dataToUpdate.order = order;
    }
    let updatedFormula;
    try {
      updatedFormula = await prisma22.fieldFormula.update({
        where: { id: formulaId },
        data: dataToUpdate
      });
      console.log(`[API] Formule mise \xE0 jour avec succ\xE8s:`, {
        id: updatedFormula.id,
        name: updatedFormula.name
      });
    } catch (updateError) {
      console.error(`[API] Erreur lors de la mise \xE0 jour de la formule:`, updateError);
      updatedFormula = await prisma22.fieldFormula.create({
        data: {
          id: formulaId,
          fieldId,
          name: name || "Nouvelle formule",
          sequence: sequence ? typeof sequence === "string" ? sequence : JSON.stringify(sequence) : "[]",
          order: order || 0
        }
      });
      console.log(`[API] Formule cr\xE9\xE9e avec succ\xE8s comme alternative:`, {
        id: updatedFormula.id,
        name: updatedFormula.name
      });
    }
    const formulas = await prisma22.fieldFormula.findMany({
      where: { fieldId },
      orderBy: { order: "asc" }
    });
    const processedFormulas = formulas.map((f) => ({
      ...f,
      sequence: f.sequence ? JSON.parse(f.sequence) : []
    }));
    console.log(`[API] Retour de ${processedFormulas.length} formules au client`);
    res.json(processedFormulas);
  } catch (err) {
    const { formulaId } = req2.params;
    const fieldId = req2.params.id || "";
    console.error(`Erreur API PUT /api/fields/.../formulas/${formulaId}:`, err);
    if (process.env.NODE_ENV === "development") {
      console.log("[API] Mode d\xE9veloppement, utilisation du syst\xE8me de mock pour la persistance");
      const { sequence, name, order } = req2.body;
      updateFormula(fieldId, formulaId, {
        name,
        sequence,
        order
      });
      const allFormulas = getFormulasForField(fieldId);
      console.log(`[API] Formules mock\xE9es retourn\xE9es: ${allFormulas.length}`);
      return res.json(allFormulas);
    }
    if (err.code === "P2025") {
      res.status(404).json({ error: "Formule non trouv\xE9e" });
    } else {
      res.status(500).json({ error: "Erreur lors de la mise \xE0 jour de la formule", details: err.message });
    }
  }
});
router45.delete("/:formulaId", async (req2, res) => {
  const { formulaId } = req2.params;
  try {
    if (!formulaId) {
      return res.status(400).json({ error: "ID de formule manquant" });
    }
    const existing = await prisma22.fieldFormula.findUnique({ where: { id: formulaId } });
    if (!existing) {
      return res.status(404).json({ error: "Formule non trouv\xE9e" });
    }
    const fieldId = existing.fieldId;
    await prisma22.fieldFormula.delete({ where: { id: formulaId } });
    const formulas = await prisma22.fieldFormula.findMany({
      where: { fieldId },
      orderBy: { order: "asc" }
    });
    const processedFormulas = formulas.map((f) => ({
      ...f,
      sequence: f.sequence ? JSON.parse(f.sequence) : []
    }));
    return res.status(200).json(processedFormulas);
  } catch (err) {
    console.error(`[API] Erreur lors de la suppression de la formule ${req2.params.formulaId}:`, err);
    const e = err;
    if (e.code === "P2025") {
      return res.status(404).json({ error: "Formule non trouv\xE9e" });
    }
    return res.status(500).json({ error: "Erreur interne du serveur lors de la suppression de la formule." });
  }
});
var formulas_default2 = router45;

// src/routes/api/dependencies.ts
var import_express47 = __toESM(require("express"), 1);
init_database();
var router46 = import_express47.default.Router({ mergeParams: true });
var prisma23 = db;
router46.put("/:dependencyId", async (req2, res) => {
  const { dependencyId } = req2.params;
  const { name, description, sequence, order, targetFieldId, operator, value, action: action2, prefillValue } = req2.body || {};
  try {
    const existing = await prisma23.fieldDependency.findUnique({ where: { id: dependencyId } });
    if (!existing) {
      return res.status(404).json({ error: "D\xE9pendance non trouv\xE9e" });
    }
    const dataToUpdate = {};
    if (name !== void 0) dataToUpdate.name = name;
    if (description !== void 0) dataToUpdate.description = description;
    if (sequence !== void 0) dataToUpdate.sequence = JSON.stringify(sequence);
    if (order !== void 0) dataToUpdate.order = order;
    if (targetFieldId !== void 0) dataToUpdate.dependsOnId = targetFieldId;
    if (operator !== void 0) dataToUpdate.condition = operator;
    if (value !== void 0) dataToUpdate.value = value;
    if (action2 !== void 0 || prefillValue !== void 0) dataToUpdate.params = { action: action2, prefillValue };
    await prisma23.fieldDependency.update({ where: { id: dependencyId }, data: dataToUpdate });
    const deps = await prisma23.fieldDependency.findMany({
      where: { fieldId: existing.fieldId },
      orderBy: { order: "asc" }
    });
    const processed = deps.map((d) => ({
      ...d,
      sequence: typeof d.sequence === "string" ? JSON.parse(d.sequence) : d.sequence ?? []
    }));
    return res.json(processed);
  } catch (error) {
    console.error(`[API] Erreur PUT /api/dependencies/${dependencyId}:`, error);
    return res.status(500).json({ error: "Erreur lors de la mise \xE0 jour de la d\xE9pendance", details: error.message });
  }
});
router46.delete("/:dependencyId", async (req2, res) => {
  const { dependencyId } = req2.params;
  try {
    const existing = await prisma23.fieldDependency.findUnique({ where: { id: dependencyId } });
    if (!existing) {
      return res.status(404).json({ error: "D\xE9pendance non trouv\xE9e" });
    }
    const fieldId = existing.fieldId;
    await prisma23.fieldDependency.delete({ where: { id: dependencyId } });
    const deps = await prisma23.fieldDependency.findMany({ where: { fieldId }, orderBy: { order: "asc" } });
    const processed = deps.map((d) => ({
      ...d,
      sequence: typeof d.sequence === "string" ? JSON.parse(d.sequence) : d.sequence ?? []
    }));
    return res.status(200).json(processed);
  } catch (error) {
    console.error(`[API] Erreur DELETE /api/dependencies/${req2.params.dependencyId}:`, error);
    const errObj = error;
    if (errObj?.code === "P2025") {
      return res.status(404).json({ error: "D\xE9pendance non trouv\xE9e" });
    }
    return res.status(500).json({ error: "Erreur lors de la suppression de la d\xE9pendance", details: error.message });
  }
});
var dependencies_default2 = router46;

// src/routes/sections.ts
var import_express48 = require("express");
init_prisma();
var router47 = (0, import_express48.Router)();
router47.use(authMiddleware, impersonationMiddleware);
router47.get("/", async (req2, res) => {
  try {
    const organizationId = req2.query.organizationId;
    console.log("[SECTIONS\u2192CATEGORIES] GET - R\xE9cup\xE9ration des Categories existantes depuis admin-modules");
    const categories = await db.category.findMany({
      where: organizationId ? {
        OR: [
          { organizationId },
          { organizationId: null }
          // Categories globales
        ]
      } : void 0,
      orderBy: { order: "asc" }
    });
    const sectionsFormat = categories.map((category) => ({
      id: category.id,
      title: category.name,
      description: category.description || "",
      iconName: category.icon,
      iconColor: category.iconColor,
      order: category.order,
      active: category.active,
      organizationId: category.organizationId,
      createdAt: category.createdAt.toISOString(),
      updatedAt: category.updatedAt.toISOString()
    }));
    console.log(`[SECTIONS\u2192CATEGORIES] ${sectionsFormat.length} Categories existantes converties en sections`);
    console.log(`[SECTIONS\u2192CATEGORIES] Categories trouv\xE9es: ${sectionsFormat.map((s) => s.title).join(", ")}`);
    res.json(sectionsFormat);
  } catch (error) {
    console.error("[SECTIONS\u2192CATEGORIES] Erreur GET:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la r\xE9cup\xE9ration des sections"
    });
  }
});
router47.post("/bulk", async (req2, res) => {
  try {
    const { sections } = req2.body;
    console.log(`[SECTIONS\u2192CATEGORIES] POST/bulk - Cr\xE9ation de ${sections.length} Categories`);
    const categoriesToCreate = sections.map((section) => ({
      name: section.title,
      description: section.description,
      icon: section.iconName,
      iconColor: section.iconColor,
      order: section.order,
      active: section.active,
      organizationId: section.organizationId,
      superAdminOnly: false
    }));
    const createdCategories = await Promise.all(
      categoriesToCreate.map(
        (category) => db.category.create({ data: category })
      )
    );
    const sectionsFormat = createdCategories.map((category) => ({
      id: category.id,
      title: category.name,
      description: category.description || "",
      iconName: category.icon,
      iconColor: category.iconColor,
      order: category.order,
      active: category.active,
      organizationId: category.organizationId,
      createdAt: category.createdAt.toISOString(),
      updatedAt: category.updatedAt.toISOString()
    }));
    console.log(`[SECTIONS\u2192CATEGORIES] ${createdCategories.length} Categories cr\xE9\xE9es avec succ\xE8s`);
    res.json(sectionsFormat);
  } catch (error) {
    console.error("[SECTIONS\u2192CATEGORIES] Erreur POST/bulk:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la cr\xE9ation des sections"
    });
  }
});
router47.post("/", async (req2, res) => {
  try {
    const { name, description, iconName, iconColor, order, active, organizationId } = req2.body;
    console.log(`[SECTIONS\u2192CATEGORIES] POST - Cr\xE9ation Category "${name}"`);
    const category = await db.category.create({
      data: {
        name,
        description: description || `Category ${name}`,
        icon: iconName || "AppstoreOutlined",
        iconColor: iconColor || "#1890ff",
        order: order || 999,
        active: active !== false,
        organizationId,
        superAdminOnly: false
      }
    });
    const sectionFormat = {
      id: category.id,
      title: category.name,
      description: category.description || "",
      iconName: category.icon,
      iconColor: category.iconColor,
      order: category.order,
      active: category.active,
      organizationId: category.organizationId,
      createdAt: category.createdAt.toISOString(),
      updatedAt: category.updatedAt.toISOString()
    };
    console.log(`[SECTIONS\u2192CATEGORIES] Category "${name}" cr\xE9\xE9e avec succ\xE8s`);
    res.json({ success: true, data: sectionFormat });
  } catch (error) {
    console.error("[SECTIONS\u2192CATEGORIES] Erreur POST:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la cr\xE9ation de la section"
    });
  }
});
router47.patch("/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const updateData = req2.body;
    console.log(`[SECTIONS\u2192CATEGORIES] PATCH - Mise \xE0 jour Category ${id}`);
    const categoryUpdateData = {};
    if (updateData.title) categoryUpdateData.name = updateData.title;
    if (updateData.description !== void 0) categoryUpdateData.description = updateData.description;
    if (updateData.iconName) categoryUpdateData.icon = updateData.iconName;
    if (updateData.iconColor) categoryUpdateData.iconColor = updateData.iconColor;
    if (updateData.order !== void 0) categoryUpdateData.order = updateData.order;
    if (updateData.active !== void 0) categoryUpdateData.active = updateData.active;
    const category = await db.category.update({
      where: { id },
      data: categoryUpdateData
    });
    const sectionFormat = {
      id: category.id,
      title: category.name,
      description: category.description || "",
      iconName: category.icon,
      iconColor: category.iconColor,
      order: category.order,
      active: category.active,
      organizationId: category.organizationId,
      createdAt: category.createdAt.toISOString(),
      updatedAt: category.updatedAt.toISOString()
    };
    console.log(`[SECTIONS\u2192CATEGORIES] Category ${id} mise \xE0 jour avec succ\xE8s`);
    res.json(sectionFormat);
  } catch (error) {
    console.error("[SECTIONS\u2192CATEGORIES] Erreur PATCH:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la mise \xE0 jour de la section"
    });
  }
});
router47.delete("/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    console.log(`[SECTIONS\u2192CATEGORIES] DELETE - Suppression Category ${id}`);
    await db.category.delete({
      where: { id }
    });
    console.log(`[SECTIONS\u2192CATEGORIES] Category ${id} supprim\xE9e avec succ\xE8s`);
    res.json({ success: true });
  } catch (error) {
    console.error("[SECTIONS\u2192CATEGORIES] Erreur DELETE:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la suppression de la section"
    });
  }
});
var sections_default = router47;

// src/routes/module-navigation.ts
var import_express49 = require("express");
init_prisma();
var router48 = (0, import_express49.Router)();
router48.use(authMiddleware, impersonationMiddleware);
router48.get("/", async (req2, res) => {
  try {
    const organizationId = req2.query.organizationId;
    if (!organizationId) {
      res.status(400).json({ error: "organizationId required" });
      return;
    }
    const user = req2.user;
    const isSuperAdmin2 = user?.role === "super_admin";
    let userOrganizationId = user?.organizationId;
    if (!userOrganizationId && user?.id) {
      const userOrg = await db.userOrganization.findFirst({
        where: { userId: user.id }
      });
      userOrganizationId = userOrg?.organizationId;
    }
    const whereCategories = {
      AND: [
        // Cat√©gories actives uniquement
        { active: true },
        // Cat√©gories globales OU sp√©cifiques √† l'organisation
        {
          OR: [
            { organizationId: null },
            // Cat√©gories globales
            { organizationId }
            // Cat√©gories sp√©cifiques √† l'org
          ]
        },
        // V√©rification superAdminOnly
        ...isSuperAdmin2 ? [] : [{ superAdminOnly: false }]
      ]
    };
    const categories = await db.category.findMany({
      where: whereCategories,
      include: {
        // Inclure les modules associ√©s
        Module: {
          where: {
            AND: [
              // Modules actifs uniquement
              { active: true },
              // V√©rification superAdminOnly pour les modules
              ...isSuperAdmin2 ? [] : [{ superAdminOnly: false }],
              // Modules pour cette organisation ou modules globaux
              {
                OR: [
                  ...userOrganizationId ? [{ organizationId: userOrganizationId }] : [],
                  ...isSuperAdmin2 ? [{ organizationId: null }] : []
                ]
              }
            ]
          },
          orderBy: { order: "asc" }
        }
      },
      orderBy: { order: "asc" }
    });
    const sections = categories.map((category) => ({
      id: `section-${category.id}`,
      title: category.name,
      description: category.description || category.Module.map((m) => m.label).join(", "),
      icon: category.icon,
      iconColor: category.iconColor,
      order: category.order,
      organizationId,
      modules: category.Module.map((module2) => ({
        ...module2,
        category: category.name,
        // ‚úÖ Ajouter le nom de la cat√©gorie √† chaque module
        categoryIcon: category.icon,
        categoryColor: category.iconColor
      })),
      createdAt: category.createdAt.toISOString(),
      updatedAt: category.updatedAt.toISOString(),
      // M√©tadonn√©es pour debugging
      categoryId: category.id,
      superAdminOnly: category.superAdminOnly,
      allowedRoles: category.allowedRoles,
      requiredPermissions: category.requiredPermissions
    }));
    res.json(sections);
  } catch (error) {
    console.error("[module-navigation] Erreur:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des cat\xE9gories depuis la table Category" });
  }
});
var module_navigation_default = router48;

// src/routes/form-sections.ts
var import_express50 = require("express");
init_database();
var router49 = (0, import_express50.Router)();
var prisma24 = db;
router49.get("/:blockId", async (req2, res) => {
  const { blockId } = req2.params;
  try {
    console.log(`[API] GET /api/form-sections/${blockId} - R\xE9cup\xE9ration sections de formulaire`);
    const sections = await prisma24.section.findMany({
      where: { blockId },
      include: {
        Field: {
          // Inclure les champs pour chaque section
          orderBy: {
            order: "asc"
          }
        }
      },
      orderBy: {
        order: "asc"
      }
    });
    const adaptedSections = sections.map((section) => ({
      ...section,
      fields: section.Field || []
      // 'Field' est maintenant inclus et disponible
    }));
    console.log(`[API] ${adaptedSections.length} sections de formulaire trouv\xE9es pour bloc ${blockId}`);
    res.json(adaptedSections);
  } catch (e) {
    console.error(`[API] Erreur r\xE9cup\xE9ration sections pour bloc ${blockId}:`, e);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des sections", details: e });
  }
});
router49.post("/", async (req2, res) => {
  try {
    const { name, blockId, order, sectionType } = req2.body;
    console.log(`[API] POST /api/form-sections - Cr\xE9ation section: ${name} pour bloc ${blockId}`);
    if (!name || !blockId) {
      res.status(400).json({ error: "Name et blockId requis" });
      return;
    }
    const section = await prisma24.section.create({
      data: {
        id: `section-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        name,
        blockId,
        order: order || 0,
        sectionType: sectionType || "normal",
        active: true
      },
      include: {
        Field: true
      }
    });
    console.log(`[API] \u2705 Section de formulaire cr\xE9\xE9e: ${section.id}`);
    res.json({ success: true, data: section });
  } catch (error) {
    console.error("[API] Erreur cr\xE9ation section:", error);
    res.status(500).json({ error: "Erreur lors de la cr\xE9ation de la section de formulaire" });
  }
});
router49.put("/:sectionId", async (req2, res) => {
  try {
    const { sectionId } = req2.params;
    const { name, order, sectionType, active } = req2.body;
    console.log(`[API] PUT /api/form-sections/${sectionId} - Modification section`);
    const section = await prisma24.section.update({
      where: { id: sectionId },
      data: {
        ...name && { name },
        ...order !== void 0 && { order },
        ...sectionType && { sectionType },
        ...active !== void 0 && { active }
      },
      include: {
        Field: true
      }
    });
    console.log(`[API] \u2705 Section de formulaire modifi\xE9e: ${section.id}`);
    res.json({ success: true, data: section });
  } catch (error) {
    console.error(`[API] Erreur modification section ${req2.params.sectionId}:`, error);
    res.status(500).json({ error: "Erreur lors de la modification de la section de formulaire" });
  }
});
router49.delete("/:sectionId", async (req2, res) => {
  try {
    const { sectionId } = req2.params;
    console.log(`[API] DELETE /api/form-sections/${sectionId} - Suppression section`);
    await prisma24.section.delete({
      where: { id: sectionId }
    });
    console.log(`[API] \u2705 Section de formulaire supprim\xE9e: ${sectionId}`);
    res.json({ success: true, message: "Section de formulaire supprim\xE9e" });
  } catch (error) {
    console.error(`[API] Erreur suppression section ${req2.params.sectionId}:`, error);
    res.status(500).json({ error: "Erreur lors de la suppression de la section de formulaire" });
  }
});
var form_sections_default = router49;

// src/routes/fieldTypes.ts
var import_express51 = require("express");
init_database();
var router50 = (0, import_express51.Router)();
var prisma25 = db;
router50.use(authMiddleware);
router50.get("/", async (_req, res) => {
  try {
    const types = await prisma25.fieldType.findMany({
      orderBy: { label: "asc" }
    });
    res.json({ success: true, data: types });
  } catch (error) {
    console.error("[API] Erreur GET /api/field-types:", error);
    res.status(500).json({ success: false, message: "Erreur serveur lors de la r\xE9cup\xE9ration des types de champs" });
  }
});
var fieldTypes_default = router50;

// src/routes/optionNodes.ts
var import_express52 = require("express");
init_database();
var router51 = (0, import_express52.Router)();
var prisma26 = db;
router51.use(authMiddleware);
function buildTree(nodes) {
  const byId = new Map(nodes.map((n) => [n.id, { ...n, children: [] }]));
  const roots = [];
  nodes.forEach((n) => {
    if (n.parentId && byId.has(n.parentId)) {
      const parent = byId.get(n.parentId);
      parent.children.push(byId.get(n.id));
    } else {
      roots.push(byId.get(n.id));
    }
  });
  const sortRec = (arr) => {
    arr.sort((a, b) => (a.order ?? 0) - (b.order ?? 0));
    arr.forEach((c) => sortRec(c.children || []));
  };
  sortRec(roots);
  return roots;
}
router51.get("/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const node = await prisma26.fieldOptionNode.findUnique({ where: { id }, select: { id: true, label: true, value: true, parentId: true, order: true, data: true, fieldId: true } });
    if (!node) return res.status(404).json({ success: false, message: "Not found" });
    return res.json({ success: true, data: node });
  } catch (e) {
    console.error("[API] GET option-node detail error:", e);
    return res.status(500).json({ success: false, message: "Erreur serveur" });
  }
});
router51.get("/field/:fieldId/tree", async (req2, res) => {
  try {
    const { fieldId } = req2.params;
    const nodes = await prisma26.fieldOptionNode.findMany({
      where: { fieldId },
      orderBy: [{ parentId: "asc" }, { order: "asc" }],
      select: { id: true, label: true, value: true, parentId: true, order: true, data: true }
    });
    const tree = buildTree(nodes);
    const childrenCount = /* @__PURE__ */ new Map();
    tree.forEach(function collect(n) {
      n.children.forEach((c) => collect(c));
      if (n.parentId) {
        childrenCount.set(n.parentId, (childrenCount.get(n.parentId) || 0) + 1);
      }
    });
    const enrich = (n, pathIds, pathLabels) => {
      const nextIds = [...pathIds, n.id];
      const nextLabels = [...pathLabels, n.label];
      const children = n.children.map((c) => enrich(c, nextIds, nextLabels));
      const dataObj = n.data && typeof n.data === "object" ? n.data : {};
      const hasExtra = Object.prototype.hasOwnProperty.call(dataObj, "nextField") && !!dataObj.nextField;
      return {
        id: n.id,
        label: n.label,
        value: n.value,
        parentId: n.parentId,
        order: n.order,
        data: n.data,
        children,
        hasChildren: children.length > 0,
        hasExtra,
        pathIds: nextIds,
        pathLabels: nextLabels
      };
    };
    const enriched = tree.map((r) => enrich(r, [], []));
    return res.json({ success: true, data: enriched, _v: 1 });
  } catch (e) {
    console.error("[API] GET option-nodes tree error:", e);
    return res.status(500).json({ success: false, message: "Erreur serveur" });
  }
});
router51.get("/field/:fieldId/children", async (req2, res) => {
  try {
    const { fieldId } = req2.params;
    const parentId = req2.query.parentId || null;
    const base = await prisma26.fieldOptionNode.findMany({ where: { fieldId, parentId }, orderBy: { order: "asc" } });
    const children = base.map((b) => ({ id: b.id, label: b.label, value: b.value ?? void 0 }));
    return res.json({ success: true, data: children });
  } catch (e) {
    console.error("[API] GET option-nodes children error:", e);
    return res.status(500).json({ success: false, message: "Erreur serveur" });
  }
});
router51.post("/", async (req2, res) => {
  try {
    const { fieldId, parentId, label, value, order, data } = req2.body;
    if (!fieldId || !label) return res.status(400).json({ success: false, message: "fieldId et label requis" });
    const created = await prisma26.fieldOptionNode.create({
      data: {
        fieldId,
        parentId: parentId ?? null,
        label,
        value: value ?? label,
        // Use label as value if not provided
        order: order ?? 0,
        data: data ?? void 0
      }
    });
    return res.json({ success: true, data: created });
  } catch (e) {
    console.error("[API] POST option-nodes create error:", e);
    return res.status(500).json({ success: false, message: "Erreur serveur" });
  }
});
router51.put("/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { label, value, order, data, parentId } = req2.body;
    const updated = await prisma26.fieldOptionNode.update({ where: { id }, data: { label: label ?? void 0, value: value === void 0 ? void 0 : value, order: order ?? void 0, data: data === void 0 ? void 0 : data, parentId: parentId === void 0 ? void 0 : parentId } });
    return res.json({ success: true, data: updated });
  } catch (e) {
    console.error("[API] PUT option-nodes update error:", e);
    return res.status(500).json({ success: false, message: "Erreur serveur" });
  }
});
router51.delete("/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const mode = req2.query.mode || "with-children";
    if (mode === "only") {
      const node = await prisma26.fieldOptionNode.findUnique({ where: { id }, select: { parentId: true } });
      if (!node) return res.status(404).json({ success: false, message: "Not found" });
      await prisma26.$transaction([
        prisma26.fieldOptionNode.updateMany({ where: { parentId: id }, data: { parentId: node.parentId } }),
        prisma26.fieldOptionNode.delete({ where: { id } })
      ]);
      return res.json({ success: true });
    }
    const collectIds = async (ids) => {
      const children = await prisma26.fieldOptionNode.findMany({ where: { parentId: { in: ids } }, select: { id: true } });
      if (children.length === 0) return ids;
      const childIds = children.map((c) => c.id);
      const all = await collectIds(childIds);
      return [...ids, ...all];
    };
    const allIds = await collectIds([id]);
    await prisma26.fieldOptionNode.deleteMany({ where: { id: { in: allIds } } });
    return res.json({ success: true });
  } catch (e) {
    console.error("[API] DELETE option-nodes error:", e);
    return res.status(500).json({ success: false, message: "Erreur serveur" });
  }
});
router51.post("/reorder", async (req2, res) => {
  try {
    const { fieldId, orderedIds } = req2.body;
    if (!fieldId || !Array.isArray(orderedIds)) return res.status(400).json({ success: false, message: "Payload invalide" });
    await prisma26.$transaction(orderedIds.map((id, idx) => prisma26.fieldOptionNode.update({ where: { id }, data: { order: idx } })));
    return res.json({ success: true });
  } catch (e) {
    console.error("[API] POST option-nodes reorder error:", e);
    return res.status(500).json({ success: false, message: "Erreur serveur" });
  }
});
router51.post("/import", async (req2, res) => {
  try {
    const { fieldId, tree } = req2.body;
    if (!fieldId || !Array.isArray(tree)) return res.status(400).json({ success: false, message: "Payload invalide" });
    await prisma26.fieldOptionNode.deleteMany({ where: { fieldId } });
    const inserts = [];
    const walk = (nodes, parentId) => {
      nodes.forEach((n, idx) => {
        const id = n.id || void 0;
        inserts.push(prisma26.fieldOptionNode.create({ data: { id, fieldId, parentId, label: n.label, value: n.value ?? null, order: idx, data: n.data ?? void 0 } }));
        if (Array.isArray(n.children) && n.children.length > 0) {
          if (!n.id) {
            throw new Error("Chaque n\u0153ud avec enfants doit fournir un id pour import");
          }
          walk(n.children, n.id);
        }
      });
    };
    walk(tree, null);
    await Promise.all(inserts);
    return res.json({ success: true });
  } catch (e) {
    console.error("[API] POST option-nodes import error:", e);
    return res.status(500).json({ success: false, message: e?.message || "Erreur serveur" });
  }
});
router51.get("/export/:fieldId", async (req2, res) => {
  try {
    const { fieldId } = req2.params;
    const nodes = await prisma26.fieldOptionNode.findMany({ where: { fieldId }, orderBy: [{ parentId: "asc" }, { order: "asc" }], select: { id: true, label: true, value: true, parentId: true, order: true, data: true } });
    return res.json({ success: true, data: buildTree(nodes) });
  } catch (e) {
    console.error("[API] GET option-nodes export error:", e);
    return res.status(500).json({ success: false, message: "Erreur serveur" });
  }
});
var optionNodes_default = router51;

// src/api/advanced-select.js
var import_express53 = __toESM(require("express"), 1);

// src/services/AdvancedSelectService.js
init_database();
var prisma27 = db;
var AdvancedSelectService = class {
  constructor() {
    this.validationRules = {
      "realistic_energy_price": {
        condition: (value) => value >= 0.05 && value <= 0.5,
        message: "Prix \xE9nerg\xE9tique irr\xE9aliste (attendu: 0.05\u20AC - 0.50\u20AC/kWh)",
        level: "warning"
      },
      "positive_number": {
        condition: (value) => value > 0,
        message: "La valeur doit \xEAtre sup\xE9rieure \xE0 0",
        level: "error"
      },
      "consumption_realistic": {
        condition: (value) => value >= 1e3 && value <= 5e4,
        message: "Consommation annuelle attendue: 1,000 - 50,000 kWh",
        level: "info"
      }
    };
  }
  /**
   * üìù R√©cup√©rer un champ advanced_select avec ses options
   */
  async getAdvancedSelectField(fieldId, organizationId) {
    try {
      const field = await prisma27.field.findFirst({
        where: {
          id: fieldId,
          Section: {
            Block: {
              organizationId
            }
          }
        },
        include: {
          optionNodes: {
            orderBy: { order: "asc" }
          },
          Section: {
            include: {
              Block: true
            }
          }
        }
      });
      if (!field) {
        throw new Error(`Champ advanced_select ${fieldId} non trouv\xE9`);
      }
      const enrichedOptions = field.optionNodes.map((option) => ({
        ...option,
        config: this.parseOptionConfig(option.data),
        hasFormula: this.hasFormula(option.data),
        hasValidation: this.hasValidation(option.data)
      }));
      return {
        ...field,
        optionNodes: enrichedOptions,
        capabilities: {
          hasCalculations: enrichedOptions.some((opt) => opt.hasFormula),
          hasValidations: enrichedOptions.some((opt) => opt.hasValidation),
          supportsDynamicFields: true,
          supportsWorkflows: true
        }
      };
    } catch (error) {
      console.error("Erreur lors de la r\xE9cup\xE9ration du champ advanced_select:", error);
      throw error;
    }
  }
  /**
   * üßÆ Effectuer un calcul bas√© sur les options s√©lectionn√©es
   */
  async performCalculation(fieldId, optionValue, inputData2, relatedFieldsData2 = {}) {
    try {
      const option = await prisma27.fieldOptionNode.findFirst({
        where: {
          fieldId,
          value: optionValue
        }
      });
      if (!option || !option.data) {
        throw new Error(`Option ${optionValue} non trouv\xE9e ou mal configur\xE9e`);
      }
      const config = this.parseOptionConfig(option.data);
      if (!config.formula) {
        return {
          success: true,
          result: inputData2,
          type: "direct_value",
          validation: this.validateResult(inputData2, config.businessLogic?.unit)
        };
      }
      let result;
      switch (config.formula.type) {
        case "division":
          result = await this.performDivisionCalculation(
            config.formula,
            inputData2,
            relatedFieldsData2
          );
          break;
        case "multiplication":
          result = await this.performMultiplicationCalculation(
            config.formula,
            inputData2,
            relatedFieldsData2
          );
          break;
        case "conditional":
          result = await this.performConditionalCalculation(
            config.formula,
            inputData2,
            relatedFieldsData2
          );
          break;
        default:
          throw new Error(`Type de formule non support\xE9: ${config.formula.type}`);
      }
      const validation = this.validateResult(result, config.businessLogic?.unit);
      await this.logCalculation(fieldId, optionValue, inputData2, result, validation);
      return {
        success: true,
        result,
        type: config.formula.type,
        validation,
        metadata: {
          formula: config.formula,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          inputs: { inputData: inputData2, relatedFieldsData: relatedFieldsData2 }
        }
      };
    } catch (error) {
      console.error("Erreur lors du calcul:", error);
      return {
        success: false,
        error: error.message,
        type: "error"
      };
    }
  }
  /**
   * ‚ûó Calcul de division (ex: prix total / consommation)
   */
  async performDivisionCalculation(formula, numerator, relatedFieldsData2) {
    const denominatorFieldId = formula.denominator;
    const denominatorValue = relatedFieldsData2[denominatorFieldId];
    if (!denominatorValue || denominatorValue <= 0) {
      throw new Error("Le diviseur doit \xEAtre sup\xE9rieur \xE0 0");
    }
    const result = parseFloat(numerator) / parseFloat(denominatorValue);
    const precision = formula.precision || 3;
    return parseFloat(result.toFixed(precision));
  }
  /**
   * ‚úñÔ∏è Calcul de multiplication
   */
  async performMultiplicationCalculation(formula, factor1, relatedFieldsData2) {
    const factor2FieldId = formula.factor2;
    const factor2Value = relatedFieldsData2[factor2FieldId];
    if (!factor2Value) {
      throw new Error("Le second facteur est requis pour la multiplication");
    }
    const result = parseFloat(factor1) * parseFloat(factor2Value);
    const precision = formula.precision || 2;
    return parseFloat(result.toFixed(precision));
  }
  /**
   * üîÄ Calcul conditionnel
   */
  async performConditionalCalculation(formula, inputData2, relatedFieldsData2) {
    for (const condition of formula.conditions) {
      if (this.evaluateCondition(condition.when, relatedFieldsData2)) {
        return this.executeFormulaAction(condition.then, inputData2, relatedFieldsData2);
      }
    }
    return formula.default || inputData2;
  }
  /**
   * ‚úÖ Validation intelligente des r√©sultats
   */
  validateResult(value, unit = null) {
    const validations = [];
    if (value <= 0) {
      validations.push({
        type: "error",
        message: "Le r\xE9sultat doit \xEAtre sup\xE9rieur \xE0 0",
        rule: "positive_number"
      });
    }
    if (unit === "EUR/kWh") {
      if (value < 0.05 || value > 0.5) {
        validations.push({
          type: "warning",
          message: `Prix ${value.toFixed(3)} \u20AC/kWh semble ${value < 0.05 ? "tr\xE8s bas" : "tr\xE8s \xE9lev\xE9"}`,
          rule: "realistic_energy_price"
        });
      } else {
        validations.push({
          type: "success",
          message: `Prix ${value.toFixed(3)} \u20AC/kWh dans la fourchette normale`,
          rule: "realistic_energy_price"
        });
      }
    }
    return {
      isValid: validations.filter((v) => v.type === "error").length === 0,
      validations,
      summary: this.getValidationSummary(validations)
    };
  }
  /**
   * üîç √âvaluer une condition
   */
  evaluateCondition(condition, data) {
    const regex = /(\w+)\s*(==|!=|>|<|>=|<=)\s*'([^']+)'/;
    const match = condition.match(regex);
    if (!match) return false;
    const [, fieldId, operator, expectedValue] = match;
    const actualValue = data[fieldId];
    switch (operator) {
      case "==":
        return actualValue == expectedValue;
      case "!=":
        return actualValue != expectedValue;
      case ">":
        return parseFloat(actualValue) > parseFloat(expectedValue);
      case "<":
        return parseFloat(actualValue) < parseFloat(expectedValue);
      case ">=":
        return parseFloat(actualValue) >= parseFloat(expectedValue);
      case "<=":
        return parseFloat(actualValue) <= parseFloat(expectedValue);
      default:
        return false;
    }
  }
  /**
   * ‚ö° Ex√©cuter une action de formule
   */
  executeFormulaAction(action, inputData, relatedFieldsData) {
    let processedAction = action;
    processedAction = processedAction.replace(/\{\{input_value\}\}/g, inputData);
    processedAction = processedAction.replace(/\{\{field:(\w+)\}\}/g, (match, fieldId) => {
      return relatedFieldsData[fieldId] || 0;
    });
    try {
      const sanitized = processedAction.replace(/[^0-9+\-*/().\s]/g, "");
      return eval(sanitized);
    } catch (error) {
      throw new Error(`Erreur dans l'\xE9valuation de la formule: ${error.message}`);
    }
  }
  /**
   * üìä Mettre √† jour un champ calcul√©
   */
  async updateCalculatedField(targetFieldId, value, organizationId, metadata = {}) {
    try {
      const field = await prisma27.field.findFirst({
        where: {
          id: targetFieldId,
          Section: {
            Block: {
              organizationId
            }
          }
        }
      });
      if (!field) {
        throw new Error(`Champ cible ${targetFieldId} non trouv\xE9`);
      }
      const updatedConfig = {
        ...field.advancedConfig,
        calculatedValue: value,
        lastCalculation: {
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          value,
          metadata
        }
      };
      await prisma27.field.update({
        where: { id: targetFieldId },
        data: { advancedConfig: updatedConfig }
      });
      return {
        success: true,
        fieldId: targetFieldId,
        value,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
    } catch (error) {
      console.error("Erreur lors de la mise \xE0 jour du champ calcul\xE9:", error);
      throw error;
    }
  }
  /**
   * üìù Logger les calculs pour audit
   */
  async logCalculation(fieldId, optionValue, inputData2, result, validation) {
    console.log("\u{1F4CA} CALCUL EFFECTU\xC9:", {
      fieldId,
      optionValue,
      inputData: inputData2,
      result,
      validation: validation.summary,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  /**
   * üîß Fonctions utilitaires
   */
  parseOptionConfig(data) {
    if (typeof data === "string") {
      try {
        return JSON.parse(data);
      } catch {
        return {};
      }
    }
    return data || {};
  }
  hasFormula(data) {
    const config = this.parseOptionConfig(data);
    return !!(config.formula && config.formula.type);
  }
  hasValidation(data) {
    const config = this.parseOptionConfig(data);
    return !!(config.validation || config.businessLogic);
  }
  getValidationSummary(validations) {
    const errors = validations.filter((v) => v.type === "error");
    const warnings = validations.filter((v) => v.type === "warning");
    const successes = validations.filter((v) => v.type === "success");
    if (errors.length > 0) {
      return { type: "error", message: errors[0].message };
    } else if (warnings.length > 0) {
      return { type: "warning", message: warnings[0].message };
    } else if (successes.length > 0) {
      return { type: "success", message: successes[0].message };
    } else {
      return { type: "info", message: "Validation en attente" };
    }
  }
};
module.exports = AdvancedSelectService;
var AdvancedSelectService_default = AdvancedSelectService;

// src/api/advanced-select.js
var router52 = import_express53.default.Router();
var advancedSelectService = new AdvancedSelectService_default();
router52.get("/:fieldId", async (req2, res) => {
  try {
    const { fieldId } = req2.params;
    const { organizationId } = req2.query;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        error: "organizationId est requis"
      });
    }
    const field = await advancedSelectService.getAdvancedSelectField(fieldId, organizationId);
    res.json({
      success: true,
      data: field,
      metadata: {
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        capabilities: field.capabilities
      }
    });
  } catch (error) {
    console.error("Erreur GET advanced-select:", error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});
router52.post("/:fieldId/calculate", async (req2, res) => {
  try {
    const { fieldId } = req2.params;
    const {
      optionValue,
      inputData: inputData2,
      relatedFieldsData: relatedFieldsData2 = {},
      organizationId
    } = req2.body;
    if (!optionValue || inputData2 === void 0) {
      return res.status(400).json({
        success: false,
        error: "optionValue et inputData sont requis"
      });
    }
    const calculationResult = await advancedSelectService.performCalculation(
      fieldId,
      optionValue,
      inputData2,
      relatedFieldsData2
    );
    if (calculationResult.success && calculationResult.metadata?.formula?.result_field) {
      const targetFieldId = calculationResult.metadata.formula.result_field;
      await advancedSelectService.updateCalculatedField(
        targetFieldId,
        calculationResult.result,
        organizationId,
        {
          sourceField: fieldId,
          calculation: calculationResult.metadata
        }
      );
    }
    res.json({
      success: true,
      data: calculationResult,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("Erreur POST calculate:", error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});
router52.put("/:fieldId/update", async (req2, res) => {
  try {
    const { fieldId } = req2.params;
    const { value, organizationId, metadata = {} } = req2.body;
    if (value === void 0 || !organizationId) {
      return res.status(400).json({
        success: false,
        error: "value et organizationId sont requis"
      });
    }
    const updateResult = await advancedSelectService.updateCalculatedField(
      fieldId,
      value,
      organizationId,
      metadata
    );
    res.json({
      success: true,
      data: updateResult
    });
  } catch (error) {
    console.error("Erreur PUT update:", error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});
router52.post("/validate", async (req2, res) => {
  try {
    const { value, unit, rules = [] } = req2.body;
    if (value === void 0) {
      return res.status(400).json({
        success: false,
        error: "value est requis"
      });
    }
    const validation = advancedSelectService.validateResult(value, unit);
    res.json({
      success: true,
      data: {
        isValid: validation.isValid,
        validations: validation.validations,
        summary: validation.summary
      }
    });
  } catch (error) {
    console.error("Erreur POST validate:", error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});
router52.post("/templates", async (req2, res) => {
  try {
    const { templateType, fieldConfig, organizationId } = req2.body;
    if (!templateType || !fieldConfig || !organizationId) {
      return res.status(400).json({
        success: false,
        error: "templateType, fieldConfig et organizationId sont requis"
      });
    }
    const templates = {
      "energy_pricing": {
        name: "Calcul Prix \xC9nerg\xE9tique",
        description: "Template pour calculer des prix \xE9nerg\xE9tiques automatiquement",
        options: [
          {
            label: "Calcul automatique",
            value: "auto_calculate",
            data: {
              nextField: {
                type: "number",
                placeholder: "Montant total (\u20AC)",
                validation: { required: true, min: 0 }
              },
              formula: {
                type: "division",
                denominator: fieldConfig.consumptionFieldId,
                result_field: fieldConfig.resultFieldId,
                precision: 3
              },
              businessLogic: {
                category: "energy_calculation",
                unit: "EUR/kWh"
              }
            }
          },
          {
            label: "Saisie directe",
            value: "direct_input",
            data: {
              nextField: {
                type: "number",
                placeholder: "Prix direct (\u20AC/kWh)",
                validation: { required: true, min: 0, step: 1e-3 }
              },
              workflow: {
                target_field: fieldConfig.resultFieldId,
                action: "copy_value"
              },
              businessLogic: {
                category: "direct_input",
                unit: "EUR/kWh"
              }
            }
          }
        ]
      },
      "multi_step_form": {
        name: "Formulaire Multi-\xC9tapes",
        description: "Template pour cr\xE9er des formulaires en cascade",
        options: []
        // √Ä d√©finir selon les besoins
      }
    };
    const template = templates[templateType];
    if (!template) {
      return res.status(400).json({
        success: false,
        error: `Template ${templateType} non trouv\xE9`
      });
    }
    res.json({
      success: true,
      data: {
        template,
        ready_to_apply: true,
        instructions: [
          "Ce template peut \xEAtre appliqu\xE9 directement \xE0 votre champ",
          "Les options seront cr\xE9\xE9es automatiquement",
          "Les formules de calcul seront configur\xE9es",
          "La validation sera activ\xE9e"
        ]
      }
    });
  } catch (error) {
    console.error("Erreur POST templates:", error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});
router52.get("/:fieldId/analytics", async (req2, res) => {
  try {
    const { fieldId } = req2.params;
    const { organizationId, period = "30d" } = req2.query;
    const analytics = {
      field_id: fieldId,
      period,
      usage_stats: {
        total_calculations: 0,
        // √Ä impl√©menter avec une vraie base de calculs
        most_used_option: "calcul-du-prix-kwh",
        average_calculation_time: "15ms",
        success_rate: "98.5%"
      },
      popular_values: {
        "calcul-du-prix-kwh": {
          usage_count: 0,
          average_input: 0,
          average_result: 0
        },
        "prix-kwh": {
          usage_count: 0,
          average_input: 0
        }
      },
      performance: {
        response_time_avg: "12ms",
        error_rate: "1.5%",
        cache_hit_rate: "85%"
      }
    };
    res.json({
      success: true,
      data: analytics,
      generated_at: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("Erreur GET analytics:", error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});
module.exports = router52;
var advanced_select_default = router52;

// src/config/fieldMapping.ts
var DEFAULT_FIELD_MAPPING = {
  prix_kwh: process.env.FIELD_ID_PRIX_KWH || "c8a2467b-9cf1-4dba-aeaf-77240adeedd5",
  prix_mois: process.env.FIELD_ID_PRIX_MOIS || "52c7f63b-7e57-4ba8-86da-19a176f09220",
  consommation_kwh: process.env.FIELD_ID_CONSOMMATION_KWH || "aa448cfa-3d97-4c23-8995-8e013577e27d"
};
function getFieldMapping(organizationId) {
  return DEFAULT_FIELD_MAPPING;
}

// src/api/dynamic-formulas.ts
var import_express54 = __toESM(require("express"), 1);

// src/services/DynamicFormulaEngine.ts
init_database();
var DynamicFormulaEngine = class {
  prisma;
  configCache = /* @__PURE__ */ new Map();
  formulaCache = /* @__PURE__ */ new Map();
  fieldMapping = getFieldMapping();
  // Mapping des champs centralis√©
  constructor() {
    this.prisma = db;
  }
  /**
   * üîÑ Charge toutes les configurations de champs dynamiquement
   */
  async loadFieldConfigurations(organizationId) {
    try {
      console.log("\u{1F504} [DynamicFormulaEngine] Chargement des configurations pour org:", organizationId);
      const fields = await this.prisma.field.findMany({
        include: {
          FieldFormula: true,
          FieldDependency_FieldDependency_fieldIdToField: {
            include: {
              Field_FieldDependency_dependsOnIdToField: true
            }
          },
          FieldValidation: true,
          optionNodes: true
        }
      });
      const configurations = {};
      for (const field of fields) {
        const config = {
          id: field.id,
          label: field.label,
          type: field.type,
          advancedConfig: field.advancedConfig,
          options: field.optionNodes.map((node) => ({
            id: node.id,
            label: node.label,
            value: node.value,
            fieldId: node.fieldId
          })),
          formulas: field.FieldFormula.map((formula) => ({
            id: formula.id,
            formula: formula.formula || "",
            sequence: formula.sequence,
            fieldId: formula.fieldId
          })),
          dependencies: field.FieldDependency_FieldDependency_fieldIdToField.map((dep) => ({
            id: dep.id,
            fieldId: dep.fieldId,
            dependsOnId: dep.dependsOnId,
            condition: dep.condition,
            value: dep.value || ""
          })),
          validations: field.FieldValidation.map((val) => ({
            id: val.id,
            fieldId: val.fieldId,
            rule: val.rule,
            message: val.message || ""
          }))
        };
        configurations[field.id] = config;
        this.configCache.set(field.id, config);
      }
      console.log("\u2705 [DynamicFormulaEngine] Configurations charg\xE9es:", Object.keys(configurations).length);
      return configurations;
    } catch (error) {
      console.error("\u274C [DynamicFormulaEngine] Erreur chargement configurations:", error);
      throw new Error(`Erreur lors du chargement des configurations: ${error.message}`);
    }
  }
  /**
   * üß† Analyse et interpr√®te les logiques conditionnelles automatiquement
   */
  analyzeConditionalLogic(fieldConfig) {
    const logics = [];
    if (fieldConfig.type === "advanced_select" && fieldConfig.options) {
      for (const option of fieldConfig.options) {
        const logic = this.interpretAdvancedSelectOption(fieldConfig, option);
        if (logic) {
          logics.push(logic);
        }
      }
    }
    if (fieldConfig.formulas) {
      for (const formula of fieldConfig.formulas) {
        const logic = this.parseFormulaToConditionalLogic(formula);
        if (logic) {
          logics.push(logic);
        }
      }
    }
    if (fieldConfig.dependencies) {
      for (const dependency of fieldConfig.dependencies) {
        const logic = this.interpretDependencyAsLogic(dependency);
        if (logic) {
          logics.push(logic);
        }
      }
    }
    return logics;
  }
  /**
   * üéØ Interpr√®te une option d'advanced_select en logique conditionnelle
   */
  interpretAdvancedSelectOption(fieldConfig, option) {
    if (fieldConfig.label.includes("Prix Kw/h")) {
      if (option.value === "prix-kwh") {
        return {
          condition: `IF_${fieldConfig.id}_EQUALS_DIRECT_VALUE`,
          field1: "52c7f63b-7e57-4ba8-86da-19a176f09220",
          // Prix Kw/h - D√©fini
          operator: "EQUALS",
          field2: "direct_price_value",
          // Valeur directe saisie
          thenAction: "COPY_VALUE",
          elseAction: "CALCULATE_DIVISION",
          resultField: fieldConfig.id
        };
      } else if (option.value === "calcul-du-prix-kwh") {
        return {
          condition: `IF_${fieldConfig.id}_EQUALS_CALCULATION`,
          field1: "calcul_du_prix_base",
          // Champ base de calcul
          operator: "DIVIDE_BY",
          field2: "aa448cfa-3d97-4c23-8995-8e013577e27d",
          // Consommation annuelle
          thenAction: "PERFORM_DIVISION",
          elseAction: "USE_DEFAULT",
          resultField: "52c7f63b-7e57-4ba8-86da-19a176f09220"
          // Prix Kw/h - D√©fini
        };
      }
    }
    return null;
  }
  /**
   * üìê Parse une formule textuelle en logique conditionnelle
   */
  parseFormulaToConditionalLogic(formula) {
    if (!formula.formula) return null;
    const patterns = [
      {
        regex: /IF\s+(.+?)\s*=\s*(.+?)\s+THEN\s+(.+?)\s+ELSE\s+(.+)/i,
        handler: (matches) => ({
          condition: `PARSED_${formula.id}`,
          field1: matches[1].trim(),
          operator: "EQUALS",
          field2: matches[2].trim(),
          thenAction: matches[3].trim(),
          elseAction: matches[4].trim(),
          resultField: formula.fieldId
        })
      },
      {
        regex: /(.+?)\s*\/\s*(.+)/,
        handler: (matches) => ({
          condition: `DIVISION_${formula.id}`,
          field1: matches[1].trim(),
          operator: "DIVIDE_BY",
          field2: matches[2].trim(),
          thenAction: "PERFORM_DIVISION",
          elseAction: "USE_DEFAULT",
          resultField: formula.fieldId
        })
      }
    ];
    for (const pattern of patterns) {
      const matches = formula.formula.match(pattern.regex);
      if (matches) {
        return pattern.handler(matches);
      }
    }
    return null;
  }
  /**
   * üîó Interpr√®te une d√©pendance comme logique conditionnelle
   */
  interpretDependencyAsLogic(dependency) {
    return {
      condition: `DEPENDENCY_${dependency.id}`,
      field1: dependency.fieldId,
      operator: dependency.condition,
      field2: dependency.dependsOnId,
      thenAction: "UPDATE_FIELD",
      elseAction: "NO_ACTION",
      resultField: dependency.fieldId
    };
  }
  /**
   * üßÆ Ex√©cute les calculs dynamiques selon les configurations
   */
  async executeCalculations(context) {
    console.log("\u{1F9EE} [DynamicFormulaEngine] Ex\xE9cution des calculs dynamiques...");
    const results = {};
    try {
      const conditionalFields = Object.values(context.fieldConfigs).filter((config) => config.type === "advanced_select" || config.formulas && config.formulas.length > 0 || config.dependencies && config.dependencies.length > 0);
      console.log("\u{1F3AF} Champs conditionnels trouv\xE9s:", conditionalFields.length);
      for (const fieldConfig of conditionalFields) {
        const logics = this.analyzeConditionalLogic(fieldConfig);
        for (const logic of logics) {
          const result = await this.executeConditionalLogic(logic, context);
          if (result !== null) {
            results[logic.resultField || fieldConfig.id] = result;
          }
        }
      }
      if (context.fieldValues[this.fieldMapping.prix_kwh]) {
        const prixKwhResult = await this.executePrixKwhLogic(context);
        if (prixKwhResult !== null) {
          results[this.fieldMapping.prix_mois] = prixKwhResult;
        }
      }
      console.log("\u2705 [DynamicFormulaEngine] Calculs termin\xE9s:", Object.keys(results).length);
      return results;
    } catch (error) {
      console.error("\u274C [DynamicFormulaEngine] Erreur dans les calculs:", error);
      throw error;
    }
  }
  /**
   * ‚ö° Logique sp√©cifique Prix Kw/h selon vos sp√©cifications
   */
  async executePrixKwhLogic(context) {
    const selectedOption = context.fieldValues[this.fieldMapping.prix_kwh];
    const prixDefini = context.fieldValues[this.fieldMapping.prix_mois];
    const consommation = context.fieldValues[this.fieldMapping.consommation_kwh];
    console.log("\u26A1 [Prix Kw/h Logic] Option s\xE9lectionn\xE9e:", selectedOption);
    console.log("\u26A1 [Prix Kw/h Logic] Prix d\xE9fini actuel:", prixDefini);
    console.log("\u26A1 [Prix Kw/h Logic] Consommation:", consommation);
    if (selectedOption === "prix-kwh") {
      const directValue = context.fieldValues["direct_prix_kwh_input"];
      console.log("\u{1F4A1} Utilisation valeur directe:", directValue);
      return directValue || prixDefini || 0;
    } else if (selectedOption === "calcul-du-prix-kwh") {
      const calculBase = context.fieldValues["calcul_du_prix_base"] || prixDefini || 0;
      const consommationValue = parseFloat(consommation) || 1;
      const result = calculBase / consommationValue;
      console.log("\u{1F9EE} Calcul division:", calculBase, "/", consommationValue, "=", result);
      return result;
    }
    return null;
  }
  /**
   * üéØ Ex√©cute une logique conditionnelle sp√©cifique
   */
  async executeConditionalLogic(logic, context) {
    const value1 = context.fieldValues[logic.field1] || "";
    const value2 = context.fieldValues[logic.field2] || "";
    console.log("\u{1F3AF} Ex\xE9cution logique:", logic.condition);
    console.log("   Field1:", logic.field1, "=", value1);
    console.log("   Operator:", logic.operator);
    console.log("   Field2:", logic.field2, "=", value2);
    let conditionMet = false;
    switch (logic.operator) {
      case "EQUALS":
        conditionMet = value1 === value2;
        break;
      case "DIVIDE_BY": {
        const num1 = parseFloat(String(value1)) || 0;
        const num2 = parseFloat(String(value2)) || 1;
        return num1 / num2;
      }
      case "MULTIPLY_BY":
        return (parseFloat(String(value1)) || 0) * (parseFloat(String(value2)) || 1);
      case "GREATER_THAN":
        conditionMet = parseFloat(String(value1)) > parseFloat(String(value2));
        break;
      case "LESS_THAN":
        conditionMet = parseFloat(String(value1)) < parseFloat(String(value2));
        break;
      default:
        console.log("\u26A0\uFE0F Op\xE9rateur non reconnu:", logic.operator);
    }
    const action2 = conditionMet ? logic.thenAction : logic.elseAction;
    console.log("\u2728 Action \xE0 ex\xE9cuter:", action2, "(condition met:", conditionMet, ")");
    switch (action2) {
      case "COPY_VALUE":
        return value1;
      case "PERFORM_DIVISION":
        return (parseFloat(String(value1)) || 0) / (parseFloat(String(value2)) || 1);
      case "USE_DEFAULT":
        return context.fieldValues[logic.resultField || ""] || 0;
      case "NO_ACTION":
        return null;
      default:
        console.log("\u26A0\uFE0F Action non reconnue:", action2);
        return null;
    }
  }
  /**
   * üîÑ Met √† jour une configuration de champ (adaptatif)
   */
  async updateFieldConfiguration(fieldId, newConfig) {
    try {
      console.log("\u{1F504} [DynamicFormulaEngine] Mise \xE0 jour configuration:", fieldId);
      const updateData = {};
      if (newConfig.advancedConfig) {
        updateData.advancedConfig = newConfig.advancedConfig;
      }
      if (Object.keys(updateData).length > 0) {
        await this.prisma.field.update({
          where: { id: fieldId },
          data: updateData
        });
        this.configCache.delete(fieldId);
        console.log("\u2705 Configuration mise \xE0 jour et cache invalid\xE9");
      }
    } catch (error) {
      console.error("\u274C Erreur mise \xE0 jour configuration:", error);
      throw error;
    }
  }
  /**
   * ÔøΩ M√©thode principale appel√©e par DevisPage
   * Applique toutes les formules dynamiques selon les configurations de la base de donn√©es
   */
  async applyFormulas(fieldValues, options) {
    const debug = options?.debug || false;
    const changedFieldId = options?.changedFieldId;
    const preloadedRules = options?.preloadedRules;
    if (debug) console.log("\u{1F680} [DynamicFormulaEngine] Application des formules - d\xE9clench\xE9e par:", changedFieldId, "r\xE8gles pr\xE9charg\xE9es:", !!preloadedRules);
    try {
      const calculatedValues = {};
      const appliedFormulas = [];
      const errors = [];
      let formulas = [];
      if (preloadedRules) {
        if (debug) console.log("\u{1F4CB} Utilisation des r\xE8gles pr\xE9charg\xE9es");
        Object.entries(preloadedRules).forEach(([fieldId, rules]) => {
          if (rules.formulas && Array.isArray(rules.formulas)) {
            rules.formulas.forEach((formula) => {
              formulas.push({
                ...formula,
                fieldId
              });
            });
          }
        });
        if (debug) console.log(`\u{1F4CA} ${formulas.length} formules trouv\xE9es dans les r\xE8gles pr\xE9charg\xE9es`);
      } else {
        if (debug) console.log("\u{1F504} Chargement des formules depuis la base de donn\xE9es");
        formulas = await this.prisma.fieldFormula.findMany({
          orderBy: { order: "asc" }
        });
      }
      for (const formula of formulas) {
        if (!formula.sequence) continue;
        try {
          let sequence;
          if (typeof formula.sequence === "string") {
            try {
              sequence = JSON.parse(formula.sequence);
            } catch {
              if (debug) console.warn("\u26A0\uFE0F Formule avec s\xE9quence JSON invalide:", formula.id);
              continue;
            }
          } else if (Array.isArray(formula.sequence)) {
            sequence = formula.sequence;
          } else {
            if (debug) console.warn("\u26A0\uFE0F Formule avec format de s\xE9quence non support\xE9:", formula.id);
            continue;
          }
          if (!Array.isArray(sequence) || sequence.length === 0) continue;
          const result = await this.evaluateFormulaSequence(sequence, fieldValues, { debug });
          if (result.success && result.value !== void 0) {
            calculatedValues[formula.fieldId] = result.value;
            appliedFormulas.push({ id: formula.id, name: formula.name || formula.id });
            if (debug) {
              console.log(`\u2705 Formule appliqu\xE9e: ${formula.name} \u2192 ${formula.fieldId} = ${result.value}`);
            }
          } else if (result.error) {
            errors.push(`Erreur formule ${formula.name}: ${result.error}`);
          }
        } catch (formulaError) {
          const errorMsg = formulaError instanceof Error ? formulaError.message : String(formulaError);
          errors.push(`Erreur formule ${formula.name || formula.id}: ${errorMsg}`);
          if (debug) console.error("\u274C Erreur formule:", formula.id, errorMsg);
        }
      }
      return {
        success: true,
        calculatedValues,
        appliedFormulas,
        errors: errors.length > 0 ? errors : void 0
      };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      if (debug) console.error("\u274C [DynamicFormulaEngine] Erreur g\xE9n\xE9rale:", errorMsg);
      return {
        success: false,
        calculatedValues: {},
        appliedFormulas: [],
        errors: [errorMsg]
      };
    }
  }
  /**
   * üéØ √âvalue une s√©quence de formule (comme notre formule Prix Kw/h)
   */
  async evaluateFormulaSequence(sequence, fieldValues, options = {}) {
    const debug = options.debug || false;
    for (const item of sequence) {
      if (!item || typeof item !== "object") continue;
      const element = item;
      if (element.type === "cond") {
        return this.evaluateConditionalElement(element, fieldValues, { debug });
      }
    }
    return { success: false, error: "Aucun \xE9l\xE9ment \xE9valuable dans la s\xE9quence" };
  }
  /**
   * üîÄ √âvalue un √©l√©ment conditionnel (IF/THEN/ELSE)
   */
  async evaluateConditionalElement(element, fieldValues, options = {}) {
    const debug = options.debug || false;
    const condition = element.condition;
    if (!condition) {
      return { success: false, error: "Condition manquante" };
    }
    const fieldId = condition.fieldId;
    const operator = condition.operator;
    const expectedValue = condition.value;
    const part = condition.part || "selection";
    let actualValue;
    const fieldValue = fieldValues[fieldId];
    if (fieldValue && typeof fieldValue === "object" && !Array.isArray(fieldValue)) {
      const obj = fieldValue;
      actualValue = obj[part];
    } else {
      actualValue = fieldValue;
    }
    if (debug) {
      console.log(`\u{1F50D} Condition: ${fieldId}.${part} ${operator} ${expectedValue}`);
      console.log(`\u{1F50D} Valeur actuelle: ${actualValue}`);
    }
    let conditionMet = false;
    if (operator === "=") {
      conditionMet = actualValue === expectedValue;
    }
    if (debug) {
      console.log(`\u{1F50D} Condition remplie: ${conditionMet}`);
    }
    const branch = conditionMet ? element.then : element.else;
    if (!Array.isArray(branch)) {
      return { success: false, error: "Branche manquante" };
    }
    return this.evaluateBranch(branch, fieldValues, { debug });
  }
  /**
   * üåø √âvalue une branche (THEN ou ELSE)
   */
  async evaluateBranch(branch, fieldValues, options = {}) {
    const debug = options.debug || false;
    if (debug) {
      console.log(`\u{1F33F} evaluateBranch: longueur = ${branch.length}`);
      console.log(`\u{1F33F} Structure branche:`, JSON.stringify(branch, null, 2));
    }
    if (branch.length === 1) {
      const action2 = branch[0];
      return this.evaluateAction(action2, fieldValues, { debug });
    } else if (branch.length === 3) {
      const value1Action = branch[0];
      const operatorAction = branch[1];
      const value2Action = branch[2];
      if (debug) {
        console.log(`\u{1F9EE} \xC9valuation branche 3 \xE9l\xE9ments:`);
        console.log(`\u{1F9EE} \xC9l\xE9ment 1:`, JSON.stringify(value1Action, null, 2));
        console.log(`\u{1F9EE} \xC9l\xE9ment 2:`, JSON.stringify(operatorAction, null, 2));
        console.log(`\u{1F9EE} \xC9l\xE9ment 3:`, JSON.stringify(value2Action, null, 2));
      }
      const val1Result = await this.evaluateAction(value1Action, fieldValues, { debug });
      const val2Result = await this.evaluateAction(value2Action, fieldValues, { debug });
      if (debug) {
        console.log(`\u{1F9EE} R\xE9sultat val1:`, val1Result);
        console.log(`\u{1F9EE} R\xE9sultat val2:`, val2Result);
      }
      if (!val1Result.success || !val2Result.success) {
        return { success: false, error: "Erreur \xE9valuation des op\xE9randes" };
      }
      const operator = operatorAction.value;
      const num1 = parseFloat(String(val1Result.value)) || 0;
      const num2 = parseFloat(String(val2Result.value)) || 0;
      if (debug) {
        console.log(`\u{1F9EE} Calcul: ${num1} ${operator} ${num2}`);
      }
      if (operator === "/") {
        if (num2 === 0) {
          return { success: false, error: "Division par z\xE9ro" };
        }
        const result = num1 / num2;
        if (debug) console.log(`\u{1F9EE} R\xE9sultat division: ${result}`);
        return { success: true, value: result };
      }
    } else {
      if (debug) {
        console.log(`\u{1F33F} Branche non trait\xE9e - longueur: ${branch.length}`);
        console.log(`\u{1F33F} Contenu:`, JSON.stringify(branch, null, 2));
      }
    }
    return { success: false, error: "Structure de branche non support\xE9e" };
  }
  /**
   * ‚ö° √âvalue une action individuelle
   */
  async evaluateAction(action2, fieldValues, options = {}) {
    const debug = options.debug || false;
    const type = action2.type;
    const value = action2.value;
    if (debug) {
      console.log(`\u26A1 Action: ${type} = ${value}`);
    }
    if (type === "value" && typeof value === "string" && value.startsWith("nextField:")) {
      const nextFieldId = value.substring("nextField:".length);
      if (debug) console.log(`\u{1F50D} Recherche NextField: ${nextFieldId}`);
      for (const [_fieldId, fieldValue] of Object.entries(fieldValues)) {
        if (fieldValue && typeof fieldValue === "object" && !Array.isArray(fieldValue)) {
          const obj = fieldValue;
          if (obj.nodeId === nextFieldId && obj.extra !== void 0) {
            const result = parseFloat(String(obj.extra)) || 0;
            if (debug) console.log(`\u{1F4CB} NextField trouv\xE9 directement: ${result} (nodeId: ${nextFieldId})`);
            return { success: true, value: result };
          }
        }
      }
      for (const [, fieldValue] of Object.entries(fieldValues)) {
        if (fieldValue && typeof fieldValue === "object" && !Array.isArray(fieldValue)) {
          const obj = fieldValue;
          if (obj.nodeId && obj.extra !== void 0) {
            try {
              const node = await this.prisma.optionNode.findUnique({
                where: { id: obj.nodeId }
              });
              if (node && node.data) {
                const nodeData = typeof node.data === "string" ? JSON.parse(node.data) : node.data;
                if (nodeData && typeof nodeData === "object") {
                  const nextField = nodeData.nextField;
                  if (nextField && typeof nextField === "object") {
                    const nextFieldObj = nextField;
                    if (nextFieldObj.id === nextFieldId) {
                      const result = parseFloat(String(obj.extra)) || 0;
                      if (debug) console.log(`\u{1F4CB} NextField trouv\xE9: ${result}`);
                      return { success: true, value: result };
                    }
                  }
                }
              }
            } catch {
            }
          }
        }
      }
      return { success: false, error: `NextField ${nextFieldId} non trouv\xE9` };
    } else if (type === "field") {
      const fieldValue = fieldValues[value];
      const numValue = parseFloat(String(fieldValue)) || 0;
      if (debug) console.log(`\u{1F4CB} Field ${value}: ${numValue}`);
      return { success: true, value: numValue };
    } else if (type === "value") {
      const numValue = parseFloat(String(value)) || 0;
      if (debug) console.log(`\u{1F4CB} Value: ${numValue}`);
      return { success: true, value: numValue };
    }
    return { success: false, error: `Type d'action non support\xE9: ${type}` };
  }
  /**
   * ÔøΩüóëÔ∏è Nettoyage des ressources
   */
  async cleanup() {
    this.configCache.clear();
    this.formulaCache.clear();
    await this.prisma.$disconnect();
  }
};
var DynamicFormulaEngine_default = DynamicFormulaEngine;

// src/api/dynamic-formulas.ts
var router53 = import_express54.default.Router();
router53.get("/configurations", async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"];
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        error: "Organization ID requis dans les headers"
      });
    }
    const engine = new DynamicFormulaEngine_default();
    const configurations = await engine.loadFieldConfigurations(organizationId);
    await engine.cleanup();
    res.json({
      success: true,
      data: {
        configurations,
        organizationId,
        totalFields: Object.keys(configurations).length,
        conditionalFields: Object.values(configurations).filter(
          (config) => config.type === "advanced_select" || config.formulas && config.formulas.length > 0
        ).length
      }
    });
  } catch (error) {
    console.error("\xC3\xA2\xC2\x9D\xC5\u2019 [DynamicFormulaAPI] Erreur r\xC3\u0192\xC2\xA9cup\xC3\u0192\xC2\xA9ration configurations:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la r\xC3\u0192\xC2\xA9cup\xC3\u0192\xC2\xA9ration des configurations",
      details: error.message
    });
  }
});
router53.post("/calculate", async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"];
    const { fieldValues } = req2.body;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        error: "Organization ID requis dans les headers"
      });
    }
    if (!fieldValues || typeof fieldValues !== "object") {
      return res.status(400).json({
        success: false,
        error: "fieldValues requis dans le body de la requ\xC3\u0192\xC2\xAAte"
      });
    }
    const engine = new DynamicFormulaEngine_default();
    const fieldConfigs = await engine.loadFieldConfigurations(organizationId);
    const context = {
      fieldValues,
      fieldConfigs,
      organizationId
    };
    const results = await engine.executeCalculations(context);
    await engine.cleanup();
    res.json({
      success: true,
      data: {
        results,
        calculatedFields: Object.keys(results),
        organizationId,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        inputFieldsCount: Object.keys(fieldValues).length,
        outputFieldsCount: Object.keys(results).length
      }
    });
  } catch (error) {
    console.error("\xC3\xA2\xC2\x9D\xC5\u2019 [DynamicFormulaAPI] Erreur calculs:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors des calculs dynamiques",
      details: error.message
    });
  }
});
router53.post("/calculate-prix-kwh", async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"];
    const {
      selectedOption,
      // 'prix-kwh' ou 'calcul-du-prix-kwh'
      prixDefini,
      // Valeur actuelle Prix Kw/h - D√É∆í√Ç¬©fini
      consommation,
      // Consommation annuelle Kw/h
      calculBase,
      // Base de calcul si n√É∆í√Ç¬©cessaire
      directValue
      // Valeur directe si saisie
    } = req2.body;
    const engine = new DynamicFormulaEngine_default();
    const fieldConfigs = await engine.loadFieldConfigurations(organizationId);
    const fieldMapping = getFieldMapping();
    const context = {
      fieldValues: {
        [fieldMapping.prix_kwh]: selectedOption,
        // Prix Kw/h (advanced_select)
        [fieldMapping.prix_mois]: prixDefini,
        // Prix Kw/h - D√É∆í√Ç¬©fini
        [fieldMapping.consommation_kwh]: consommation,
        // Consommation annuelle
        "direct_prix_kwh_input": directValue,
        "calcul_du_prix_base": calculBase || prixDefini
      },
      fieldConfigs,
      organizationId
    };
    const results = await engine.executeCalculations(context);
    await engine.cleanup();
    const finalPrixKwh = results["52c7f63b-7e57-4ba8-86da-19a176f09220"];
    res.json({
      success: true,
      data: {
        prixKwhDefini: finalPrixKwh,
        selectedOption,
        calculation: {
          method: selectedOption === "prix-kwh" ? "Valeur directe" : "Division par consommation",
          baseValue: selectedOption === "prix-kwh" ? directValue : calculBase || prixDefini,
          divisor: selectedOption === "calcul-du-prix-kwh" ? consommation : null,
          result: finalPrixKwh
        },
        allResults: results,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }
    });
  } catch (error) {
    console.error("\xC3\xA2\xC2\x9D\xC5\u2019 [Prix Kw/h API] Erreur:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors du calcul Prix Kw/h",
      details: error.message
    });
  }
});
router53.put("/configurations/:fieldId", async (req2, res) => {
  try {
    const { fieldId } = req2.params;
    const { advancedConfig, formulas, dependencies } = req2.body;
    const engine = new DynamicFormulaEngine_default();
    await engine.updateFieldConfiguration(fieldId, {
      advancedConfig,
      formulas,
      dependencies
    });
    await engine.cleanup();
    res.json({
      success: true,
      data: {
        fieldId,
        updated: true,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }
    });
  } catch (error) {
    console.error("\xC3\xA2\xC2\x9D\xC5\u2019 [DynamicFormulaAPI] Erreur mise \xC3\u0192\xC2\xA0 jour:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la mise \xC3\u0192\xC2\xA0 jour de la configuration",
      details: error.message
    });
  }
});
router53.get("/field/:fieldId/logic", async (req2, res) => {
  try {
    const { fieldId } = req2.params;
    const organizationId = req2.headers["x-organization-id"];
    const engine = new DynamicFormulaEngine_default();
    const configurations = await engine.loadFieldConfigurations(organizationId);
    const fieldConfig = configurations[fieldId];
    if (!fieldConfig) {
      return res.status(404).json({
        success: false,
        error: "Champ non trouv\xC3\u0192\xC2\xA9"
      });
    }
    const logics = engine.analyzeConditionalLogic(fieldConfig);
    await engine.cleanup();
    res.json({
      success: true,
      data: {
        fieldId,
        fieldLabel: fieldConfig.label,
        fieldType: fieldConfig.type,
        logics,
        hasConditionalLogic: logics.length > 0,
        optionsCount: fieldConfig.options?.length || 0,
        formulasCount: fieldConfig.formulas?.length || 0,
        dependenciesCount: fieldConfig.dependencies?.length || 0
      }
    });
  } catch (error) {
    console.error("\xC3\xA2\xC2\x9D\xC5\u2019 [DynamicFormulaAPI] Erreur analyse logique:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de l'analyse de la logique",
      details: error.message
    });
  }
});
router53.get("/analytics", async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"];
    const engine = new DynamicFormulaEngine_default();
    const configurations = await engine.loadFieldConfigurations(organizationId);
    await engine.cleanup();
    const fields = Object.values(configurations);
    const analytics = {
      totalFields: fields.length,
      advancedSelectFields: fields.filter((f) => f.type === "advanced_select").length,
      fieldsWithFormulas: fields.filter((f) => f.formulas && f.formulas.length > 0).length,
      fieldsWithDependencies: fields.filter((f) => f.dependencies && f.dependencies.length > 0).length,
      fieldsWithValidations: fields.filter((f) => f.validations && f.validations.length > 0).length,
      totalOptions: fields.reduce((sum, f) => sum + (f.options?.length || 0), 0),
      totalFormulas: fields.reduce((sum, f) => sum + (f.formulas?.length || 0), 0),
      totalDependencies: fields.reduce((sum, f) => sum + (f.dependencies?.length || 0), 0),
      organizationId,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    res.json({
      success: true,
      data: analytics
    });
  } catch (error) {
    console.error("\xC3\xA2\xC2\x9D\xC5\u2019 [DynamicFormulaAPI] Erreur analytics:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de la r\xC3\u0192\xC2\xA9cup\xC3\u0192\xC2\xA9ration des statistiques",
      details: error.message
    });
  }
});
var dynamic_formulas_default = router53;

// src/routes/dashboard.ts
var import_express55 = __toESM(require("express"), 1);
init_database();
var router54 = import_express55.default.Router();
var prisma28 = db;
router54.get("/stats", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const isSuperAdmin2 = req2.user?.role === "super_admin";
    if (!organizationId && !isSuperAdmin2) {
      return res.status(400).json({
        success: false,
        message: "Organisation ID requis ou droits super admin"
      });
    }
    const whereCondition = isSuperAdmin2 ? {} : { organizationId };
    const [
      totalLeads,
      newLeadsToday,
      totalClients,
      totalUsers,
      completedLeads,
      pendingTasks,
      upcomingMeetings,
      monthlyRevenue
    ] = await Promise.all([
      // Total des leads
      prisma28.lead.count({
        where: whereCondition
      }),
      // Nouveaux leads aujourd'hui
      prisma28.lead.count({
        where: {
          ...whereCondition,
          createdAt: {
            gte: new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0))
          }
        }
      }),
      // Total clients actifs
      prisma28.user.count({
        where: {
          ...whereCondition,
          status: "active"
        }
      }),
      // Total utilisateurs
      prisma28.user.count({
        where: whereCondition
      }),
      // Leads convertis (pour calculer le taux de conversion)
      prisma28.lead.count({
        where: {
          ...whereCondition,
          status: "converti"
        }
      }),
      // T√¢ches en attente (simul√© pour l'instant)
      Promise.resolve(Math.floor(Math.random() * 20) + 5),
      // RDV √† venir (simul√© pour l'instant)
      Promise.resolve(Math.floor(Math.random() * 10) + 2),
      // CA du mois (simul√© pour l'instant)
      Promise.resolve(Math.floor(Math.random() * 1e5) + 5e4)
    ]);
    const conversionRate = totalLeads > 0 ? completedLeads / totalLeads * 100 : 0;
    const monthlyGrowth = Math.floor(Math.random() * 30) - 10;
    const stats = {
      totalLeads,
      newLeadsToday,
      totalClients,
      totalUsers,
      conversionRate: Math.round(conversionRate * 10) / 10,
      pendingTasks,
      upcomingMeetings,
      totalRevenue: monthlyRevenue,
      monthlyGrowth
    };
    res.json({
      success: true,
      data: stats
    });
  } catch (error) {
    console.error("\u274C [DASHBOARD] Erreur lors de la r\xE9cup\xE9ration des stats:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration des statistiques",
      error: process.env.NODE_ENV === "development" ? error.message : void 0
    });
  }
});
router54.get("/activities", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const isSuperAdmin2 = req2.user?.role === "super_admin";
    const limit = parseInt(req2.query.limit) || 10;
    if (!organizationId && !isSuperAdmin2) {
      return res.status(400).json({
        success: false,
        message: "Organisation ID requis ou droits super admin"
      });
    }
    const whereCondition = isSuperAdmin2 ? {} : { organizationId };
    const [
      recentLeads,
      recentEmails,
      recentCalendarEvents,
      timelineEvents
    ] = await Promise.all([
      // Leads r√©cents
      prisma28.lead.findMany({
        where: {
          ...whereCondition,
          createdAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1e3)
            // 7 derniers jours
          }
        },
        select: {
          id: true,
          firstName: true,
          lastName: true,
          company: true,
          createdAt: true,
          status: true
        },
        orderBy: { createdAt: "desc" },
        take: limit
      }),
      // Emails r√©cents (si applicable)
      organizationId ? prisma28.email.findMany({
        where: {
          createdAt: {
            gte: new Date(Date.now() - 24 * 60 * 60 * 1e3)
            // 24 derni√®res heures
          },
          User: {
            UserOrganization: {
              some: {
                organizationId
              }
            }
          }
        },
        select: {
          id: true,
          subject: true,
          from: true,
          to: true,
          createdAt: true
        },
        orderBy: { createdAt: "desc" },
        take: Math.floor(limit / 2)
      }) : [],
      // √âv√©nements de calendrier r√©cents
      prisma28.calendarEvent.findMany({
        where: {
          ...whereCondition,
          createdAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1e3)
          }
        },
        select: {
          id: true,
          title: true,
          description: true,
          startDate: true,
          createdAt: true,
          status: true
        },
        orderBy: { createdAt: "desc" },
        take: Math.floor(limit / 2)
      }),
      // √âv√©nements de timeline
      prisma28.timelineEvent.findMany({
        where: {
          ...whereCondition,
          createdAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1e3)
          }
        },
        select: {
          id: true,
          eventType: true,
          entityType: true,
          data: true,
          createdAt: true
        },
        orderBy: { createdAt: "desc" },
        take: Math.floor(limit / 2)
      })
    ]);
    const activities = [];
    recentLeads.forEach((lead) => {
      activities.push({
        id: `lead-${lead.id}`,
        type: "lead",
        title: "Nouveau lead cr\xE9\xE9",
        description: `${lead.firstName} ${lead.lastName}${lead.company ? ` - ${lead.company}` : ""}`,
        timestamp: lead.createdAt.toISOString(),
        status: "success",
        entityId: lead.id
      });
    });
    recentEmails.forEach((email) => {
      activities.push({
        id: `email-${email.id}`,
        type: "email",
        title: "Email re\xE7u",
        description: email.subject || "Sans objet",
        timestamp: email.createdAt.toISOString(),
        status: "info",
        entityId: email.id
      });
    });
    recentCalendarEvents.forEach((event) => {
      activities.push({
        id: `calendar-${event.id}`,
        type: "meeting",
        title: event.title || "\xC9v\xE9nement calendrier",
        description: event.description || `Pr\xE9vu le ${event.startDate.toLocaleDateString("fr-FR")}`,
        timestamp: event.createdAt.toISOString(),
        status: event.status === "confirmed" ? "success" : "warning",
        entityId: event.id
      });
    });
    timelineEvents.forEach((event) => {
      activities.push({
        id: `timeline-${event.id}`,
        type: event.entityType || "task",
        title: event.eventType || "Activit\xE9 syst\xE8me",
        description: event.data ? JSON.stringify(event.data).substring(0, 100) + "..." : "Activit\xE9 automatique",
        timestamp: event.createdAt.toISOString(),
        status: "info",
        entityId: event.id
      });
    });
    const sortedActivities = activities.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()).slice(0, limit);
    res.json({
      success: true,
      data: sortedActivities
    });
  } catch (error) {
    console.error("\u274C [DASHBOARD] Erreur lors de la r\xE9cup\xE9ration des activit\xE9s:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration des activit\xE9s",
      error: process.env.NODE_ENV === "development" ? error.message : void 0
    });
  }
});
router54.get("/top-leads", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const isSuperAdmin2 = req2.user?.role === "super_admin";
    const limit = parseInt(req2.query.limit) || 5;
    if (!organizationId && !isSuperAdmin2) {
      return res.status(400).json({
        success: false,
        message: "Organisation ID requis ou droits super admin"
      });
    }
    const whereCondition = isSuperAdmin2 ? {} : { organizationId };
    const topLeads = await prisma28.lead.findMany({
      where: {
        ...whereCondition,
        status: {
          not: "supprim\xE9"
        }
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        company: true,
        email: true,
        phone: true,
        status: true,
        lastContactDate: true,
        nextFollowUpDate: true,
        createdAt: true,
        updatedAt: true,
        source: true,
        notes: true,
        assignedToId: true,
        User: {
          select: {
            firstName: true,
            lastName: true
          }
        },
        LeadStatus: {
          select: {
            name: true,
            color: true
          }
        }
      },
      orderBy: [
        { updatedAt: "desc" },
        { createdAt: "desc" }
      ],
      take: limit
    });
    const leadsWithScore = topLeads.map((lead) => {
      let score = 50;
      if (lead.lastContactDate) {
        const daysSinceContact = Math.floor((Date.now() - lead.lastContactDate.getTime()) / (1e3 * 60 * 60 * 24));
        if (daysSinceContact < 7) score += 20;
        else if (daysSinceContact < 30) score += 10;
      }
      if (lead.nextFollowUpDate && lead.nextFollowUpDate > /* @__PURE__ */ new Date()) {
        score += 15;
      }
      if (lead.email) score += 10;
      if (lead.phone) score += 10;
      if (lead.company) score += 15;
      switch (lead.status) {
        case "qualifi\xE9":
        case "n\xE9gociation":
          score += 25;
          break;
        case "nouveau":
          score += 10;
          break;
        case "prospect":
          score += 15;
          break;
        case "perdu":
          score -= 30;
          break;
      }
      score = Math.max(0, Math.min(100, score));
      return {
        id: lead.id,
        nom: lead.lastName || "N/A",
        prenom: lead.firstName || "N/A",
        entreprise: lead.company || "Particulier",
        email: lead.email,
        phone: lead.phone,
        status: lead.LeadStatus?.name || lead.status || "nouveau",
        statusColor: lead.LeadStatus?.color || "#6b7280",
        score: Math.round(score),
        lastContact: lead.lastContactDate?.toISOString().split("T")[0] || null,
        nextFollowUp: lead.nextFollowUpDate?.toISOString().split("T")[0] || null,
        assignedTo: lead.User ? `${lead.User.firstName} ${lead.User.lastName}` : null,
        source: lead.source || "Manuel",
        createdAt: lead.createdAt.toISOString(),
        notes: lead.notes?.substring(0, 100) + (lead.notes && lead.notes.length > 100 ? "..." : "") || null
      };
    });
    const sortedLeads = leadsWithScore.sort((a, b) => b.score - a.score);
    res.json({
      success: true,
      data: sortedLeads
    });
  } catch (error) {
    console.error("\u274C [DASHBOARD] Erreur lors de la r\xE9cup\xE9ration des top leads:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration des meilleurs leads",
      error: process.env.NODE_ENV === "development" ? error.message : void 0
    });
  }
});
router54.get("/tasks", authMiddleware, async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const isSuperAdmin2 = req2.user?.role === "super_admin";
    if (!organizationId && !isSuperAdmin2) {
      return res.status(400).json({
        success: false,
        message: "Organisation ID requis ou droits super admin"
      });
    }
    const whereCondition = isSuperAdmin2 ? {} : { organizationId };
    const today = /* @__PURE__ */ new Date();
    const startOfDay = new Date(today.setHours(0, 0, 0, 0));
    const endOfDay = new Date(today.setHours(23, 59, 59, 999));
    const [
      leadsToFollowUp,
      todayEvents,
      overdueFollowUps
    ] = await Promise.all([
      // Leads avec suivi pr√©vu aujourd'hui
      prisma28.lead.count({
        where: {
          ...whereCondition,
          nextFollowUpDate: {
            gte: startOfDay,
            lte: endOfDay
          }
        }
      }),
      // √âv√©nements d'aujourd'hui
      prisma28.calendarEvent.count({
        where: {
          ...whereCondition,
          startDate: {
            gte: startOfDay,
            lte: endOfDay
          }
        }
      }),
      // Suivis en retard
      prisma28.lead.count({
        where: {
          ...whereCondition,
          nextFollowUpDate: {
            lt: startOfDay
          }
        }
      })
    ]);
    const taskData = {
      pendingTasks: overdueFollowUps,
      upcomingMeetings: todayEvents,
      followUpsToday: leadsToFollowUp,
      totalTasks: overdueFollowUps + todayEvents + leadsToFollowUp
    };
    res.json({
      success: true,
      data: taskData
    });
  } catch (error) {
    console.error("\u274C [DASHBOARD] Erreur lors de la r\xE9cup\xE9ration des t\xE2ches:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration des t\xE2ches",
      error: process.env.NODE_ENV === "development" ? error.message : void 0
    });
  }
});
var dashboard_default = router54;

// src/components/TreeBranchLeaf/treebranchleaf-new/api/treebranchleaf-routes.ts
var import_express57 = require("express");
init_formulaEngine();

// src/components/TreeBranchLeaf/treebranchleaf-new/api/evaluation/orchestrator.ts
var normalize = (s) => s.toLowerCase().normalize("NFD").replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
var isNumericLike = (v) => {
  if (v == null || v === "") return false;
  const str = String(v).trim().replace(/\s+/g, "").replace(/,/g, ".");
  return str !== "" && !isNaN(Number(str));
};
var toNumber = (v) => {
  if (!isNumericLike(v)) return 0;
  const n = parseFloat(String(v).replace(/\s+/g, "").replace(/,/g, "."));
  return isNaN(n) ? 0 : n;
};
function evaluateFormulaOrchestrated(opts) {
  const trace = [];
  const { fieldValues, tokens: tokens2, variableMap, rawExpression, hasOperatorsOverride } = opts;
  const tokenVariables = tokens2.filter((t) => t.type === "variable" && t.name).map((t) => t.name);
  trace.push({ step: "extract_token_variables", output: tokenVariables });
  const operatorsDetected = hasOperatorsOverride ?? (rawExpression ? /[+\-*/]/.test(rawExpression) : tokens2.some((t) => t.type === "operator"));
  trace.push({ step: "detect_operators", output: operatorsDetected, meta: { rawExpression } });
  const mirrors = Object.entries(fieldValues).filter(([k]) => k.startsWith("__mirror_data_"));
  const mirrorsByNorm = {};
  for (const [k, v] of mirrors) {
    const norm = normalize(k.replace(/^__mirror_data_/, ""));
    mirrorsByNorm[norm] = mirrorsByNorm[norm] || [];
    mirrorsByNorm[norm].push({ key: k, value: v });
  }
  trace.push({ step: "collect_mirrors", output: Object.keys(mirrorsByNorm) });
  const resolvedVariables = {};
  const pickBest = (cands) => {
    const scored = cands.filter((c) => isNumericLike(c.value)).map((c) => ({ ...c, num: toNumber(c.value), len: String(c.value).length })).sort((a, b) => b.len - a.len);
    if (scored.length === 0) return { value: 0, source: "none" };
    return { value: scored[0].num, source: scored[0].source };
  };
  for (const varName of tokenVariables) {
    const varTrace = { step: "resolve_variable", input: varName, meta: {} };
    const candidates = [];
    if (variableMap && variableMap[varName]) {
      candidates.push({ value: variableMap[varName].numeric ?? variableMap[varName].raw, source: "variableMap" });
      varTrace.meta.variableMap = true;
    }
    if (fieldValues[varName] != null) candidates.push({ value: fieldValues[varName], source: "direct" });
    const suffixKey = `${varName}_field`;
    if (fieldValues[suffixKey] != null) candidates.push({ value: fieldValues[suffixKey], source: "_field_suffix" });
    Object.entries(fieldValues).forEach(([k, v]) => {
      if (k !== varName && k !== suffixKey && k.includes(varName) && v != null) {
        candidates.push({ value: v, source: "contains_pattern" });
      }
    });
    const norm = normalize(varName);
    if (mirrorsByNorm[norm]) {
      mirrorsByNorm[norm].forEach((m) => candidates.push({ value: m.value, source: "mirror" }));
      varTrace.meta.mirrorMatched = true;
    }
    if (!candidates.some((c) => c.source === "_field_suffix")) {
      const anyField = Object.keys(fieldValues).find((k) => k.endsWith("_field") && fieldValues[k] != null && fieldValues[k] !== "");
      if (anyField) candidates.push({ value: fieldValues[anyField], source: "generic_field_fallback" });
    }
    const chosen = pickBest(candidates);
    resolvedVariables[varName] = chosen.value;
    varTrace.output = chosen.value;
    varTrace.meta.candidates = candidates.slice(0, 6).map((c) => ({ source: c.source, sample: String(c.value).slice(0, 20) }));
    varTrace.meta.chosenSource = chosen.source;
    trace.push(varTrace);
  }
  let strategy = "FULL_CALCULATION";
  if (!operatorsDetected) {
    const nonZero = Object.values(resolvedVariables).filter((v) => v !== 0);
    if (nonZero.length === 1 && tokenVariables.length === 1) strategy = "DIRECT_VALUE";
  }
  trace.push({ step: "select_strategy", output: strategy });
  return { resolvedVariables, strategy, operatorsDetected, trace };
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/treebranchleaf-routes.ts
init_database();

// src/components/TreeBranchLeaf/treebranchleaf-new/api/universal-linking-system.ts
function normalizeCapacityRef(raw) {
  const trim = raw.trim();
  const lower = trim.toLowerCase();
  const takeId = (s, prefix) => s.slice(prefix.length);
  if (lower.startsWith("condition:")) {
    const id = takeId(trim, "condition:");
    return { type: "condition", id, canonical: `condition:${id}` };
  }
  if (lower.startsWith("node-condition:")) {
    const id = takeId(trim, "node-condition:");
    return { type: "condition", id, canonical: `condition:${id}` };
  }
  if (lower.startsWith("formula:")) {
    const id = takeId(trim, "formula:");
    return { type: "formula", id, canonical: `formula:${id}` };
  }
  if (lower.startsWith("node-formula:")) {
    const id = takeId(trim, "node-formula:");
    return { type: "formula", id, canonical: `formula:${id}` };
  }
  if (lower.startsWith("table:")) {
    const id = takeId(trim, "table:");
    return { type: "table", id, canonical: `table:${id}` };
  }
  if (lower.startsWith("table.")) {
    const id = takeId(trim, "table.");
    return { type: "table", id, canonical: `table:${id}` };
  }
  if (lower.startsWith("@table.")) {
    const id = takeId(trim, "@table.");
    return { type: "table", id, canonical: `table:${id}` };
  }
  if (lower.startsWith("@table:")) {
    const id = takeId(trim, "@table:");
    return { type: "table", id, canonical: `table:${id}` };
  }
  if (lower.startsWith("node-table:")) {
    const id = takeId(trim, "node-table:");
    return { type: "table", id, canonical: `table:${id}` };
  }
  return { type: "unknown", id: trim, canonical: trim };
}
function extractCapacityRefsFromString(str) {
  const refs = /* @__PURE__ */ new Set();
  const regex = /(condition:[a-f0-9-]+|node-condition:[a-f0-9-]+|formula:[a-f0-9-]+|node-formula:[a-f0-9-]+|table:[a-z0-9-]+|table\.[a-z0-9-]+|@table\.[a-z0-9-]+|@table:[a-z0-9-]+|node-table:[a-z0-9-]+)/gi;
  let m;
  while ((m = regex.exec(str)) !== null) {
    refs.add(m[1]);
  }
  return refs;
}
function extractNodeIdsFromCondition(conditionSet) {
  const ids = /* @__PURE__ */ new Set();
  if (!conditionSet || typeof conditionSet !== "object") return ids;
  const str = JSON.stringify(conditionSet);
  const uuidRegex = /@(?:value|calculated|select)\.([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:-\d+)?)/gi;
  let match;
  while ((match = uuidRegex.exec(str)) !== null) {
    ids.add(match[1]);
  }
  const nodeRegex = /@value\.(node_[a-z0-9_-]+)/gi;
  while ((match = nodeRegex.exec(str)) !== null) {
    ids.add(match[1]);
  }
  const sharedRefRegex = /@(?:value|calculated|select)\.(shared-ref-[a-z0-9-]+(?:-\d+)?)/gi;
  while ((match = sharedRefRegex.exec(str)) !== null) {
    ids.add(match[1]);
  }
  const obj = conditionSet;
  const extractFromActions = (actions) => {
    if (!Array.isArray(actions)) return;
    for (const action2 of actions) {
      if (Array.isArray(action2.nodeIds)) {
        for (const nodeId of action2.nodeIds) {
          if (typeof nodeId === "string") {
            const cleanId = nodeId.replace(/^condition:/, "").replace(/^node-formula:/, "").replace(/^node-condition:/, "").replace(/^table:/, "");
            if (cleanId && cleanId !== nodeId) {
              continue;
            }
            ids.add(nodeId);
          }
        }
      }
    }
  };
  if (Array.isArray(obj.branches)) {
    for (const branch of obj.branches) {
      if (Array.isArray(branch.actions)) {
        extractFromActions(branch.actions);
      }
    }
  }
  if (obj.fallback && Array.isArray(obj.fallback.actions)) {
    extractFromActions(obj.fallback.actions);
  }
  const genericUuid = /([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:-\d+)?)/gi;
  while ((match = genericUuid.exec(str)) !== null) {
    ids.add(match[1]);
  }
  const genericNode = /(node_[a-z0-9_-]+(?:-\d+)?)/gi;
  while ((match = genericNode.exec(str)) !== null) {
    ids.add(match[1]);
  }
  const genericShared = /(shared-ref-[a-z0-9-]+(?:-\d+)?)/gi;
  while ((match = genericShared.exec(str)) !== null) {
    ids.add(match[1]);
  }
  return ids;
}
function extractNodeAndCapacityRefsFromCondition(conditionSet) {
  const nodeIds = /* @__PURE__ */ new Set();
  const capacityRefs = /* @__PURE__ */ new Set();
  if (!conditionSet || typeof conditionSet !== "object") return { nodeIds, capacityRefs };
  const str = JSON.stringify(conditionSet);
  const uuidRegex = /@(?:value|calculated|select)\.([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:-\d+)?)/gi;
  let match;
  while ((match = uuidRegex.exec(str)) !== null) nodeIds.add(match[1]);
  const nodeRegex = /@(?:value|calculated|select)\.(node_[a-z0-9_-]+(?:-\d+)?)/gi;
  while ((match = nodeRegex.exec(str)) !== null) nodeIds.add(match[1]);
  const sharedRefRegex = /@(?:value|calculated|select)\.(shared-ref-[a-z0-9-]+(?:-\d+)?)/gi;
  while ((match = sharedRefRegex.exec(str)) !== null) nodeIds.add(match[1]);
  const obj = conditionSet;
  const extractFromActions = (actions) => {
    if (!Array.isArray(actions)) return;
    for (const action2 of actions) {
      if (Array.isArray(action2.nodeIds)) {
        for (const nodeId of action2.nodeIds) {
          if (typeof nodeId !== "string") continue;
          const normalized = normalizeCapacityRef(nodeId);
          if (normalized.type === "unknown") {
            nodeIds.add(nodeId);
          } else {
            capacityRefs.add(normalized.canonical);
          }
        }
      }
    }
  };
  if (Array.isArray(obj.branches)) {
    for (const branch of obj.branches) {
      if (Array.isArray(branch.actions)) extractFromActions(branch.actions);
    }
  }
  if (obj.fallback && Array.isArray(obj.fallback.actions)) {
    extractFromActions(obj.fallback.actions);
  }
  const genericUuid = /([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:-\d+)?)/gi;
  while ((match = genericUuid.exec(str)) !== null) nodeIds.add(match[1]);
  const genericNode = /(node_[a-z0-9_-]+(?:-\d+)?)/gi;
  while ((match = genericNode.exec(str)) !== null) nodeIds.add(match[1]);
  const genericShared = /(shared-ref-[a-z0-9-]+(?:-\d+)?)/gi;
  while ((match = genericShared.exec(str)) !== null) nodeIds.add(match[1]);
  for (const ref of extractCapacityRefsFromString(str)) capacityRefs.add(ref);
  return { nodeIds, capacityRefs };
}
function extractNodeIdsFromFormula(tokens2) {
  const ids = /* @__PURE__ */ new Set();
  if (!tokens2) return ids;
  let tokensArray;
  if (typeof tokens2 === "string") {
    try {
      tokensArray = JSON.parse(tokens2);
    } catch {
      return ids;
    }
  } else if (Array.isArray(tokens2)) {
    tokensArray = tokens2;
  } else {
    return ids;
  }
  for (const token of tokensArray) {
    if (token && typeof token === "object") {
      if (token.type === "field" && token.fieldId) {
        ids.add(token.fieldId);
      }
      if (token.type === "nodeValue" && token.nodeId) {
        ids.add(token.nodeId);
      }
      if (token.ref && typeof token.ref === "string") {
        const match = token.ref.match(/@value\.([a-f0-9-]+)/);
        if (match) ids.add(match[1]);
      }
    }
  }
  const str = JSON.stringify(tokensArray);
  let m;
  const refWithSuffixRegex = /@(?:value|calculated|select)\.([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:-\d+)?)/gi;
  while ((m = refWithSuffixRegex.exec(str)) !== null) ids.add(m[1]);
  const uuidRegex = /([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:-\d+)?)/gi;
  while ((m = uuidRegex.exec(str)) !== null) ids.add(m[1]);
  const nodeRegex = /(node_[a-z0-9_-]+)/gi;
  while ((m = nodeRegex.exec(str)) !== null) ids.add(m[1]);
  const sharedRegex = /(shared-ref-[a-z0-9-]+(?:-\d+)?)/gi;
  while ((m = sharedRegex.exec(str)) !== null) ids.add(m[1]);
  return ids;
}
function extractNodeAndCapacityRefsFromFormula(tokens2) {
  const nodeIds = /* @__PURE__ */ new Set();
  const capacityRefs = /* @__PURE__ */ new Set();
  if (!tokens2) return { nodeIds, capacityRefs };
  let tokensArray;
  if (typeof tokens2 === "string") {
    try {
      tokensArray = JSON.parse(tokens2);
    } catch {
      return { nodeIds, capacityRefs };
    }
  } else if (Array.isArray(tokens2)) {
    tokensArray = tokens2;
  } else {
    return { nodeIds, capacityRefs };
  }
  for (const token of tokensArray) {
    if (!token || typeof token !== "object") continue;
    if (token.type === "field" && token.fieldId) nodeIds.add(token.fieldId);
    if (token.type === "nodeValue" && token.nodeId) nodeIds.add(token.nodeId);
    if (token.ref && typeof token.ref === "string") {
      const m2 = token.ref.match(/@value\.([a-f0-9-]+)/);
      if (m2) nodeIds.add(m2[1]);
    }
  }
  const str = JSON.stringify(tokensArray);
  let m;
  const uuidRegex = /([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:-\d+)?)/gi;
  while ((m = uuidRegex.exec(str)) !== null) nodeIds.add(m[1]);
  const nodeRegex = /(node_[a-z0-9_-]+(?:-\d+)?)/gi;
  while ((m = nodeRegex.exec(str)) !== null) nodeIds.add(m[1]);
  const sharedRegex = /(shared-ref-[a-z0-9-]+(?:-\d+)?)/gi;
  while ((m = sharedRegex.exec(str)) !== null) nodeIds.add(m[1]);
  for (const ref of extractCapacityRefsFromString(str)) capacityRefs.add(ref);
  return { nodeIds, capacityRefs };
}
function extractNodeIdsFromTable(tableData) {
  const ids = /* @__PURE__ */ new Set();
  if (!tableData || typeof tableData !== "object") return ids;
  const table = tableData;
  if (table.nodeId && typeof table.nodeId === "string") {
    ids.add(table.nodeId);
  }
  return ids;
}
function extractNodeAndCapacityRefsFromTable(tableData) {
  const nodeIds = /* @__PURE__ */ new Set();
  const capacityRefs = /* @__PURE__ */ new Set();
  if (!tableData || typeof tableData !== "object") return { nodeIds, capacityRefs };
  const str = JSON.stringify(tableData);
  let match;
  const uuidRegex = /([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:-\d+)?)/gi;
  while ((match = uuidRegex.exec(str)) !== null) nodeIds.add(match[1]);
  const nodeRegex = /(node_[a-z0-9_-]+(?:-\d+)?)/gi;
  while ((match = nodeRegex.exec(str)) !== null) nodeIds.add(match[1]);
  const sharedRefRegex = /(shared-ref-[a-z0-9-]+(?:-\d+)?)/gi;
  while ((match = sharedRefRegex.exec(str)) !== null) nodeIds.add(match[1]);
  for (const ref of extractCapacityRefsFromString(str)) capacityRefs.add(ref);
  return { nodeIds, capacityRefs };
}
async function getNodeLinkedField(client, nodeId, field) {
  try {
    const node = await client.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      select: { [field]: true }
    });
    if (!node) return [];
    const value = node[field];
    if (Array.isArray(value)) return value.filter(Boolean);
    return [];
  } catch (e) {
    console.warn(`\xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F Impossible de lire ${field} pour n\xC3\u2026\xE2\u20AC\u0153ud ${nodeId}:`, e.message);
    return [];
  }
}
async function setNodeLinkedField(client, nodeId, field, values) {
  try {
    const uniqueValues = Array.from(new Set(values.filter(Boolean)));
    const exists = await client.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      select: { id: true }
    });
    if (!exists) {
      return;
    }
    await client.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: { [field]: uniqueValues }
    });
  } catch (e) {
  }
}
async function gatherNodeIdsRecursively(client, sourceRef, visited = /* @__PURE__ */ new Set()) {
  const aggregated = /* @__PURE__ */ new Set();
  const norm = normalizeCapacityRef(sourceRef);
  const isUuid = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i.test(sourceRef);
  const isNodeId = /^node_[a-z0-9_-]+$/i.test(sourceRef);
  const isSharedRef = /^shared-ref-[a-z0-9-]+$/i.test(sourceRef);
  if (norm.type === "unknown") {
    if (isUuid || isNodeId || isSharedRef) aggregated.add(sourceRef);
    return aggregated;
  }
  if (visited.has(norm.canonical)) return aggregated;
  visited.add(norm.canonical);
  if (norm.type === "condition") {
    const condition = await client.treeBranchLeafNodeCondition.findUnique({
      where: { id: norm.id },
      select: { conditionSet: true }
    });
    if (condition) {
      const { nodeIds, capacityRefs } = extractNodeAndCapacityRefsFromCondition(condition.conditionSet);
      for (const id of nodeIds) aggregated.add(id);
      for (const capRef of capacityRefs) {
        const rec = await gatherNodeIdsRecursively(client, capRef, visited);
        for (const id of rec) aggregated.add(id);
      }
    }
    return aggregated;
  }
  if (norm.type === "formula") {
    const formula = await client.treeBranchLeafNodeFormula.findUnique({
      where: { id: norm.id },
      select: { tokens: true }
    });
    if (formula) {
      const { nodeIds, capacityRefs } = extractNodeAndCapacityRefsFromFormula(formula.tokens);
      for (const id of nodeIds) aggregated.add(id);
      for (const capRef of capacityRefs) {
        const rec = await gatherNodeIdsRecursively(client, capRef, visited);
        for (const id of rec) aggregated.add(id);
      }
    }
    return aggregated;
  }
  if (norm.type === "table") {
    const table = await client.treeBranchLeafNodeTable.findUnique({
      where: { id: norm.id },
      select: { meta: true, tableRows: true, tableColumns: true }
    });
    if (table) {
      const { nodeIds, capacityRefs } = extractNodeAndCapacityRefsFromTable({
        meta: table.meta,
        rows: table.tableRows,
        columns: table.tableColumns
      });
      for (const id of nodeIds) aggregated.add(id);
      for (const capRef of capacityRefs) {
        const rec = await gatherNodeIdsRecursively(client, capRef, visited);
        for (const id of rec) aggregated.add(id);
      }
    }
    return aggregated;
  }
  return aggregated;
}
async function addToNodeLinkedField(client, nodeId, field, idsToAdd) {
  if (!idsToAdd || idsToAdd.length === 0) return;
  const current = await getNodeLinkedField(client, nodeId, field);
  const updated = Array.from(/* @__PURE__ */ new Set([...current, ...idsToAdd.filter(Boolean)]));
  if (updated.length === current.length) return;
  await setNodeLinkedField(client, nodeId, field, updated);
}
async function linkConditionToAllNodes(client, conditionId, conditionSet) {
  const nodeIds = extractNodeIdsFromCondition(conditionSet);
  let successCount = 0;
  let errorCount = 0;
  for (const nodeId of nodeIds) {
    try {
      await addToNodeLinkedField(client, nodeId, "linkedConditionIds", [conditionId]);
      successCount++;
    } catch (e) {
      errorCount++;
      console.error(`   \xC3\xA2\xC2\x9D\xC5\u2019 ${nodeId} \xC3\xA2\xE2\u20AC\xA0\xE2\u20AC\u2122 \xC3\u0192\xE2\u20AC\xB0CHEC:`, e.message);
    }
  }
}
async function linkFormulaToAllNodes(client, formulaId, tokens2) {
  const nodeIds = extractNodeIdsFromFormula(tokens2);
  let successCount = 0;
  let errorCount = 0;
  for (const nodeId of nodeIds) {
    try {
      await addToNodeLinkedField(client, nodeId, "linkedFormulaIds", [formulaId]);
      successCount++;
    } catch (e) {
      errorCount++;
      console.error(`   \xC3\xA2\xC2\x9D\xC5\u2019 ${nodeId} \xC3\xA2\xE2\u20AC\xA0\xE2\u20AC\u2122 \xC3\u0192\xE2\u20AC\xB0CHEC:`, e.message);
    }
  }
}
async function linkTableToAllNodes(client, tableId, tableData) {
  const nodeIds = extractNodeIdsFromTable(tableData);
  let successCount = 0;
  let errorCount = 0;
  for (const nodeId of nodeIds) {
    try {
      const node = await client.treeBranchLeafNode.findUnique({
        where: { id: nodeId },
        select: { fieldType: true, id: true }
      });
      if (!node) continue;
      if (node.fieldType === null || node.fieldType === "" || node.fieldType === void 0) {
        continue;
      }
      await addToNodeLinkedField(client, nodeId, "linkedTableIds", [tableId]);
      successCount++;
    } catch (e) {
      errorCount++;
      console.error(`   \u2717 ${nodeId} ECHEC:`, e.message);
    }
  }
}
async function linkVariableToAllCapacityNodes(client, variableId, sourceRef) {
  try {
    const nodeIds = await gatherNodeIdsRecursively(client, sourceRef);
    let successCount = 0;
    let errorCount = 0;
    for (const nodeId of nodeIds) {
      try {
        await addToNodeLinkedField(client, nodeId, "linkedVariableIds", [variableId]);
        successCount++;
      } catch (e) {
        errorCount++;
        console.error(`   \xC3\xA2\xC2\x9D\xC5\u2019 ${nodeId} \xC3\xA2\xE2\u20AC\xA0\xE2\u20AC\u2122 \xC3\u0192\xE2\u20AC\xB0CHEC:`, e.message);
      }
    }
  } catch (e) {
    console.error(`   \xC3\xA2\xC2\x9D\xC5\u2019 Erreur lors de la liaison variable:`, e.message);
  }
}

// src/components/TreeBranchLeaf/treebranchleaf-new/shared/hierarchyRules.ts
function calculateGenealogy(nodeId, nodesMap) {
  const genealogy = [];
  let currentNode = nodesMap.get(nodeId);
  const visitedNodes = /* @__PURE__ */ new Set();
  while (currentNode) {
    if (visitedNodes.has(currentNode.id)) {
      throw new Error(`\xAD\u0192\xF6\xE4 Cycle d\u251C\xAEtect\u251C\xAE dans la hi\u251C\xAErarchie au n\u253C\xF4ud ${currentNode.id} (${currentNode.label})`);
    }
    visitedNodes.add(currentNode.id);
    genealogy.unshift(currentNode.id);
    if (!currentNode.parentId) {
      break;
    }
    currentNode = nodesMap.get(currentNode.parentId);
    if (genealogy.length > 100) {
      throw new Error("\xAD\u0192\xDC\xBD Profondeur hi\u251C\xAErarchique excessive d\u251C\xAEtect\u251C\xAEe (>100 niveaux)");
    }
  }
  return genealogy;
}
function calculateNodeLevel(nodeId, nodesMap) {
  try {
    const genealogy = calculateGenealogy(nodeId, nodesMap);
    return genealogy.length;
  } catch (error) {
    console.error("\xD4\xD8\xEE Erreur lors du calcul du niveau:", error);
    return -1;
  }
}
function validateNodeTypeAtLevel(nodeType, level) {
  switch (nodeType) {
    case "tree":
      return level === 1;
    // Racine uniquement
    case "branch":
      return level >= 1;
    case "section":
      return level >= 1;
    case "leaf_field":
    case "leaf_option":
    case "leaf_option_field":
    case "leaf_repeater":
      return level >= 1;
    default:
      return false;
  }
}
function getDetailedLevelRule(nodeType) {
  switch (nodeType) {
    case "tree":
      return "Les arbres sont des racines (niveau 1 uniquement)";
    case "branch":
      return "Les branches peuvent \u251C\xACtre cr\u251C\xAE\u251C\xAEes \u251C\xE1 partir du niveau 2, sous l'arbre ou sous une autre branche";
    case "leaf_field":
      return "Les champs doivent \u251C\xACtre cr\u251C\xAE\u251C\xAEs au niveau 2 ou plus (sous des branches)";
    case "leaf_option":
      return "Les options doivent \u251C\xACtre cr\u251C\xAE\u251C\xAEes au niveau 2 ou plus (sous des branches)";
    case "leaf_option_field":
      return "Les champs+options doivent \u251C\xACtre cr\u251C\xAE\u251C\xAEs au niveau 2 ou plus (sous des branches)";
    case "leaf_select":
      return "Les s\u251C\xAElecteurs doivent \u251C\xACtre cr\u251C\xAE\u251C\xAEs au niveau 2 ou plus (sous des branches)";
    case "leaf_text":
      return "Les champs texte doivent \u251C\xACtre cr\u251C\xAE\u251C\xAEs au niveau 2 ou plus (sous des branches)";
    case "leaf_email":
      return "Les champs email doivent \u251C\xACtre cr\u251C\xAE\u251C\xAEs au niveau 2 ou plus (sous des branches)";
    case "leaf_phone":
      return "Les champs t\u251C\xAEl\u251C\xAEphone doivent \u251C\xACtre cr\u251C\xAE\u251C\xAEs au niveau 2 ou plus (sous des branches)";
    case "leaf_date":
      return "Les champs date doivent \u251C\xACtre cr\u251C\xAE\u251C\xAEs au niveau 2 ou plus (sous des branches)";
    case "leaf_number":
      return "Les champs num\u251C\xAEriques doivent \u251C\xACtre cr\u251C\xAE\u251C\xAEs au niveau 2 ou plus (sous des branches)";
    case "leaf_checkbox":
      return "Les cases \u251C\xE1 cocher doivent \u251C\xACtre cr\u251C\xAE\u251C\xAEes au niveau 2 ou plus (sous des branches)";
    case "leaf_radio":
      return "Les boutons radio doivent \u251C\xACtre cr\u251C\xAE\u251C\xAEs au niveau 2 ou plus (sous des branches)";
    case "leaf_repeater":
      return "Les blocs r\u251C\xAEp\u251C\xAEtables doivent \u251C\xACtre cr\u251C\xAE\u251C\xAEs au niveau 2 ou plus (sous des branches)";
    default:
      return "Type de n\u253C\xF4ud inconnu";
  }
}
function validateLeafElement(parentType, parentLevel, childType, childLevel, elementName) {
  if (false) {
    return {
      isValid: false,
      reason: `Les ${elementName} ne peuvent pas \u251C\xACtre cr\u251C\xAE\u251C\xAEs directement sous l'arbre`,
      level: childLevel,
      errorCode: "LEAF_NEEDS_BRANCH_PARENT",
      suggestion: "Cr\u251C\xAEez d'abord une branche au niveau 2, puis ajoutez vos \u251C\xAEl\u251C\xAEments dedans"
    };
  }
  if (parentType === "tree" || parentType === "branch" || parentType === "section" || parentType.startsWith("leaf_")) {
    return {
      isValid: true,
      level: childLevel,
      errorCode: void 0
    };
  }
  return {
    isValid: false,
    reason: `Les ${elementName} ne peuvent \u251C\xACtre cr\u251C\xAE\u251C\xAEs que sous des branches ou d'autres \u251C\xAEl\u251C\xAEments leaf (niveau 3+)`,
    level: childLevel,
    errorCode: "INVALID_LEAF_PARENT",
    suggestion: "Glissez cet \u251C\xAEl\u251C\xAEment vers une branche ou un autre champ"
  };
}
function validateParentChildRelation(parentType, parentSubType, childType, childSubType, parentLevel, nodesMap, parentId) {
  let actualParentLevel;
  if (parentLevel !== void 0) {
    actualParentLevel = parentLevel;
  } else if (nodesMap && parentId) {
    actualParentLevel = calculateNodeLevel(parentId, nodesMap);
    if (actualParentLevel === -1) {
      return {
        isValid: false,
        reason: "Impossible de calculer le niveau du parent (structure corrompue)",
        errorCode: "CORRUPTED_HIERARCHY",
        suggestion: "Rechargez la page ou contactez le support"
      };
    }
  } else {
    actualParentLevel = parentType === "tree" ? 1 : parentType === "branch" ? 2 : 3;
  }
  const childLevel = actualParentLevel + 1;
  if (!validateNodeTypeAtLevel(childType, childLevel)) {
    return {
      isValid: false,
      reason: `Le type ${childType} ne peut pas \u251C\xACtre plac\u251C\xAE au niveau ${childLevel}. ${getDetailedLevelRule(childType)}`,
      level: childLevel,
      errorCode: "INVALID_LEVEL"
    };
  }
  if (nodesMap && parentId) {
    try {
      const genealogy = calculateGenealogy(parentId, nodesMap);
      return {
        isValid: true,
        level: childLevel,
        genealogy,
        errorCode: void 0
      };
    } catch (error) {
      return {
        isValid: false,
        reason: error instanceof Error ? error.message : "Erreur de g\u251C\xAEn\u251C\xAEalogie",
        level: childLevel,
        errorCode: "GENEALOGY_ERROR"
      };
    }
  }
  switch (childType) {
    case "tree":
      return {
        isValid: false,
        reason: "Un arbre ne peut pas avoir de parent (c'est la racine)",
        level: childLevel,
        errorCode: "TREE_CANNOT_HAVE_PARENT",
        suggestion: "Les arbres sont des \u251C\xAEl\u251C\xAEments racines et ne peuvent \u251C\xACtre imbriqu\u251C\xAEs"
      };
    case "branch":
    case "section":
      if (parentType === "tree" || parentType === "branch" || parentType === "section") {
        return {
          isValid: true,
          level: childLevel,
          errorCode: void 0
        };
      }
      return {
        isValid: false,
        reason: `Les branches/sections doivent \u251C\xACtre sous l'arbre ou une autre branche/section (parent actuel: ${parentType})`,
        level: childLevel,
        errorCode: "BRANCH_INVALID_PARENT",
        suggestion: "Placez cet \u251C\xAEl\u251C\xAEment sous l'arbre ou une branche/section existante"
      };
    case "leaf_field":
    case "leaf_option_field":
    case "leaf_repeater":
      return validateLeafElement(
        parentType,
        actualParentLevel,
        childType,
        childLevel,
        childType === "leaf_field" ? "champs" : childType === "leaf_repeater" ? "blocs r\u251C\xAEp\u251C\xAEtables" : "champs+options"
      );
    case "leaf_option":
      return validateLeafElement(parentType, actualParentLevel, childType, childLevel, "options");
    case "leaf_select":
      return validateLeafElement(parentType, actualParentLevel, childType, childLevel, "s\u251C\xAElecteurs");
    case "leaf_text":
      return validateLeafElement(parentType, actualParentLevel, childType, childLevel, "champs texte");
    case "leaf_email":
      return validateLeafElement(parentType, actualParentLevel, childType, childLevel, "champs email");
    case "leaf_phone":
      return validateLeafElement(parentType, actualParentLevel, childType, childLevel, "champs t\u251C\xAEl\u251C\xAEphone");
    case "leaf_date":
      return validateLeafElement(parentType, actualParentLevel, childType, childLevel, "champs date");
    case "leaf_number":
      return validateLeafElement(parentType, actualParentLevel, childType, childLevel, "champs num\u251C\xAEriques");
    case "leaf_checkbox":
      return validateLeafElement(parentType, actualParentLevel, childType, childLevel, "cases \u251C\xE1 cocher");
    case "leaf_radio":
      return validateLeafElement(parentType, actualParentLevel, childType, childLevel, "boutons radio");
    default:
      return {
        isValid: false,
        reason: `Type de n\u253C\xF4ud non reconnu: ${childType}`,
        level: childLevel,
        errorCode: "UNKNOWN_NODE_TYPE",
        suggestion: "Contactez le support technique"
      };
  }
}
function getValidationErrorMessage(parentType, parentSubType, childType, childSubType, parentLevel) {
  const validation = validateParentChildRelation(
    parentType,
    parentSubType,
    childType,
    childSubType,
    parentLevel
  );
  if (validation.isValid) {
    return "\xD4\xA3\xE0 Op\u251C\xAEration valide";
  }
  switch (validation.errorCode) {
    case "BRANCH_ONLY_UNDER_TREE":
      return "\xAD\u0192\xDC\xBD R\u251C\xBFgle mise \u251C\xE1 jour: les branches sont permises \u251C\xE1 partir du niveau 2 sous l'arbre ou une autre branche";
    case "BRANCH_INVALID_PARENT":
      return "\xAD\u0192\xDC\xBD Les branches doivent \u251C\xACtre sous l'arbre ou une autre branche";
    case "LEAF_NEEDS_BRANCH_PARENT": {
      const elementName = childType === "leaf_field" ? "champs" : childType === "leaf_option" ? "options" : "champs+options";
      return `\xAD\u0192\xDC\xBD Les ${elementName} doivent \u251C\xACtre cr\u251C\xAE\u251C\xAEs au niveau 3 ou plus. Cr\u251C\xAEez d'abord une branche`;
    }
    case "TREE_CANNOT_HAVE_PARENT":
      return "\xAD\u0192\xDC\xBD Un arbre est une racine et ne peut pas avoir de parent";
    case "WOULD_CREATE_CYCLE":
      return "\xAD\u0192\xF6\xE4 Cette op\u251C\xAEration cr\u251C\xAEerait un cycle dans l'arbre (n\u253C\xF4ud qui deviendrait son propre parent)";
    case "CORRUPTED_HIERARCHY":
      return "\xAD\u0192\xC6\xD1 Structure d'arbre corrompue d\u251C\xAEtect\u251C\xAEe. Rechargez la page";
    case "INVALID_LEVEL":
      return `\xAD\u0192\xF4\xC5 Niveau incorrect pour ce type de n\u253C\xF4ud. ${validation.reason}`;
    default: {
      const message = validation.reason || "\xD4\xD8\xEE Relation parent-enfant non autoris\u251C\xAEe";
      return validation.suggestion ? `${message} (\xAD\u0192\xC6\xED ${validation.suggestion})` : message;
    }
  }
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/treebranchleaf-routes.ts
var import_crypto19 = require("crypto");
init_operation_interpreter();

// src/components/TreeBranchLeaf/treebranchleaf-new/api/registry/repeat-id-registry.ts
var DEFAULT_SCOPE = "global";
var registryStore = /* @__PURE__ */ new Map();
function resolveScopeId(ctx) {
  return ctx?.scopeId || ctx?.repeaterNodeId || ctx?.templateNodeId || ctx?.duplicatedFromNodeId || DEFAULT_SCOPE;
}
function resolveRegistryScopes(ctx) {
  const scopes = /* @__PURE__ */ new Set();
  const primary = resolveScopeId(ctx);
  if (primary) {
    scopes.add(primary);
  }
  if (ctx?.repeaterNodeId) {
    scopes.add(ctx.repeaterNodeId);
  }
  return Array.from(scopes);
}
function appendVariableRecord(scopeId, input) {
  const record = getRecord(scopeId);
  record.variables.push({ ...input, copyContext: { ...input.copyContext, scopeId } });
  record.lastUpdatedAt = (/* @__PURE__ */ new Date()).toISOString();
}
function appendCapacityRecord(scopeId, input) {
  const record = getRecord(scopeId);
  record.capacities.push({ ...input, copyContext: { ...input.copyContext, scopeId } });
  record.lastUpdatedAt = (/* @__PURE__ */ new Date()).toISOString();
}
function getRecord(scopeId) {
  const existing = registryStore.get(scopeId);
  if (existing) {
    return existing;
  }
  const fresh = {
    variables: [],
    capacities: [],
    lastUpdatedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  registryStore.set(scopeId, fresh);
  return fresh;
}
function registerVariable(input) {
  if (!input?.nodeId || !input?.variableId) {
    return;
  }
  const scopeIds = resolveRegistryScopes(input.copyContext);
  scopeIds.forEach((scopeId) => appendVariableRecord(scopeId, input));
}
function registerCapacityLink(input) {
  if (!input?.ownerNodeId || !input?.capacityId) {
    return;
  }
  const scopeIds = resolveRegistryScopes(input.copyContext);
  scopeIds.forEach((scopeId) => appendCapacityRecord(scopeId, input));
}
function captureRepeatTemplate(repeaterNodeId) {
  if (!repeaterNodeId) {
    return null;
  }
  const record = registryStore.get(repeaterNodeId);
  if (!record) {
    return null;
  }
  return {
    scopeId: repeaterNodeId,
    variables: [...record.variables],
    capacities: [...record.capacities],
    totalField: record.totalField ? { ...record.totalField } : void 0,
    capturedAt: (/* @__PURE__ */ new Date()).toISOString(),
    lastUpdatedAt: record.lastUpdatedAt
  };
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/repeat-blueprint-writer.ts
function logVariableEvent(payload) {
  try {
    const input = {
      nodeId: payload.nodeId,
      variableId: payload.variableId,
      sourceRef: payload.sourceRef,
      sourceType: payload.sourceType,
      displayNodeId: payload.displayNodeId,
      metadata: payload.metadata ?? void 0,
      copyContext: payload.context
    };
    registerVariable(input);
  } catch (err) {
    console.warn("[repeat-blueprint-writer] Unable to log variable event:", err);
  }
}
function logCapacityEvent(payload) {
  try {
    const input = {
      ownerNodeId: payload.ownerNodeId,
      capacityId: payload.capacityId,
      capacityType: payload.capacityType,
      referencedNodeIds: payload.referencedNodeIds,
      copyContext: payload.context
    };
    registerCapacityLink(input);
  } catch (err) {
    console.warn("[repeat-blueprint-writer] Unable to log capacity event:", err);
  }
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/utils/source-ref.ts
function parseSourceRef2(sourceRef) {
  if (!sourceRef || typeof sourceRef !== "string") return null;
  const cleaned = sourceRef.trim();
  if (!cleaned) return null;
  if (cleaned.startsWith("node-formula:")) {
    return { type: "formula", id: cleaned.replace("node-formula:", ""), prefix: "node-formula:" };
  }
  if (cleaned.startsWith("formula:")) {
    return { type: "formula", id: cleaned.replace("formula:", ""), prefix: "formula:" };
  }
  if (cleaned.startsWith("condition:")) {
    return { type: "condition", id: cleaned.replace("condition:", ""), prefix: "condition:" };
  }
  if (cleaned.startsWith("node-condition:")) {
    return { type: "condition", id: cleaned.replace("node-condition:", ""), prefix: "node-condition:" };
  }
  if (cleaned.startsWith("@table.")) {
    return { type: "table", id: cleaned.replace("@table.", ""), prefix: "@table." };
  }
  if (cleaned.startsWith("@table:")) {
    return { type: "table", id: cleaned.replace("@table:", ""), prefix: "@table:" };
  }
  if (cleaned.startsWith("table:")) {
    return { type: "table", id: cleaned.replace("table:", ""), prefix: "table:" };
  }
  if (cleaned.startsWith("table.")) {
    return { type: "table", id: cleaned.replace("table.", ""), prefix: "table." };
  }
  if (cleaned.startsWith("node-table:")) {
    return { type: "table", id: cleaned.replace("node-table:", ""), prefix: "node-table:" };
  }
  return { type: "field", id: cleaned, prefix: "" };
}
function applySuffixToSourceRef(sourceRef, suffix) {
  if (!sourceRef) return null;
  const parsed = parseSourceRef2(sourceRef);
  if (!parsed) return sourceRef;
  const suffixStr = `${suffix}`;
  const newId = `${parsed.id}-${suffixStr}`;
  return `${parsed.prefix}${newId}`;
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/sum-display-field-routes.ts
var import_client4 = require("@prisma/client");
init_database();
var prisma29 = db;
function getOrgId(req2) {
  const user = req2.user || {};
  const headerOrg = req2.headers?.["x-organization-id"] || req2.headers?.["x-organization"] || req2.headers?.["organization-id"];
  return user.organizationId || headerOrg || null;
}
function registerSumDisplayFieldRoutes(router94) {
  router94.post("/trees/:treeId/nodes/:nodeId/sum-display-field", async (req2, res) => {
    try {
      const { treeId, nodeId } = req2.params;
      const organizationId = getOrgId(req2);
      const tree = await prisma29.treeBranchLeafTree.findFirst({
        where: organizationId ? { id: treeId, organizationId } : { id: treeId }
      });
      if (!tree) {
        return res.status(404).json({ error: "Arbre non trouv\xC3\u0192\xC2\xA9" });
      }
      const node = await prisma29.treeBranchLeafNode.findFirst({
        where: { id: nodeId, treeId },
        select: {
          id: true,
          parentId: true,
          label: true,
          order: true,
          subtab: true,
          linkedVariableIds: true,
          metadata: true,
          subType: true,
          // üéØ FIX: R√©cup√©rer le subType de l'original
          fieldType: true
        }
      });
      if (!node) {
        return res.status(404).json({ error: "N\u0153ud non trouv\xE9" });
      }
      const originalMetadata = node.metadata || {};
      const originalTriggerNodeIds = originalMetadata.triggerNodeIds;
      const originalSubType = node.subType;
      console.log("\u{1F3AF} [SUM-DISPLAY] N\u0153ud original:", {
        nodeId,
        subType: originalSubType,
        triggerNodeIds: originalTriggerNodeIds,
        metadata: JSON.stringify(originalMetadata)
      });
      const mainVariable = await prisma29.treeBranchLeafNodeVariable.findUnique({
        where: { nodeId },
        select: {
          id: true,
          displayName: true,
          exposedKey: true,
          displayFormat: true,
          unit: true,
          precision: true
        }
      });
      if (!mainVariable) {
        return res.status(404).json({ error: "Variable non trouv\xC3\u0192\xC2\xA9e pour ce n\xC3\u2026\xE2\u20AC\u0153ud" });
      }
      const baseExposedKey = mainVariable.exposedKey.replace(/-\d+$/, "");
      const allCopies = await prisma29.treeBranchLeafNodeVariable.findMany({
        where: {
          OR: [
            { exposedKey: baseExposedKey },
            { exposedKey: { startsWith: `${baseExposedKey}-` } }
          ]
        },
        select: { id: true, exposedKey: true, nodeId: true }
      });
      const copyNodeIds = allCopies.map((c) => c.nodeId);
      const copyNodes = await prisma29.treeBranchLeafNode.findMany({
        where: { id: { in: copyNodeIds } },
        select: { id: true, order: true }
      });
      const maxCopyOrder = copyNodes.reduce((max, n) => Math.max(max, n.order ?? 0), 0);
      const sumFieldNodeId = `${nodeId}-sum-total`;
      const sumFieldVariableId = `${mainVariable.id}-sum-total`;
      const sumDisplayName = `${mainVariable.displayName} - Total`;
      const sumExposedKey = `${baseExposedKey}_TOTAL`;
      const existingSumNode = await prisma29.treeBranchLeafNode.findUnique({
        where: { id: sumFieldNodeId },
        select: { id: true, metadata: true }
      });
      const sourceNodeIcon = node.metadata?.icon || null;
      console.log(`[SUM-DISPLAY] \u{1F3A8} Ic\xF4ne h\xE9rit\xE9e du champ source "${node.label}": ${sourceNodeIcon || "(aucune)"}`);
      const sumTokens = [];
      allCopies.forEach((copy, index) => {
        if (index > 0) {
          sumTokens.push("+");
        }
        sumTokens.push(`@value.${copy.nodeId}`);
      });
      if (sumTokens.length === 0) {
        sumTokens.push("0");
      }
      const now = /* @__PURE__ */ new Date();
      const sumFormulaId = `${mainVariable.id}-sum-formula`;
      const formulaInstance = {
        id: sumFormulaId,
        name: `Somme ${mainVariable.displayName}`,
        tokens: sumTokens,
        description: `Somme automatique de toutes les copies de ${mainVariable.displayName}`
      };
      const inheritedSubType = originalSubType || null;
      const inheritedFieldType = node.fieldType || null;
      const sumNodeData = {
        label: sumDisplayName,
        field_label: sumDisplayName,
        fieldType: inheritedFieldType,
        // üéØ FIX: H√©riter le fieldType de l'original
        subType: inheritedSubType,
        // üéØ FIX: H√©riter le subType ('display' si c'est un champ display)
        fieldSubType: null,
        hasData: true,
        hasFormula: true,
        data_visibleToUser: false,
        // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬ß UNIFI√É∆í√¢‚Ç¨¬∞: false comme M√É‚Äö√Ç¬≤ toiture - Total
        formula_activeId: sumFormulaId,
        formula_instances: { [sumFormulaId]: formulaInstance },
        formula_tokens: sumTokens,
        linkedFormulaIds: [sumFormulaId],
        data_activeId: sumFieldVariableId,
        data_displayFormat: mainVariable.displayFormat,
        data_unit: mainVariable.unit,
        data_precision: mainVariable.precision,
        metadata: {
          ...existingSumNode?.metadata || {},
          icon: sourceNodeIcon,
          // üé® H√âRITAGE: m√™me ic√¥ne que le champ source
          isSumDisplayField: true,
          sourceVariableId: mainVariable.id,
          sourceNodeId: nodeId,
          sumTokens,
          copiesCount: allCopies.length,
          // ÔøΩ FIX: Copier les triggerNodeIds de l'original pour que le Total se recalcule
          // Le Total doit se recalculer quand les m√™mes champs que l'original changent
          ...originalTriggerNodeIds && originalTriggerNodeIds.length > 0 ? { triggerNodeIds: originalTriggerNodeIds } : {},
          // ÔøΩüé® H√âRITAGE IC√îNE: Ajouter l'ic√¥ne dans capabilities.datas pour le frontend
          capabilities: {
            ...existingSumNode?.metadata?.capabilities || {},
            datas: [{
              id: `data_${sumFieldNodeId}`,
              config: {
                icon: sourceNodeIcon,
                // üé® L'ic√¥ne doit aussi √™tre ici pour l'affichage frontend
                sourceRef: `node-variable:${sumFieldVariableId}`
              }
            }]
          },
          // üö´ PAS de capabilities.datas ici - le frontend utilise formula_instances directement
          // C'est le chemin qui fonctionne pour M¬≤ toiture - Total
          updatedAt: now.toISOString()
        },
        updatedAt: now
      };
      if (existingSumNode) {
        await prisma29.treeBranchLeafNode.update({
          where: { id: sumFieldNodeId },
          data: sumNodeData
        });
      } else {
        try {
          await prisma29.treeBranchLeafNode.create({
            data: {
              id: sumFieldNodeId,
              treeId,
              parentId: node.parentId,
              // M√É∆í√Ç¬™me section que le n√É‚Ä¶√¢‚Ç¨≈ìud original
              type: "leaf_field",
              label: sumDisplayName,
              field_label: sumDisplayName,
              order: maxCopyOrder + 1,
              // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬• APR√É∆í√ã‚Ä†S le dernier n√É‚Ä¶√¢‚Ç¨≈ìud copi√É∆í√Ç¬© (Mur-1, Mur-2, etc.)
              isVisible: true,
              isActive: true,
              subtab: node.subtab,
              hasData: true,
              hasFormula: true,
              data_activeId: sumFieldVariableId,
              createdAt: now,
              updatedAt: now,
              ...sumNodeData
            }
          });
        } catch (err) {
          if (err instanceof import_client4.Prisma.PrismaClientKnownRequestError && err.code === "P2002") {
            await prisma29.treeBranchLeafNode.update({ where: { id: sumFieldNodeId }, data: sumNodeData });
            console.warn(`\xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F [SUM DISPLAY] N\xC3\u2026\xE2\u20AC\u0153ud Total d\xC3\u0192\xC2\xA9j\xC3\u0192\xC2\xA0 existant, mise \xC3\u0192\xC2\xA0 jour forc\xC3\u0192\xC2\xA9e: ${sumFieldNodeId}`);
          } else {
            throw err;
          }
        }
      }
      const existingSumVariable = await prisma29.treeBranchLeafNodeVariable.findUnique({
        where: { nodeId: sumFieldNodeId }
      });
      const sumVariableData = {
        displayName: sumDisplayName,
        displayFormat: mainVariable.displayFormat,
        unit: mainVariable.unit,
        precision: mainVariable.precision,
        visibleToUser: true,
        sourceType: "formula",
        sourceRef: `node-formula:${sumFormulaId}`,
        metadata: {
          isSumVariable: true,
          sumTokens,
          copiesCount: allCopies.length,
          sourceVariableId: mainVariable.id
        },
        updatedAt: now
      };
      if (existingSumVariable) {
        await prisma29.treeBranchLeafNodeVariable.update({
          where: { nodeId: sumFieldNodeId },
          data: sumVariableData
        });
      } else {
        const existingKey = await prisma29.treeBranchLeafNodeVariable.findUnique({ where: { exposedKey: sumExposedKey } });
        const finalExposedKey = existingKey ? `${sumExposedKey}_${Date.now()}` : sumExposedKey;
        try {
          await prisma29.treeBranchLeafNodeVariable.create({
            data: {
              id: sumFieldVariableId,
              nodeId: sumFieldNodeId,
              exposedKey: finalExposedKey,
              createdAt: now,
              ...sumVariableData
            }
          });
        } catch (err) {
          if (err instanceof import_client4.Prisma.PrismaClientKnownRequestError && err.code === "P2002") {
            await prisma29.treeBranchLeafNodeVariable.update({ where: { nodeId: sumFieldNodeId }, data: sumVariableData });
            console.warn(`\xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F [SUM DISPLAY] Variable Total d\xC3\u0192\xC2\xA9j\xC3\u0192\xC2\xA0 existante, mise \xC3\u0192\xC2\xA0 jour forc\xC3\u0192\xC2\xA9e: ${sumFieldNodeId}`);
          } else {
            throw err;
          }
        }
      }
      const existingSumFormula = await prisma29.treeBranchLeafNodeFormula.findUnique({
        where: { id: sumFormulaId }
      });
      const formulaOrgId = tree.organizationId || organizationId;
      const sumFormulaData = {
        tokens: sumTokens,
        organizationId: formulaOrgId,
        updatedAt: now
      };
      if (existingSumFormula) {
        await prisma29.treeBranchLeafNodeFormula.update({ where: { id: sumFormulaId }, data: sumFormulaData });
      } else {
        try {
          await prisma29.treeBranchLeafNodeFormula.create({
            data: {
              id: sumFormulaId,
              nodeId: sumFieldNodeId,
              organizationId: formulaOrgId,
              name: `Somme ${mainVariable.displayName}`,
              description: `Somme automatique de toutes les copies de ${mainVariable.displayName}`,
              createdAt: now,
              ...sumFormulaData
            }
          });
        } catch (err) {
          if (err instanceof import_client4.Prisma.PrismaClientKnownRequestError && err.code === "P2002") {
            await prisma29.treeBranchLeafNodeFormula.update({
              where: {
                nodeId_name: {
                  nodeId: sumFieldNodeId,
                  name: `Somme ${mainVariable.displayName}`
                }
              },
              data: sumFormulaData
            });
            console.warn(`\xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F [SUM DISPLAY] Formule Total d\xC3\u0192\xC2\xA9j\xC3\u0192\xC2\xA0 existante, mise \xC3\u0192\xC2\xA0 jour forc\xC3\u0192\xC2\xA9e: ${sumFormulaId}`);
          } else {
            throw err;
          }
        }
      }
      const existingMeta = node.metadata || {};
      await prisma29.treeBranchLeafNode.update({
        where: { id: nodeId },
        data: {
          metadata: {
            ...existingMeta,
            createSumDisplayField: true,
            sumDisplayFieldNodeId: sumFieldNodeId
          }
        }
      });
      return res.json({
        success: true,
        sumFieldNodeId,
        sumFieldVariableId,
        sumFormulaId,
        copiesCount: allCopies.length,
        sumTokens
      });
    } catch (error) {
      const errMsg = error instanceof Error ? error.message : String(error);
      const errStack = error instanceof Error ? error.stack : "";
      console.error("\xC3\xA2\xC2\x9D\xC5\u2019 [SUM DISPLAY] Erreur:", errMsg);
      console.error("\xC3\xA2\xC2\x9D\xC5\u2019 [SUM DISPLAY] Stack:", errStack);
      res.status(500).json({ error: "Erreur lors de la cr\xC3\u0192\xC2\xA9ation du champ Total", details: errMsg });
    }
  });
  router94.delete("/trees/:treeId/nodes/:nodeId/sum-display-field", async (req2, res) => {
    try {
      const { treeId, nodeId } = req2.params;
      const organizationId = getOrgId(req2);
      const tree = await prisma29.treeBranchLeafTree.findFirst({
        where: organizationId ? { id: treeId, organizationId } : { id: treeId }
      });
      if (!tree) {
        return res.status(404).json({ error: "Arbre non trouv\xC3\u0192\xC2\xA9" });
      }
      const node = await prisma29.treeBranchLeafNode.findFirst({
        where: { id: nodeId, treeId },
        select: { id: true, metadata: true }
      });
      if (!node) {
        return res.status(404).json({ error: "N\xC3\u2026\xE2\u20AC\u0153ud non trouv\xC3\u0192\xC2\xA9" });
      }
      const sumFieldNodeId = `${nodeId}-sum-total`;
      const mainVariable = await prisma29.treeBranchLeafNodeVariable.findUnique({
        where: { nodeId },
        select: { id: true }
      });
      const sumFormulaId = mainVariable ? `${mainVariable.id}-sum-formula` : null;
      if (sumFormulaId) {
        try {
          await prisma29.treeBranchLeafNodeFormula.delete({
            where: { id: sumFormulaId }
          });
        } catch {
        }
      }
      try {
        await prisma29.treeBranchLeafNodeVariable.delete({
          where: { nodeId: sumFieldNodeId }
        });
      } catch {
      }
      try {
        await prisma29.treeBranchLeafNode.delete({
          where: { id: sumFieldNodeId }
        });
      } catch {
      }
      const existingMeta = node.metadata || {};
      await prisma29.treeBranchLeafNode.update({
        where: { id: nodeId },
        data: {
          metadata: {
            ...existingMeta,
            createSumDisplayField: false,
            sumDisplayFieldNodeId: null
          }
        }
      });
      return res.json({ success: true });
    } catch (error) {
      console.error("\xC3\xA2\xC2\x9D\xC5\u2019 [SUM DISPLAY] Erreur suppression:", error);
      res.status(500).json({ error: "Erreur lors de la suppression du champ Total" });
    }
  });
}
async function updateSumDisplayFieldAfterCopyChange(sourceNodeId, prismaClient) {
  const db2 = prismaClient || prisma29;
  try {
    const sourceNode = await db2.treeBranchLeafNode.findUnique({
      where: { id: sourceNodeId },
      select: {
        id: true,
        treeId: true,
        metadata: true
      }
    });
    if (!sourceNode) return;
    const metadata = sourceNode.metadata;
    const hasSum = metadata?.createSumDisplayField === true;
    const sumFieldNodeId = metadata?.sumDisplayFieldNodeId;
    if (!hasSum || !sumFieldNodeId) {
      return;
    }
    const mainVariable = await db2.treeBranchLeafNodeVariable.findUnique({
      where: { nodeId: sourceNodeId },
      select: { id: true, exposedKey: true, displayName: true }
    });
    if (!mainVariable) return;
    const baseExposedKey = mainVariable.exposedKey.replace(/-\d+$/, "");
    const allCopies = await db2.treeBranchLeafNodeVariable.findMany({
      where: {
        OR: [
          { exposedKey: baseExposedKey },
          { exposedKey: { startsWith: `${baseExposedKey}-` } }
        ]
      },
      select: { nodeId: true }
    });
    const copyNodeIds = allCopies.map((c) => c.nodeId);
    const allCopyNodes = await db2.treeBranchLeafNode.findMany({
      where: { id: { in: copyNodeIds } },
      select: { id: true, metadata: true, calculatedValue: true }
    });
    const aggregatedTriggers = /* @__PURE__ */ new Set();
    allCopyNodes.forEach((copyNode) => {
      const copyMetadata = copyNode.metadata || {};
      const copyTriggers = copyMetadata.triggerNodeIds;
      if (Array.isArray(copyTriggers)) {
        copyTriggers.forEach((t) => aggregatedTriggers.add(t));
      }
    });
    const allTriggerNodeIds = Array.from(aggregatedTriggers);
    console.log("\u{1F3AF} [SUM UPDATE] Triggers agr\xE9g\xE9s:", {
      copiesCount: allCopies.length,
      copyNodeIds,
      aggregatedTriggers: allTriggerNodeIds
    });
    const sumTokens = [];
    allCopies.forEach((copy, index) => {
      if (index > 0) sumTokens.push("+");
      sumTokens.push(`@value.${copy.nodeId}`);
    });
    if (sumTokens.length === 0) sumTokens.push("0");
    const now = /* @__PURE__ */ new Date();
    const sumFormulaId = `${mainVariable.id}-sum-formula`;
    const formulaInstance = {
      id: sumFormulaId,
      name: `Somme ${mainVariable.displayName}`,
      tokens: sumTokens,
      description: `Somme automatique de toutes les copies de ${mainVariable.displayName}`
    };
    const sumNodeExists = await db2.treeBranchLeafNode.findUnique({
      where: { id: sumFieldNodeId },
      select: { id: true }
    });
    if (!sumNodeExists) {
      return;
    }
    const formulaName = `Somme ${mainVariable.displayName}`;
    await db2.treeBranchLeafNodeFormula.upsert({
      where: {
        nodeId_name: {
          nodeId: sumFieldNodeId,
          name: formulaName
        }
      },
      update: { tokens: sumTokens, updatedAt: now },
      create: {
        id: sumFormulaId,
        name: formulaName,
        tokens: sumTokens,
        nodeId: sumFieldNodeId,
        createdAt: now,
        updatedAt: now
      }
    });
    let newCalculatedValue = 0;
    for (const node of allCopyNodes) {
      newCalculatedValue += parseFloat(String(node.calculatedValue)) || 0;
    }
    const sumNode = await db2.treeBranchLeafNode.findUnique({
      where: { id: sumFieldNodeId },
      select: { metadata: true }
    });
    if (sumNode) {
      await db2.treeBranchLeafNode.update({
        where: { id: sumFieldNodeId },
        data: {
          updatedAt: now,
          formula_instances: { [sumFormulaId]: formulaInstance },
          formula_tokens: sumTokens,
          calculatedValue: String(newCalculatedValue),
          // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬• NOUVEAU: Mettre √É∆í√Ç¬† jour la valeur
          metadata: {
            ...sumNode.metadata || {},
            sumTokens,
            copiesCount: allCopies.length,
            // üéØ FIX: Ajouter les triggerNodeIds agr√©g√©s de TOUTES les copies
            ...allTriggerNodeIds.length > 0 ? { triggerNodeIds: allTriggerNodeIds } : {},
            updatedAt: now.toISOString()
          }
        }
      });
    }
  } catch (error) {
    console.error("\xC3\xA2\xC2\x9D\xC5\u2019 [SUM UPDATE] Erreur mise \xC3\u0192\xC2\xA0 jour champ Total:", error);
  }
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/utils/universal-reference-rewriter.ts
function rewriteReferences(text, maps, suffix) {
  if (!text) return text;
  const suffixStr = suffix !== void 0 ? String(suffix) : void 0;
  const stripAllSuffixes = (id) => {
    return id.replace(/(-\d+)+$/, "");
  };
  const applySuffix = (id) => {
    if (!suffixStr) return id;
    const cleanId = stripAllSuffixes(id);
    return `${cleanId}-${suffixStr}`;
  };
  const mapOrSuffix = (id, map, isSharedRef = false) => {
    if (map.has(id)) {
      const mapped = map.get(id);
      return mapped;
    }
    if (isSharedRef) {
      if (!suffixStr) {
        return id;
      }
      const suffixed2 = applySuffix(id);
      return suffixed2;
    }
    const suffixed = applySuffix(id);
    if (suffixed !== id) {
    }
    return suffixed;
  };
  let result = text;
  result = result.replace(
    /@value\.node-formula:([A-Za-z0-9_-]+)/g,
    (_match, formulaIdWithSuffix) => {
      const formulaId = stripAllSuffixes(formulaIdWithSuffix);
      const newId = mapOrSuffix(formulaId, maps.formulaIdMap);
      return `@value.node-formula:${newId}`;
    }
  );
  result = result.replace(
    /@value\.node-condition:([A-Za-z0-9_-]+)/g,
    (_match, conditionIdWithSuffix) => {
      const conditionId = stripAllSuffixes(conditionIdWithSuffix);
      const newId = mapOrSuffix(conditionId, maps.conditionIdMap);
      return `@value.node-condition:${newId}`;
    }
  );
  result = result.replace(
    /@value\.condition:([A-Za-z0-9_-]+)/g,
    (_match, conditionIdWithSuffix) => {
      const conditionId = stripAllSuffixes(conditionIdWithSuffix);
      const newId = mapOrSuffix(conditionId, maps.conditionIdMap);
      return `@value.condition:${newId}`;
    }
  );
  result = result.replace(
    /@value\.node-table:([A-Za-z0-9_-]+)/g,
    (_match, tableIdWithSuffix) => {
      const tableId = stripAllSuffixes(tableIdWithSuffix);
      const newId = mapOrSuffix(tableId, maps.tableIdMap);
      return `@value.node-table:${newId}`;
    }
  );
  result = result.replace(
    /@value\.([A-Za-z0-9_:-]+)/g,
    (_match, nodeIdWithSuffix) => {
      if (nodeIdWithSuffix.startsWith("node-formula:") || nodeIdWithSuffix.startsWith("node-condition:") || nodeIdWithSuffix.startsWith("condition:") || nodeIdWithSuffix.startsWith("node-table:")) {
        return _match;
      }
      const nodeId = stripAllSuffixes(nodeIdWithSuffix);
      const isSharedRef = nodeId.startsWith("shared-ref-");
      const newId = mapOrSuffix(nodeId, maps.nodeIdMap, isSharedRef);
      return `@value.${newId}`;
    }
  );
  result = result.replace(
    /@table\.([A-Za-z0-9_-]+)/g,
    (_match, tableIdWithSuffix) => {
      const tableId = stripAllSuffixes(tableIdWithSuffix);
      const newId = mapOrSuffix(tableId, maps.tableIdMap);
      return `@table.${newId}`;
    }
  );
  result = result.replace(
    /node-formula:([A-Za-z0-9_-]+)/g,
    (_match, formulaIdWithSuffix) => {
      const formulaId = stripAllSuffixes(formulaIdWithSuffix);
      const newId = mapOrSuffix(formulaId, maps.formulaIdMap);
      return `node-formula:${newId}`;
    }
  );
  result = result.replace(
    /node-condition:([A-Za-z0-9_-]+)/g,
    (_match, conditionIdWithSuffix) => {
      const conditionId = stripAllSuffixes(conditionIdWithSuffix);
      const newId = mapOrSuffix(conditionId, maps.conditionIdMap);
      return `node-condition:${newId}`;
    }
  );
  result = result.replace(
    /condition:([A-Za-z0-9_-]+)/g,
    (_match, conditionIdWithSuffix) => {
      const conditionId = stripAllSuffixes(conditionIdWithSuffix);
      const newId = mapOrSuffix(conditionId, maps.conditionIdMap);
      return `condition:${newId}`;
    }
  );
  result = result.replace(
    /node-table:([A-Za-z0-9_-]+)/g,
    (_match, tableIdWithSuffix) => {
      const tableId = stripAllSuffixes(tableIdWithSuffix);
      const newId = mapOrSuffix(tableId, maps.tableIdMap);
      return `node-table:${newId}`;
    }
  );
  result = result.replace(
    /\b([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})(-\d+)?\b/gi,
    (fullMatch, uuid, existingSuffix) => {
      if (existingSuffix) {
        return fullMatch;
      }
      const newId = mapOrSuffix(uuid, maps.nodeIdMap, false);
      return newId;
    }
  );
  result = result.replace(
    /\b(node_[A-Za-z0-9_-]*[A-Za-z0-9])(-\d+)?\b/g,
    (fullMatch, baseNodeId, existingSuffix) => {
      if (existingSuffix) {
        return fullMatch;
      }
      const newId = mapOrSuffix(baseNodeId, maps.nodeIdMap, false);
      return newId;
    }
  );
  result = result.replace(
    /\b(shared-ref-[A-Za-z0-9_-]*[A-Za-z0-9])(-\d+)?\b/g,
    (fullMatch, baseRefId, existingSuffix) => {
      if (existingSuffix) {
        return fullMatch;
      }
      const newId = mapOrSuffix(baseRefId, maps.nodeIdMap, true);
      return newId;
    }
  );
  return result;
}
function rewriteJsonReferences(obj, maps, suffix) {
  if (obj === null || obj === void 0) return obj;
  if (typeof obj === "string") {
    return rewriteReferences(obj, maps, suffix);
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => rewriteJsonReferences(item, maps, suffix));
  }
  if (typeof obj === "object") {
    const result = {};
    for (const [key2, value] of Object.entries(obj)) {
      result[key2] = rewriteJsonReferences(value, maps, suffix);
    }
    return result;
  }
  return obj;
}
function forceSharedRefSuffixes(tokens2, suffix) {
  if (!Array.isArray(tokens2)) {
    return tokens2;
  }
  let modified = 0;
  let matchCount = 0;
  const result = tokens2.map((token, idx) => {
    if (typeof token === "string") {
      const sharedRefPattern = /^(@value\.shared-ref-[A-Za-z0-9_-]+)(?:-\d+)?$/;
      const match = token.match(sharedRefPattern);
      if (match) {
        matchCount++;
        const baseRef = match[1];
        const alreadySuffixed = /-\d+$/.test(token);
        if (!alreadySuffixed) {
          const suffixed = `${baseRef}-${suffix}`;
          modified++;
          return suffixed;
        } else {
        }
      } else if (token.includes("shared-ref")) {
        console.warn(`\xC3\xB0\xC5\xB8\xE2\u20AC\x9D\xC2\xA5 [idx ${idx}] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F CONTAINS 'shared-ref' MAIS NE MATCHE PAS regex: "${token}"`);
      }
    } else {
      if (String(token).includes("shared-ref")) {
        console.warn(`\xC3\xB0\xC5\xB8\xE2\u20AC\x9D\xC2\xA5 [idx ${idx}] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F Token NOT STRING mais contient 'shared-ref': Type=${typeof token}, Value=`, token);
      }
    }
    return token;
  });
  return result;
}
function forceSharedRefSuffixesInJson(obj, suffix) {
  if (obj === null || obj === void 0) return obj;
  if (Array.isArray(obj)) {
    return obj.map((item) => forceSharedRefSuffixesInJson(item, suffix));
  }
  if (typeof obj === "string") {
    const sharedRefPattern = /^(@value\.shared-ref-[A-Za-z0-9_-]+)(?:-\d+)?$/;
    const match = obj.match(sharedRefPattern);
    if (match) {
      const baseRef = match[1];
      const alreadySuffixed = /-\d+$/.test(obj);
      if (!alreadySuffixed) {
        const suffixed = `${baseRef}-${suffix}`;
        return suffixed;
      }
    }
    return obj;
  }
  if (typeof obj === "object") {
    let modified = 0;
    const result = {};
    for (const key2 in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key2)) {
        const newVal = forceSharedRefSuffixesInJson(obj[key2], suffix);
        result[key2] = newVal;
        if (newVal !== obj[key2]) modified++;
      }
    }
    if (modified > 0) {
    }
    return result;
  }
  return obj;
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/copy-capacity-formula.ts
async function copyFormulaCapacity(originalFormulaId, newNodeId, suffix, prisma51, options = {}) {
  const {
    nodeIdMap = /* @__PURE__ */ new Map(),
    formulaCopyCache = /* @__PURE__ */ new Map()
  } = options;
  try {
    if (formulaCopyCache.has(originalFormulaId)) {
      const cachedId = formulaCopyCache.get(originalFormulaId);
      const cached = await prisma51.treeBranchLeafNodeFormula.findUnique({
        where: { id: cachedId }
      });
      if (cached) {
        return {
          newFormulaId: cached.id,
          nodeId: cached.nodeId,
          tokens: cached.tokens,
          success: true
        };
      }
    }
    const cleanFormulaId = originalFormulaId.replace(/-\d+$/, "");
    const originalFormula = await prisma51.treeBranchLeafNodeFormula.findUnique({
      where: { id: cleanFormulaId }
    });
    if (!originalFormula) {
      console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 Formule introuvable avec id: ${cleanFormulaId}`);
      return {
        newFormulaId: "",
        nodeId: "",
        tokens: null,
        success: false,
        error: `Formule introuvable avec id: ${cleanFormulaId}`
      };
    }
    const newFormulaId = `${originalFormula.id}-${suffix}`;
    const originalOwnerNodeId = originalFormula.nodeId;
    const correctOwnerNodeId = `${originalOwnerNodeId}-${suffix}`;
    const ownerNodeExists = await prisma51.treeBranchLeafNode.findUnique({
      where: { id: correctOwnerNodeId },
      select: { id: true, label: true }
    });
    const finalOwnerNodeId = correctOwnerNodeId;
    const ownerNodeExistsForUpdate = !!ownerNodeExists;
    const rewriteMaps = {
      nodeIdMap,
      formulaIdMap: formulaCopyCache || /* @__PURE__ */ new Map(),
      conditionIdMap: /* @__PURE__ */ new Map(),
      // Pas besoin ici mais requis par l'interface
      tableIdMap: /* @__PURE__ */ new Map()
      // Pas besoin ici mais requis par l'interface
    };
    let rewrittenTokens = rewriteJsonReferences(originalFormula.tokens, rewriteMaps, suffix);
    const sharedRefsCountBefore = rewrittenTokens && Array.isArray(rewrittenTokens) ? rewrittenTokens.filter((t) => typeof t === "string" && t.includes("shared-ref")).length : 0;
    rewrittenTokens = forceSharedRefSuffixes(rewrittenTokens, suffix);
    const sharedRefsCountAfter1 = rewrittenTokens && Array.isArray(rewrittenTokens) ? rewrittenTokens.filter((t) => typeof t === "string" && t.includes("shared-ref")).length : 0;
    rewrittenTokens = forceSharedRefSuffixesInJson(rewrittenTokens, suffix);
    const sharedRefsCountAfter2 = rewrittenTokens && Array.isArray(rewrittenTokens) ? rewrittenTokens.filter((t) => typeof t === "string" && t.includes("shared-ref")).length : 0;
    if (Array.isArray(rewrittenTokens)) {
      const unsuffixed = rewrittenTokens.filter(
        (t) => typeof t === "string" && t.includes("shared-ref") && !/-\d+$/.test(t)
      );
      if (unsuffixed.length > 0) {
        console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 ALERTE: ${unsuffixed.length} shared-refs TOUJOURS non-suffix\xC3\u0192\xC2\xA9s:`, unsuffixed);
      } else {
      }
    }
    const formulaIdShort = originalFormula.id.substring(0, 8);
    const uniqueName = originalFormula.name ? `${originalFormula.name}-${formulaIdShort}-${suffix}` : `formula-${formulaIdShort}-${suffix}`;
    const newFormula = await prisma51.treeBranchLeafNodeFormula.upsert({
      where: { id: newFormulaId },
      update: {
        nodeId: finalOwnerNodeId,
        name: uniqueName,
        description: originalFormula.description,
        tokens: rewrittenTokens,
        targetProperty: originalFormula.targetProperty,
        constraintMessage: originalFormula.constraintMessage,
        isDefault: originalFormula.isDefault,
        order: originalFormula.order,
        updatedAt: /* @__PURE__ */ new Date()
      },
      create: {
        id: newFormulaId,
        nodeId: finalOwnerNodeId,
        organizationId: originalFormula.organizationId,
        name: uniqueName,
        description: originalFormula.description,
        tokens: rewrittenTokens,
        // üèØ CHAMPS CRITIQUES - Copie de la cible et des propri√©t√©s
        targetProperty: originalFormula.targetProperty,
        // ‚Üí CIBLE DE LA FORMULE
        constraintMessage: originalFormula.constraintMessage,
        // ‚Üí Message de contrainte
        isDefault: originalFormula.isDefault,
        // ‚Üí Formule par d√©faut
        order: originalFormula.order,
        // ‚Üí Ordre d'affichage
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    const savedFormula = await prisma51.treeBranchLeafNodeFormula.findUnique({
      where: { id: newFormula.id }
    });
    if (savedFormula && Array.isArray(savedFormula.tokens)) {
      const savedSharedRefs = savedFormula.tokens.filter(
        (t) => typeof t === "string" && t.includes("shared-ref")
      );
      const suffixed = savedSharedRefs.filter((s) => /-\d+$/.test(s));
      const nonSuffixed = savedSharedRefs.filter((s) => !/-\d+$/.test(s));
      if (nonSuffixed.length > 0) {
        console.error(`\xC3\xB0\xC5\xB8\xC5\xA1\xC2\xA8 ERREUR! Tokens non-suffix\xC3\u0192\xC2\xA9s en BD:`, nonSuffixed.slice(0, 2));
      } else {
      }
    }
    try {
      await linkFormulaToAllNodes(prisma51, newFormulaId, rewrittenTokens);
    } catch (e) {
      console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 Erreur LIAISON AUTOMATIQUE:`, e.message);
    }
    if (ownerNodeExistsForUpdate) {
      try {
        await addToNodeLinkedField2(prisma51, finalOwnerNodeId, "linkedFormulaIds", [newFormulaId]);
      } catch (e) {
        console.warn(`Erreur MAJ linkedFormulaIds du proprietaire:`, e.message);
      }
    }
    if (ownerNodeExistsForUpdate) {
      try {
        await prisma51.treeBranchLeafNode.update({
          where: { id: finalOwnerNodeId },
          data: {
            hasFormula: true,
            formula_activeId: newFormulaId,
            formula_name: newFormula.name
          }
        });
      } catch (e) {
        console.warn(`Erreur lors de la mise a jour des parametres capacite:`, e.message);
      }
    }
    formulaCopyCache.set(originalFormulaId, newFormulaId);
    return {
      newFormulaId,
      nodeId: finalOwnerNodeId,
      tokens: rewrittenTokens,
      success: true
    };
  } catch (error) {
    console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 Erreur lors de la copie de la formule:`, error);
    return {
      newFormulaId: "",
      nodeId: "",
      tokens: null,
      success: false,
      error: error instanceof Error ? error.message : String(error)
    };
  }
}
async function addToNodeLinkedField2(prisma51, nodeId, field, idsToAdd) {
  if (!idsToAdd || idsToAdd.length === 0) return;
  const node = await prisma51.treeBranchLeafNode.findUnique({
    where: { id: nodeId },
    select: { [field]: true }
  });
  if (!node) {
    console.warn(`\xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F N\xC3\u2026\xE2\u20AC\u0153ud ${nodeId} introuvable pour MAJ ${field}`);
    return;
  }
  const current = node[field] || [];
  const newIds = [.../* @__PURE__ */ new Set([...current, ...idsToAdd])];
  await prisma51.treeBranchLeafNode.update({
    where: { id: nodeId },
    data: { [field]: { set: newIds } }
  });
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/copy-capacity-condition.ts
function regenerateInternalIds(conditionSet, suffix) {
  if (!conditionSet || typeof conditionSet !== "object") {
    return conditionSet;
  }
  try {
    const suffixStr = String(suffix);
    let result = JSON.parse(JSON.stringify(conditionSet));
    const processObject = (obj) => {
      if (!obj || typeof obj !== "object") return obj;
      if (Array.isArray(obj)) {
        return obj.map(processObject);
      }
      const newObj = {};
      for (const [key2, value] of Object.entries(obj)) {
        if (key2 === "id" && typeof value === "string") {
          if (value.match(/^(b|a|bin|fb|cond)_[A-Za-z0-9_-]+$/)) {
            const newId = `${value}-${suffixStr}`;
            newObj[key2] = newId;
          } else {
            newObj[key2] = value;
          }
        } else if (typeof value === "object") {
          newObj[key2] = processObject(value);
        } else {
          newObj[key2] = value;
        }
      }
      return newObj;
    };
    result = processObject(result);
    return result;
  } catch (error) {
    console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 Erreur lors de la r\xC3\u0192\xC2\xA9g\xC3\u0192\xC2\xA9n\xC3\u0192\xC2\xA9ration des IDs internes:`, error);
    return conditionSet;
  }
}
function extractLinkedConditionIdsFromConditionSet(conditionSet) {
  const ids = /* @__PURE__ */ new Set();
  if (!conditionSet || typeof conditionSet !== "object") return ids;
  const str = JSON.stringify(conditionSet);
  const conditionRegex = /(?:condition|node-condition):([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:-\d+)?|[A-Za-z0-9_-]+(?:-\d+)?)/gi;
  let match;
  while ((match = conditionRegex.exec(str)) !== null) {
    ids.add(match[1]);
  }
  return ids;
}
function extractLinkedTableIdsFromConditionSet(conditionSet) {
  const ids = /* @__PURE__ */ new Set();
  if (!conditionSet || typeof conditionSet !== "object") return ids;
  const str = JSON.stringify(conditionSet);
  const tableRegex1 = /@table\.([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:-\d+)?|[A-Za-z0-9_-]+(?:-\d+)?)/gi;
  let match;
  while ((match = tableRegex1.exec(str)) !== null) {
    ids.add(match[1]);
  }
  const tableRegex2 = /node-table:([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:-\d+)?|[A-Za-z0-9_-]+(?:-\d+)?)/gi;
  while ((match = tableRegex2.exec(str)) !== null) {
    ids.add(match[1]);
  }
  return ids;
}
function replaceInJson(json, replacements) {
  if (!json || typeof json !== "object") {
    return json;
  }
  try {
    let str = JSON.stringify(json);
    for (const [search, replacement] of replacements) {
      str = str.replace(new RegExp(search.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"), replacement);
    }
    return JSON.parse(str);
  } catch (error) {
    console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 Erreur lors du remplacement dans JSON:`, error);
    return json;
  }
}
function extractLinkedFormulaIdsFromConditionSet(conditionSet) {
  const ids = /* @__PURE__ */ new Set();
  if (!conditionSet || typeof conditionSet !== "object") return ids;
  const str = JSON.stringify(conditionSet);
  const formulaRegex = /node-formula:([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}(?:-\d+)?|[A-Za-z0-9_-]+(?:-\d+)?)/gi;
  let match;
  while ((match = formulaRegex.exec(str)) !== null) {
    ids.add(match[1]);
  }
  return ids;
}
async function copyConditionCapacity(originalConditionId, newNodeId, suffix, prisma51, options = {}) {
  const {
    nodeIdMap = /* @__PURE__ */ new Map(),
    formulaIdMap = /* @__PURE__ */ new Map(),
    conditionCopyCache = /* @__PURE__ */ new Map()
  } = options;
  try {
    if (conditionCopyCache.has(originalConditionId)) {
      const cachedId = conditionCopyCache.get(originalConditionId);
      const cached = await prisma51.treeBranchLeafNodeCondition.findUnique({
        where: { id: cachedId }
      });
      if (cached) {
        return {
          newConditionId: cached.id,
          nodeId: cached.nodeId,
          conditionSet: cached.conditionSet,
          success: true
        };
      }
    }
    const cleanConditionId = originalConditionId.replace(/-\d+$/, "");
    const originalCondition = await prisma51.treeBranchLeafNodeCondition.findUnique({
      where: { id: cleanConditionId }
    });
    if (!originalCondition) {
      console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 Condition introuvable avec id: ${cleanConditionId}`);
      return {
        newConditionId: "",
        nodeId: "",
        conditionSet: null,
        success: false,
        error: `Condition introuvable avec id: ${cleanConditionId}`
      };
    }
    const newConditionId = `${originalCondition.id}-${suffix}`;
    const originalOwnerNodeId = originalCondition.nodeId;
    const correctOwnerNodeId = `${originalOwnerNodeId}-${suffix}`;
    const ownerNodeExists = await prisma51.treeBranchLeafNode.findUnique({
      where: { id: correctOwnerNodeId },
      select: { id: true, label: true }
    });
    const finalOwnerNodeId = ownerNodeExists ? correctOwnerNodeId : newNodeId;
    const linkedFormulaIdsFromSet = extractLinkedFormulaIdsFromConditionSet(originalCondition.conditionSet);
    if (linkedFormulaIdsFromSet.size > 0) {
      for (const formId of linkedFormulaIdsFromSet) {
        const existingForm = await prisma51.treeBranchLeafNodeFormula.findUnique({
          where: { id: formId }
        });
        if (existingForm) {
          if (Array.isArray(existingForm.tokens)) {
            const unsuffixedSharedRefs = existingForm.tokens.filter(
              (t) => typeof t === "string" && t.includes("shared-ref") && !/-\d+$/.test(t)
            );
          }
        } else {
        }
      }
      const enrichedNodeIdMap = new Map(nodeIdMap);
      if (originalCondition.nodeId && finalOwnerNodeId) {
        enrichedNodeIdMap.set(originalCondition.nodeId, finalOwnerNodeId);
      }
      for (const linkedFormId of linkedFormulaIdsFromSet) {
        if (formulaIdMap.has(linkedFormId)) {
        } else {
          try {
            const linkedFormResult = await copyFormulaCapacity(
              linkedFormId,
              finalOwnerNodeId,
              // M√É∆í√Ç¬™me n√É‚Ä¶√¢‚Ç¨≈ìud propri√É∆í√Ç¬©taire (corrig√É∆í√Ç¬©)
              suffix,
              prisma51,
              { nodeIdMap: enrichedNodeIdMap, formulaIdMap }
            );
            if (linkedFormResult.success) {
              const copiedForm = await prisma51.treeBranchLeafNodeFormula.findUnique({
                where: { id: linkedFormResult.newFormulaId }
              });
              if (copiedForm) {
                if (Array.isArray(copiedForm.tokens)) {
                  const unsuffixed = copiedForm.tokens.filter(
                    (t) => typeof t === "string" && t.includes("shared-ref") && !/-\d+$/.test(t)
                  );
                  if (unsuffixed.length > 0) {
                    console.error(`   \xC3\xA2\xC2\x9D\xC5\u2019 PROBL\xC3\u0192\xCB\u2020ME: ${unsuffixed.length} shared-refs TOUJOURS non-suffix\xC3\u0192\xC2\xA9s en BD:`, unsuffixed);
                  } else {
                  }
                }
              }
              formulaIdMap.set(linkedFormId, linkedFormResult.newFormulaId);
            } else {
              console.warn(`   \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F \xC3\u0192\xE2\u20AC\xB0chec copie formule li\xC3\u0192\xC2\xA9e: ${linkedFormId}`);
            }
          } catch (e) {
            console.error(`   \xC3\xA2\xC2\x9D\xC5\u2019 Exception copie formule li\xC3\u0192\xC2\xA9e:`, e.message);
          }
        }
      }
    } else {
    }
    const rewriteMaps = {
      nodeIdMap,
      formulaIdMap,
      conditionIdMap: conditionCopyCache || /* @__PURE__ */ new Map(),
      tableIdMap: /* @__PURE__ */ new Map()
      // Pas de table dans les conditions normalement
    };
    let rewrittenConditionSet = rewriteJsonReferences(
      originalCondition.conditionSet,
      rewriteMaps,
      suffix
    );
    const enrichedRewriteMaps = {
      nodeIdMap: new Map([...nodeIdMap, [originalCondition.nodeId, finalOwnerNodeId]]),
      // Enrichi avec le bon propri√É∆í√Ç¬©taire
      formulaIdMap,
      conditionIdMap: conditionCopyCache || /* @__PURE__ */ new Map(),
      tableIdMap: /* @__PURE__ */ new Map()
    };
    rewrittenConditionSet = rewriteJsonReferences(
      rewrittenConditionSet,
      // R√É∆í√Ç¬©√É∆í√Ç¬©crire le r√É∆í√Ç¬©sultat pr√É∆í√Ç¬©c√É∆í√Ç¬©dent
      enrichedRewriteMaps,
      suffix
    );
    rewrittenConditionSet = forceSharedRefSuffixesInJson(rewrittenConditionSet, suffix);
    rewrittenConditionSet = regenerateInternalIds(rewrittenConditionSet, suffix);
    const linkedConditionIdsFromSet = extractLinkedConditionIdsFromConditionSet(rewrittenConditionSet);
    if (linkedConditionIdsFromSet.size > 0) {
      for (const linkedCondId of linkedConditionIdsFromSet) {
        if (conditionCopyCache.has(linkedCondId)) {
          const mappedId = conditionCopyCache.get(linkedCondId);
          rewrittenConditionSet = replaceInJson(
            rewrittenConditionSet,
            /* @__PURE__ */ new Map([
              [`condition:${linkedCondId}`, `condition:${mappedId}`],
              [`node-condition:${linkedCondId}`, `node-condition:${mappedId}`]
            ])
          );
        } else {
          try {
            const linkedCondResult = await copyConditionCapacity(
              linkedCondId,
              finalOwnerNodeId,
              // M√É∆í√Ç¬™me n√É‚Ä¶√¢‚Ç¨≈ìud propri√É∆í√Ç¬©taire (corrig√É∆í√Ç¬©)
              suffix,
              prisma51,
              { nodeIdMap, formulaIdMap, conditionCopyCache }
            );
            if (linkedCondResult.success) {
              rewrittenConditionSet = replaceInJson(
                rewrittenConditionSet,
                /* @__PURE__ */ new Map([
                  [`condition:${linkedCondId}`, `condition:${linkedCondResult.newConditionId}`],
                  [`node-condition:${linkedCondId}`, `node-condition:${linkedCondResult.newConditionId}`]
                ])
              );
            } else {
              console.warn(`   \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F \xC3\u0192\xE2\u20AC\xB0chec copie condition li\xC3\u0192\xC2\xA9e: ${linkedCondId}`);
            }
          } catch (e) {
            console.error(`   \xC3\xA2\xC2\x9D\xC5\u2019 Exception copie condition li\xC3\u0192\xC2\xA9e:`, e.message);
          }
        }
      }
    } else {
    }
    const linkedTableIdsFromSet = extractLinkedTableIdsFromConditionSet(rewrittenConditionSet);
    if (linkedTableIdsFromSet.size > 0) {
      for (const linkedTableId of linkedTableIdsFromSet) {
        if (tableIdMap && tableIdMap.has(linkedTableId)) {
          const mappedId = tableIdMap.get(linkedTableId);
          rewrittenConditionSet = replaceInJson(
            rewrittenConditionSet,
            /* @__PURE__ */ new Map([
              [`@table.${linkedTableId}`, `@table.${mappedId}`],
              [`node-table:${linkedTableId}`, `node-table:${mappedId}`]
            ])
          );
        } else {
          try {
            const linkedTableResult = await copyTableCapacity(
              linkedTableId,
              finalOwnerNodeId,
              // M√É∆í√Ç¬™me n√É‚Ä¶√¢‚Ç¨≈ìud propri√É∆í√Ç¬©taire (corrig√É∆í√Ç¬©)
              suffix,
              prisma51,
              { nodeIdMap, tableIdMap }
            );
            if (linkedTableResult.success) {
              if (tableIdMap) tableIdMap.set(linkedTableId, linkedTableResult.newTableId);
              rewrittenConditionSet = replaceInJson(
                rewrittenConditionSet,
                /* @__PURE__ */ new Map([
                  [`@table.${linkedTableId}`, `@table.${linkedTableResult.newTableId}`],
                  [`node-table:${linkedTableId}`, `node-table:${linkedTableResult.newTableId}`]
                ])
              );
            } else {
              console.warn(`   \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F \xC3\u0192\xE2\u20AC\xB0chec copie table li\xC3\u0192\xC2\xA9e: ${linkedTableId}`);
            }
          } catch (e) {
            console.error(`   \xC3\xA2\xC2\x9D\xC5\u2019 Exception copie table li\xC3\u0192\xC2\xA9e:`, e.message);
          }
        }
      }
    } else {
    }
    let newCondition = await prisma51.treeBranchLeafNodeCondition.findUnique({ where: { id: newConditionId } });
    if (newCondition) {
      newCondition = await prisma51.treeBranchLeafNodeCondition.update({
        where: { id: newConditionId },
        data: {
          nodeId: finalOwnerNodeId,
          name: originalCondition.name ? `${originalCondition.name}-${suffix}` : null,
          description: originalCondition.description,
          conditionSet: rewrittenConditionSet,
          metadata: originalCondition.metadata,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    } else {
      newCondition = await prisma51.treeBranchLeafNodeCondition.create({
        data: {
          id: newConditionId,
          nodeId: finalOwnerNodeId,
          organizationId: originalCondition.organizationId,
          name: originalCondition.name ? `${originalCondition.name}-${suffix}` : null,
          description: originalCondition.description,
          conditionSet: rewrittenConditionSet,
          metadata: originalCondition.metadata,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    }
    try {
      await linkConditionToAllNodes(prisma51, newConditionId, rewrittenConditionSet);
    } catch (e) {
      console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 Erreur LIAISON AUTOMATIQUE:`, e.message);
    }
    try {
      await addToNodeLinkedField3(prisma51, finalOwnerNodeId, "linkedConditionIds", [newConditionId]);
    } catch (e) {
      console.warn(`\xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F Erreur MAJ linkedConditionIds du propri\xC3\u0192\xC2\xA9taire:`, e.message);
    }
    try {
      await prisma51.treeBranchLeafNode.update({
        where: { id: finalOwnerNodeId },
        data: {
          hasCondition: true,
          condition_activeId: newConditionId
        }
      });
    } catch (e) {
      console.warn(`\xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F Erreur lors de la mise \xC3\u0192\xC2\xA0 jour des param\xC3\u0192\xC2\xA8tres capacit\xC3\u0192\xC2\xA9:`, e.message);
    }
    conditionCopyCache.set(originalConditionId, newConditionId);
    return {
      newConditionId,
      nodeId: finalOwnerNodeId,
      conditionSet: rewrittenConditionSet,
      success: true
    };
  } catch (error) {
    console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 Erreur lors de la copie de la condition:`, error);
    return {
      newConditionId: "",
      nodeId: "",
      conditionSet: null,
      success: false,
      error: error instanceof Error ? error.message : String(error)
    };
  }
}
async function addToNodeLinkedField3(prisma51, nodeId, field, idsToAdd) {
  if (!idsToAdd || idsToAdd.length === 0) return;
  const node = await prisma51.treeBranchLeafNode.findUnique({
    where: { id: nodeId },
    select: { [field]: true }
  });
  if (!node) {
    console.warn(`\xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F N\xC3\u2026\xE2\u20AC\u0153ud ${nodeId} introuvable pour MAJ ${field}`);
    return;
  }
  const current = node[field] || [];
  const newIds = [.../* @__PURE__ */ new Set([...current, ...idsToAdd])];
  await prisma51.treeBranchLeafNode.update({
    where: { id: nodeId },
    data: { [field]: { set: newIds } }
  });
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/copy-capacity-table.ts
function stripNumericSuffix(value) {
  if (!value) return value;
  const numericWithAnySuffix = /^\d+(?:-\d+)+$/;
  const numericOnly = /^\d+$/;
  if (numericWithAnySuffix.test(value)) return value.split("-")[0];
  if (numericOnly.test(value)) return value;
  return value;
}
async function copyTableCapacity2(originalTableId, newNodeId, suffix, prisma51, options = {}) {
  const {
    nodeIdMap = /* @__PURE__ */ new Map(),
    tableCopyCache = /* @__PURE__ */ new Map(),
    tableIdMap: tableIdMap2 = /* @__PURE__ */ new Map()
  } = options;
  try {
    if (tableCopyCache.has(originalTableId)) {
      const cachedId = tableCopyCache.get(originalTableId);
      const cached = await prisma51.treeBranchLeafNodeTable.findUnique({
        where: { id: cachedId },
        include: {
          tableColumns: true,
          tableRows: true
        }
      });
      if (cached) {
        let totalCells = 0;
        for (const row of cached.tableRows) {
          const cells = row.cells || [];
          totalCells += Array.isArray(cells) ? cells.length : Object.keys(cells).length;
        }
        return {
          newTableId: cached.id,
          nodeId: cached.nodeId,
          columnsCount: cached.tableColumns.length,
          rowsCount: cached.tableRows.length,
          cellsCount: totalCells,
          success: true
        };
      }
    }
    const cleanTableId = originalTableId.replace(/-\d+$/, "");
    const originalTable = await prisma51.treeBranchLeafNodeTable.findUnique({
      where: { id: cleanTableId },
      include: {
        tableColumns: { orderBy: { columnIndex: "asc" } },
        tableRows: { orderBy: { rowIndex: "asc" } }
      }
    });
    if (!originalTable) {
      console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 Table introuvable avec id: ${cleanTableId}`);
      return {
        newTableId: "",
        nodeId: "",
        columnsCount: 0,
        rowsCount: 0,
        cellsCount: 0,
        success: false,
        error: `Table introuvable avec id: ${cleanTableId}`
      };
    }
    let originalTotalCells = 0;
    for (const row of originalTable.tableRows) {
      const cells = row.cells || [];
      originalTotalCells += Array.isArray(cells) ? cells.length : Object.keys(cells).length;
    }
    const newTableId = `${originalTable.id}-${suffix}`;
    const originalOwnerNodeId = originalTable.nodeId;
    const correctOwnerNodeId = `${originalOwnerNodeId}-${suffix}`;
    const ownerNodeExists = await prisma51.treeBranchLeafNode.findUnique({
      where: { id: correctOwnerNodeId },
      select: { id: true, label: true }
    });
    const finalOwnerNodeId = ownerNodeExists ? correctOwnerNodeId : newNodeId;
    const columnIdMap = /* @__PURE__ */ new Map();
    const rowIdMap = /* @__PURE__ */ new Map();
    let tableAlreadyExisted = false;
    let newTable = await prisma51.treeBranchLeafNodeTable.findUnique({ where: { id: newTableId } });
    if (newTable) {
      tableAlreadyExisted = true;
      newTable = await prisma51.treeBranchLeafNodeTable.update({
        where: { id: newTableId },
        data: {
          nodeId: finalOwnerNodeId,
          name: originalTable.name ? `${originalTable.name}-${suffix}` : null,
          description: originalTable.description,
          type: originalTable.type,
          // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬¢ COPIE TABLE META: suffixer TOUS les UUIDs et comparisonColumn
          meta: (() => {
            const rewriteMaps2 = { nodeIdMap, formulaIdMap: /* @__PURE__ */ new Map(), conditionIdMap: /* @__PURE__ */ new Map(), tableIdMap: tableIdMap2 };
            const rewritten = rewriteJsonReferences(originalTable.meta, rewriteMaps2, suffix);
            const suffixNum = parseInt(suffix) || 1;
            if (rewritten?.lookup?.selectors?.columnFieldId && !rewritten.lookup.selectors.columnFieldId.endsWith(`-${suffixNum}`)) {
              rewritten.lookup.selectors.columnFieldId = `${rewritten.lookup.selectors.columnFieldId}-${suffixNum}`;
            }
            if (rewritten?.lookup?.selectors?.rowFieldId && !rewritten.lookup.selectors.rowFieldId.endsWith(`-${suffixNum}`)) {
              rewritten.lookup.selectors.rowFieldId = `${rewritten.lookup.selectors.rowFieldId}-${suffixNum}`;
            }
            if (rewritten?.lookup?.rowSourceOption?.sourceField && !rewritten.lookup.rowSourceOption.sourceField.endsWith(`-${suffixNum}`)) {
              rewritten.lookup.rowSourceOption.sourceField = `${rewritten.lookup.rowSourceOption.sourceField}-${suffixNum}`;
            }
            if (rewritten?.lookup?.columnSourceOption?.sourceField && !rewritten.lookup.columnSourceOption.sourceField.endsWith(`-${suffixNum}`)) {
              rewritten.lookup.columnSourceOption.sourceField = `${rewritten.lookup.columnSourceOption.sourceField}-${suffixNum}`;
            }
            if (rewritten?.lookup?.rowSourceOption?.comparisonColumn) {
              const val = rewritten.lookup.rowSourceOption.comparisonColumn;
              if (!val.endsWith(`-${suffixNum}`)) {
                rewritten.lookup.rowSourceOption.comparisonColumn = `${val}-${suffixNum}`;
              }
            }
            if (rewritten?.lookup?.columnSourceOption?.comparisonColumn) {
              const val = rewritten.lookup.columnSourceOption.comparisonColumn;
              if (!val.endsWith(`-${suffixNum}`)) {
                rewritten.lookup.columnSourceOption.comparisonColumn = `${val}-${suffixNum}`;
              }
            }
            return rewritten;
          })(),
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    } else {
      newTable = await prisma51.treeBranchLeafNodeTable.create({
        data: {
          id: newTableId,
          nodeId: finalOwnerNodeId,
          organizationId: originalTable.organizationId,
          name: originalTable.name ? `${originalTable.name}-${suffix}` : null,
          description: originalTable.description,
          type: originalTable.type,
          // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬¢ COPIE TABLE META: suffixer TOUS les UUIDs et comparisonColumn
          meta: (() => {
            const rewriteMaps2 = { nodeIdMap, formulaIdMap: /* @__PURE__ */ new Map(), conditionIdMap: /* @__PURE__ */ new Map(), tableIdMap: tableIdMap2 };
            const rewritten = rewriteJsonReferences(originalTable.meta, rewriteMaps2);
            const suffixNum = parseInt(suffix) || 1;
            if (rewritten?.lookup?.selectors?.columnFieldId && !rewritten.lookup.selectors.columnFieldId.endsWith(`-${suffixNum}`)) {
              rewritten.lookup.selectors.columnFieldId = `${rewritten.lookup.selectors.columnFieldId}-${suffixNum}`;
            }
            if (rewritten?.lookup?.selectors?.rowFieldId && !rewritten.lookup.selectors.rowFieldId.endsWith(`-${suffixNum}`)) {
              rewritten.lookup.selectors.rowFieldId = `${rewritten.lookup.selectors.rowFieldId}-${suffixNum}`;
            }
            if (rewritten?.lookup?.rowSourceOption?.sourceField && !rewritten.lookup.rowSourceOption.sourceField.endsWith(`-${suffixNum}`)) {
              rewritten.lookup.rowSourceOption.sourceField = `${rewritten.lookup.rowSourceOption.sourceField}-${suffixNum}`;
            }
            if (rewritten?.lookup?.columnSourceOption?.sourceField && !rewritten.lookup.columnSourceOption.sourceField.endsWith(`-${suffixNum}`)) {
              rewritten.lookup.columnSourceOption.sourceField = `${rewritten.lookup.columnSourceOption.sourceField}-${suffixNum}`;
            }
            if (rewritten?.lookup?.rowSourceOption?.comparisonColumn) {
              const val = rewritten.lookup.rowSourceOption.comparisonColumn;
              if (!val.endsWith(`-${suffixNum}`)) {
                rewritten.lookup.rowSourceOption.comparisonColumn = `${val}-${suffixNum}`;
              }
            }
            if (rewritten?.lookup?.columnSourceOption?.comparisonColumn) {
              const val = rewritten.lookup.columnSourceOption.comparisonColumn;
              if (!val.endsWith(`-${suffixNum}`)) {
                rewritten.lookup.columnSourceOption.comparisonColumn = `${val}-${suffixNum}`;
              }
            }
            return rewritten;
          })(),
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    }
    let columnsCount = 0;
    let rowsCount = 0;
    if (tableAlreadyExisted) {
      const existingCols = await prisma51.treeBranchLeafNodeTableColumn.count({ where: { tableId: newTableId } });
      const existingRows = await prisma51.treeBranchLeafNodeTableRow.count({ where: { tableId: newTableId } });
      columnsCount = existingCols;
      rowsCount = existingRows;
    } else {
      const originalColumnsRaw = await prisma51.$queryRaw`
      SELECT "id", "tableId", "columnIndex", "name", "type", "width", "format", "metadata"
      FROM "TreeBranchLeafNodeTableColumn"
      WHERE "tableId" = ${originalTable.id}
      ORDER BY "columnIndex" ASC
    `;
      for (const col of originalColumnsRaw) {
        try {
          const newColumnId = `${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`;
          columnIdMap.set(col.id, newColumnId);
          const normalizedName = (() => {
            const raw = col.name;
            if (!raw) return raw;
            if (/^-?\d+(\.\d+)?$/.test(raw.trim())) return raw;
            return `${raw}-${suffix}`;
          })();
          await prisma51.treeBranchLeafNodeTableColumn.create({
            data: {
              id: newColumnId,
              tableId: newTableId,
              columnIndex: col.columnIndex,
              name: normalizedName,
              type: col.type || "text",
              width: col.width,
              format: col.format,
              metadata: col.metadata
              // Copie brute, pas de r√É∆í√Ç¬©√É∆í√Ç¬©criture
            }
          });
          columnsCount++;
        } catch (e) {
          console.warn(`  \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F [${col.columnIndex}] Erreur: ${e.message.split("\n")[0].substring(0, 80)}`);
        }
      }
      const originalRowsRaw = await prisma51.$queryRaw`
      SELECT "id", "tableId", "rowIndex", "cells"
      FROM "TreeBranchLeafNodeTableRow"
      WHERE "tableId" = ${originalTable.id}
      ORDER BY "rowIndex" ASC
    `;
      for (const row of originalRowsRaw) {
        try {
          const newRowId = `${Math.random().toString(36).substring(2, 15)}${Math.random().toString(36).substring(2, 15)}`;
          rowIdMap.set(row.id, newRowId);
          await prisma51.treeBranchLeafNodeTableRow.create({
            data: {
              id: newRowId,
              tableId: newTableId,
              rowIndex: row.rowIndex,
              cells: row.cells
              // Copie brute, pas de r√É∆í√Ç¬©√É∆í√Ç¬©criture
            }
          });
          rowsCount++;
          if (rowsCount % 5 === 0) {
          }
        } catch (e) {
          console.warn(`  \u26A0\uFE0F [${row.rowIndex}] Erreur: ${e.message.split("\n")[0].substring(0, 80)}`);
        }
      }
    }
    try {
      const cols = await prisma51.treeBranchLeafNodeTableColumn.findMany({
        where: { tableId: newTableId },
        select: { id: true, name: true }
      });
      for (const c of cols) {
        const cleaned = stripNumericSuffix(c.name);
        if (cleaned !== c.name) {
          await prisma51.treeBranchLeafNodeTableColumn.update({
            where: { id: c.id },
            data: { name: cleaned }
          });
        }
      }
    } catch (e) {
      console.warn(`\xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F Normalisation des noms de colonnes \xC3\u0192\xC2\xA9chou\xC3\u0192\xC2\xA9e:`, e.message);
    }
    await prisma51.treeBranchLeafNodeTable.update({
      where: { id: newTableId },
      data: {
        rowCount: rowsCount,
        columnCount: columnsCount,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    const rewriteMaps = { nodeIdMap, formulaIdMap: /* @__PURE__ */ new Map(), conditionIdMap: /* @__PURE__ */ new Map(), tableIdMap: tableIdMap2 };
    let rewrittenTableData = rewriteJsonReferences(originalTable.tableData, rewriteMaps, suffix);
    rewrittenTableData = forceSharedRefSuffixesInJson(rewrittenTableData, suffix);
    try {
      await linkTableToAllNodes(prisma51, newTableId, rewrittenTableData);
    } catch (e) {
      console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 Erreur LIAISON AUTOMATIQUE:`, e.message);
    }
    try {
      await addToNodeLinkedField4(prisma51, finalOwnerNodeId, "linkedTableIds", [newTableId]);
    } catch (e) {
      console.warn(`\xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F Erreur MAJ linkedTableIds du propri\xC3\u0192\xC2\xA9taire:`, e.message);
    }
    try {
      const originalNode = await prisma51.treeBranchLeafNode.findUnique({
        where: { id: originalTable.nodeId },
        select: {
          table_activeId: true,
          table_instances: true
        }
      });
      let newTableInstances = {};
      if (originalNode?.table_instances && typeof originalNode.table_instances === "object") {
        const originalInstances = originalNode.table_instances;
        for (const [tableId, config] of Object.entries(originalInstances)) {
          const mappedTableId = tableIdMap2.has(tableId) ? tableIdMap2.get(tableId) : `${tableId}-${suffix}`;
          const remappedConfig = rewriteJsonReferences(config, rewriteMaps, suffix);
          newTableInstances[mappedTableId] = remappedConfig;
        }
      }
      const oldActiveId = originalNode?.table_activeId;
      let newActiveId = newTableId;
      if (oldActiveId && tableIdMap2.has(oldActiveId)) {
        newActiveId = tableIdMap2.get(oldActiveId);
      } else if (oldActiveId) {
        newActiveId = `${oldActiveId}-${suffix}`;
      }
      if (!newTableInstances[newTableId]) {
        newTableInstances[newTableId] = {};
      }
      await prisma51.treeBranchLeafNode.update({
        where: { id: finalOwnerNodeId },
        data: {
          hasTable: true,
          table_activeId: newTableId,
          table_instances: newTableInstances,
          table_name: newTable.name,
          table_type: newTable.type
        }
      });
    } catch (e) {
      console.warn(`\xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F Erreur lors de la mise \xC3\u0192\xC2\xA0 jour des param\xC3\u0192\xC2\xA8tres capacit\xC3\u0192\xC2\xA9:`, e.message);
    }
    tableCopyCache.set(originalTableId, newTableId);
    return {
      newTableId,
      nodeId: finalOwnerNodeId,
      columnsCount,
      rowsCount,
      cellsCount: columnsCount * rowsCount,
      // Estimation des cellules bas√©e sur colonnes √ó lignes
      success: true
    };
  } catch (error) {
    console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 Erreur lors de la copie de la table:`, error);
    return {
      newTableId: "",
      nodeId: "",
      columnsCount: 0,
      rowsCount: 0,
      cellsCount: 0,
      success: false,
      error: error instanceof Error ? error.message : String(error)
    };
  }
}
async function addToNodeLinkedField4(prisma51, nodeId, field, idsToAdd) {
  if (!idsToAdd || idsToAdd.length === 0) return;
  const node = await prisma51.treeBranchLeafNode.findUnique({
    where: { id: nodeId },
    select: { [field]: true }
  });
  if (!node) {
    console.warn(`\xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F N\xC3\u2026\xE2\u20AC\u0153ud ${nodeId} introuvable pour MAJ ${field}`);
    return;
  }
  const current = node[field] || [];
  const newIds = [.../* @__PURE__ */ new Set([...current, ...idsToAdd])];
  await prisma51.treeBranchLeafNode.update({
    where: { id: nodeId },
    data: { [field]: { set: newIds } }
  });
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/services/variable-copy-engine.ts
async function copyVariableWithCapacities(originalVarId, suffix, newNodeId, prisma51, options = {}) {
  const {
    formulaIdMap = /* @__PURE__ */ new Map(),
    conditionIdMap = /* @__PURE__ */ new Map(),
    tableIdMap: tableIdMap2 = /* @__PURE__ */ new Map(),
    nodeIdMap = /* @__PURE__ */ new Map(),
    variableCopyCache = /* @__PURE__ */ new Map(),
    autoCreateDisplayNode = false,
    displaySectionLabel = "Nouveau Section",
    linkToDisplaySection = false,
    displayParentId,
    isFromRepeaterDuplication = false,
    repeatContext
    // displayNodeAlreadyCreated is not used anymore in this function; keep options API stable without reassigning
  } = options;
  try {
    const cacheKey = `${originalVarId}|${newNodeId}`;
    if (variableCopyCache.has(cacheKey)) {
      const cachedId = variableCopyCache.get(cacheKey);
      const cached = await prisma51.treeBranchLeafNodeVariable.findUnique({
        where: { id: cachedId }
      });
      if (cached) {
        const parsed = parseSourceRef2(cached.sourceRef);
        return {
          variableId: cached.id,
          exposedKey: cached.exposedKey,
          capacityType: parsed?.type || null,
          sourceRef: cached.sourceRef,
          success: true,
          displayNodeId: void 0
        };
      }
    }
    const originalVar = await prisma51.treeBranchLeafNodeVariable.findUnique({
      where: { id: originalVarId }
    });
    if (!originalVar) {
      if (newNodeId) {
        try {
          const orphanLinkedVarIds = await prisma51.treeBranchLeafNode.findMany({
            where: {
              linkedVariableIds: {
                hasSome: [originalVarId]
              }
            },
            select: { id: true, linkedVariableIds: true }
          });
          for (const node of orphanLinkedVarIds) {
            const cleaned = (node.linkedVariableIds || []).filter((id) => id !== originalVarId);
            if (cleaned.length !== node.linkedVariableIds?.length) {
              await prisma51.treeBranchLeafNode.update({
                where: { id: node.id },
                data: { linkedVariableIds: cleaned }
              });
            }
          }
        } catch (cleanErr) {
          console.warn(`\u26A0\uFE0F Impossible de nettoyer linkedVariableIds orphelins:`, cleanErr.message);
        }
      }
      return {
        variableId: "",
        exposedKey: "",
        capacityType: null,
        sourceRef: null,
        success: false,
        displayNodeId: void 0,
        error: `Variable introuvable: ${originalVarId}`
      };
    }
    const normalizedRepeatContext = repeatContext ? {
      ...repeatContext,
      templateNodeId: repeatContext.templateNodeId ?? originalVar.nodeId ?? void 0,
      suffix: repeatContext.suffix ?? suffix
    } : void 0;
    const suffixToken = `${suffix}`;
    const stripTrailingNumeric = (raw) => {
      if (!raw) return "";
      const trimmed = raw.trim();
      return trimmed.replace(/(?:-\d+)+\s*$/, "");
    };
    const appendSuffixOnce = (value) => {
      if (!value) return value ?? "";
      const base = stripTrailingNumeric(value);
      return base.endsWith(`-${suffixToken}`) ? base : `${base}-${suffixToken}`;
    };
    const forceSingleSuffix = (value) => {
      if (!value) return value ?? "";
      const base = stripTrailingNumeric(value);
      return `${base}-${suffixToken}`;
    };
    let newVarId = appendSuffixOnce(originalVarId);
    let newExposedKey = appendSuffixOnce(originalVar.exposedKey);
    let newSourceRef = originalVar.sourceRef;
    let capacityType = null;
    const emitCapacityEvent = (capacityId, capacityKind) => {
      if (!normalizedRepeatContext || !capacityId) {
        return;
      }
      logCapacityEvent({
        ownerNodeId: newNodeId,
        capacityId,
        capacityType: capacityKind,
        context: normalizedRepeatContext
      });
    };
    if (originalVar.sourceRef) {
      const parsed = parseSourceRef2(originalVar.sourceRef);
      if (parsed) {
        capacityType = parsed.type;
        const applySuffixOnceToSourceRef = (ref) => {
          const parsedRef = parseSourceRef2(ref || "");
          if (!parsedRef) return ref;
          const baseId = stripTrailingNumeric(parsedRef.id);
          if (baseId.endsWith(`-${suffixToken}`)) return ref;
          return applySuffixToSourceRef(`${parsedRef.prefix}${baseId}`, suffix);
        };
        if (capacityType === "formula") {
          if (formulaIdMap.has(parsed.id)) {
            const mappedFormulaId = formulaIdMap.get(parsed.id);
            newSourceRef = `${parsed.prefix}${mappedFormulaId}`;
            emitCapacityEvent(mappedFormulaId, "formula");
          } else {
            try {
              const formulaResult = await copyFormulaCapacity(
                parsed.id,
                newNodeId,
                suffix,
                prisma51,
                { nodeIdMap, formulaCopyCache: formulaIdMap }
              );
              if (formulaResult.success) {
                formulaIdMap.set(parsed.id, formulaResult.newFormulaId);
                newSourceRef = `${parsed.prefix}${formulaResult.newFormulaId}`;
                emitCapacityEvent(formulaResult.newFormulaId, "formula");
              } else {
                newSourceRef = applySuffixOnceToSourceRef(originalVar.sourceRef);
              }
            } catch (e) {
              newSourceRef = applySuffixOnceToSourceRef(originalVar.sourceRef);
            }
          }
        } else if (capacityType === "condition") {
          if (conditionIdMap.has(parsed.id)) {
            const mappedConditionId = conditionIdMap.get(parsed.id);
            newSourceRef = `${parsed.prefix}${mappedConditionId}`;
            emitCapacityEvent(mappedConditionId, "condition");
          } else {
            try {
              const conditionResult = await copyConditionCapacity(
                parsed.id,
                newNodeId,
                suffix,
                prisma51,
                { nodeIdMap, formulaIdMap, conditionCopyCache: conditionIdMap }
              );
              if (conditionResult.success) {
                conditionIdMap.set(parsed.id, conditionResult.newConditionId);
                newSourceRef = `${parsed.prefix}${conditionResult.newConditionId}`;
                emitCapacityEvent(conditionResult.newConditionId, "condition");
              } else {
                newSourceRef = applySuffixOnceToSourceRef(originalVar.sourceRef);
              }
            } catch (e) {
              newSourceRef = applySuffixOnceToSourceRef(originalVar.sourceRef);
            }
          }
        } else if (capacityType === "table") {
          if (tableIdMap2.has(parsed.id)) {
            const mappedTableId = tableIdMap2.get(parsed.id);
            newSourceRef = `${parsed.prefix}${mappedTableId}`;
            emitCapacityEvent(mappedTableId, "table");
          } else {
            try {
              const tableResult = await copyTableCapacity2(
                parsed.id,
                newNodeId,
                suffix,
                prisma51,
                { nodeIdMap, tableCopyCache: tableIdMap2, tableIdMap: tableIdMap2 }
              );
              if (tableResult.success) {
                tableIdMap2.set(parsed.id, tableResult.newTableId);
                newSourceRef = `${parsed.prefix}${tableResult.newTableId}`;
                console.log(`\u2705 Table copi\xE9e et mapp\xE9e: ${parsed.id} \u2192 ${tableResult.newTableId}`);
                console.log(`   \u{1F4CB} ${tableResult.columnsCount} colonnes, ${tableResult.rowsCount} lignes, ${tableResult.cellsCount} cellules`);
                emitCapacityEvent(tableResult.newTableId, "table");
              } else {
                newSourceRef = applySuffixOnceToSourceRef(originalVar.sourceRef);
                console.log(`\u26A0\uFE0F \xC9chec copie table, suffixe appliqu\xE9: ${newSourceRef}`);
              }
            } catch (e) {
              console.error(`\u274C Exception copie table:`, e.message);
              newSourceRef = applySuffixOnceToSourceRef(originalVar.sourceRef);
            }
          }
        } else if (capacityType === "field") {
          const isSharedRefField = parsed.id.startsWith("shared-ref-");
          if (nodeIdMap.has(parsed.id)) {
            newSourceRef = nodeIdMap.get(parsed.id);
          } else if (isSharedRefField) {
            newSourceRef = parsed.id;
          } else {
            newSourceRef = appendSuffixOnce(parsed.id);
          }
        }
      }
    }
    let finalNodeId2 = newNodeId;
    if (autoCreateDisplayNode) {
      if (!originalVar.nodeId) {
        console.warn(`\u26A0\uFE0F [AUTO-CREATE-DISPLAY] Variable ${originalVar.id} n'a PAS de nodeId! Impossible de cr\xE9er display node. Fallback newNodeId.`);
        finalNodeId2 = newNodeId;
      } else {
        try {
          const parseJsonIfNeeded = (value) => {
            if (typeof value !== "string") return value ?? void 0;
            const trimmed = value.trim();
            if (!trimmed) return void 0;
            const first = trimmed[0];
            const last = trimmed[trimmed.length - 1];
            const looksJson = first === "[" && last === "]" || first === "{" && last === "}";
            if (!looksJson) return value;
            try {
              return JSON.parse(trimmed);
            } catch {
              return value;
            }
          };
          const originalOwnerNode = await prisma51.treeBranchLeafNode.findUnique({
            where: { id: originalVar.nodeId },
            select: {
              id: true,
              parentId: true,
              treeId: true,
              order: true,
              subType: true,
              // üéØ FIX: R√©cup√©rer le subType pour le pr√©server (ex: 'display')
              linkedTableIds: true,
              linkedVariableIds: true,
              hasTable: true,
              table_name: true,
              table_activeId: true,
              table_instances: true,
              table_columns: true,
              table_data: true,
              table_importSource: true,
              table_isImported: true,
              table_meta: true,
              table_rows: true,
              table_type: true,
              metadata: true,
              subtab: true,
              subtabs: true,
              hasAPI: true,
              hasCondition: true,
              hasData: true,
              hasFormula: true,
              hasLink: true,
              hasMarkers: true,
              // üîß FIX 16/12/2025: Ajouter condition_activeId et formula_activeId pour la copie
              condition_activeId: true,
              formula_activeId: true,
              linkedConditionIds: true,
              linkedFormulaIds: true,
              data_activeId: true,
              data_displayFormat: true,
              data_exposedKey: true,
              data_instances: true,
              data_precision: true,
              data_unit: true,
              data_visibleToUser: true,
              appearance_size: true,
              appearance_variant: true,
              appearance_width: true,
              fieldType: true,
              fieldSubType: true,
              field_label: true
            }
          });
          const displayNodeSelect = {
            id: true,
            parentId: true,
            order: true,
            metadata: true,
            subType: true,
            // üéØ FIX: R√©cup√©rer le subType pour le pr√©server (ex: 'display')
            subtab: true,
            subtabs: true,
            linkedTableIds: true,
            linkedVariableIds: true,
            hasTable: true,
            table_name: true,
            table_activeId: true,
            table_instances: true,
            table_columns: true,
            table_data: true,
            table_importSource: true,
            table_isImported: true,
            table_meta: true,
            table_rows: true,
            table_type: true,
            hasAPI: true,
            hasCondition: true,
            hasData: true,
            hasFormula: true,
            hasLink: true,
            hasMarkers: true,
            // üîß FIX 16/12/2025: Ajouter condition_activeId et formula_activeId pour la copie
            condition_activeId: true,
            formula_activeId: true,
            linkedConditionIds: true,
            linkedFormulaIds: true,
            data_activeId: true,
            data_displayFormat: true,
            data_exposedKey: true,
            data_instances: true,
            data_precision: true,
            data_unit: true,
            data_visibleToUser: true,
            appearance_size: true,
            appearance_variant: true,
            appearance_width: true,
            fieldType: true,
            fieldSubType: true,
            field_label: true,
            createdAt: true
          };
          const hasRepeaterMetadata = (metadata) => {
            if (!metadata || typeof metadata !== "object") {
              return false;
            }
            return Boolean(metadata.repeater);
          };
          const pickDisplayCandidate = (nodes) => {
            if (!nodes.length) {
              return null;
            }
            const withoutRepeater = nodes.find((node) => !hasRepeaterMetadata(node.metadata));
            return withoutRepeater ?? nodes[0];
          };
          let originalDisplayNode = await prisma51.treeBranchLeafNode.findFirst({
            where: {
              metadata: {
                path: ["fromVariableId"],
                equals: originalVar.id
              }
            },
            select: displayNodeSelect
          });
          if (!originalDisplayNode) {
            const templateNodeIds = await prisma51.treeBranchLeafNode.findMany({
              where: {
                linkedVariableIds: {
                  has: originalVar.id
                }
              },
              select: { id: true }
            });
            const templateIds = new Set(templateNodeIds.map((t) => t.id));
            const candidates = await prisma51.treeBranchLeafNode.findMany({
              where: {
                linkedVariableIds: {
                  has: originalVar.id
                },
                // ‚ö†Ô∏è CRITICAL: Exclude the template nodes themselves
                // This ensures we find TRUE display nodes, not the templates
                id: {
                  notIn: Array.from(templateIds)
                },
                ...originalVar.nodeId ? {
                  NOT: {
                    id: originalVar.nodeId
                  }
                } : {}
              },
              select: displayNodeSelect,
              orderBy: {
                createdAt: "asc"
              }
            });
            originalDisplayNode = pickDisplayCandidate(candidates);
          }
          const duplicatedOwnerNode = await prisma51.treeBranchLeafNode.findUnique({
            where: { id: newNodeId },
            select: {
              id: true,
              parentId: true
            }
          });
          if (originalOwnerNode && duplicatedOwnerNode) {
            const inheritedDisplayParentId = originalDisplayNode?.parentId ?? null;
            let resolvedParentId = inheritedDisplayParentId ?? originalOwnerNode.parentId ?? displayParentId ?? duplicatedOwnerNode.parentId ?? null;
            if (resolvedParentId && prisma51) {
              try {
                const parentExists = await prisma51.treeBranchLeafNode.findUnique({
                  where: { id: resolvedParentId },
                  select: { id: true }
                });
                if (!parentExists) {
                  resolvedParentId = duplicatedOwnerNode.parentId ?? null;
                }
              } catch (parentCheckErr) {
                resolvedParentId = duplicatedOwnerNode.parentId ?? null;
              }
            } else if (!resolvedParentId) {
              resolvedParentId = duplicatedOwnerNode.parentId ?? null;
            }
            const displayNodeBaseId = originalVar.nodeId && nodeIdMap.get(originalVar.nodeId) || originalVar.nodeId;
            const baseNormalized = stripTrailingNumeric(displayNodeBaseId);
            const displayNodeId2 = appendSuffixOnce(baseNormalized);
            finalNodeId2 = displayNodeId2;
            const now = /* @__PURE__ */ new Date();
            const cloneJson = (value) => {
              if (!value || typeof value !== "object") {
                return {};
              }
              return JSON.parse(JSON.stringify(value));
            };
            const ownerMetadata = cloneJson(originalOwnerNode.metadata);
            const inheritedMetadata = cloneJson(originalDisplayNode?.metadata);
            console.log("\u{1F7E3}\u{1F7E3}\u{1F7E3} [VARIABLE-COPY-ENGINE] Metadata originaux:", {
              ownerMetadata: JSON.stringify(ownerMetadata),
              inheritedMetadata: JSON.stringify(inheritedMetadata),
              originalVarId: originalVar.id,
              ownerSubType: originalOwnerNode.subType,
              inheritedSubType: originalDisplayNode?.subType
            });
            const { triggerNodeIds: _ownerTriggers, ...ownerMetadataWithoutTriggers } = ownerMetadata ?? {};
            const { triggerNodeIds: _inheritedTriggers, ...inheritedMetadataWithoutTriggers } = inheritedMetadata ?? {};
            const metadataForDisplay = {
              ...ownerMetadataWithoutTriggers,
              ...inheritedMetadataWithoutTriggers,
              fromVariableId: forceSingleSuffix(originalVar.id),
              autoCreatedDisplayNode: true,
              ...isFromRepeaterDuplication && { duplicatedFromRepeater: true }
            };
            const ownerSubTabRaw = ownerMetadata?.subTab ?? ownerMetadata?.subTabKey ?? parseJsonIfNeeded(originalOwnerNode.subtab ?? void 0);
            const ownerSubTabsRaw = ownerMetadata?.subTabs ?? parseJsonIfNeeded(originalOwnerNode.subtabs ?? void 0);
            const ownerSubTabsArray = Array.isArray(ownerSubTabsRaw) ? ownerSubTabsRaw.map((entry) => String(entry)) : void 0;
            const inheritedSubTab = inheritedMetadata?.subTab ?? parseJsonIfNeeded(originalDisplayNode?.subtab ?? void 0);
            const inheritedSubTabsRaw = inheritedMetadata?.subTabs ?? parseJsonIfNeeded(originalDisplayNode?.subtabs ?? void 0);
            const inheritedSubTabs = Array.isArray(inheritedSubTabsRaw) ? inheritedSubTabsRaw.map((entry) => String(entry)) : void 0;
            if (inheritedSubTab !== void 0) {
              metadataForDisplay.subTab = inheritedSubTab;
            } else if (ownerSubTabRaw !== void 0) {
              metadataForDisplay.subTab = ownerSubTabRaw;
            }
            if (Array.isArray(inheritedSubTabs) && inheritedSubTabs.length) {
              metadataForDisplay.subTabs = inheritedSubTabs;
            } else if (ownerSubTabsArray?.length) {
              metadataForDisplay.subTabs = ownerSubTabsArray;
            }
            const appendSuffix = (value) => appendSuffixOnce(value);
            const cloneAndSuffixInstances = (raw) => {
              if (!raw) {
                return raw ?? null;
              }
              let rawInstances;
              if (typeof raw === "object") {
                rawInstances = JSON.parse(JSON.stringify(raw));
              } else if (typeof raw === "string") {
                try {
                  rawInstances = JSON.parse(raw);
                } catch {
                  return raw;
                }
              } else {
                return raw;
              }
              const updatedInstances = {};
              for (const [key2, value] of Object.entries(rawInstances)) {
                const newKey = appendSuffix(String(key2));
                if (value && typeof value === "object") {
                  const nested = { ...value };
                  if (typeof nested.tableId === "string") {
                    nested.tableId = appendSuffix(nested.tableId);
                  }
                  updatedInstances[newKey] = nested;
                } else {
                  updatedInstances[newKey] = value;
                }
              }
              return updatedInstances;
            };
            const formatSubTabColumn = (value) => {
              if (value === null || value === void 0) return null;
              if (Array.isArray(value)) {
                return value.length ? JSON.stringify(value) : null;
              }
              return typeof value === "string" ? value : String(value);
            };
            const tableSourceNode = originalDisplayNode ?? originalOwnerNode;
            const displayLabel = forceSingleSuffix(originalVar.displayName || "Donn\xE9e");
            const resolvedOrder = originalDisplayNode?.order ?? (originalOwnerNode.order ?? 0) + 1;
            let actuallyOwnsTable = false;
            if (capacityType === "table" && newSourceRef) {
              const tableIdMatch = newSourceRef.match(/table:\/\/([^/:\s]+)/);
              if (tableIdMatch) {
                const tableId = tableIdMatch[1];
                const tableOwner = await prisma51.treeBranchLeafNodeTable.findUnique({
                  where: { id: tableId },
                  select: { nodeId: true }
                });
                actuallyOwnsTable = tableOwner?.nodeId === originalVar.nodeId;
              }
            }
            const resolvedSubTabsJson = (() => {
              const resolved = Array.isArray(inheritedSubTabs) && inheritedSubTabs.length ? inheritedSubTabs : ownerSubTabsArray;
              return resolved?.length ? JSON.stringify(resolved) : null;
            })();
            const inheritedSubType = originalDisplayNode?.subType ?? originalOwnerNode.subType ?? null;
            const originalTriggers = _inheritedTriggers ?? _ownerTriggers;
            console.log("\u{1F7E2}\u{1F7E2}\u{1F7E2} [VARIABLE-COPY-ENGINE] Traitement des triggers:", {
              _inheritedTriggers,
              _ownerTriggers,
              originalTriggers,
              nodeIdMapSize: nodeIdMap.size,
              nodeIdMapEntries: Array.from(nodeIdMap.entries()).slice(0, 10)
              // Premiers 10 mappings
            });
            let suffixedTriggerNodeIds = null;
            if (Array.isArray(originalTriggers) && originalTriggers.length > 0) {
              suffixedTriggerNodeIds = originalTriggers.map((triggerId) => {
                if (typeof triggerId !== "string") return triggerId;
                const cleanId = triggerId.replace(/^@value\./, "").replace(/^{/, "").replace(/}$/, "");
                const mappedId = nodeIdMap.get(cleanId);
                console.log("\u{1F535}\u{1F535}\u{1F535} [VARIABLE-COPY-ENGINE] Mapping trigger:", {
                  original: triggerId,
                  cleanId,
                  mappedId,
                  suffix
                });
                if (mappedId) {
                  if (triggerId.startsWith("@value.")) return `@value.${mappedId}`;
                  if (triggerId.startsWith("{")) return `{${mappedId}}`;
                  return mappedId;
                }
                const suffixedId = appendSuffixOnce(cleanId);
                if (triggerId.startsWith("@value.")) return `@value.${suffixedId}`;
                if (triggerId.startsWith("{")) return `{${suffixedId}}`;
                return suffixedId;
              });
              console.log("\u{1F7E2}\u{1F7E2}\u{1F7E2} [VARIABLE-COPY-ENGINE] Triggers suffix\xE9s FINAL:", {
                originalTriggers,
                suffixedTriggerNodeIds,
                displayNodeId: displayNodeId2,
                inheritedSubType
              });
            } else {
              console.log("\u26A0\uFE0F\u26A0\uFE0F\u26A0\uFE0F [VARIABLE-COPY-ENGINE] PAS DE TRIGGERS TROUV\xC9S:", {
                originalTriggers,
                type: typeof originalTriggers,
                isArray: Array.isArray(originalTriggers)
              });
            }
            if (suffixedTriggerNodeIds && suffixedTriggerNodeIds.length > 0) {
              metadataForDisplay.triggerNodeIds = suffixedTriggerNodeIds;
            }
            const isDisplaySubType = String(inheritedSubType ?? "").toLowerCase() === "display";
            const sourceLooksLikeFormulaNode = Boolean(
              tableSourceNode.hasFormula || tableSourceNode.formula_activeId || Array.isArray(tableSourceNode.linkedFormulaIds) && tableSourceNode.linkedFormulaIds.length > 0
            );
            const shouldCopyFormulaCapability = capacityType === "formula" || isDisplaySubType && sourceLooksLikeFormulaNode;
            const displayNodeData = {
              id: displayNodeId2,
              treeId: originalOwnerNode.treeId,
              parentId: resolvedParentId,
              type: "leaf_field",
              subType: inheritedSubType,
              // üéØ FIX: Utiliser le subType h√©rit√© (ex: 'display')
              label: displayLabel,
              description: null,
              value: null,
              order: resolvedOrder,
              isRequired: false,
              isVisible: true,
              isActive: true,
              isMultiple: false,
              fieldConfig: null,
              conditionConfig: null,
              formulaConfig: null,
              tableConfig: null,
              apiConfig: null,
              linkConfig: null,
              defaultValue: null,
              calculatedValue: null,
              metadata: metadataForDisplay,
              subtab: formatSubTabColumn(inheritedSubTab ?? ownerSubTabRaw),
              subtabs: resolvedSubTabsJson,
              createdAt: now,
              updatedAt: now,
              hasAPI: tableSourceNode.hasAPI ?? false,
              // üîß FIX: Ne pas h√©riter des flags hasFormula/hasCondition/hasTable du n≈ìud source
              // si la variable actuelle n'a PAS de capacit√© de ce type.
              // Sinon un simple champ de saisie (variable simple) se transforme en cellule de calcul !
              hasCondition: capacityType === "condition" ? tableSourceNode.hasCondition ?? true : false,
              hasData: tableSourceNode.hasData ?? false,
              hasFormula: shouldCopyFormulaCapability ? tableSourceNode.hasFormula ?? true : false,
              hasLink: tableSourceNode.hasLink ?? false,
              hasMarkers: tableSourceNode.hasMarkers ?? false,
              // üîß FIX 06/01/2026: SEULEMENT mettre hasTable: true si:
              // 1) La variable r√©f√©rence une table (capacityType === 'table')
              // 2) ET le node est le PROPRI√âTAIRE de la table (actuallyOwnsTable === true)
              // Sinon Inclinaison-1 (qui affiche une valeur de table d'Orientation) aurait hasTable: true incorrectement
              hasTable: actuallyOwnsTable ? tableSourceNode.hasTable ?? true : false,
              table_name: actuallyOwnsTable ? tableSourceNode.table_name : null,
              table_activeId: actuallyOwnsTable && tableSourceNode.table_activeId ? appendSuffix(String(tableSourceNode.table_activeId)) : null,
              table_instances: actuallyOwnsTable ? cloneAndSuffixInstances(tableSourceNode.table_instances) : null,
              table_columns: actuallyOwnsTable ? tableSourceNode.table_columns : null,
              table_data: actuallyOwnsTable ? tableSourceNode.table_data : null,
              table_importSource: actuallyOwnsTable ? tableSourceNode.table_importSource : null,
              table_isImported: actuallyOwnsTable ? tableSourceNode.table_isImported ?? false : false,
              table_meta: actuallyOwnsTable ? tableSourceNode.table_meta : null,
              table_rows: actuallyOwnsTable ? tableSourceNode.table_rows : null,
              table_type: actuallyOwnsTable ? tableSourceNode.table_type : null,
              linkedTableIds: actuallyOwnsTable && Array.isArray(tableSourceNode.linkedTableIds) ? tableSourceNode.linkedTableIds.map((id) => appendSuffix(String(id))) : [],
              // üîß FIX 24/12/2025: Explicitement mettre √† null/[] les IDs de capacit√©s non pertinentes
              // pour √©viter qu'un champ simple h√©rite des formules/conditions du n≈ìud source
              formula_activeId: shouldCopyFormulaCapability && tableSourceNode.formula_activeId ? appendSuffix(String(tableSourceNode.formula_activeId)) : null,
              condition_activeId: capacityType === "condition" && tableSourceNode.condition_activeId ? appendSuffix(String(tableSourceNode.condition_activeId)) : null,
              linkedFormulaIds: [],
              // Sera rempli apr√®s si capacityType === 'formula'
              linkedConditionIds: [],
              // Sera rempli apr√®s si capacityType === 'condition'
              // üîß FIX 07/01/2026: Pour les composites (qui r√©f√©rencent d'autres variables via linkedVariableIds),
              // on doit copier les linkedVariableIds du n≈ìud ORIGINAL en les suffixant,
              // pas seulement mettre [newVarId]. Exemple: Orientation-inclinaison-1 doit r√©f√©rencer
              // [Orientation-1, Inclinaison-1], pas seulement [Orientation-inclinaison-1]
              linkedVariableIds: Array.isArray(tableSourceNode.linkedVariableIds) && tableSourceNode.linkedVariableIds.length > 0 ? tableSourceNode.linkedVariableIds.map((varId) => appendSuffixOnce(String(varId))) : [newVarId],
              data_activeId: tableSourceNode.data_activeId ? appendSuffix(String(tableSourceNode.data_activeId)) : null,
              data_displayFormat: tableSourceNode.data_displayFormat,
              data_exposedKey: tableSourceNode.data_exposedKey,
              data_instances: cloneAndSuffixInstances(tableSourceNode.data_instances),
              data_precision: tableSourceNode.data_precision,
              data_unit: tableSourceNode.data_unit,
              data_visibleToUser: tableSourceNode.data_visibleToUser ?? false,
              appearance_size: tableSourceNode.appearance_size ?? "md",
              appearance_variant: tableSourceNode.appearance_variant,
              appearance_width: tableSourceNode.appearance_width ?? "100%",
              fieldType: tableSourceNode.fieldType ?? "TEXT",
              fieldSubType: tableSourceNode.fieldSubType,
              field_label: displayLabel
            };
            const maybeExisting = await prisma51.treeBranchLeafNode.findUnique({ where: { id: displayNodeId2 } });
            if (maybeExisting) {
              await prisma51.treeBranchLeafNode.update({ where: { id: displayNodeId2 }, data: { ...displayNodeData, createdAt: maybeExisting.createdAt, updatedAt: now } });
            } else {
              await prisma51.treeBranchLeafNode.create({ data: displayNodeData });
            }
            const copiedFormulaIds = [];
            const copiedConditionIds = [];
            try {
              if (shouldCopyFormulaCapability) {
                const originalFormulas = await prisma51.treeBranchLeafNodeFormula.findMany({
                  where: { nodeId: tableSourceNode.id }
                });
                for (const f of originalFormulas) {
                  const newFormulaId = appendSuffixOnce(stripTrailingNumeric(f.id));
                  const existingFormula = await prisma51.treeBranchLeafNodeFormula.findUnique({ where: { id: newFormulaId } });
                  if (existingFormula) {
                    if (existingFormula.nodeId === displayNodeId2) {
                      copiedFormulaIds.push(newFormulaId);
                      continue;
                    }
                    continue;
                  }
                  try {
                    const formulaResult = await copyFormulaCapacity(
                      f.id,
                      displayNodeId2,
                      suffix,
                      prisma51,
                      { formulaIdMap, nodeIdMap }
                    );
                    if (formulaResult.success) {
                      formulaIdMap.set(f.id, formulaResult.newFormulaId);
                      copiedFormulaIds.push(formulaResult.newFormulaId);
                    }
                  } catch (error) {
                  }
                }
              }
              if (capacityType === "condition") {
                const originalConditions = await prisma51.treeBranchLeafNodeCondition.findMany({
                  where: { nodeId: tableSourceNode.id }
                });
                for (const c of originalConditions) {
                  const newConditionId = appendSuffixOnce(stripTrailingNumeric(c.id));
                  const existingCondition = await prisma51.treeBranchLeafNodeCondition.findUnique({ where: { id: newConditionId } });
                  if (existingCondition) {
                    if (existingCondition.nodeId === displayNodeId2) {
                      copiedConditionIds.push(newConditionId);
                      continue;
                    }
                    continue;
                  }
                  try {
                    const conditionResult = await copyConditionCapacity(
                      c.id,
                      displayNodeId2,
                      suffix,
                      prisma51,
                      { nodeIdMap, formulaIdMap, conditionCopyCache: conditionIdMap }
                    );
                    if (conditionResult.success) {
                      conditionIdMap.set(c.id, conditionResult.newConditionId);
                      copiedConditionIds.push(conditionResult.newConditionId);
                    }
                  } catch (error) {
                  }
                }
              }
              const updateData = {};
              if (copiedFormulaIds.length > 0) {
                updateData.hasFormula = true;
                updateData.linkedFormulaIds = copiedFormulaIds;
                if (tableSourceNode.formula_activeId) {
                  const newFormulaActiveId = appendSuffixOnce(stripTrailingNumeric(String(tableSourceNode.formula_activeId)));
                  updateData.formula_activeId = copiedFormulaIds.includes(newFormulaActiveId) ? newFormulaActiveId : copiedFormulaIds[0];
                } else if (copiedFormulaIds.length > 0) {
                  updateData.formula_activeId = copiedFormulaIds[0];
                }
              }
              if (copiedConditionIds.length > 0) {
                updateData.hasCondition = true;
                updateData.linkedConditionIds = copiedConditionIds;
                if (tableSourceNode.condition_activeId) {
                  const newConditionActiveId = appendSuffixOnce(stripTrailingNumeric(String(tableSourceNode.condition_activeId)));
                  updateData.condition_activeId = copiedConditionIds.includes(newConditionActiveId) ? newConditionActiveId : copiedConditionIds[0];
                } else if (copiedConditionIds.length > 0) {
                  updateData.condition_activeId = copiedConditionIds[0];
                }
              }
              if (Object.keys(updateData).length > 0) {
                await prisma51.treeBranchLeafNode.update({
                  where: { id: displayNodeId2 },
                  data: updateData
                });
              }
              const copiedTableIds = [];
              const originalDisplayNodeId = originalVar.nodeId;
              const tableOwnerIsSameAsDisplay = tableSourceNode.id === originalDisplayNodeId;
              if (tableOwnerIsSameAsDisplay && tableSourceNode.hasTable && Array.isArray(tableSourceNode.linkedTableIds) && tableSourceNode.linkedTableIds.length > 0) {
                for (const originalTableId of tableSourceNode.linkedTableIds) {
                  const newTableId = appendSuffixOnce(stripTrailingNumeric(String(originalTableId)));
                  const existingTable = await prisma51.treeBranchLeafNodeTable.findUnique({ where: { id: newTableId } });
                  if (existingTable) {
                    copiedTableIds.push(newTableId);
                    tableIdMap2.set(String(originalTableId), newTableId);
                    continue;
                  }
                  try {
                    const tableResult = await copyTableCapacity2(
                      String(originalTableId),
                      displayNodeId2,
                      suffix,
                      prisma51,
                      { nodeIdMap, tableCopyCache: tableIdMap2, tableIdMap: tableIdMap2 }
                    );
                    if (tableResult.success) {
                      tableIdMap2.set(String(originalTableId), tableResult.newTableId);
                      copiedTableIds.push(tableResult.newTableId);
                    }
                  } catch (tableErr) {
                  }
                }
                if (copiedTableIds.length > 0) {
                  const displayNode = await prisma51.treeBranchLeafNode.findUnique({
                    where: { id: displayNodeId2 },
                    select: { fieldType: true }
                  });
                  const isInputField = !displayNode || !displayNode.fieldType || displayNode.fieldType === "" || displayNode.fieldType === null;
                  if (!isInputField) {
                    await prisma51.treeBranchLeafNode.update({
                      where: { id: displayNodeId2 },
                      data: { hasTable: true, linkedTableIds: copiedTableIds }
                    });
                  }
                }
              }
            } catch (copyCapErr) {
            }
          } else {
          }
        } catch (e) {
        }
      }
    }
    try {
      const existingById = await prisma51.treeBranchLeafNodeVariable.findUnique({ where: { id: newVarId } });
      if (existingById) {
        const tail = (finalNodeId2 || newNodeId || "").slice(-6) || `${Date.now()}`;
        newVarId = `${originalVarId}-${suffix}-${tail}`;
      }
    } catch (e) {
    }
    try {
      const existingByKey = await prisma51.treeBranchLeafNodeVariable.findUnique({ where: { exposedKey: newExposedKey } });
      if (existingByKey) {
        const tail = (finalNodeId2 || newNodeId || "").slice(-6) || `${Date.now()}`;
        newExposedKey = `${originalVar.exposedKey}-${suffix}-${tail}`;
      }
    } catch (e) {
    }
    let _reusingExistingVariable = false;
    let _existingVariableForReuse = null;
    try {
      const existingForNode = await prisma51.treeBranchLeafNodeVariable.findUnique({ where: { nodeId: finalNodeId2 } });
      if (existingForNode) {
        const expectedVarId = `${originalVarId}-${suffix}`;
        const hasSuffixMatch = existingForNode.id === expectedVarId || existingForNode.id === newVarId;
        if (hasSuffixMatch) {
          _reusingExistingVariable = true;
          _existingVariableForReuse = existingForNode;
          try {
            const normalizedExistingName = forceSingleSuffix(existingForNode.displayName);
            await prisma51.treeBranchLeafNode.update({
              where: { id: finalNodeId2 },
              data: {
                hasData: true,
                data_activeId: existingForNode.id,
                data_exposedKey: existingForNode.exposedKey,
                data_displayFormat: existingForNode.displayFormat,
                data_precision: existingForNode.precision,
                data_unit: existingForNode.unit,
                data_visibleToUser: existingForNode.visibleToUser,
                label: normalizedExistingName || void 0,
                field_label: normalizedExistingName || void 0
              }
            });
            const isCopiedNode = finalNodeId2.includes("-") && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}-.+$/i.test(finalNodeId2);
            if (isCopiedNode) {
              await addToNodeLinkedField5(prisma51, finalNodeId2, "linkedVariableIds", [existingForNode.id]);
            }
          } catch (e) {
          }
          const cacheKey2 = `${originalVarId}|${finalNodeId2}`;
          variableCopyCache.set(cacheKey2, existingForNode.id);
        } else {
          try {
            await prisma51.treeBranchLeafNodeVariable.delete({ where: { id: existingForNode.id } });
          } catch (delError) {
          }
          _reusingExistingVariable = false;
          _existingVariableForReuse = null;
        }
      }
    } catch (e) {
    }
    let newVariable;
    if (_reusingExistingVariable && _existingVariableForReuse) {
      newVariable = _existingVariableForReuse;
    } else {
      const normalizedDisplayName = forceSingleSuffix(originalVar.displayName);
      if (!finalNodeId2) {
        throw new Error(`Cannot create variable: finalNodeId is ${finalNodeId2}. This indicates the display node was not created properly.`);
      }
      const nodeExists = await prisma51.treeBranchLeafNode.findUnique({
        where: { id: finalNodeId2 },
        select: { id: true }
      });
      if (!nodeExists) {
        console.warn(`\u26A0\uFE0F Cannot create variable: node ${finalNodeId2} does not exist in database. Skipping variable creation.`);
        return {
          success: false,
          error: `Node ${finalNodeId2} does not exist`,
          originalVarId
        };
      }
      try {
        if (originalVar.nodeId && finalNodeId2 && !nodeIdMap.has(originalVar.nodeId)) {
          nodeIdMap.set(originalVar.nodeId, finalNodeId2);
        }
        const newLinkedFormulaIds = [];
        for (const formulaId of originalVar.linkedFormulaIds || []) {
          const mappedId = formulaIdMap.get(formulaId);
          if (mappedId) {
            newLinkedFormulaIds.push(mappedId);
          } else {
            try {
              const formulaResult = await copyFormulaCapacity(
                formulaId,
                finalNodeId2,
                suffix,
                prisma51,
                { nodeIdMap, formulaIdMap, conditionIdMap }
              );
              if (formulaResult.success) {
                formulaIdMap.set(formulaId, formulaResult.newFormulaId);
                newLinkedFormulaIds.push(formulaResult.newFormulaId);
              } else {
                newLinkedFormulaIds.push(`${formulaId}-${suffix}`);
              }
            } catch (e) {
              newLinkedFormulaIds.push(`${formulaId}-${suffix}`);
            }
          }
        }
        const newLinkedConditionIds = [];
        for (const conditionId of originalVar.linkedConditionIds || []) {
          const mappedId = conditionIdMap.get(conditionId);
          if (mappedId) {
            newLinkedConditionIds.push(mappedId);
          } else {
            try {
              const conditionResult = await copyConditionCapacity(
                conditionId,
                finalNodeId2,
                suffix,
                prisma51,
                { nodeIdMap, formulaIdMap, conditionIdMap }
              );
              if (conditionResult.success) {
                conditionIdMap.set(conditionId, conditionResult.newConditionId);
                newLinkedConditionIds.push(conditionResult.newConditionId);
              } else {
                newLinkedConditionIds.push(`${conditionId}-${suffix}`);
              }
            } catch (e) {
              newLinkedConditionIds.push(`${conditionId}-${suffix}`);
            }
          }
        }
        const newLinkedTableIds = [];
        for (const tableId of originalVar.linkedTableIds || []) {
          const mappedId = tableIdMap2.get(tableId);
          if (mappedId) {
            newLinkedTableIds.push(mappedId);
          } else {
            try {
              const tableResult = await copyTableCapacity2(
                tableId,
                finalNodeId2,
                suffix,
                prisma51,
                { nodeIdMap, formulaIdMap, conditionIdMap, tableIdMap: tableIdMap2 }
              );
              if (tableResult.success) {
                tableIdMap2.set(tableId, tableResult.newTableId);
                newLinkedTableIds.push(tableResult.newTableId);
              } else {
                newLinkedTableIds.push(`${tableId}-${suffix}`);
              }
            } catch (e) {
              newLinkedTableIds.push(`${tableId}-${suffix}`);
            }
          }
        }
        newVariable = await prisma51.treeBranchLeafNodeVariable.create({
          data: {
            id: newVarId,
            nodeId: finalNodeId2,
            exposedKey: newExposedKey,
            displayName: normalizedDisplayName,
            displayFormat: originalVar.displayFormat,
            unit: originalVar.unit,
            precision: originalVar.precision,
            visibleToUser: originalVar.visibleToUser,
            isReadonly: originalVar.isReadonly,
            defaultValue: originalVar.defaultValue,
            fixedValue: originalVar.fixedValue,
            selectedNodeId: originalVar.selectedNodeId ? nodeIdMap.get(originalVar.selectedNodeId) || `${originalVar.selectedNodeId}-${suffix}` : null,
            sourceRef: newSourceRef,
            sourceType: originalVar.sourceType,
            metadata: originalVar.metadata,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
      } catch (createError) {
        throw createError;
      }
    }
    if (normalizedRepeatContext) {
      const metadataPayload = newVariable.metadata && typeof newVariable.metadata === "object" ? newVariable.metadata : void 0;
      logVariableEvent({
        nodeId: newVariable.nodeId,
        displayNodeId: finalNodeId2,
        variableId: newVariable.id,
        sourceRef: newVariable.sourceRef,
        sourceType: newVariable.sourceType,
        metadata: metadataPayload,
        context: normalizedRepeatContext
      });
    }
    if (!isFromRepeaterDuplication) {
      try {
        await linkVariableToAllCapacityNodes(prisma51, newVariable.id, newVariable.sourceRef);
      } catch (e) {
      }
    }
    const verification = await prisma51.treeBranchLeafNodeVariable.findUnique({
      where: { id: newVariable.id }
    });
    if (!verification) {
      console.error(`\u274C Variable ${newVariable.id} N'EXISTE PAS apr\xE8s cr\xE9ation !`);
    }
    try {
      const normalizedNodeLabel = forceSingleSuffix(newVariable.displayName);
      await prisma51.treeBranchLeafNode.update({
        where: { id: finalNodeId2 },
        data: {
          hasData: true,
          data_activeId: newVariable.id,
          data_exposedKey: newVariable.exposedKey,
          data_displayFormat: newVariable.displayFormat,
          data_precision: newVariable.precision,
          data_unit: newVariable.unit,
          data_visibleToUser: newVariable.visibleToUser,
          label: normalizedNodeLabel || void 0,
          field_label: normalizedNodeLabel || void 0
        }
      });
    } catch (e) {
    }
    if (linkToDisplaySection) {
      try {
        const originalOwnerNode = await prisma51.treeBranchLeafNode.findUnique({
          where: { id: originalVar.nodeId },
          select: { parentId: true, treeId: true }
        });
        if (originalOwnerNode?.parentId) {
          const displaySection = await prisma51.treeBranchLeafNode.findFirst({
            where: {
              treeId: originalOwnerNode.treeId,
              parentId: originalOwnerNode.parentId,
              type: "section",
              label: { equals: displaySectionLabel }
            },
            select: { id: true }
          });
          if (displaySection) {
            await addToNodeLinkedField5(prisma51, displaySection.id, "linkedVariableIds", [newVariable.id]);
          }
        }
      } catch (e) {
      }
    } else if (autoCreateDisplayNode) {
      try {
        const isCopiedNode = finalNodeId2.includes("-") && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}-.+$/i.test(finalNodeId2);
        if (isCopiedNode) {
          await addToNodeLinkedField5(prisma51, finalNodeId2, "linkedVariableIds", [newVariable.id]);
        }
      } catch (e) {
      }
      try {
        if (capacityType && newSourceRef) {
          const parsedCap = parseSourceRef2(newSourceRef);
          const capId = parsedCap?.id;
          if (parsedCap && capId) {
            if (parsedCap.type === "condition") {
              await prisma51.treeBranchLeafNode.update({
                where: { id: finalNodeId2 },
                data: {
                  hasCondition: true,
                  condition_activeId: capId
                }
              });
              await addToNodeLinkedField5(prisma51, finalNodeId2, "linkedConditionIds", [capId]);
              try {
                if (newNodeId) {
                  const suffixedVarId = `${originalVarId}-${suffix}`;
                  const targetNode = await prisma51.treeBranchLeafNode.findUnique({
                    where: { id: newNodeId },
                    select: { linkedVariableIds: true }
                  });
                  if (targetNode) {
                    const current = targetNode.linkedVariableIds || [];
                    const withoutOriginal = current.filter((id) => id !== originalVarId);
                    const candidates = [newVariable.id, suffixedVarId].filter(Boolean);
                    const next = Array.from(/* @__PURE__ */ new Set([...withoutOriginal, ...candidates]));
                    const changed = current.length !== next.length || current.some((id) => !next.includes(id));
                    if (changed) {
                      await prisma51.treeBranchLeafNode.update({
                        where: { id: newNodeId },
                        data: {
                          linkedVariableIds: { set: next }
                        }
                      });
                    }
                  }
                }
              } catch (e) {
              }
            } else if (parsedCap.type === "table") {
              const tbl = await prisma51.treeBranchLeafNodeTable.findUnique({
                where: { id: capId },
                select: { name: true, type: true, nodeId: true }
              });
              const tableOwnerIsFinalNode = tbl?.nodeId === finalNodeId2;
              if (tableOwnerIsFinalNode) {
                await prisma51.treeBranchLeafNode.update({
                  where: { id: finalNodeId2 },
                  data: {
                    hasTable: true,
                    table_activeId: capId,
                    table_name: tbl?.name || null,
                    table_type: tbl?.type || null
                  }
                });
                await addToNodeLinkedField5(prisma51, finalNodeId2, "linkedTableIds", [capId]);
              }
            }
          }
        }
      } catch (e) {
      }
    }
    try {
      if (newNodeId) {
        await replaceLinkedVariableId(prisma51, newNodeId, originalVarId, newVariable.id, suffix);
      }
      if (finalNodeId2 && finalNodeId2 !== newNodeId) {
        await replaceLinkedVariableId(prisma51, finalNodeId2, originalVarId, newVariable.id, suffix);
      }
    } catch (e) {
    }
    const cacheKeyFinal = `${originalVarId}|${finalNodeId2}`;
    variableCopyCache.set(cacheKeyFinal, newVariable.id);
    if (capacityType && newSourceRef) {
      const parsed = parseSourceRef2(newSourceRef);
      if (parsed && parsed.id) {
        try {
          if (capacityType === "formula") {
            const formula = await prisma51.treeBranchLeafNodeFormula.findUnique({
              where: { id: parsed.id },
              select: { nodeId: true }
            });
            if (formula) {
              await addToNodeLinkedField5(prisma51, formula.nodeId, "linkedFormulaIds", [parsed.id]);
            }
          } else if (capacityType === "condition") {
            const condition = await prisma51.treeBranchLeafNodeCondition.findUnique({
              where: { id: parsed.id },
              select: { nodeId: true }
            });
            if (condition) {
              await addToNodeLinkedField5(prisma51, condition.nodeId, "linkedConditionIds", [parsed.id]);
            }
          } else if (capacityType === "table") {
            const table = await prisma51.treeBranchLeafNodeTable.findUnique({
              where: { id: parsed.id },
              select: { nodeId: true }
            });
            if (table) {
              await addToNodeLinkedField5(prisma51, table.nodeId, "linkedTableIds", [parsed.id]);
            }
          }
        } catch (e) {
        }
      }
    }
    try {
      const originalVariable = await prisma51.treeBranchLeafNodeVariable.findUnique({
        where: { id: originalVarId },
        select: { nodeId: true }
      });
      if (originalVariable?.nodeId) {
        updateSumDisplayFieldAfterCopyChange(originalVariable.nodeId, prisma51).catch(() => {
        });
      }
    } catch (sumErr) {
    }
    return {
      variableId: newVariable.id,
      exposedKey: newExposedKey,
      capacityType,
      sourceRef: newSourceRef,
      success: true,
      displayNodeId: autoCreateDisplayNode ? finalNodeId2 : void 0,
      // üü¢ RETOURNER LES MAPS pour que repeat-executor puisse les agr√©ger
      formulaIdMap,
      conditionIdMap,
      tableIdMap: tableIdMap2
    };
  } catch (error) {
    console.error(`
${"\u2550".repeat(80)}`);
    console.error(`\u274C\u274C\u274C ERREUR FATALE lors de la copie de la variable!`);
    console.error(`Variable ID: ${originalVarId}`);
    console.error(`Suffix: ${suffix}`);
    console.error(`Display Node ID: ${finalNodeId || "undefined"}`);
    console.error(`Message d'erreur:`, error instanceof Error ? error.message : String(error));
    console.error(`Stack trace:`, error instanceof Error ? error.stack : "N/A");
    console.error(`${"\u2550".repeat(80)}
`);
    throw error;
  }
}
async function createDisplayNodeForExistingVariable(variableId, prisma51, displaySectionLabel = "Nouveau Section", suffix = "nouveau") {
  const v = await prisma51.treeBranchLeafNodeVariable.findUnique({ where: { id: variableId } });
  if (!v) throw new Error(`Variable introuvable: ${variableId}`);
  const owner = await prisma51.treeBranchLeafNode.findUnique({
    where: { id: v.nodeId },
    select: {
      id: true,
      parentId: true,
      treeId: true,
      order: true,
      linkedTableIds: true,
      hasTable: true,
      table_name: true,
      table_activeId: true,
      table_instances: true,
      // üîë IMPORTANT: R√©cup√©rer subtab pour que la copie soit dans le bon sous-onglet
      subtab: true,
      subtabs: true
    }
  });
  if (!owner) throw new Error(`N\u0153ud propri\xE9taire introuvable: ${v.nodeId}`);
  const displayParentId = owner.parentId;
  console.log(`\u{1F4CC} [createDisplayNodeForExistingVariable] R\xC8GLE: Copie dans le M\xCAME parent que l'original: ${displayParentId}`);
  const now = /* @__PURE__ */ new Date();
  const variableHasTableCapacity = v.sourceType === "table" || v.sourceRef?.includes("table:");
  const baseData = {
    id: displayNodeId,
    treeId: owner.treeId,
    parentId: displayParentId,
    type: "leaf_field",
    subType: null,
    label: v.displayName || "Donn\xE9e",
    description: null,
    value: null,
    order: (owner.order ?? 0) + 1,
    isRequired: false,
    isVisible: true,
    isActive: true,
    isMultiple: false,
    fieldConfig: null,
    conditionConfig: null,
    formulaConfig: null,
    tableConfig: null,
    apiConfig: null,
    linkConfig: null,
    defaultValue: null,
    calculatedValue: null,
    metadata: { fromVariableId: variableId },
    // üîë IMPORTANT: Copier le subtab pour que la copie soit dans le bon sous-onglet
    subtab: owner.subtab,
    subtabs: owner.subtabs,
    createdAt: now,
    updatedAt: now,
    hasAPI: false,
    hasCondition: false,
    hasData: false,
    hasFormula: false,
    hasLink: false,
    hasMarkers: false,
    // üìä TABLE: SEULEMENT mettre hasTable: true si la VARIABLE a une capacit√© table
    // Sinon, une variable qui affiche une valeur de table (ex: Inclinaison) aurait incorrectement hasTable: true
    hasTable: variableHasTableCapacity ? owner.hasTable ?? false : false,
    table_name: variableHasTableCapacity ? owner.table_name : null,
    table_activeId: variableHasTableCapacity ? owner.table_activeId : null,
    table_instances: variableHasTableCapacity ? owner.table_instances : null,
    linkedTableIds: variableHasTableCapacity && Array.isArray(owner.linkedTableIds) ? owner.linkedTableIds : [],
    linkedConditionIds: [],
    linkedFormulaIds: [],
    linkedVariableIds: [variableId],
    appearance_size: "md",
    appearance_variant: null,
    appearance_width: "100%",
    fieldType: "TEXT",
    fieldSubType: null,
    field_label: v.displayName
  };
  const existing = await prisma51.treeBranchLeafNode.findUnique({ where: { id: displayNodeId } });
  if (existing) {
    await prisma51.treeBranchLeafNode.update({ where: { id: displayNodeId }, data: { ...baseData, createdAt: existing.createdAt, updatedAt: now } });
  } else {
    await prisma51.treeBranchLeafNode.create({ data: baseData });
  }
  await prisma51.treeBranchLeafNode.update({
    where: { id: displayNodeId },
    data: {
      hasData: true,
      data_activeId: variableId,
      data_exposedKey: v.exposedKey,
      data_displayFormat: v.displayFormat,
      data_precision: v.precision,
      data_unit: v.unit,
      data_visibleToUser: v.visibleToUser
    }
  });
  return { displayNodeId, created: !existing };
}
async function addToNodeLinkedField5(prisma51, nodeId, field, idsToAdd) {
  if (!idsToAdd || idsToAdd.length === 0) return;
  const node = await prisma51.treeBranchLeafNode.findUnique({
    where: { id: nodeId },
    select: { [field]: true }
  });
  if (!node) {
    console.warn(`\u26A0\uFE0F N\u0153ud ${nodeId} introuvable pour MAJ ${field}`);
    return;
  }
  const current = node[field] || [];
  const newIds = [.../* @__PURE__ */ new Set([...current, ...idsToAdd])];
  await prisma51.treeBranchLeafNode.update({
    where: { id: nodeId },
    data: { [field]: { set: newIds } }
  });
}
async function replaceLinkedVariableId(prisma51, nodeId, originalVarId, newVarId, suffix) {
  const stripNumericSuffix2 = (raw) => raw.replace(/-\d+(?:-\d+)*$/, "");
  const node = await prisma51.treeBranchLeafNode.findUnique({
    where: { id: nodeId },
    select: { linkedVariableIds: true }
  });
  if (!node) return;
  const suffixedId = `${originalVarId}-${suffix}`;
  const current = node.linkedVariableIds || [];
  const base = stripNumericSuffix2(originalVarId);
  const filtered = current.filter((id) => stripNumericSuffix2(id) !== base);
  const next = Array.from(/* @__PURE__ */ new Set([...filtered, newVarId, suffixedId]));
  const changed = current.length !== next.length || current.some((id) => !next.includes(id));
  if (!changed) return;
  await prisma51.treeBranchLeafNode.update({
    where: { id: nodeId },
    data: { linkedVariableIds: { set: next } }
  });
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/copy-selector-tables.ts
async function copySelectorTablesAfterNodeCopy(prisma51, copiedRootNodeId, originalRootNodeId, options, suffix) {
  try {
    const getAllDescendants = async (nodeId) => {
      const results = [];
      const queue = [nodeId];
      while (queue.length > 0) {
        const currentId = queue.shift();
        results.push(currentId);
        const children = await prisma51.treeBranchLeafNode.findMany({
          where: { parentId: currentId },
          select: { id: true }
        });
        queue.push(...children.map((c) => c.id));
      }
      return results;
    };
    const originalNodeIds = await getAllDescendants(originalRootNodeId);
    const copiedNodeIds = await getAllDescendants(copiedRootNodeId);
    const selectorsInOriginal = await prisma51.treeBranchLeafNode.findMany({
      where: {
        id: { in: originalNodeIds },
        table_activeId: { not: null }
      },
      select: {
        id: true,
        label: true,
        type: true,
        table_activeId: true,
        linkedTableIds: true
      }
    });
    for (const originalSelector of selectorsInOriginal) {
      const originalTableId = originalSelector.table_activeId;
      if (!originalTableId) continue;
      const copiedSelectorId = options.nodeIdMap.get(originalSelector.id);
      if (!copiedSelectorId) {
        continue;
      }
      const hasSelectConfig = await prisma51.treeBranchLeafSelectConfig.findUnique({
        where: { nodeId: originalSelector.id }
      });
      if (hasSelectConfig) {
        continue;
      }
      const originalTable = await prisma51.treeBranchLeafNodeTable.findUnique({
        where: { id: originalTableId },
        select: {
          id: true,
          nodeId: true,
          name: true,
          meta: true,
          type: true,
          description: true,
          displayInline: true,
          tableColumns: { select: { id: true } },
          tableRows: { select: { id: true, cells: true } }
        }
      });
      if (!originalTable) {
        continue;
      }
      try {
        const result = await copyTableCapacity2(
          originalTableId,
          // ID de la table originale
          copiedSelectorId,
          // √É¬∞√Ö¬∏√¢‚Ç¨Àú√ã‚Ä† Le n√É‚Ä¶√¢‚Ç¨≈ìud selector copi√É∆í√Ç¬© sera propri√É∆í√Ç¬©taire de la table copi√É∆í√Ç¬©e
          suffix,
          prisma51,
          {
            nodeIdMap: options.nodeIdMap,
            tableCopyCache: options.tableCopyCache,
            tableIdMap: options.tableIdMap
          }
        );
        if (result.success) {
        } else {
        }
      } catch (e) {
        console.warn(`      \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F Erreur lors de la copie:`, e.message);
      }
    }
  } catch (e) {
    console.warn(`\xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F Erreur dans copySelectorTablesAfterNodeCopy:`, e.message);
  }
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/services/shared-helpers.ts
function getAuthCtx(req2) {
  const user = req2 && req2.user || {};
  const headerOrg = req2?.headers?.["x-organization-id"] || req2?.headers?.["x-organization"] || req2?.headers?.["organization-id"];
  const role = user.role || user.userRole;
  const isSuperAdmin2 = Boolean(user.isSuperAdmin || role === "super_admin" || role === "superadmin");
  const organizationId = user.organizationId || headerOrg || null;
  return { organizationId, isSuperAdmin: isSuperAdmin2 };
}
var uniq = (arr) => Array.from(new Set(arr));
var uuidLikeRef = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
var isRealNodeRef = (ref) => {
  if (!ref) return false;
  return uuidLikeRef.test(ref) || ref.startsWith("node_") || ref.startsWith("shared-ref-");
};
function normalizeRefId(ref) {
  if (!ref) return ref;
  if (ref.startsWith("node-formula:")) return ref.replace(/^node-formula:/, "");
  return ref;
}
function extractNodeIdsFromConditionSet(conditionSet) {
  const ids = /* @__PURE__ */ new Set();
  if (!conditionSet || typeof conditionSet !== "object") return ids;
  const obj = conditionSet;
  if (Array.isArray(obj.tokens)) {
    for (const t of obj.tokens) {
      const asStr = typeof t === "string" ? t : JSON.stringify(t);
      const re = /@value\.([a-f0-9-]{36})/gi;
      let m;
      while ((m = re.exec(asStr)) !== null) {
        ids.add(m[1]);
      }
    }
  }
  if (Array.isArray(obj.branches)) {
    for (const br of obj.branches) {
      const b = br;
      const when = b.when;
      const scanWhen = (node) => {
        if (!node) return;
        const ref = node.ref;
        if (typeof ref === "string") {
          const m = /@value\.([a-f0-9-]{36})/i.exec(ref);
          if (m && m[1]) ids.add(m[1]);
        }
        if (node.left && typeof node.left === "object") scanWhen(node.left);
        if (node.right && typeof node.right === "object") scanWhen(node.right);
      };
      scanWhen(when);
      const actions = b.actions;
      if (Array.isArray(actions)) {
        for (const a of actions) {
          const aa = a;
          const nodeIds = aa.nodeIds;
          if (Array.isArray(nodeIds)) {
            for (const nid of nodeIds) ids.add(normalizeRefId(nid));
          }
        }
      }
    }
  }
  if (obj.fallback && typeof obj.fallback === "object") {
    const fb = obj.fallback;
    const actions = fb.actions;
    if (Array.isArray(actions)) {
      for (const a of actions) {
        const aa = a;
        const nodeIds = aa.nodeIds;
        if (Array.isArray(nodeIds)) {
          for (const nid of nodeIds) ids.add(normalizeRefId(nid));
        }
      }
    }
  }
  const str = JSON.stringify(obj);
  if (str) {
    const re = /@value\.([a-f0-9-]{36})/gi;
    let m;
    while ((m = re.exec(str)) !== null) ids.add(m[1]);
  }
  return ids;
}
function extractNodeIdsFromTokens(tokens2) {
  const ids = /* @__PURE__ */ new Set();
  if (!tokens2) return ids;
  const addFromString = (s) => {
    let m;
    const re = /@value\.([A-Za-z0-9_:-]+)/gi;
    while ((m = re.exec(s)) !== null) ids.add(m[1]);
  };
  if (Array.isArray(tokens2)) {
    for (const t of tokens2) {
      if (typeof t === "string") addFromString(t);
      else addFromString(JSON.stringify(t));
    }
  } else if (typeof tokens2 === "string") {
    addFromString(tokens2);
  } else {
    addFromString(JSON.stringify(tokens2));
  }
  return ids;
}
async function getNodeLinkedField2(client, nodeId, field) {
  const node = await client.treeBranchLeafNode.findUnique({
    where: { id: nodeId },
    select: { [field]: true }
  });
  return node?.[field] ?? [];
}
async function setNodeLinkedField2(client, nodeId, field, values) {
  try {
    await client.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: { [field]: { set: uniq(values) } }
    });
  } catch (e) {
    console.warn("[TreeBranchLeaf API] setNodeLinkedField skipped:", { nodeId, field, error: e.message });
  }
}
async function addToNodeLinkedField6(client, nodeId, field, idsToAdd) {
  const sanitized2 = idsToAdd?.filter((id) => id && isRealNodeRef(id)) ?? [];
  if (!sanitized2.length) return;
  const current = await getNodeLinkedField2(client, nodeId, field);
  const next = uniq([...current, ...sanitized2]);
  await setNodeLinkedField2(client, nodeId, field, next);
}
function buildResponseFromColumns(node) {
  const appearance = {
    size: node.appearance_size || "md",
    width: node.appearance_width || null,
    variant: node.appearance_variant || null,
    helpTooltipType: node.text_helpTooltipType || "none",
    helpTooltipText: node.text_helpTooltipText || null,
    helpTooltipImage: node.text_helpTooltipImage || null
  };
  const legacyRepeater = (() => {
    if (node.metadata && typeof node.metadata === "object" && node.metadata.repeater) {
      const legacy = node.metadata.repeater;
      return typeof legacy === "object" && legacy !== null ? legacy : null;
    }
    return null;
  })();
  const repeater = {
    templateNodeIds: (() => {
      if (node.repeater_templateNodeIds) {
        try {
          const parsed = JSON.parse(node.repeater_templateNodeIds);
          return Array.isArray(parsed) ? parsed : [];
        } catch (e) {
          console.error("\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA2\xC3\u0192\xE2\u20AC\u0161\xC3\u201A\xC2\x9D\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xE2\u201E\xA2 [buildResponseFromColumns] Erreur parse repeater_templateNodeIds:", e);
          return [];
        }
      }
      const legacyIds = legacyRepeater?.templateNodeIds;
      if (Array.isArray(legacyIds)) {
        return legacyIds;
      }
      return [];
    })(),
    templateNodeLabels: (() => {
      if (node.repeater_templateNodeLabels) {
        try {
          const parsedLabels = JSON.parse(node.repeater_templateNodeLabels);
          return parsedLabels && typeof parsedLabels === "object" ? parsedLabels : null;
        } catch (e) {
          console.error("\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA2\xC3\u0192\xE2\u20AC\u0161\xC3\u201A\xC2\x9D\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xE2\u201E\xA2 [buildResponseFromColumns] Erreur parse repeater_templateNodeLabels:", e);
        }
      }
      const legacyLabels = legacyRepeater?.templateNodeLabels;
      if (legacyLabels && typeof legacyLabels === "object") {
        return legacyLabels;
      }
      return null;
    })(),
    minItems: node.repeater_minItems ?? legacyRepeater?.minItems ?? 0,
    maxItems: node.repeater_maxItems ?? legacyRepeater?.maxItems ?? null,
    addButtonLabel: node.repeater_addButtonLabel || legacyRepeater?.addButtonLabel || null,
    buttonSize: node.repeater_buttonSize || legacyRepeater?.buttonSize || "middle",
    buttonWidth: node.repeater_buttonWidth || legacyRepeater?.buttonWidth || "auto",
    iconOnly: node.repeater_iconOnly ?? legacyRepeater?.iconOnly ?? false
  };
  const appearanceConfig = {
    size: node.appearance_size || "md",
    variant: node.appearance_variant || "singleline",
    placeholder: node.text_placeholder || "",
    maxLength: node.text_maxLength || 255,
    mask: node.text_mask || "",
    regex: node.text_regex || "",
    helpTooltipType: node.text_helpTooltipType || "none",
    helpTooltipText: node.text_helpTooltipText || null,
    helpTooltipImage: node.text_helpTooltipImage || null
  };
  const fieldConfig = {
    text: {
      placeholder: node.text_placeholder || null,
      maxLength: node.text_maxLength || null,
      minLength: node.text_minLength || null,
      mask: node.text_mask || null,
      regex: node.text_regex || null,
      rows: node.text_rows || 3
    },
    number: {
      min: node.number_min || null,
      max: node.number_max || null,
      step: node.number_step || 1,
      // √É∆í√Ü‚Äô√É‚Äö√Ç¬∞√É∆í√¢‚Ç¨¬¶√É‚Äö√Ç¬∏√É∆í√Ç¬¢√É¬¢√¢‚Ç¨≈°√Ç¬¨√É‚Äö√Ç¬ù√É∆í√¢‚Ç¨≈°√É‚Äö√Ç¬ß FIX: Priorit√É∆í√Ü‚Äô√É‚Ä†√¢‚Ç¨‚Ñ¢√É∆í√¢‚Ç¨≈°√É‚Äö√Ç¬© √É∆í√Ü‚Äô√É‚Ä†√¢‚Ç¨‚Ñ¢√É∆í√¢‚Ç¨≈°√É‚Äö√Ç¬† data_precision pour les champs d'affichage (cartes bleues), sinon number_decimals
      decimals: node.data_precision ?? node.number_decimals ?? 0,
      prefix: node.number_prefix || null,
      suffix: node.number_suffix || null,
      unit: node.number_unit ?? node.data_unit ?? null,
      defaultValue: node.number_defaultValue || null
    },
    select: {
      multiple: node.select_multiple || false,
      searchable: node.select_searchable !== false,
      allowClear: node.select_allowClear !== false,
      defaultValue: node.select_defaultValue || null,
      options: node.select_options || []
    },
    bool: {
      trueLabel: node.bool_trueLabel || null,
      falseLabel: node.bool_falseLabel || null,
      defaultValue: node.bool_defaultValue || null
    },
    date: {
      format: node.date_format || "DD/MM/YYYY",
      showTime: node.date_showTime || false,
      minDate: node.date_minDate || null,
      maxDate: node.date_maxDate || null
    },
    image: {
      maxSize: node.image_maxSize || null,
      ratio: node.image_ratio || null,
      crop: node.image_crop || false,
      thumbnails: node.image_thumbnails || null
    }
  };
  Object.keys(fieldConfig).forEach((key2) => {
    const config = fieldConfig[key2];
    const hasValues = Object.values(config).some((val) => val !== null && val !== void 0 && val !== false && val !== 0 && val !== "");
    if (!hasValues) delete fieldConfig[key2];
  });
  const cleanedMetadata = {
    ...node.metadata || {},
    appearance
  };
  if (node.subtabs) {
    try {
      const parsed = JSON.parse(node.subtabs);
      if (Array.isArray(parsed)) {
        cleanedMetadata.subTabs = parsed;
      }
    } catch {
    }
  }
  if (node.subtab !== void 0 && node.subtab !== null) {
    const rawSubTab = node.subtab;
    let parsedSubTab = rawSubTab;
    if (typeof rawSubTab === "string") {
      const trimmed = rawSubTab.trim();
      if (trimmed.startsWith("[")) {
        try {
          const candidate = JSON.parse(trimmed);
          if (Array.isArray(candidate)) {
            parsedSubTab = candidate;
          }
        } catch {
          parsedSubTab = rawSubTab;
        }
      } else if (trimmed.includes(",")) {
        parsedSubTab = trimmed.split(",").map((part) => part.trim()).filter(Boolean);
      } else {
        parsedSubTab = trimmed;
      }
    }
    try {
      cleanedMetadata.subTab = parsedSubTab;
    } catch {
    }
  }
  if (node.id === "131a7b51-97d5-4f40-8a5a-9359f38939e8") {
  }
  if (cleanedMetadata && cleanedMetadata.subTabs) {
    try {
    } catch {
    }
  }
  const metadataWithRepeater = {
    ...cleanedMetadata,
    repeater
  };
  if (repeater.templateNodeIds && repeater.templateNodeIds.length > 0) {
  }
  const result = {
    ...node,
    metadata: metadataWithRepeater,
    fieldConfig,
    appearance,
    appearanceConfig,
    fieldType: node.fieldType || node.type,
    fieldSubType: node.fieldSubType || node.subType,
    text_helpTooltipType: node.text_helpTooltipType,
    text_helpTooltipText: node.text_helpTooltipText,
    text_helpTooltipImage: node.text_helpTooltipImage,
    // üéØ AI Measure columns - MUST be included in API responses
    aiMeasure_enabled: node.aiMeasure_enabled ?? false,
    aiMeasure_autoTrigger: node.aiMeasure_autoTrigger ?? true,
    aiMeasure_prompt: node.aiMeasure_prompt || null,
    aiMeasure_keys: node.aiMeasure_keys || null,
    tables: node.TreeBranchLeafNodeTable || [],
    sharedReferenceIds: node.sharedReferenceIds || void 0
  };
  try {
    const legacyMetaCaps = node.metadata && typeof node.metadata === "object" ? node.metadata.capabilities : void 0;
    const buildInstances = (raw) => {
      if (!raw) return void 0;
      if (typeof raw === "object" && raw !== null) return raw;
      return void 0;
    };
    const capabilities = {
      data: node.hasData || node.data_activeId || node.data_instances ? {
        enabled: !!node.hasData,
        activeId: node.data_activeId || null,
        instances: buildInstances(node.data_instances) || {},
        unit: node.data_unit || null,
        precision: typeof node.data_precision === "number" ? node.data_precision : 2,
        exposedKey: node.data_exposedKey || null,
        displayFormat: node.data_displayFormat || null,
        visibleToUser: node.data_visibleToUser === true
      } : void 0,
      formula: node.hasFormula || node.formula_activeId || node.formula_instances ? {
        enabled: !!node.hasFormula,
        activeId: node.formula_activeId || null,
        instances: buildInstances(node.formula_instances) || {},
        tokens: buildInstances(node.formula_tokens) || void 0,
        name: node.formula_name || null
      } : void 0,
      table: node.hasTable || node.table_activeId || node.table_instances ? {
        enabled: !!node.hasTable,
        activeId: node.table_activeId || null,
        instances: buildInstances(node.table_instances) || {},
        name: node.table_name || null,
        meta: buildInstances(node.table_meta) || {},
        type: node.table_type || "columns",
        isImported: node.table_isImported === true,
        importSource: node.table_importSource || null,
        columns: Array.isArray(node.table_columns) ? node.table_columns : null,
        rows: Array.isArray(node.table_rows) ? node.table_rows : null
      } : void 0,
      select: node.select_options || node.select_defaultValue ? {
        options: Array.isArray(node.select_options) ? node.select_options : [],
        allowClear: node.select_allowClear !== false,
        multiple: node.select_multiple === true,
        searchable: node.select_searchable !== false,
        defaultValue: node.select_defaultValue || null
      } : void 0,
      number: node.number_min !== void 0 || node.number_max !== void 0 || node.number_defaultValue !== void 0 ? {
        min: node.number_min ?? null,
        max: node.number_max ?? null,
        step: node.number_step ?? 1,
        // √É∆í√Ü‚Äô√É‚Äö√Ç¬∞√É∆í√¢‚Ç¨¬¶√É‚Äö√Ç¬∏√É∆í√Ç¬¢√É¬¢√¢‚Ç¨≈°√Ç¬¨√É‚Äö√Ç¬ù√É∆í√¢‚Ç¨≈°√É‚Äö√Ç¬ß FIX: Priorit√É∆í√Ü‚Äô√É‚Ä†√¢‚Ç¨‚Ñ¢√É∆í√¢‚Ç¨≈°√É‚Äö√Ç¬© √É∆í√Ü‚Äô√É‚Ä†√¢‚Ç¨‚Ñ¢√É∆í√¢‚Ç¨≈°√É‚Äö√Ç¬† data_precision pour les champs d'affichage
        decimals: node.data_precision ?? node.number_decimals ?? 0,
        unit: node.number_unit ?? node.data_unit ?? null,
        prefix: node.number_prefix || null,
        suffix: node.number_suffix || null,
        defaultValue: node.number_defaultValue || null
      } : void 0,
      bool: node.bool_trueLabel || node.bool_falseLabel || node.bool_defaultValue !== void 0 ? {
        trueLabel: node.bool_trueLabel || null,
        falseLabel: node.bool_falseLabel || null,
        defaultValue: node.bool_defaultValue ?? null
      } : void 0,
      date: node.date_format || node.date_showTime || node.date_minDate || node.date_maxDate ? {
        format: node.date_format || "DD/MM/YYYY",
        showTime: node.date_showTime === true,
        minDate: node.date_minDate || null,
        maxDate: node.date_maxDate || null
      } : void 0,
      image: node.image_maxSize || node.image_ratio || node.image_crop || node.image_thumbnails ? {
        maxSize: node.image_maxSize || null,
        ratio: node.image_ratio || null,
        crop: node.image_crop === true,
        thumbnails: node.image_thumbnails || null
      } : void 0,
      link: node.link_activeId || node.link_instances ? {
        enabled: !!node.hasLink,
        activeId: node.link_activeId || null,
        instances: buildInstances(node.link_instances) || {},
        mode: node.link_mode || "JUMP",
        name: node.link_name || null,
        carryContext: node.link_carryContext === true,
        params: buildInstances(node.link_params) || {},
        targetNodeId: node.link_targetNodeId || null,
        targetTreeId: node.link_targetTreeId || null
      } : void 0,
      markers: node.markers_activeId || node.markers_instances || node.markers_selectedIds ? {
        enabled: !!node.hasMarkers,
        activeId: node.markers_activeId || null,
        instances: buildInstances(node.markers_instances) || {},
        available: buildInstances(node.markers_available) || {},
        selectedIds: buildInstances(node.markers_selectedIds) || {}
      } : void 0,
      api: node.api_activeId || node.api_instances ? {
        enabled: !!node.hasAPI,
        activeId: node.api_activeId || null,
        instances: buildInstances(node.api_instances) || {},
        bodyVars: buildInstances(node.api_bodyVars) || {},
        name: node.api_name || null
      } : void 0
    };
    Object.keys(capabilities).forEach((key2) => {
      if (capabilities[key2] === void 0) delete capabilities[key2];
    });
    let mergedCaps = capabilities;
    if (legacyMetaCaps && typeof legacyMetaCaps === "object") {
      mergedCaps = { ...legacyMetaCaps, ...capabilities };
    }
    result.capabilities = mergedCaps;
  } catch (e) {
    console.error("\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA2\xC3\u0192\xE2\u20AC\u0161\xC3\u201A\xC2\x9D\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xE2\u201E\xA2 [buildResponseFromColumns] Erreur adaptation legacy capabilities:", e);
  }
  if (node.sharedReferenceIds && node.sharedReferenceIds.length > 0) {
  }
  if (node.text_helpTooltipType && node.text_helpTooltipType !== "none") {
  }
  return result;
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/services/repeat-context-utils.ts
var toRecord = (metadata) => {
  if (!metadata || typeof metadata !== "object" || Array.isArray(metadata)) {
    return {};
  }
  return metadata;
};
var pickString = (value) => {
  return typeof value === "string" && value.trim().length ? value : void 0;
};
var pickNumericLike = (value) => {
  if (typeof value === "number" && Number.isFinite(value)) {
    return value;
  }
  if (typeof value === "string" && value.trim().length) {
    return value;
  }
  return void 0;
};
function deriveRepeatContextFromMetadata(carrier, fallback = {}) {
  const meta = toRecord(carrier.metadata);
  const repeaterNodeId = pickString(meta.duplicatedFromRepeater) ?? fallback.repeaterNodeId;
  const templateNodeId = pickString(meta.sourceTemplateId) ?? fallback.templateNodeId;
  const duplicatedFromNodeId = pickString(meta.copiedFromNodeId) ?? templateNodeId ?? fallback.templateNodeId ?? carrier.id;
  const scopeId = pickString(meta.repeatScopeId) ?? pickString(meta.repeaterScopeId) ?? fallback.scopeId ?? repeaterNodeId;
  const suffix = pickNumericLike(meta.copySuffix) ?? pickNumericLike(meta.suffixNum) ?? pickNumericLike(meta.suffix) ?? fallback.suffix;
  if (!repeaterNodeId && !scopeId) {
    return void 0;
  }
  return {
    repeaterNodeId,
    templateNodeId: templateNodeId ?? carrier.id,
    duplicatedFromNodeId,
    scopeId,
    suffix,
    mode: "repeater"
  };
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/services/table-lookup-duplication-service.ts
var import_crypto17 = require("crypto");
var TableLookupDuplicationService = class {
  /**
   * Duplique compl√É∆í√Ç¬®tement les tables TBL et leurs configurations SELECT associ√É∆í√Ç¬©es
   * Assure l'ind√É∆í√Ç¬©pendance totale des lookups pour les n√É‚Ä¶√¢‚Ç¨≈ìuds copi√É∆í√Ç¬©s
   */
  async duplicateTableLookupSystem(prisma51, originalNodeId, arg) {
    let suffixToken = typeof arg === "string" ? arg : arg?.suffixToken ?? "-1";
    if (!suffixToken) suffixToken = "-1";
    if (!suffixToken.startsWith("-")) {
      suffixToken = `-${suffixToken}`;
    }
    const normalizedOriginalId = normalizeNodeBase(originalNodeId);
    const copiedNodeId = typeof arg === "object" && arg?.copiedNodeId ? arg.copiedNodeId : `${normalizedOriginalId}${suffixToken}`;
    console.log(`[TBL-DUP] START duplicateTableLookupSystem: orig=${originalNodeId}, copy=${copiedNodeId}`);
    try {
      const copiedNode = await prisma51.treeBranchLeafNode.findUnique({
        where: { id: copiedNodeId }
      });
      if (!copiedNode) {
        console.log(`[TBL-DUP] \u26A0\uFE0F Copied node does not exist (shared reference): ${copiedNodeId}, skipping`);
        return;
      }
      console.log(`[TBL-DUP] \u2705 Copied node exists: ${copiedNode.label}, proceeding...`);
      const originalSelectConfigs = await prisma51.treeBranchLeafSelectConfig.findMany({
        where: { nodeId: originalNodeId }
      });
      console.log(`[TBL-DUP] Found ${originalSelectConfigs.length} SelectConfigs for node=${originalNodeId}`);
      if (originalSelectConfigs.length === 0) {
        console.log(`[TBL-DUP] \u26A0\uFE0F No SelectConfigs on original, creating NEW one for copy`);
        const originalNode = await prisma51.treeBranchLeafNode.findUnique({
          where: { id: originalNodeId },
          select: { table_activeId: true }
        });
        if (originalNode?.table_activeId) {
          const copiedTableId = `${originalNode.table_activeId}${suffixToken}`;
          const copiedTable = await prisma51.treeBranchLeafNodeTable.findUnique({
            where: { id: copiedTableId },
            include: { tableColumns: { take: 1, orderBy: { columnIndex: "asc" } } }
          });
          const firstColName = copiedTable?.tableColumns[0]?.name || null;
          if (firstColName) {
            const displayCol = firstColName;
            console.log(`[TBL-DUP] Creating NEW SelectConfig with displayColumn="${displayCol}"`);
            await prisma51.treeBranchLeafSelectConfig.create({
              data: {
                id: (0, import_crypto17.randomUUID)(),
                nodeId: copiedNodeId,
                tableReference: copiedTableId,
                // üî• CRITICAL: Remplir TOUS les champs n√©cessaires (pas juste displayColumn)
                displayColumn: displayCol,
                optionsSource: "table",
                // Type de source
                multiple: false,
                // Single select par d√©faut
                searchable: true,
                // Searchable par d√©faut
                allowCustom: false,
                // No custom values
                options: [],
                // Empty options (used only for 'fixed' source)
                maxSelections: null,
                apiEndpoint: null,
                keyColumn: null,
                keyRow: null,
                valueColumn: null,
                valueRow: null,
                displayRow: null,
                dependsOnNodeId: null,
                createdAt: /* @__PURE__ */ new Date(),
                updatedAt: /* @__PURE__ */ new Date()
              }
            });
            console.log(`[TBL-DUP] \u2705 NEW SelectConfig created with displayColumn="${displayCol}"`);
            return;
          }
        }
        console.log(`[TBL-DUP] No table or columns found, skipping`);
        return;
      }
      for (const selectConfig of originalSelectConfigs) {
        console.log(`[TBL-DUP] Processing SelectConfig id=${selectConfig.id} tableRef=${selectConfig.tableReference}`);
        await this.duplicateTableAndSelectConfig(prisma51, selectConfig, copiedNodeId, suffixToken);
        console.log(`[TBL-DUP] \u2705 Completed SelectConfig ${selectConfig.id}`);
      }
      console.log(`[TBL-DUP] \u2705 SUCCESS duplicateTableLookupSystem`);
    } catch (error) {
      console.error(`[TBL-DUP] ERROR: ${error instanceof Error ? error.message : String(error)}`);
      if (error instanceof Error) console.error(`[TBL-DUP] Stack: ${error.stack}`);
      throw error;
    }
  }
  /**
   * Duplique une table TBL et sa configuration SELECT associ√É∆í√Ç¬©e
   */
  async duplicateTableAndSelectConfig(prisma51, originalSelectConfig, copiedNodeId, suffix) {
    const originalTableId = originalSelectConfig.tableReference;
    const copiedTableId = `${originalTableId}${suffix}`;
    try {
      const originalTable = await prisma51.treeBranchLeafNodeTable.findUnique({
        where: { id: originalTableId },
        include: {
          tableColumns: true,
          tableRows: true
        }
      });
      if (!originalTable) {
        return;
      }
      const originalNodeIdBase = normalizeNodeBase(originalSelectConfig.nodeId);
      const tableOwnerNodeIdBase = normalizeNodeBase(originalTable.nodeId);
      const isTableOwnedByThisNode = originalNodeIdBase === tableOwnerNodeIdBase;
      const copiedTableOwnerNodeId = isTableOwnedByThisNode ? copiedNodeId : `${tableOwnerNodeIdBase}${suffix}`;
      let nodeOwnerExists = await prisma51.treeBranchLeafNode.findUnique({
        where: { id: copiedTableOwnerNodeId },
        select: { id: true }
      });
      if (!nodeOwnerExists && !isTableOwnedByThisNode) {
        console.log(
          `[TBL-DUP] Creating stub node "${copiedTableOwnerNodeId}" for table owner`
        );
        const originalOwnerNode = await prisma51.treeBranchLeafNode.findUnique({
          where: { id: originalTable.nodeId },
          select: {
            type: true,
            label: true,
            treeId: true,
            parentId: true
          }
        });
        if (originalOwnerNode) {
          try {
            const createdNode = await prisma51.treeBranchLeafNode.create({
              data: {
                id: copiedTableOwnerNodeId,
                type: originalOwnerNode.type,
                label: originalOwnerNode.label ? `${originalOwnerNode.label}${suffix}` : "Stub",
                treeId: originalOwnerNode.treeId,
                parentId: null,
                order: 0,
                createdAt: /* @__PURE__ */ new Date(),
                updatedAt: /* @__PURE__ */ new Date()
              }
            });
            nodeOwnerExists = createdNode;
            console.log(`[TBL-DUP] \u2705 Stub node created: ${copiedTableOwnerNodeId}`);
          } catch (err) {
            console.error(`[TBL-DUP] \u274C Failed to create stub node: ${err.message}`);
            throw err;
          }
        }
      }
      if (!nodeOwnerExists) {
        console.warn(
          `[TBL-DUP] Cannot duplicate table: owner node "${copiedTableOwnerNodeId}" doesn't exist`
        );
        return;
      }
      const existingCopiedTable = await prisma51.treeBranchLeafNodeTable.findUnique({
        where: { id: copiedTableId }
      });
      const rewrittenMeta = (() => {
        if (!originalTable.meta) return originalTable.meta;
        try {
          const metaObj = typeof originalTable.meta === "string" ? JSON.parse(originalTable.meta) : JSON.parse(JSON.stringify(originalTable.meta));
          const suffixNum = parseInt(suffix.replace("-", "")) || 1;
          if (metaObj?.lookup?.selectors?.columnFieldId && !metaObj.lookup.selectors.columnFieldId.endsWith(`-${suffixNum}`)) {
            metaObj.lookup.selectors.columnFieldId = `${metaObj.lookup.selectors.columnFieldId}-${suffixNum}`;
          }
          if (metaObj?.lookup?.selectors?.rowFieldId && !metaObj.lookup.selectors.rowFieldId.endsWith(`-${suffixNum}`)) {
            metaObj.lookup.selectors.rowFieldId = `${metaObj.lookup.selectors.rowFieldId}-${suffixNum}`;
          }
          if (metaObj?.lookup?.rowSourceOption?.sourceField && !metaObj.lookup.rowSourceOption.sourceField.endsWith(`-${suffixNum}`)) {
            metaObj.lookup.rowSourceOption.sourceField = `${metaObj.lookup.rowSourceOption.sourceField}-${suffixNum}`;
          }
          if (metaObj?.lookup?.columnSourceOption?.sourceField && !metaObj.lookup.columnSourceOption.sourceField.endsWith(`-${suffixNum}`)) {
            metaObj.lookup.columnSourceOption.sourceField = `${metaObj.lookup.columnSourceOption.sourceField}-${suffixNum}`;
          }
          if (metaObj?.lookup?.rowSourceOption?.comparisonColumn && !metaObj.lookup.rowSourceOption.operator) {
            metaObj.lookup.rowSourceOption.operator = "=";
            console.log(`[TBL-DUP] \u2705 Ajout operator '=' pour rowSourceOption`);
          }
          if (metaObj?.lookup?.columnSourceOption?.comparisonColumn && !metaObj.lookup.columnSourceOption.operator) {
            metaObj.lookup.columnSourceOption.operator = "=";
            console.log(`[TBL-DUP] \u2705 Ajout operator '=' pour columnSourceOption`);
          }
          if (metaObj?.lookup?.rowSourceOption?.comparisonColumn) {
            const val = metaObj.lookup.rowSourceOption.comparisonColumn;
            if (!/^-?\d+(\.\d+)?$/.test(val.trim()) && !val.endsWith(suffix)) {
              metaObj.lookup.rowSourceOption.comparisonColumn = `${val}${suffix}`;
            }
          }
          if (metaObj?.lookup?.columnSourceOption?.comparisonColumn) {
            const val = metaObj.lookup.columnSourceOption.comparisonColumn;
            if (!/^-?\d+(\.\d+)?$/.test(val.trim()) && !val.endsWith(suffix)) {
              metaObj.lookup.columnSourceOption.comparisonColumn = `${val}${suffix}`;
            }
          }
          console.log(`[TBL-DUP] DEBUG: displayColumn original = "${metaObj?.lookup?.displayColumn}"`);
          if (metaObj?.lookup?.displayColumn) {
            if (Array.isArray(metaObj.lookup.displayColumn)) {
              metaObj.lookup.displayColumn = metaObj.lookup.displayColumn.map((col) => {
                if (col && !/^-?\d+(\.\d+)?$/.test(col.trim()) && !col.endsWith(suffix)) {
                  return `${col}${suffix}`;
                }
                return col;
              });
            } else if (typeof metaObj.lookup.displayColumn === "string") {
              const val = metaObj.lookup.displayColumn;
              if (!/^-?\d+(\.\d+)?$/.test(val.trim()) && !val.endsWith(suffix)) {
                metaObj.lookup.displayColumn = `${val}${suffix}`;
              }
            }
            console.log(`[TBL-DUP] \u2705 displayColumn suffix\xE9 = "${metaObj.lookup.displayColumn}"`);
          } else {
            console.log(`[TBL-DUP] \u274C displayColumn non d\xE9fini!`);
          }
          if (metaObj?.lookup?.displayRow) {
            if (Array.isArray(metaObj.lookup.displayRow)) {
              metaObj.lookup.displayRow = metaObj.lookup.displayRow.map((row) => {
                if (row && !/^-?\d+(\.\d+)?$/.test(row.trim()) && !row.endsWith(suffix)) {
                  return `${row}${suffix}`;
                }
                return row;
              });
            } else if (typeof metaObj.lookup.displayRow === "string") {
              const val = metaObj.lookup.displayRow;
              if (!/^-?\d+(\.\d+)?$/.test(val.trim()) && !val.endsWith(suffix)) {
                metaObj.lookup.displayRow = `${val}${suffix}`;
              }
            }
          }
          return metaObj;
        } catch {
          return originalTable.meta;
        }
      })();
      if (!existingCopiedTable) {
        await prisma51.treeBranchLeafNodeTable.create({
          data: {
            id: copiedTableId,
            nodeId: copiedTableOwnerNodeId,
            // üîß FIX: Utiliser le vrai propri√©taire,
            name: originalTable.name + suffix,
            type: originalTable.type,
            description: originalTable.description,
            // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬¢ COPIE TABLE META: suffixer UUIDs et comparisonColumn
            meta: rewrittenMeta,
            organizationId: originalTable.organizationId,
            rowCount: originalTable.rowCount,
            columnCount: originalTable.columnCount,
            lookupDisplayColumns: originalTable.lookupDisplayColumns,
            lookupSelectColumn: originalTable.lookupSelectColumn,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date(),
            // Duplication des colonnes
            // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬¢ COPIE TABLE COLUMN: suffixe seulement pour texte, pas pour nombres
            // √∞ ÀÜ√¢‚Ç¨  FIX 07/01/2026: R√É¬©assigner les columnIndex en s√É¬©quence (0, 1, 2, ...) pour pr√É¬©server l'ordre
            tableColumns: {
              create: originalTable.tableColumns.map((col, idx) => {
                const baseName = String(col.name ?? "");
                const isNumericName = /^-?\d+(\.\d+)?$/.test(baseName.trim());
                const shouldSuffix = baseName.length > 0 && !isNumericName && !baseName.endsWith(suffix);
                const newName = shouldSuffix ? `${baseName}${suffix}` : baseName;
                console.log(`[TBL-DUP] Column ${idx}: "${col.name}" -> "${newName}" (columnIndex: ${col.columnIndex} -> ${idx})`);
                return {
                  id: col.id ? `${col.id}${suffix}` : (0, import_crypto17.randomUUID)(),
                  // ‚úÖ FIX 11/01/2026: NE PAS inclure tableId dans nested create - Prisma le remplit automatiquement
                  columnIndex: idx,
                  // ‚úÖ FIX: R√©assigner en s√©quence au lieu de copier
                  name: newName,
                  type: col.type,
                  width: col.width,
                  format: col.format,
                  metadata: col.metadata
                };
              })
            },
            // Duplication des lignes
            // ‚úÖ FIX 07/01/2026: R√©assigner aussi les rowIndex en s√©quence pour pr√©server l'ordre
            tableRows: {
              create: originalTable.tableRows.map((row, idx) => ({
                id: row.id ? `${row.id}${suffix}` : (0, import_crypto17.randomUUID)(),
                // ‚úÖ FIX 11/01/2026: NE PAS inclure tableId dans nested create - Prisma le remplit automatiquement
                rowIndex: idx,
                // ‚úÖ FIX: R√©assigner en s√©quence
                cells: row.cells
              }))
            }
          }
        });
      } else {
        console.log(`[TBL-DUP] Table "${copiedTableId}" existe d\xE9j\xE0, mise \xE0 jour des colonnes...`);
        await prisma51.treeBranchLeafNodeTableColumn.deleteMany({
          where: { tableId: copiedTableId }
        });
        const newColumns = await Promise.all(
          originalTable.tableColumns.map((col, idx) => {
            const baseName = String(col.name ?? "");
            const isNumericName = /^-?\d+(\.\d+)?$/.test(baseName.trim());
            const shouldSuffix = baseName.length > 0 && !isNumericName && !baseName.endsWith(suffix);
            const newName = shouldSuffix ? `${baseName}${suffix}` : baseName;
            console.log(`[TBL-DUP] Update Column ${idx}: "${col.name}" -> "${newName}"`);
            return prisma51.treeBranchLeafNodeTableColumn.create({
              data: {
                id: col.id ? `${col.id}${suffix}` : (0, import_crypto17.randomUUID)(),
                tableId: copiedTableId,
                columnIndex: col.columnIndex,
                name: newName,
                type: col.type,
                width: col.width,
                format: col.format,
                metadata: col.metadata
              }
            });
          })
        );
        console.log(`[TBL-DUP] \u2705 ${newColumns.length} colonnes cr\xE9\xE9es avec suffixe`);
        await prisma51.treeBranchLeafNodeTable.update({
          where: { id: copiedTableId },
          data: { meta: rewrittenMeta, updatedAt: /* @__PURE__ */ new Date() }
        });
        console.log(`[TBL-DUP] \u2705 Meta de la table mise \xE0 jour avec suffixes`);
      }
      const existingSelectConfig = await prisma51.treeBranchLeafSelectConfig.findUnique({
        where: { nodeId: copiedNodeId }
      });
      if (!existingSelectConfig) {
        const shouldSuffixColumns = true;
        console.log(`[TBL-DUP] Cr\xE9ation SelectConfig: nodeId=${copiedNodeId}, tableRef=${copiedTableId}, displayColumn=${originalSelectConfig.displayColumn || "(null)"}`);
        await prisma51.treeBranchLeafSelectConfig.create({
          data: {
            id: (0, import_crypto17.randomUUID)(),
            // üîß FIX: G√©n√©rer l'id manuellement
            nodeId: copiedNodeId,
            tableReference: copiedTableId,
            // üî• SUFFIXER les r√©f√©rences de colonnes/lignes si elles pointent vers la premi√®re colonne/ligne
            keyColumn: originalSelectConfig.keyColumn ? `${originalSelectConfig.keyColumn}${suffix}` : null,
            keyRow: originalSelectConfig.keyRow ? `${originalSelectConfig.keyRow}${suffix}` : null,
            valueColumn: originalSelectConfig.valueColumn ? `${originalSelectConfig.valueColumn}${suffix}` : null,
            valueRow: originalSelectConfig.valueRow ? `${originalSelectConfig.valueRow}${suffix}` : null,
            displayColumn: (() => {
              if (originalSelectConfig.displayColumn) {
                return `${originalSelectConfig.displayColumn}${suffix}`;
              }
              const firstCol = originalTable.tableColumns && originalTable.tableColumns.length > 0 ? originalTable.tableColumns[0] : null;
              if (firstCol && firstCol.name) {
                const baseName = String(firstCol.name);
                const isNumericName = /^-?\d+(\.\d+)?$/.test(baseName.trim());
                const shouldSuffix = baseName.length > 0 && !isNumericName && !baseName.endsWith(suffix);
                const result = shouldSuffix ? `${baseName}${suffix}` : baseName;
                console.log(`[TBL-DUP] displayColumn init: firstCol="${firstCol.name}" \u2192 "${result}"`);
                return result;
              }
              console.log(`[TBL-DUP] displayColumn: AUCUNE COLONNE TROUV\xC9E`);
              return null;
            })(),
            displayRow: originalSelectConfig.displayRow ? `${originalSelectConfig.displayRow}${suffix}` : null,
            // üîß FIX 07/01/2026: Copier TOUS les autres champs du SelectConfig original
            options: originalSelectConfig.options,
            multiple: originalSelectConfig.multiple,
            searchable: originalSelectConfig.searchable,
            allowCustom: originalSelectConfig.allowCustom,
            maxSelections: originalSelectConfig.maxSelections,
            optionsSource: originalSelectConfig.optionsSource,
            apiEndpoint: originalSelectConfig.apiEndpoint,
            // üî• CRITICAL: Suffixer dependsOnNodeId s'il existe (r√©f√©rence √† un autre n≈ìud)
            dependsOnNodeId: originalSelectConfig.dependsOnNodeId ? `${originalSelectConfig.dependsOnNodeId}${suffix}` : null,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
        console.log(`[TBL-DUP] \u2705 SelectConfig cr\xE9\xE9 avec displayColumn SAUVEGARD\xC9 en DB`);
        try {
          const node = await prisma51.treeBranchLeafNode.findUnique({ where: { id: copiedNodeId }, select: { capabilities: true, linkedTableIds: true, fieldType: true, metadata: true } });
          const currentCapabilities = node?.capabilities && typeof node.capabilities === "object" ? node.capabilities : {};
          const isInputField = node?.fieldType === null || node?.fieldType === "" || node?.fieldType === void 0;
          const currentLinked = node?.linkedTableIds || [];
          const newLinked = isInputField ? [] : Array.from(/* @__PURE__ */ new Set([...currentLinked, copiedTableId]));
          const currentMetadata = node?.metadata && typeof node.metadata === "object" ? JSON.parse(JSON.stringify(node.metadata)) : {};
          if (currentMetadata.lookup) {
            if (currentMetadata.lookup.tableRef) {
              currentMetadata.lookup.tableRef = copiedTableId;
            }
            if (currentMetadata.lookup.displayColumn) {
              if (Array.isArray(currentMetadata.lookup.displayColumn)) {
                currentMetadata.lookup.displayColumn = currentMetadata.lookup.displayColumn.map(
                  (col) => col && !col.endsWith(suffix) ? `${col}${suffix}` : col
                );
              } else if (typeof currentMetadata.lookup.displayColumn === "string") {
                const val = currentMetadata.lookup.displayColumn;
                if (!val.endsWith(suffix)) {
                  currentMetadata.lookup.displayColumn = `${val}${suffix}`;
                }
              }
            }
          }
          if (isTableOwnedByThisNode) {
            currentCapabilities.table = currentCapabilities.table || {};
            currentCapabilities.table.enabled = true;
            currentCapabilities.table.activeId = copiedTableId;
            currentCapabilities.table.instances = currentCapabilities.table.instances || {};
            currentCapabilities.table.instances[copiedTableId] = currentCapabilities.table.instances[copiedTableId] || {};
            await prisma51.treeBranchLeafNode.update({
              where: { id: copiedNodeId },
              data: {
                hasTable: true,
                // ‚úÖ Seulement le propri√©taire a hasTable: true
                table_activeId: copiedTableId,
                table_instances: { set: currentCapabilities.table.instances },
                table_name: originalTable.name + suffix,
                table_type: originalTable.type,
                capabilities: currentCapabilities,
                linkedTableIds: { set: newLinked },
                metadata: currentMetadata
                // üî• FIX: Sauvegarder le metadata mis √† jour
              }
            });
          } else {
            await prisma51.treeBranchLeafNode.update({
              where: { id: copiedNodeId },
              data: {
                hasTable: false,
                // ‚úÖ IMPORTANT: Les non-propri√©taires NE doivent PAS avoir hasTable: true!
                linkedTableIds: { set: newLinked },
                metadata: currentMetadata
                // üî• FIX: Sauvegarder le metadata mis √† jour
              }
            });
          }
        } catch (nodeUpdateErr) {
          console.warn(`   \u26A0\uFE0F Warning updating node ${copiedNodeId} capabilities:`, nodeUpdateErr.message);
        }
      } else {
      }
    } catch (error) {
      console.error(`\u274C Erreur duplication table/config ${originalTableId}:`, error);
      throw error;
    }
  }
  /**
   * R√É∆í√Ç¬©pare les configurations SELECT manquantes pour les n√É‚Ä¶√¢‚Ç¨≈ìuds copi√É∆í√Ç¬©s existants
   */
  async repairMissingSelectConfigs(prisma51) {
    try {
      const copiedNodes = await prisma51.treeBranchLeafNode.findMany({
        where: {
          id: {
            endsWith: "-1"
          }
        }
      });
      for (const copiedNode of copiedNodes) {
        const originalNodeId = copiedNode.id.replace("-1", "");
        const copiedSelectConfigs = await prisma51.treeBranchLeafSelectConfig.findMany({
          where: { nodeId: copiedNode.id }
        });
        if (copiedSelectConfigs.length === 0) {
          await this.duplicateTableLookupSystem(prisma51, originalNodeId, {
            copiedNodeId: copiedNode.id,
            suffixToken: "-1"
          });
        }
      }
    } catch (error) {
      console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 [TableLookupDuplication] Erreur r\xC3\u0192\xC2\xA9paration:`, error);
      throw error;
    }
  }
};
var tableLookupDuplicationService = new TableLookupDuplicationService();
function normalizeNodeBase(value) {
  return value.replace(/-\d+(?:-\d+)*$/, "");
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/services/deep-copy-service.ts
async function deepCopyNodeInternal(prisma51, req2, nodeId, opts) {
  const {
    targetParentId,
    suffixNum,
    preserveSharedReferences = false,
    forcedSuffix,
    repeatContext,
    cloneExternalParents = false,
    isFromRepeaterDuplication = false
  } = opts || {};
  const replaceIdsInTokens = (tokens2, idMap2) => {
    if (!tokens2) return tokens2;
    const mapOne = (s) => s.replace(/@value\.([A-Za-z0-9_:-]+)/g, (_m, p1) => {
      if (idMap2.has(p1)) {
        const newId = idMap2.get(p1);
        return `@value.${newId}`;
      }
      const suffixedId = appendSuffix(p1);
      return `@value.${suffixedId}`;
    });
    if (Array.isArray(tokens2)) return tokens2.map((t) => typeof t === "string" ? mapOne(t) : t);
    if (typeof tokens2 === "string") return mapOne(tokens2);
    try {
      const asStr = JSON.stringify(tokens2);
      const replaced = mapOne(asStr);
      return JSON.parse(replaced);
    } catch {
      return tokens2;
    }
  };
  const replaceIdsInConditionSet = (conditionSet, idMap2, formulaIdMap2) => {
    if (!conditionSet) return conditionSet;
    try {
      let str = JSON.stringify(conditionSet);
      str = str.replace(/@value\.([A-Za-z0-9_:-]+)/g, (_m, p1) => {
        if (idMap2.has(p1)) {
          const newId = idMap2.get(p1);
          return `@value.${newId}`;
        }
        const suffixedId = appendSuffix(p1);
        return `@value.${suffixedId}`;
      });
      str = str.replace(/node-formula:([a-f0-9-]{36})/gi, (_m, p1) => {
        const newId = formulaIdMap2.get(p1) || p1;
        return `node-formula:${newId}`;
      });
      str = str.replace(/("nodeIds":\s*\["?)([a-zA-Z0-9_:-]+)/g, (_m, prefix, nodeId2) => {
        if (nodeId2.includes(":")) {
          return _m;
        }
        if (nodeId2.startsWith("shared-ref-") || !nodeId2.includes("-")) {
          if (idMap2.has(nodeId2)) {
            const newId = idMap2.get(nodeId2);
            return prefix + newId;
          }
          const suffixedId = appendSuffix(nodeId2);
          return prefix + suffixedId;
        }
        return _m;
      });
      return JSON.parse(str);
    } catch {
      return conditionSet;
    }
  };
  const source = await prisma51.treeBranchLeafNode.findUnique({
    where: { id: nodeId },
    include: { TreeBranchLeafTree: { select: { organizationId: true } } }
  });
  if (!source) {
    throw new Error("N\xC3\u2026\xE2\u20AC\u0153ud source introuvable");
  }
  const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx(req2);
  if (!isSuperAdmin2 && organizationId && source.TreeBranchLeafTree?.organizationId !== organizationId) {
    throw new Error("Acc\xC3\u0192\xC2\xA8s non autoris\xC3\u0192\xC2\xA9 \xC3\u0192\xC2\xA0 cet arbre");
  }
  const sanitizedForcedSuffix = (() => {
    if (forcedSuffix === void 0 || forcedSuffix === null) return "";
    const token = `${forcedSuffix}`.trim();
    return token;
  })();
  let copySuffixNum = typeof forcedSuffix === "number" && Number.isFinite(forcedSuffix) ? forcedSuffix : suffixNum ?? null;
  if (!sanitizedForcedSuffix) {
    if (suffixNum != null && Number.isFinite(suffixNum)) {
      copySuffixNum = suffixNum;
    } else if (copySuffixNum != null && Number.isFinite(copySuffixNum)) {
    } else {
      const baseSourceId = source.id.replace(/-\d+(?:-\d+)*$/, "");
      const existingIdsWithSuffix = await prisma51.treeBranchLeafNode.findMany({
        where: {
          treeId: source.treeId,
          id: {
            startsWith: `${baseSourceId}-`
            // Exclure les suffixes compos√É∆í√Ç¬©s (on cherche juste -1, -2, -3, pas -1-1)
          }
        },
        select: { id: true }
      });
      let maxSuffix = 0;
      for (const rec of existingIdsWithSuffix) {
        const rest = rec.id.slice(baseSourceId.length + 1);
        if (/^\d+$/.test(rest)) {
          const num = Number(rest);
          if (Number.isFinite(num) && num > maxSuffix) maxSuffix = num;
        }
      }
      copySuffixNum = maxSuffix + 1;
    }
  }
  const suffixToken = sanitizedForcedSuffix || `${copySuffixNum}`;
  const computedLabelSuffix = `-${suffixToken}`;
  const suffixPattern = new RegExp(`-${suffixToken.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}$`);
  const numericSuffixPattern = /-\d+$/;
  const hasCurrentSuffix = (value) => suffixPattern.test(value);
  const stripNumericSuffix2 = (value) => value.replace(/-\d+(?:-\d+)*$/, "");
  const hasAnySuffix = (value) => hasCurrentSuffix(value) || numericSuffixPattern.test(value);
  const ensureSuffix = (value) => {
    if (!value) return value;
    if (hasCurrentSuffix(value)) return value;
    const base = stripNumericSuffix2(value);
    return `${base}-${suffixToken}`;
  };
  const buildParentSuffix = (value) => {
    if (!value) return value ?? null;
    const base = value.replace(/-\d+$/, "");
    return `${base}-${suffixToken}`;
  };
  const appendSuffix = (value) => `${value}-${suffixToken}`;
  const normalizeLabelWithSuffix = (value) => {
    if (!value) return value;
    const base = value.replace(/-\d+(?:-\d+)*$/, "");
    if (hasCurrentSuffix(value)) return `${base}-${suffixToken}`;
    return `${base}-${suffixToken}`;
  };
  const metadataCopySuffix = Number.isFinite(Number(suffixToken)) ? Number(suffixToken) : suffixToken;
  const derivedRepeatContext = repeatContext ?? deriveRepeatContextFromMetadata(source, { suffix: suffixToken });
  const normalizedRepeatContext = derivedRepeatContext ? {
    ...derivedRepeatContext,
    suffix: derivedRepeatContext.suffix ?? suffixToken
  } : void 0;
  const allNodes = await prisma51.treeBranchLeafNode.findMany({ where: { treeId: source.treeId } });
  const byId = new Map(allNodes.map((n) => [n.id, n]));
  const existingNodeIds = new Set(byId.keys());
  const childrenByParent = /* @__PURE__ */ new Map();
  for (const n of allNodes) {
    if (!n.parentId) continue;
    const arr = childrenByParent.get(n.parentId) || [];
    arr.push(n.id);
    childrenByParent.set(n.parentId, arr);
  }
  const toCopy = /* @__PURE__ */ new Set();
  const queue = [source.id];
  while (queue.length) {
    const cur = queue.shift();
    if (toCopy.has(cur)) continue;
    toCopy.add(cur);
    const children = childrenByParent.get(cur) || [];
    for (const c of children) queue.push(c);
  }
  const idMap = /* @__PURE__ */ new Map();
  for (const oldId of toCopy) {
    const candidateId = appendSuffix(oldId);
    idMap.set(oldId, candidateId);
  }
  const formulaIdMap = /* @__PURE__ */ new Map();
  const conditionIdMap = /* @__PURE__ */ new Map();
  const tableIdMap2 = /* @__PURE__ */ new Map();
  const displayNodeIds = [];
  const directVariableIdByNodeId = /* @__PURE__ */ new Map();
  if (toCopy.size > 0) {
    const nodeVariables = await prisma51.treeBranchLeafNodeVariable.findMany({
      where: { nodeId: { in: Array.from(toCopy) } },
      select: { nodeId: true, id: true }
    });
    for (const variable of nodeVariables) {
      if (variable.nodeId && variable.id) {
        if (!directVariableIdByNodeId.has(variable.nodeId)) {
          directVariableIdByNodeId.set(variable.nodeId, /* @__PURE__ */ new Set());
        }
        directVariableIdByNodeId.get(variable.nodeId).add(variable.id);
      }
    }
  }
  const buildCreationOrder = () => {
    const edges = /* @__PURE__ */ new Map();
    const indegree = /* @__PURE__ */ new Map();
    const ensureNode = (id) => {
      if (!edges.has(id)) edges.set(id, /* @__PURE__ */ new Set());
      if (!indegree.has(id)) indegree.set(id, 0);
    };
    for (const id of toCopy) ensureNode(id);
    for (const id of toCopy) {
      const n = byId.get(id);
      if (n?.parentId && toCopy.has(n.parentId)) {
        const from = n.parentId;
        const to = id;
        const set = edges.get(from);
        if (!set.has(to)) {
          set.add(to);
          indegree.set(to, (indegree.get(to) || 0) + 1);
        }
      }
    }
    const localQueue = [];
    const zeroIndegreeNodes = [];
    for (const [id, deg] of indegree.entries()) if (deg === 0) zeroIndegreeNodes.push(id);
    zeroIndegreeNodes.sort((a, b) => {
      const nodeA = byId.get(a);
      const nodeB = byId.get(b);
      const orderA = nodeA?.order ?? 0;
      const orderB = nodeB?.order ?? 0;
      return orderA - orderB;
    });
    localQueue.push(...zeroIndegreeNodes);
    const ordered = [];
    while (localQueue.length) {
      const id = localQueue.shift();
      ordered.push(id);
      const nextNodes = [];
      for (const next of edges.get(id) || []) {
        const d = (indegree.get(next) || 0) - 1;
        indegree.set(next, d);
        if (d === 0) nextNodes.push(next);
      }
      nextNodes.sort((a, b) => {
        const nodeA = byId.get(a);
        const nodeB = byId.get(b);
        const orderA = nodeA?.order ?? 0;
        const orderB = nodeB?.order ?? 0;
        return orderA - orderB;
      });
      localQueue.push(...nextNodes);
    }
    if (ordered.length !== toCopy.size) {
      const remaining = new Set(Array.from(toCopy).filter((id) => !ordered.includes(id)));
      const depth = /* @__PURE__ */ new Map();
      const getDepth = (id) => {
        if (depth.has(id)) return depth.get(id);
        const n = byId.get(id);
        if (!n || !n.parentId || !toCopy.has(n.parentId)) {
          depth.set(id, 0);
          return 0;
        }
        const d = getDepth(n.parentId) + 1;
        depth.set(id, d);
        return d;
      };
      const rest = Array.from(remaining).sort((a, b) => getDepth(a) - getDepth(b));
      return [...ordered, ...rest];
    }
    return ordered;
  };
  const nodesToCreate = buildCreationOrder();
  const createdNodes = [];
  const shouldCloneExternalParents = cloneExternalParents === true;
  const resolvedExternalParents = /* @__PURE__ */ new Map();
  const buildCloneData = (oldNode, newId, newParentId) => ({
    id: newId,
    treeId: oldNode.treeId,
    type: oldNode.type,
    subType: oldNode.subType,
    fieldType: oldNode.fieldType,
    label: normalizeLabelWithSuffix(oldNode.label) ?? oldNode.label,
    description: oldNode.description,
    parentId: newParentId,
    order: oldNode.order,
    isVisible: oldNode.isVisible,
    isActive: oldNode.isActive,
    isRequired: oldNode.isRequired,
    isMultiple: oldNode.isMultiple,
    hasData: oldNode.hasData,
    hasFormula: oldNode.hasFormula,
    hasCondition: oldNode.hasCondition,
    hasTable: oldNode.hasTable,
    hasAPI: oldNode.hasAPI,
    hasLink: oldNode.hasLink,
    hasMarkers: oldNode.hasMarkers,
    // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬ß FIX: Copier les propri√É∆í√Ç¬©t√É∆í√Ç¬©s data_* pour h√É∆í√Ç¬©riter de l'unit√É∆í√Ç¬© et de la pr√É∆í√Ç¬©cision
    data_unit: oldNode.data_unit,
    data_precision: oldNode.data_precision,
    data_displayFormat: oldNode.data_displayFormat,
    data_exposedKey: oldNode.data_exposedKey,
    data_visibleToUser: oldNode.data_visibleToUser,
    defaultValue: oldNode.defaultValue,
    calculatedValue: oldNode.calculatedValue,
    appearance_size: oldNode.appearance_size,
    appearance_variant: oldNode.appearance_variant,
    appearance_width: oldNode.appearance_width,
    text_placeholder: oldNode.text_placeholder,
    text_maxLength: oldNode.text_maxLength,
    text_minLength: oldNode.text_minLength,
    text_mask: oldNode.text_mask,
    text_regex: oldNode.text_regex,
    text_rows: oldNode.text_rows,
    text_helpTooltipType: oldNode.text_helpTooltipType,
    text_helpTooltipText: oldNode.text_helpTooltipText,
    text_helpTooltipImage: oldNode.text_helpTooltipImage,
    number_min: oldNode.number_min,
    number_max: oldNode.number_max,
    number_step: oldNode.number_step,
    number_decimals: oldNode.number_decimals,
    number_prefix: oldNode.number_prefix,
    number_suffix: oldNode.number_suffix,
    number_unit: oldNode.number_unit,
    number_defaultValue: oldNode.number_defaultValue,
    select_multiple: oldNode.select_multiple,
    select_searchable: oldNode.select_searchable,
    select_allowClear: oldNode.select_allowClear,
    select_source: oldNode.select_source ? (() => {
      const sourceValue = oldNode.select_source;
      if (sourceValue.startsWith("@table.")) {
        const tableId = sourceValue.substring(7);
        const newTableId = idMap.get(tableId);
        if (newTableId) {
          return `@table.${newTableId}`;
        }
      }
      return sourceValue;
    })() : oldNode.select_source,
    select_defaultValue: oldNode.select_defaultValue,
    select_options: oldNode.select_options ? (() => {
      try {
        const str = JSON.stringify(oldNode.select_options);
        let replaced = str.replace(/([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/gi, (uuid) => idMap.get(uuid) || uuid);
        replaced = replaced.replace(/(node_[a-z0-9_-]+)/gi, (id) => idMap.get(id) || id);
        return JSON.parse(replaced);
      } catch {
        return oldNode.select_options;
      }
    })() : oldNode.select_options,
    bool_trueLabel: oldNode.bool_trueLabel,
    bool_falseLabel: oldNode.bool_falseLabel,
    bool_defaultValue: oldNode.bool_defaultValue,
    date_format: oldNode.date_format,
    date_minDate: oldNode.date_minDate,
    date_maxDate: oldNode.date_maxDate,
    date_showTime: oldNode.date_showTime,
    image_maxSize: oldNode.image_maxSize,
    image_ratio: oldNode.image_ratio,
    image_crop: oldNode.image_crop,
    image_thumbnails: oldNode.image_thumbnails ? (() => {
      try {
        const str = JSON.stringify(oldNode.image_thumbnails);
        let replaced = str.replace(/([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/gi, (uuid) => idMap.get(uuid) || uuid);
        replaced = replaced.replace(/(node_[a-z0-9_-]+)/gi, (id) => idMap.get(id) || id);
        return JSON.parse(replaced);
      } catch {
        return oldNode.image_thumbnails;
      }
    })() : oldNode.image_thumbnails,
    // üì∏ AI MEASURE: Copier la configuration IA Mesure Photo
    aiMeasure_enabled: oldNode.aiMeasure_enabled,
    aiMeasure_autoTrigger: oldNode.aiMeasure_autoTrigger,
    aiMeasure_prompt: oldNode.aiMeasure_prompt,
    aiMeasure_keys: oldNode.aiMeasure_keys,
    link_activeId: oldNode.link_activeId,
    link_carryContext: oldNode.link_carryContext,
    link_mode: oldNode.link_mode,
    link_name: oldNode.link_name,
    link_params: oldNode.link_params ? (() => {
      try {
        const str = JSON.stringify(oldNode.link_params);
        let replaced = str.replace(/([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/gi, (uuid) => idMap.get(uuid) || uuid);
        replaced = replaced.replace(/(node_[a-z0-9_-]+)/gi, (id) => idMap.get(id) || id);
        return JSON.parse(replaced);
      } catch {
        return oldNode.link_params;
      }
    })() : oldNode.link_params,
    link_targetNodeId: oldNode.link_targetNodeId && idMap.has(oldNode.link_targetNodeId) ? idMap.get(oldNode.link_targetNodeId) : oldNode.link_targetNodeId,
    link_targetTreeId: oldNode.link_targetTreeId,
    // IMPORTANT: table_activeId doit √™tre mapp√© via tableIdMap (cr√©√© lors de la copie des tables),
    // pas via un simple suffixe. On le synchronise plus bas apr√®s la copie des tables.
    table_activeId: null,
    table_instances: (() => {
      if (!oldNode.table_instances) {
        return oldNode.table_instances;
      }
      let rawInstances;
      try {
        if (typeof oldNode.table_instances === "string") {
          rawInstances = JSON.parse(oldNode.table_instances);
        } else if (typeof oldNode.table_instances === "object") {
          rawInstances = JSON.parse(JSON.stringify(oldNode.table_instances));
        } else {
          return oldNode.table_instances;
        }
      } catch {
        return oldNode.table_instances;
      }
      const updatedInstances = {};
      for (const [key2, value] of Object.entries(rawInstances)) {
        const hasSuffixRegex = /-\d+$/;
        const newKey = hasSuffixRegex.test(key2) ? key2 : appendSuffix(key2);
        if (value && typeof value === "object") {
          const tableInstanceObj = value;
          const updatedObj = { ...tableInstanceObj };
          if (tableInstanceObj.tableId && typeof tableInstanceObj.tableId === "string") {
            const oldTableId = tableInstanceObj.tableId;
            updatedObj.tableId = hasSuffixRegex.test(oldTableId) ? oldTableId : appendSuffix(oldTableId);
          }
          updatedInstances[newKey] = updatedObj;
        } else {
          updatedInstances[newKey] = value;
        }
      }
      return updatedInstances;
    })(),
    table_name: oldNode.table_name,
    // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬¥ CRITIQUE: Garder TOUJOURS les repeater_templateNodeIds ORIGINAUX (pas de suffixe!)
    // Les templateNodeIds doivent √É∆í√Ç¬™tre les UUIDs purs des templates originaux,
    // JAMAIS les IDs suffix√É∆í√Ç¬©s des copies (-1, -2, etc.)
    // Si on mappe vers les suffix√É∆í√Ç¬©s, la 2e duplication trouvera uuid-A-1 au lieu de uuid-A!
    repeater_templateNodeIds: (() => {
      if (normalizedRepeatContext) return null;
      if (!oldNode.repeater_templateNodeIds) return oldNode.repeater_templateNodeIds;
      return oldNode.repeater_templateNodeIds;
    })(),
    repeater_templateNodeLabels: oldNode.repeater_templateNodeLabels,
    repeater_minItems: oldNode.repeater_minItems,
    repeater_maxItems: oldNode.repeater_maxItems,
    repeater_addButtonLabel: oldNode.repeater_addButtonLabel,
    repeater_buttonSize: oldNode.repeater_buttonSize,
    repeater_buttonWidth: oldNode.repeater_buttonWidth,
    repeater_iconOnly: oldNode.repeater_iconOnly,
    metadata: (() => {
      const origMeta = typeof oldNode.metadata === "object" ? oldNode.metadata : {};
      const newMeta = { ...origMeta, copiedFromNodeId: oldNode.id, copySuffix: metadataCopySuffix };
      if (newMeta.lookup) {
        const suf = `-${suffixNum}`;
        if (newMeta.lookup.rowSourceOption?.sourceField) {
          const sf = newMeta.lookup.rowSourceOption.sourceField;
          if (typeof sf === "string" && !/^\d+$/.test(sf) && !sf.endsWith(suf)) {
            newMeta.lookup.rowSourceOption.sourceField = `${sf}${suf}`;
          }
        }
        if (newMeta.lookup.columnSourceOption?.sourceField) {
          const sf = newMeta.lookup.columnSourceOption.sourceField;
          if (typeof sf === "string" && !/^\d+$/.test(sf) && !sf.endsWith(suf)) {
            newMeta.lookup.columnSourceOption.sourceField = `${sf}${suf}`;
          }
        }
        if (newMeta.lookup.rowSourceOption?.comparisonColumn) {
          const cc = newMeta.lookup.rowSourceOption.comparisonColumn;
          if (typeof cc === "string" && !/^\d+$/.test(cc) && !cc.endsWith(suf)) {
            newMeta.lookup.rowSourceOption.comparisonColumn = `${cc}${suf}`;
          }
        }
        if (newMeta.lookup.columnSourceOption?.comparisonColumn) {
          const cc = newMeta.lookup.columnSourceOption.comparisonColumn;
          if (typeof cc === "string" && !/^\d+$/.test(cc) && !cc.endsWith(suf)) {
            newMeta.lookup.columnSourceOption.comparisonColumn = `${cc}${suf}`;
          }
        }
        if (newMeta.lookup.displayRow) {
          if (Array.isArray(newMeta.lookup.displayRow)) {
            newMeta.lookup.displayRow = newMeta.lookup.displayRow.map(
              (r) => r && !/^\d+$/.test(r) && !r.endsWith(suf) ? `${r}${suf}` : r
            );
          } else if (typeof newMeta.lookup.displayRow === "string") {
            const dr = newMeta.lookup.displayRow;
            if (!/^\d+$/.test(dr) && !dr.endsWith(suf)) {
              newMeta.lookup.displayRow = `${dr}${suf}`;
            }
          }
        }
        if (newMeta.lookup.displayColumn) {
          const col = newMeta.lookup.displayColumn;
          if (Array.isArray(col)) {
            newMeta.lookup.displayColumn = col.map(
              (c) => c && !/^\d+$/.test(c) && !c.endsWith(suf) ? `${c}${suf}` : c
            );
          } else if (typeof col === "string" && !/^\d+$/.test(col) && !col.endsWith(suf)) {
            newMeta.lookup.displayColumn = `${col}${suf}`;
          }
        }
      }
      if (normalizedRepeatContext && newMeta.repeater) {
        delete newMeta.repeater;
      }
      if (newMeta.triggerNodeIds && Array.isArray(newMeta.triggerNodeIds)) {
        const oldTriggers = [...newMeta.triggerNodeIds];
        newMeta.triggerNodeIds = newMeta.triggerNodeIds.map((triggerId) => {
          const cleanId = triggerId.replace(/^@value\./, "").replace(/^{/, "").replace(/}$/, "");
          if (idMap.has(cleanId)) {
            const newTriggerId = idMap.get(cleanId);
            if (triggerId.startsWith("@value.")) {
              return `@value.${newTriggerId}`;
            } else if (triggerId.startsWith("{")) {
              return `{${newTriggerId}}`;
            }
            return newTriggerId;
          }
          const suffixedId = appendSuffix(cleanId);
          if (triggerId.startsWith("@value.")) {
            return `@value.${suffixedId}`;
          } else if (triggerId.startsWith("{")) {
            return `{${suffixedId}}`;
          }
          return suffixedId;
        });
        console.log(`\u{1F3AF} [DEEP-COPY] Suffixe triggers pour ${oldNode.label} (${newId}):`, {
          oldTriggers,
          newTriggers: newMeta.triggerNodeIds
        });
      }
      return newMeta;
    })(),
    // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬ß TRAITER LE fieldConfig: suffix les r√É∆í√Ç¬©f√É∆í√Ç¬©rences aux nodes
    fieldConfig: (() => {
      if (!oldNode.fieldConfig) {
        return oldNode.fieldConfig;
      }
      try {
        const str = JSON.stringify(oldNode.fieldConfig);
        let replaced = str.replace(/([a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12})/gi, (uuid) => {
          const mapped = idMap.get(uuid);
          if (mapped) {
            return mapped;
          }
          if (!uuid.match(/-\d+$/)) {
            return `${uuid}-${suffixNum}`;
          }
          return uuid;
        });
        return JSON.parse(replaced);
      } catch {
        console.warn("[fieldConfig] Erreur traitement fieldConfig, copie tel quel");
        return oldNode.fieldConfig;
      }
    })(),
    isSharedReference: preserveSharedReferences ? oldNode.isSharedReference : false,
    sharedReferenceId: preserveSharedReferences ? oldNode.sharedReferenceId : null,
    sharedReferenceIds: preserveSharedReferences ? oldNode.sharedReferenceIds : [],
    sharedReferenceName: preserveSharedReferences ? oldNode.sharedReferenceName : null,
    sharedReferenceDescription: preserveSharedReferences ? oldNode.sharedReferenceDescription : null,
    linkedFormulaIds: Array.isArray(oldNode.linkedFormulaIds) ? oldNode.linkedFormulaIds : [],
    linkedConditionIds: Array.isArray(oldNode.linkedConditionIds) ? oldNode.linkedConditionIds : [],
    // CRITIQUE: Ne copier linkedTableIds QUE si le noeud n'est PAS un INPUT pur
    // Un INPUT (fieldType = NULL) ne doit JAMAIS avoir de linkedTableIds !
    linkedTableIds: Array.isArray(oldNode.linkedTableIds) && oldNode.fieldType !== null && oldNode.fieldType !== "" && oldNode.fieldType !== void 0 ? oldNode.linkedTableIds.map((id) => ensureSuffix(id) || id) : [],
    // Suffixer aussi les linkedVariableIds pour que les copies pointent vers les variables copiees
    linkedVariableIds: Array.isArray(oldNode.linkedVariableIds) ? oldNode.linkedVariableIds.map((id) => ensureSuffix(id) || id) : [],
    updatedAt: /* @__PURE__ */ new Date()
  });
  const ensureExternalParentChain = async (parentId) => {
    if (!parentId) {
      return parentId ?? null;
    }
    const cloneParentNodeChain = async (originalParentId, clonedParentId) => {
      const parentNode = byId.get(originalParentId);
      if (!parentNode) {
        resolvedExternalParents.set(originalParentId, originalParentId ?? null);
        return originalParentId ?? null;
      }
      if (!shouldCloneExternalParents && parentNode.type === "section") {
        resolvedExternalParents.set(originalParentId, originalParentId ?? null);
        return originalParentId ?? null;
      }
      const parentOfParentId = await ensureExternalParentChain(parentNode.parentId ?? null);
      const parentCloneData = buildCloneData(parentNode, clonedParentId, parentOfParentId);
      await prisma51.treeBranchLeafNode.create({ data: parentCloneData });
      createdNodes.push({ oldId: originalParentId, newId: clonedParentId });
      existingNodeIds.add(clonedParentId);
      resolvedExternalParents.set(originalParentId, clonedParentId);
      idMap.set(originalParentId, clonedParentId);
      return clonedParentId;
    };
    if (!shouldCloneExternalParents) {
      const suffixedParentId2 = buildParentSuffix(parentId);
      if (suffixedParentId2 && existingNodeIds.has(suffixedParentId2)) {
        resolvedExternalParents.set(parentId, suffixedParentId2);
        idMap.set(parentId, suffixedParentId2);
        return suffixedParentId2;
      }
      const resolvedId = parentId ?? null;
      resolvedExternalParents.set(parentId, resolvedId);
      return resolvedId;
    }
    if (resolvedExternalParents.has(parentId)) {
      const resolvedId = resolvedExternalParents.get(parentId);
      if (resolvedId) {
        idMap.set(parentId, resolvedId);
      }
      return resolvedId;
    }
    if (toCopy.has(parentId)) {
      const mappedId = idMap.get(parentId);
      resolvedExternalParents.set(parentId, mappedId);
      idMap.set(parentId, mappedId);
      return mappedId;
    }
    const suffixedParentId = buildParentSuffix(parentId);
    if (!suffixedParentId) {
      resolvedExternalParents.set(parentId, parentId ?? null);
      return parentId ?? null;
    }
    if (existingNodeIds.has(suffixedParentId)) {
      resolvedExternalParents.set(parentId, suffixedParentId);
      idMap.set(parentId, suffixedParentId);
      return suffixedParentId;
    }
    return cloneParentNodeChain(parentId, suffixedParentId);
  };
  const resolveParentId = async (oldNode, isRoot) => {
    if (oldNode.parentId && toCopy.has(oldNode.parentId)) {
      return idMap.get(oldNode.parentId);
    }
    if (isRoot && targetParentId !== void 0) {
      return targetParentId ?? null;
    }
    return ensureExternalParentChain(oldNode.parentId);
  };
  for (const oldId of nodesToCreate) {
    const oldNode = byId.get(oldId);
    const newId = idMap.get(oldId);
    const isRoot = oldId === source.id;
    const newParentId = await resolveParentId(oldNode, isRoot);
    const cloneData = buildCloneData(oldNode, newId, newParentId);
    await prisma51.treeBranchLeafNode.create({ data: cloneData });
    createdNodes.push({ oldId, newId, newParentId });
    existingNodeIds.add(newId);
    try {
      const tableLookupService = new TableLookupDuplicationService();
      await tableLookupService.duplicateTableLookupSystem(prisma51, oldId, {
        suffixToken,
        copiedNodeId: newId
      });
    } catch (lookupError) {
      console.warn(`[DEEP-COPY] Warning duplicating table lookup for ${oldId} -> ${newId}:`, lookupError.message);
    }
    if (oldNode.aiMeasure_keys && Array.isArray(oldNode.aiMeasure_keys) && oldNode.aiMeasure_keys.length > 0) {
      try {
        console.log(`[DEEP-COPY] \u{1F4D0} Duplication des champs AI Measure pour ${newId}`);
        const mappings = oldNode.aiMeasure_keys;
        for (const mapping of mappings) {
          if (!mapping.targetRef) continue;
          const originalTargetField = await prisma51.treeBranchLeafNode.findUnique({
            where: { id: mapping.targetRef }
          });
          if (!originalTargetField) {
            console.warn(`[DEEP-COPY] \u26A0\uFE0F Champ cible ${mapping.targetRef} introuvable pour ${mapping.key}`);
            continue;
          }
          const duplicatedTargetId = `${mapping.targetRef}${suffixToken}`;
          const existingDuplicatedField = await prisma51.treeBranchLeafNode.findUnique({
            where: { id: duplicatedTargetId }
          });
          if (existingDuplicatedField) {
            console.log(`[DEEP-COPY] \u2713 Champ cible ${duplicatedTargetId} existe d\xE9j\xE0`);
            continue;
          }
          const duplicatedFieldData = {
            id: duplicatedTargetId,
            treeId: originalTargetField.treeId,
            type: originalTargetField.type,
            subType: originalTargetField.subType,
            fieldType: originalTargetField.fieldType,
            label: `${originalTargetField.label}${suffixToken}`,
            description: originalTargetField.description,
            parentId: originalTargetField.parentId,
            order: originalTargetField.order,
            isVisible: originalTargetField.isVisible,
            isActive: originalTargetField.isActive,
            isRequired: originalTargetField.isRequired,
            isMultiple: originalTargetField.isMultiple,
            hasData: originalTargetField.hasData,
            hasFormula: originalTargetField.hasFormula,
            hasCondition: originalTargetField.hasCondition,
            hasTable: originalTargetField.hasTable,
            hasAPI: originalTargetField.hasAPI,
            hasLink: originalTargetField.hasLink,
            hasMarkers: originalTargetField.hasMarkers,
            // üìè CRITIQUE: Copier TOUTES les propri√©t√©s de donn√©es (unit√©, pr√©cision, format, etc.)
            data_unit: originalTargetField.data_unit,
            data_precision: originalTargetField.data_precision,
            data_displayFormat: originalTargetField.data_displayFormat,
            data_exposedKey: originalTargetField.data_exposedKey,
            data_visibleToUser: originalTargetField.data_visibleToUser,
            defaultValue: originalTargetField.defaultValue,
            calculatedValue: null,
            appearance_size: originalTargetField.appearance_size,
            appearance_variant: originalTargetField.appearance_variant,
            appearance_width: originalTargetField.appearance_width,
            text_placeholder: originalTargetField.text_placeholder,
            text_maxLength: originalTargetField.text_maxLength,
            text_minLength: originalTargetField.text_minLength,
            text_mask: originalTargetField.text_mask,
            text_regex: originalTargetField.text_regex,
            text_rows: originalTargetField.text_rows,
            text_helpTooltipType: originalTargetField.text_helpTooltipType,
            text_helpTooltipText: originalTargetField.text_helpTooltipText,
            text_helpTooltipImage: originalTargetField.text_helpTooltipImage,
            number_min: originalTargetField.number_min,
            number_max: originalTargetField.number_max,
            number_step: originalTargetField.number_step,
            number_decimals: originalTargetField.number_decimals,
            number_prefix: originalTargetField.number_prefix,
            number_suffix: originalTargetField.number_suffix,
            number_unit: originalTargetField.number_unit,
            number_defaultValue: originalTargetField.number_defaultValue,
            metadata: {
              copiedFromNodeId: originalTargetField.id,
              copySuffix: metadataCopySuffix,
              duplicatedFromAIMeasure: true
            }
          };
          await prisma51.treeBranchLeafNode.create({ data: duplicatedFieldData });
          console.log(`[DEEP-COPY] \u2705 Champ AI Measure cr\xE9\xE9: ${duplicatedTargetId} (${mapping.key})`);
        }
      } catch (aiMeasureError) {
        console.error(`[DEEP-COPY] \u274C Erreur duplication champs AI Measure:`, aiMeasureError);
      }
    }
    if (Array.isArray(cloneData.linkedTableIds) && cloneData.linkedTableIds.length > 0) {
      displayNodeIds.push(newId);
    }
  }
  for (const { oldId, newId, newParentId } of createdNodes) {
    const oldNode = byId.get(oldId);
    const linkedFormulaIdOrder = Array.isArray(oldNode.linkedFormulaIds) ? oldNode.linkedFormulaIds : [];
    const formulas = await prisma51.treeBranchLeafNodeFormula.findMany({ where: { nodeId: oldId } });
    const formulaMap = new Map(formulas.map((f) => [f.id, f]));
    const sortedFormulas = [];
    const validLinkedIds = [];
    for (const formulaId of linkedFormulaIdOrder) {
      const formula = formulaMap.get(formulaId);
      if (formula) {
        sortedFormulas.push(formula);
        validLinkedIds.push(formulaId);
        formulaMap.delete(formulaId);
      } else {
      }
    }
    const unlinkedFormulas = Array.from(formulaMap.values());
    const allFormulas = [...sortedFormulas, ...unlinkedFormulas];
    const newLinkedFormulaIds = [];
    let firstNewFormulaId = null;
    for (const f of allFormulas) {
      try {
        const formulaResult = await copyFormulaCapacity(
          f.id,
          newId,
          suffixNum,
          prisma51,
          {
            formulaIdMap,
            nodeIdMap: idMap
          }
        );
        if (formulaResult.success) {
          const newFormulaId = formulaResult.newFormulaId;
          formulaIdMap.set(f.id, newFormulaId);
          if (!firstNewFormulaId) firstNewFormulaId = newFormulaId;
          if (validLinkedIds.includes(f.id)) {
            newLinkedFormulaIds.push(newFormulaId);
          }
          if (normalizedRepeatContext) {
            const referencedNodeIds = Array.from(extractNodeIdsFromTokens(formulaResult.tokens || f.tokens));
            logCapacityEvent({
              ownerNodeId: newId,
              capacityId: newFormulaId,
              capacityType: "formula",
              referencedNodeIds,
              context: normalizedRepeatContext
            });
          }
        } else {
          console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 Erreur copie formule centralis\xC3\u0192\xC2\xA9e: ${f.id}`);
        }
      } catch (error) {
        console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 Exception copie formule ${f.id}:`, error);
      }
    }
    if (newLinkedFormulaIds.length > 0) {
      try {
        await addToNodeLinkedField6(prisma51, newId, "linkedFormulaIds", newLinkedFormulaIds);
      } catch (e) {
        console.warn("[TreeBranchLeaf API] Warning updating linkedFormulaIds for node:", e.message);
      }
    }
    const conditions = await prisma51.treeBranchLeafNodeCondition.findMany({ where: { nodeId: oldId } });
    const linkedConditionIdOrder = Array.isArray(oldNode.linkedConditionIds) ? oldNode.linkedConditionIds : [];
    const copiedNodeIds = new Set(idMap.values());
    const conditionMap = new Map(conditions.map((c) => [c.id, c]));
    const sortedConditions = [];
    const validLinkedConditionIds = [];
    for (const conditionId of linkedConditionIdOrder) {
      const condition = conditionMap.get(conditionId);
      if (condition) {
        sortedConditions.push(condition);
        validLinkedConditionIds.push(conditionId);
        conditionMap.delete(conditionId);
      } else {
      }
    }
    const unlinkedConditions = Array.from(conditionMap.values());
    const allConditions = [...sortedConditions, ...unlinkedConditions];
    const newLinkedConditionIds = [];
    let firstNewConditionId = null;
    for (const c of allConditions) {
      const newConditionId = appendSuffix(c.id);
      if (!firstNewConditionId) firstNewConditionId = newConditionId;
      conditionIdMap.set(c.id, newConditionId);
      const newSet = replaceIdsInConditionSet(c.conditionSet, idMap, formulaIdMap, conditionIdMap);
      const existingCondition = await prisma51.treeBranchLeafNodeCondition.findUnique({
        where: { id: newConditionId }
      });
      if (existingCondition) {
        if (validLinkedConditionIds.includes(c.id)) {
          newLinkedConditionIds.push(newConditionId);
        }
        continue;
      }
      await prisma51.treeBranchLeafNodeCondition.create({
        data: {
          id: newConditionId,
          nodeId: newId,
          organizationId: c.organizationId,
          name: c.name ? `${c.name}${computedLabelSuffix}` : c.name,
          conditionSet: newSet,
          description: c.description,
          isDefault: c.isDefault,
          order: c.order,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
      if (validLinkedConditionIds.includes(c.id)) {
        newLinkedConditionIds.push(newConditionId);
      }
      if (normalizedRepeatContext) {
        const referencedNodeIds = Array.from(extractNodeIdsFromConditionSet(newSet));
        logCapacityEvent({
          ownerNodeId: newId,
          capacityId: newConditionId,
          capacityType: "condition",
          referencedNodeIds,
          context: normalizedRepeatContext
        });
      }
      try {
        const refs = Array.from(extractNodeIdsFromConditionSet(newSet));
        for (const refId of refs) {
          const normalizedRefId = normalizeRefId(refId);
          if (normalizedRepeatContext && !copiedNodeIds.has(normalizedRefId)) {
            continue;
          }
          await addToNodeLinkedField6(prisma51, normalizedRefId, "linkedConditionIds", [newConditionId]);
        }
      } catch (e) {
        console.warn("[TreeBranchLeaf API] Warning updating linkedConditionIds during deep copy:", e.message);
      }
    }
    if (newLinkedConditionIds.length > 0) {
      try {
        await addToNodeLinkedField6(prisma51, newId, "linkedConditionIds", newLinkedConditionIds);
      } catch (e) {
        console.warn("[TreeBranchLeaf API] Warning updating linkedConditionIds for node:", e.message);
      }
    }
    const shouldHaveFormula = oldNode.hasFormula === true || formulas.length > 0;
    const shouldHaveCondition = oldNode.hasCondition === true || conditions.length > 0;
    const updateCaps = {};
    if (shouldHaveFormula) {
      updateCaps.hasFormula = true;
      const mappedActive = oldNode.formula_activeId ? formulaIdMap.get(oldNode.formula_activeId) || null : null;
      updateCaps.formula_activeId = mappedActive || firstNewFormulaId || null;
    }
    if (shouldHaveCondition) {
      updateCaps.hasCondition = true;
      const mappedActive = oldNode.condition_activeId ? conditionIdMap.get(oldNode.condition_activeId) || null : null;
      updateCaps.condition_activeId = mappedActive || firstNewConditionId || null;
    }
    if (Object.keys(updateCaps).length > 0) {
      try {
        await prisma51.treeBranchLeafNode.update({
          where: { id: newId },
          data: updateCaps
        });
      } catch (e) {
        console.warn("[DEEP-COPY]  Erreur mise \b\b\b\b\b\b\b jour flags/activeIds:", e.message);
      }
    }
    const tables = await prisma51.treeBranchLeafNodeTable.findMany({
      where: { nodeId: oldId },
      include: { tableColumns: true, tableRows: true }
    });
    const additionalTableIds = [];
    if (source.table_activeId && !tables.some((t) => t.id === source.table_activeId)) {
      additionalTableIds.push(source.table_activeId);
    }
    if (Array.isArray(oldNode.linkedTableIds)) {
      for (const linkedTableId of oldNode.linkedTableIds) {
        if (!tables.some((t) => t.id === linkedTableId) && !additionalTableIds.includes(linkedTableId)) {
          additionalTableIds.push(linkedTableId);
        }
      }
    }
    if (source.table_activeId && !tables.some((t) => t.id === source.table_activeId)) {
      additionalTableIds.push(source.table_activeId);
    }
    const additionalTables = additionalTableIds.length > 0 ? await prisma51.treeBranchLeafNodeTable.findMany({
      where: { id: { in: additionalTableIds } },
      include: { tableColumns: true, tableRows: true }
    }) : [];
    const linkedTableIdOrder = Array.isArray(oldNode.linkedTableIds) ? oldNode.linkedTableIds : [];
    const sortedTables = linkedTableIdOrder.map((id) => [...tables, ...additionalTables].find((t) => t.id === id)).filter((t) => t !== void 0);
    const unlinkedTables = [...tables, ...additionalTables].filter((t) => !linkedTableIdOrder.includes(t.id));
    const allTablesToCopy = [...sortedTables, ...unlinkedTables];
    if (additionalTables.length > 0) {
    }
    const newLinkedTableIds = [];
    for (const t of allTablesToCopy) {
      const newTableId = appendSuffix(t.id);
      tableIdMap2.set(t.id, newTableId);
      const existingTable = await prisma51.treeBranchLeafNodeTable.findUnique({
        where: { id: newTableId }
      });
      if (existingTable) {
        continue;
      }
      if (linkedTableIdOrder.includes(t.id)) {
        newLinkedTableIds.push(newTableId);
      }
      const tableOwnerNodeId = t.nodeId === oldId ? newId : appendSuffix(t.nodeId);
      let nodeExists = await prisma51.treeBranchLeafNode.findUnique({
        where: { id: tableOwnerNodeId },
        select: { id: true }
      });
      if (!nodeExists && tableOwnerNodeId !== newId) {
        console.log(
          `[DEEP-COPY] Creating stub node "${tableOwnerNodeId}" for linked table owner`
        );
        const originalOwnerNode = await prisma51.treeBranchLeafNode.findUnique({
          where: { id: t.nodeId },
          select: {
            type: true,
            label: true,
            treeId: true,
            parentId: true
          }
        });
        if (originalOwnerNode) {
          try {
            const createdNode = await prisma51.treeBranchLeafNode.create({
              data: {
                id: tableOwnerNodeId,
                type: originalOwnerNode.type,
                label: originalOwnerNode.label ? `${originalOwnerNode.label}-1` : "Stub",
                treeId: originalOwnerNode.treeId,
                parentId: originalOwnerNode.parentId ? appendSuffix(originalOwnerNode.parentId) : null,
                order: 0,
                createdAt: /* @__PURE__ */ new Date(),
                updatedAt: /* @__PURE__ */ new Date()
              }
            });
            nodeExists = createdNode;
            console.log(`[DEEP-COPY] \u2705 Stub node created: ${tableOwnerNodeId}`);
          } catch (err) {
            console.error(`[DEEP-COPY] \u274C Failed to create stub node: ${err.message}`);
            throw err;
          }
        }
      }
      if (!nodeExists) {
        console.warn(
          `[DEEP-COPY] \u26A0\uFE0F Cannot create table "${t.name}": owner node "${tableOwnerNodeId}" doesn't exist. Original nodeId: "${t.nodeId}", oldId: "${oldId}", newId: "${newId}"`
        );
        return;
      }
      await prisma51.treeBranchLeafNodeTable.create({
        data: {
          id: newTableId,
          nodeId: tableOwnerNodeId,
          organizationId: t.organizationId,
          name: t.name ? `${t.name}${computedLabelSuffix}` : t.name,
          description: t.description,
          type: t.type,
          rowCount: t.rowCount,
          columnCount: t.columnCount,
          // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬ß TRAITER LE meta: suffix les r√É∆í√Ç¬©f√É∆í√Ç¬©rences aux nodes ET comparisonColumn
          meta: (() => {
            if (!t.meta) {
              return t.meta;
            }
            try {
              const metaObj = typeof t.meta === "string" ? JSON.parse(t.meta) : JSON.parse(JSON.stringify(t.meta));
              if (metaObj?.lookup?.selectors?.columnFieldId && !metaObj.lookup.selectors.columnFieldId.endsWith(`-${copySuffixNum}`)) {
                metaObj.lookup.selectors.columnFieldId = `${metaObj.lookup.selectors.columnFieldId}-${copySuffixNum}`;
              }
              if (metaObj?.lookup?.selectors?.rowFieldId && !metaObj.lookup.selectors.rowFieldId.endsWith(`-${copySuffixNum}`)) {
                metaObj.lookup.selectors.rowFieldId = `${metaObj.lookup.selectors.rowFieldId}-${copySuffixNum}`;
              }
              if (metaObj?.lookup?.rowSourceOption?.sourceField && !metaObj.lookup.rowSourceOption.sourceField.endsWith(`-${copySuffixNum}`)) {
                metaObj.lookup.rowSourceOption.sourceField = `${metaObj.lookup.rowSourceOption.sourceField}-${copySuffixNum}`;
              }
              if (metaObj?.lookup?.columnSourceOption?.sourceField && !metaObj.lookup.columnSourceOption.sourceField.endsWith(`-${copySuffixNum}`)) {
                metaObj.lookup.columnSourceOption.sourceField = `${metaObj.lookup.columnSourceOption.sourceField}-${copySuffixNum}`;
              }
              if (metaObj?.lookup?.displayColumn) {
                const originalDisplay = JSON.stringify(metaObj.lookup.displayColumn);
                if (Array.isArray(metaObj.lookup.displayColumn)) {
                  metaObj.lookup.displayColumn = metaObj.lookup.displayColumn.map((col) => {
                    if (typeof col === "string" && !col.endsWith(`-${copySuffixNum}`)) {
                      return `${col}-${copySuffixNum}`;
                    }
                    return col;
                  });
                } else if (typeof metaObj.lookup.displayColumn === "string" && !metaObj.lookup.displayColumn.endsWith(`-${copySuffixNum}`)) {
                  metaObj.lookup.displayColumn = `${metaObj.lookup.displayColumn}-${copySuffixNum}`;
                }
                console.log(`\u{1F527} [DEEP-COPY] displayColumn: ${originalDisplay} \u2192 ${JSON.stringify(metaObj.lookup.displayColumn)}`);
              }
              if (metaObj?.lookup?.columnSourceOption?.comparisonColumn && !metaObj.lookup.columnSourceOption.comparisonColumn.endsWith(`-${copySuffixNum}`)) {
                metaObj.lookup.columnSourceOption.comparisonColumn = `${metaObj.lookup.columnSourceOption.comparisonColumn}-${copySuffixNum}`;
              }
              if (metaObj?.lookup?.displayRow && typeof metaObj.lookup.displayRow === "string" && !metaObj.lookup.displayRow.endsWith(`-${copySuffixNum}`)) {
                metaObj.lookup.displayRow = `${metaObj.lookup.displayRow}-${copySuffixNum}`;
              }
              if (metaObj?.data?.columns && Array.isArray(metaObj.data.columns)) {
                metaObj.data.columns = metaObj.data.columns.map((col) => {
                  if (typeof col === "string" && !col.endsWith(`-${copySuffixNum}`)) {
                    return `${col}-${copySuffixNum}`;
                  }
                  return col;
                });
              }
              return metaObj;
            } catch (err) {
              console.warn("[table.meta] Erreur traitement meta, copie tel quel:", err);
              return t.meta;
            }
          })(),
          isDefault: t.isDefault,
          order: t.order,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          lookupDisplayColumns: t.lookupDisplayColumns,
          lookupSelectColumn: t.lookupSelectColumn,
          tableColumns: {
            create: t.tableColumns.map((col) => ({
              id: appendSuffix(col.id),
              columnIndex: col.columnIndex,
              // üéØ FIX 24/01/2026: SUFFIXER les noms de colonnes !
              // Quand on duplique une table avec des champs, les colonnes prennent aussi le suffix
              // Ex: "Puissance" devient "Puissance-1" dans la table dupliqu√©e
              name: `${col.name}-${copySuffixNum}`,
              type: col.type,
              width: col.width,
              format: col.format,
              metadata: col.metadata
            }))
          },
          tableRows: {
            create: t.tableRows.map((row) => ({
              id: appendSuffix(row.id),
              rowIndex: row.rowIndex,
              cells: row.cells
            }))
          }
        }
      });
      if (normalizedRepeatContext) {
        logCapacityEvent({
          ownerNodeId: newId,
          capacityId: newTableId,
          capacityType: "table",
          referencedNodeIds: void 0,
          context: normalizedRepeatContext
        });
      }
    }
    if (newLinkedTableIds.length > 0) {
      try {
        await addToNodeLinkedField6(prisma51, newId, "linkedTableIds", newLinkedTableIds);
      } catch (e) {
        console.warn("[TreeBranchLeaf API] Warning updating linkedTableIds for node:", e.message);
      }
    }
    const shouldHaveTable = oldNode.hasTable === true || allTablesToCopy.length > 0;
    if (shouldHaveTable) {
      const mappedActiveTableId = oldNode.table_activeId ? tableIdMap2.get(oldNode.table_activeId) || null : null;
      const firstNewTableId = allTablesToCopy.length > 0 ? tableIdMap2.get(allTablesToCopy[0].id) || null : null;
      try {
        await prisma51.treeBranchLeafNode.update({
          where: { id: newId },
          data: {
            hasTable: true,
            table_activeId: mappedActiveTableId || firstNewTableId || (newLinkedTableIds[0] ?? null)
          }
        });
      } catch (e) {
        console.warn("[DEEP-COPY] Erreur mise \xE0 jour hasTable/table_activeId:", e.message);
      }
    }
    const originalSelectConfig = await prisma51.treeBranchLeafSelectConfig.findUnique({
      where: { nodeId: oldId }
    });
    if (originalSelectConfig) {
      const existingCopyConfig = await prisma51.treeBranchLeafSelectConfig.findUnique({
        where: { nodeId: newId }
      });
      if (!existingCopyConfig) {
        let newTableReference = null;
        const shouldSuffixColumns = true;
        if (originalSelectConfig.tableReference) {
          const tableWasCopied2 = tableIdMap2.has(originalSelectConfig.tableReference);
          console.log(`[DEEP-COPY SelectConfig] nodeId=${oldId} \u2192 tableReference=${originalSelectConfig.tableReference}, tableWasCopied=${tableWasCopied2}, tableIdMap.size=${tableIdMap2.size}`);
          if (tableWasCopied2) {
            newTableReference = tableIdMap2.get(originalSelectConfig.tableReference);
            console.log(`[DEEP-COPY SelectConfig] \u2705 Table copi\xE9e, utilisation de newTableReference=${newTableReference}`);
          } else {
            newTableReference = originalSelectConfig.tableReference;
            console.log(`[DEEP-COPY SelectConfig] \u26A0\uFE0F Table partag\xE9e, conservation de tableReference original`);
          }
        }
        try {
          const copiedSelectConfigId = appendSuffix(originalSelectConfig.id);
          await prisma51.treeBranchLeafSelectConfig.create({
            data: {
              id: copiedSelectConfigId,
              nodeId: newId,
              options: originalSelectConfig.options,
              multiple: originalSelectConfig.multiple,
              searchable: originalSelectConfig.searchable,
              allowCustom: originalSelectConfig.allowCustom,
              maxSelections: originalSelectConfig.maxSelections,
              optionsSource: originalSelectConfig.optionsSource,
              apiEndpoint: originalSelectConfig.apiEndpoint,
              tableReference: newTableReference,
              dependsOnNodeId: originalSelectConfig.dependsOnNodeId ? idMap.get(originalSelectConfig.dependsOnNodeId) || appendSuffix(originalSelectConfig.dependsOnNodeId) : null,
              // Suffixer les colonnes seulement si table locale
              keyColumn: originalSelectConfig.keyColumn ? shouldSuffixColumns ? `${originalSelectConfig.keyColumn}${computedLabelSuffix}` : originalSelectConfig.keyColumn : null,
              valueColumn: originalSelectConfig.valueColumn ? shouldSuffixColumns ? `${originalSelectConfig.valueColumn}${computedLabelSuffix}` : originalSelectConfig.valueColumn : null,
              displayColumn: (() => {
                if (originalSelectConfig.displayColumn) {
                  const computed = shouldSuffixColumns ? `${originalSelectConfig.displayColumn}${computedLabelSuffix}` : originalSelectConfig.displayColumn;
                  return computed;
                }
                return null;
              })(),
              displayRow: originalSelectConfig.displayRow,
              keyRow: originalSelectConfig.keyRow,
              valueRow: originalSelectConfig.valueRow,
              createdAt: /* @__PURE__ */ new Date(),
              updatedAt: /* @__PURE__ */ new Date()
            }
          });
          try {
            if (tableWasCopied && newTableReference) {
              const copiedSelectConfig = await prisma51.treeBranchLeafSelectConfig.findUnique({
                where: { id: copiedSelectConfigId },
                select: { displayColumn: true }
              });
              if (!copiedSelectConfig?.displayColumn) {
                const copiedColumns = await prisma51.treeBranchLeafTableColumn.findMany({
                  where: { tableId: newTableReference },
                  orderBy: { columnIndex: "asc" },
                  select: { name: true }
                });
                const firstColumnName = copiedColumns?.[0]?.name || null;
                if (firstColumnName) {
                  await prisma51.treeBranchLeafSelectConfig.update({
                    where: { id: copiedSelectConfigId },
                    data: { displayColumn: firstColumnName }
                  });
                }
              } else {
                console.log(`[DEEP-COPY SelectConfig] \u2705 displayColumn d\xE9j\xE0 rempli, pas de remplacement`);
              }
            }
          } catch (initDisplayErr) {
            console.warn("[DEEP-COPY SelectConfig] Erreur initialisation displayColumn:", initDisplayErr.message);
          }
        } catch (selectConfigErr) {
        }
      } else {
      }
    }
    const originalNumberConfig = await prisma51.treeBranchLeafNumberConfig.findUnique({
      where: { nodeId: oldId }
    });
    if (originalNumberConfig) {
      const existingCopyNumberConfig = await prisma51.treeBranchLeafNumberConfig.findUnique({
        where: { nodeId: newId }
      });
      if (!existingCopyNumberConfig) {
        try {
          await prisma51.treeBranchLeafNumberConfig.create({
            data: {
              id: appendSuffix(originalNumberConfig.id),
              nodeId: newId,
              min: originalNumberConfig.min,
              max: originalNumberConfig.max,
              decimals: originalNumberConfig.decimals,
              step: originalNumberConfig.step,
              unit: originalNumberConfig.unit,
              prefix: originalNumberConfig.prefix
            }
          });
        } catch (numberConfigErr) {
        }
      }
    }
  }
  const variableCopyCache = /* @__PURE__ */ new Map();
  for (const oldNodeId of toCopy) {
    const newNodeId = idMap.get(oldNodeId);
    const oldNode = byId.get(oldNodeId);
    const newLinkedFormulaIds = oldNode.hasFormula ? (Array.isArray(oldNode.linkedFormulaIds) ? oldNode.linkedFormulaIds : []).map((id) => {
      const mappedId = formulaIdMap.get(id);
      if (mappedId) return mappedId;
      const ensured = ensureSuffix(id);
      return ensured || appendSuffix(id);
    }).filter(Boolean) : [];
    const newLinkedConditionIds = oldNode.hasCondition ? (Array.isArray(oldNode.linkedConditionIds) ? oldNode.linkedConditionIds : []).map((id) => {
      const mappedId = conditionIdMap.get(id);
      if (mappedId) return mappedId;
      const ensured = ensureSuffix(id);
      return ensured || appendSuffix(id);
    }).filter(Boolean) : [];
    const newLinkedTableIds = (Array.isArray(oldNode.linkedTableIds) ? oldNode.linkedTableIds : []).map((id) => {
      const mappedId = tableIdMap2.get(id);
      if (mappedId) return mappedId;
      const ensured = ensureSuffix(id);
      return ensured || appendSuffix(id);
    }).filter(Boolean);
    const sourceLinkedVariableIds = /* @__PURE__ */ new Set();
    if (Array.isArray(oldNode.linkedVariableIds)) {
      for (const rawId of oldNode.linkedVariableIds) {
        if (typeof rawId === "string") {
          const normalized = rawId.trim();
          if (normalized) {
            const baseId = stripNumericSuffix2(normalized);
            sourceLinkedVariableIds.add(baseId || normalized);
          }
        }
      }
    }
    const directVarIds = directVariableIdByNodeId.get(oldNodeId);
    if (directVarIds && directVarIds.size > 0) {
      for (const directVarIdForNode of directVarIds) {
        const baseId = stripNumericSuffix2(directVarIdForNode);
        sourceLinkedVariableIds.add(baseId || directVarIdForNode);
      }
    }
    if (sourceLinkedVariableIds.size > 0) {
      for (const linkedVarId of sourceLinkedVariableIds) {
        const isSharedRef = linkedVarId.startsWith("shared-ref-");
        if (!isSharedRef) {
          try {
            const copyResult = await copyVariableWithCapacities(
              linkedVarId,
              suffixToken,
              newNodeId,
              prisma51,
              {
                formulaIdMap,
                conditionIdMap,
                tableIdMap: tableIdMap2,
                nodeIdMap: idMap,
                variableCopyCache,
                autoCreateDisplayNode: true,
                displayNodeAlreadyCreated: false,
                displayParentId: newNodeId,
                // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬ß FIX: Le parent doit √É∆í√Ç¬™tre le n√É‚Ä¶√¢‚Ç¨≈ìud copi√É∆í√Ç¬© (pas son parent)
                isFromRepeaterDuplication,
                repeatContext: normalizedRepeatContext
              }
            );
            if (copyResult.success && copyResult.displayNodeId) {
              displayNodeIds.push(copyResult.displayNodeId);
            } else {
            }
          } catch (e) {
          }
        } else {
        }
      }
    }
    if (newLinkedFormulaIds.length > 0 || newLinkedConditionIds.length > 0 || newLinkedTableIds.length > 0) {
      try {
        await prisma51.treeBranchLeafNode.update({
          where: { id: newNodeId },
          data: {
            linkedFormulaIds: newLinkedFormulaIds.length > 0 ? { set: newLinkedFormulaIds } : { set: [] },
            linkedConditionIds: newLinkedConditionIds.length > 0 ? { set: newLinkedConditionIds } : { set: [] },
            linkedTableIds: newLinkedTableIds.length > 0 ? { set: newLinkedTableIds } : { set: [] }
            // linkedVariableIds: SUPPRIM√É∆í√¢‚Ç¨¬∞ - ne doit PAS √É∆í√Ç¬™tre mis √É∆í√Ç¬† jour !
          }
        });
      } catch (e) {
        console.warn("[DEEP-COPY] Erreur lors du UPDATE des linked***", e.message);
      }
    }
  }
  const rootNewId = idMap.get(source.id);
  if (displayNodeIds.length > 0) {
    for (const nodeId2 of displayNodeIds) {
      try {
        const copiedNode = await prisma51.treeBranchLeafNode.findUnique({
          where: { id: nodeId2 },
          select: { id: true, label: true, field_label: true, linkedTableIds: true }
        });
        if (!copiedNode || !copiedNode.linkedTableIds || copiedNode.linkedTableIds.length === 0) {
          continue;
        }
        const originalNodeId = nodeId2.replace(/-\d+$/, "");
        const originalVar = await prisma51.treeBranchLeafNodeVariable.findFirst({
          where: { nodeId: originalNodeId }
        });
        if (!originalVar) {
          continue;
        }
        const newVarId = appendSuffix(originalVar.id);
        const newExposedKey = appendSuffix(originalVar.exposedKey);
        const existingVar = await prisma51.treeBranchLeafNodeVariable.findUnique({
          where: { id: newVarId }
        });
        if (existingVar) {
          continue;
        }
        await prisma51.treeBranchLeafNodeVariable.create({
          data: {
            id: newVarId,
            nodeId: nodeId2,
            exposedKey: newExposedKey,
            displayName: copiedNode.label || copiedNode.field_label || originalVar.displayName,
            displayFormat: originalVar.displayFormat,
            precision: originalVar.precision,
            unit: originalVar.unit,
            visibleToUser: originalVar.visibleToUser,
            isReadonly: originalVar.isReadonly,
            defaultValue: originalVar.defaultValue,
            metadata: originalVar.metadata || {},
            fixedValue: originalVar.fixedValue,
            selectedNodeId: originalVar.selectedNodeId,
            sourceRef: applySuffixToSourceRef(originalVar.sourceRef, Number(suffixToken)),
            sourceType: originalVar.sourceType,
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
        await prisma51.treeBranchLeafNode.update({
          where: { id: nodeId2 },
          data: {
            hasData: true,
            data_activeId: newVarId,
            data_exposedKey: newExposedKey,
            data_displayFormat: originalVar.displayFormat,
            data_precision: originalVar.precision,
            data_unit: originalVar.unit,
            data_visibleToUser: originalVar.visibleToUser,
            // linkedVariableIds doit contenir la variable copi√É∆í√Ç¬©e (suffix√É∆í√Ç¬©e)
            linkedVariableIds: { set: [newVarId] }
          }
        });
      } catch (varError) {
        console.error(`[DEEP-COPY] \xC3\xA2\xC2\x9D\xC5\u2019 Erreur cr\xC3\u0192\xC2\xA9ation variable pour ${nodeId2}:`, varError);
      }
    }
  }
  try {
    const newNodeIds = Array.from(idMap.values());
    if (newNodeIds.length > 0) {
      const copiedVariables = await prisma51.treeBranchLeafNodeVariable.findMany({
        where: { nodeId: { in: newNodeIds } },
        select: {
          nodeId: true,
          id: true,
          exposedKey: true,
          displayFormat: true,
          precision: true,
          unit: true,
          visibleToUser: true,
          displayName: true
        }
      });
      for (const variable of copiedVariables) {
        try {
          await prisma51.treeBranchLeafNode.updateMany({
            where: {
              id: variable.nodeId,
              OR: [{ data_activeId: null }, { hasData: false }]
            },
            data: {
              hasData: true,
              data_activeId: variable.id,
              data_exposedKey: variable.exposedKey,
              data_displayFormat: variable.displayFormat,
              data_precision: variable.precision,
              data_unit: variable.unit,
              data_visibleToUser: variable.visibleToUser,
              label: variable.displayName || void 0,
              field_label: variable.displayName || void 0
            }
          });
        } catch (syncError) {
          console.warn("[DEEP-COPY] Post-copy data sync failed for node", variable.nodeId, syncError.message);
        }
      }
    }
  } catch (syncPassThroughError) {
    console.warn("[DEEP-COPY] Post-copy data sync skipped:", syncPassThroughError.message);
  }
  return {
    root: { oldId: source.id, newId: rootNewId },
    idMap: Object.fromEntries(idMap),
    formulaIdMap: Object.fromEntries(formulaIdMap),
    conditionIdMap: Object.fromEntries(conditionIdMap),
    tableIdMap: Object.fromEntries(tableIdMap2),
    displayNodeIds
  };
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/table-routes-new.ts
var import_express56 = require("express");
var import_client5 = require("@prisma/client");
init_database();
var import_crypto18 = require("crypto");
var router55 = (0, import_express56.Router)();
var prisma30 = db;
function toJsonSafe(value) {
  if (value === void 0) return null;
  if (value === null) return null;
  if (typeof value === "number") {
    return Number.isFinite(value) ? value : null;
  }
  if (typeof value === "bigint") {
    return value.toString();
  }
  if (value instanceof Date) {
    return value.toISOString();
  }
  if (Array.isArray(value)) {
    return value.map((v) => toJsonSafe(v));
  }
  if (typeof value === "object") {
    const obj = value;
    const out = {};
    for (const [k, v] of Object.entries(obj)) {
      out[k] = toJsonSafe(v);
    }
    return out;
  }
  if (typeof value === "string" || typeof value === "boolean") {
    return value;
  }
  return String(value);
}
function getAuthCtx2(req2) {
  const user = req2 && req2.user || {};
  const headerOrg = req2?.headers?.["x-organization-id"] || req2?.headers?.["x-organization"] || req2?.headers?.["organization-id"];
  const role = user.role || user.userRole;
  const isSuperAdmin2 = Boolean(user.isSuperAdmin || role === "super_admin" || role === "superadmin");
  const organizationId = user.organizationId || headerOrg || null;
  return { organizationId, isSuperAdmin: isSuperAdmin2 };
}
router55.post("/nodes/:nodeId/tables", async (req2, res) => {
  const { nodeId } = req2.params;
  const { name, description, columns, rows, type = "static", meta: incomingMeta } = req2.body;
  const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx2(req2);
  if (!name) {
    return res.status(400).json({ error: "Le nom de la table est requis" });
  }
  if (!Array.isArray(columns)) {
    return res.status(400).json({ error: "La d\xC3\u0192\xC2\xA9finition des colonnes est requise (array)" });
  }
  if (!Array.isArray(rows)) {
    return res.status(400).json({ error: "Les donn\xC3\u0192\xC2\xA9es (rows) sont requises (array)" });
  }
  try {
    const node = await prisma30.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      include: { TreeBranchLeafTree: true }
    });
    if (!node) {
      return res.status(404).json({ error: "N\xC3\u2026\xE2\u20AC\u0153ud non trouv\xC3\u0192\xC2\xA9" });
    }
    if (!isSuperAdmin2 && organizationId && node.TreeBranchLeafTree.organizationId !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC2\xA8s non autoris\xC3\u0192\xC2\xA9 \xC3\u0192\xC2\xA0 ce n\xC3\u2026\xE2\u20AC\u0153ud" });
    }
    let finalName = name;
    const existingTable = await prisma30.treeBranchLeafNodeTable.findFirst({
      where: { nodeId, name: finalName }
    });
    if (existingTable) {
      const existingCount = await prisma30.treeBranchLeafNodeTable.count({
        where: { nodeId }
      });
      finalName = `${name} (${existingCount + 1})`;
    }
    const tableId = (0, import_crypto18.randomUUID)();
    const defaultMeta = {
      lookup: {
        enabled: true,
        columnLookupEnabled: true,
        rowLookupEnabled: true,
        selectors: {}
      }
    };
    const finalMeta = incomingMeta ? (() => {
      const incoming = typeof incomingMeta === "string" ? JSON.parse(incomingMeta) : incomingMeta;
      return {
        ...defaultMeta,
        ...incoming,
        lookup: {
          ...defaultMeta.lookup,
          ...incoming.lookup || {}
        }
      };
    })() : defaultMeta;
    const tableData = {
      id: tableId,
      nodeId,
      organizationId: node.TreeBranchLeafTree.organizationId,
      name: finalName,
      description: description || null,
      type,
      meta: toJsonSafe(finalMeta),
      rowCount: rows.length,
      columnCount: columns.length,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    };
    const tableColumnsData = columns.map((col, index) => {
      const colName = typeof col === "string" ? col : col.name || `Colonne ${index + 1}`;
      const colType = typeof col === "object" && col.type ? col.type : "text";
      const colWidth = typeof col === "object" && col.width ? col.width : null;
      const colFormat = typeof col === "object" && col.format ? col.format : null;
      const colMetadata = typeof col === "object" && col.metadata ? col.metadata : {};
      return {
        id: (0, import_crypto18.randomUUID)(),
        tableId,
        columnIndex: index,
        name: colName,
        type: colType,
        width: colWidth,
        format: colFormat,
        metadata: toJsonSafe(colMetadata)
      };
    });
    const tableRowsData = rows.map((row, index) => ({
      id: (0, import_crypto18.randomUUID)(),
      tableId,
      rowIndex: index,
      // IMPORTANT: Prisma JSON ne supporte pas undefined/NaN/BigInt/Date
      cells: toJsonSafe(row)
    }));
    const result = await prisma30.$transaction(async (tx) => {
      const newTable = await tx.treeBranchLeafNodeTable.create({
        data: tableData
      });
      if (tableColumnsData.length > 0) {
        await tx.treeBranchLeafNodeTableColumn.createMany({
          data: tableColumnsData
        });
      }
      if (tableRowsData.length > 0) {
        for (const rowData of tableRowsData) {
          await tx.treeBranchLeafNodeTableRow.create({
            data: rowData
          });
        }
      }
      return newTable;
    }, {
      timeout: 6e4
      // 60 secondes pour les gros fichiers (43k+ lignes)
    });
    await prisma30.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: { hasTable: true }
    });
    try {
      const node2 = await prisma30.treeBranchLeafNode.findUnique({ where: { id: nodeId }, select: { linkedTableIds: true } });
      const current = node2?.linkedTableIds ?? [];
      const next = Array.from(/* @__PURE__ */ new Set([...current || [], result.id]));
      await prisma30.treeBranchLeafNode.update({ where: { id: nodeId }, data: { linkedTableIds: { set: next } } });
    } catch {
    }
    try {
      const selectConfig = await prisma30.treeBranchLeafSelectConfig.findFirst({
        where: { nodeId }
      });
      if (selectConfig) {
        const oldTableRef = selectConfig.tableReference;
        await prisma30.treeBranchLeafSelectConfig.update({
          where: { id: selectConfig.id },
          data: { tableReference: result.id }
        });
        if (oldTableRef) {
          const otherConfigs = await prisma30.treeBranchLeafSelectConfig.findMany({
            where: {
              tableReference: oldTableRef,
              nodeId: { not: nodeId }
              // Exclure celui qu'on vient de mettre √É∆í√Ç¬† jour
            }
          });
          if (otherConfigs.length > 0) {
            await prisma30.treeBranchLeafSelectConfig.updateMany({
              where: {
                tableReference: oldTableRef,
                nodeId: { not: nodeId }
              },
              data: { tableReference: result.id }
            });
          }
        }
      } else {
        try {
          const lookupMeta = finalMeta?.lookup;
          if (lookupMeta && (lookupMeta.enabled || lookupMeta.rowLookupEnabled || lookupMeta.columnLookupEnabled)) {
            const rowSourceField = lookupMeta.rowSourceOption?.sourceField || lookupMeta.selectors?.rowFieldId;
            if (rowSourceField) {
              const existingRowConfig = await prisma30.treeBranchLeafSelectConfig.findFirst({
                where: { nodeId: rowSourceField }
              });
              if (!existingRowConfig) {
                await prisma30.treeBranchLeafSelectConfig.create({
                  data: {
                    id: (0, import_crypto18.randomUUID)(),
                    nodeId: rowSourceField,
                    options: [],
                    multiple: false,
                    searchable: true,
                    allowCustom: false,
                    optionsSource: "table",
                    tableReference: result.id,
                    keyColumn: null,
                    valueColumn: null,
                    displayColumn: lookupMeta.displayRow ? Array.isArray(lookupMeta.displayRow) ? lookupMeta.displayRow[0] : lookupMeta.displayRow : null,
                    dependsOnNodeId: null,
                    createdAt: /* @__PURE__ */ new Date(),
                    updatedAt: /* @__PURE__ */ new Date()
                  }
                });
                console.log(`[LOOKUP] SelectConfig cree pour ROW source: ${rowSourceField}`);
              }
              if (!lookupMeta.selectors) {
                lookupMeta.selectors = {};
              }
              if (!lookupMeta.selectors.rowFieldId) {
                lookupMeta.selectors.rowFieldId = rowSourceField;
              }
            }
            const colSourceField = lookupMeta.columnSourceOption?.sourceField || lookupMeta.selectors?.columnFieldId;
            if (colSourceField) {
              const existingColConfig = await prisma30.treeBranchLeafSelectConfig.findFirst({
                where: { nodeId: colSourceField }
              });
              if (!existingColConfig) {
                await prisma30.treeBranchLeafSelectConfig.create({
                  data: {
                    id: (0, import_crypto18.randomUUID)(),
                    nodeId: colSourceField,
                    options: [],
                    multiple: false,
                    searchable: true,
                    allowCustom: false,
                    optionsSource: "table",
                    tableReference: result.id,
                    keyColumn: null,
                    valueColumn: null,
                    displayColumn: lookupMeta.displayColumn ? Array.isArray(lookupMeta.displayColumn) ? lookupMeta.displayColumn[0] : lookupMeta.displayColumn : null,
                    dependsOnNodeId: null,
                    createdAt: /* @__PURE__ */ new Date(),
                    updatedAt: /* @__PURE__ */ new Date()
                  }
                });
                console.log(`[LOOKUP] SelectConfig cree pour COLUMN source: ${colSourceField}`);
              }
              if (!lookupMeta.selectors) {
                lookupMeta.selectors = {};
              }
              if (!lookupMeta.selectors.columnFieldId) {
                lookupMeta.selectors.columnFieldId = colSourceField;
              }
            }
            const existingCompositeConfig = await prisma30.treeBranchLeafSelectConfig.findFirst({
              where: { nodeId }
            });
            if (!existingCompositeConfig) {
              await prisma30.treeBranchLeafSelectConfig.create({
                data: {
                  id: (0, import_crypto18.randomUUID)(),
                  nodeId,
                  options: [],
                  multiple: false,
                  searchable: true,
                  allowCustom: false,
                  optionsSource: "table",
                  tableReference: result.id,
                  keyColumn: null,
                  valueColumn: null,
                  displayColumn: null,
                  dependsOnNodeId: null,
                  createdAt: /* @__PURE__ */ new Date(),
                  updatedAt: /* @__PURE__ */ new Date()
                }
              });
              console.log(`[LOOKUP] SelectConfig cree pour champ composite: ${nodeId}`);
            }
            await prisma30.treeBranchLeafNodeTable.update({
              where: { id: result.id },
              // IMPORTANT: ne pas ecraser le meta complet avec lookupMeta.
              // finalMeta contient deja lookupMeta (modifie ci-dessus) + toutes les autres cles meta.
              data: { meta: toJsonSafe(finalMeta) }
            });
            console.log(`[LOOKUP] Configuration de lookup complete pour table: ${result.id}`);
            console.log(`[LOOKUP] Selectors remplis: rowFieldId=${lookupMeta.selectors?.rowFieldId}, columnFieldId=${lookupMeta.selectors?.columnFieldId}`);
          }
        } catch (lookupError) {
          console.error(`[NEW POST /tables] Erreur lors de la creation des SelectConfigs lookup:`, lookupError);
        }
      }
    } catch (updateError) {
      console.error(`[NEW POST /tables] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F Erreur lors de la mise \xC3\u0192\xC2\xA0 jour des SelectConfigs:`, updateError);
    }
    const createdTable = await prisma30.treeBranchLeafNodeTable.findUnique({
      where: { id: result.id },
      include: {
        tableColumns: {
          orderBy: { columnIndex: "asc" }
        },
        tableRows: {
          orderBy: { rowIndex: "asc" }
        }
      }
    });
    if (!createdTable) {
      throw new Error("Table cr\xC3\u0192\xC2\xA9\xC3\u0192\xC2\xA9e mais introuvable lors de la relecture");
    }
    res.status(201).json({
      id: createdTable.id,
      nodeId: createdTable.nodeId,
      name: createdTable.name,
      description: createdTable.description,
      type: createdTable.type,
      columns: createdTable.tableColumns.map((c) => c.name),
      rows: createdTable.tableRows.map((r) => {
        const cells = r.cells;
        if (Array.isArray(cells)) {
          return cells;
        }
        if (typeof cells === "string") {
          try {
            const parsed = JSON.parse(cells);
            return Array.isArray(parsed) ? parsed : [String(parsed)];
          } catch {
            return [String(cells)];
          }
        }
        if (cells && typeof cells === "object") {
          return Object.values(cells);
        }
        return [String(cells || "")];
      }),
      meta: createdTable.meta || {},
      rowCount: createdTable.rowCount,
      columnCount: createdTable.columnCount,
      createdAt: createdTable.createdAt,
      updatedAt: createdTable.updatedAt
    });
  } catch (error) {
    console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 [NEW POST /tables] Erreur lors de la cr\xC3\u0192\xC2\xA9ation de la table:`, error);
    if (error instanceof import_client5.Prisma.PrismaClientValidationError) {
      return res.status(400).json({
        error: "Requ\xC3\xAAte invalide pour la cr\xC3\u0192\xC2\xA9ation de la table.",
        details: error.message
      });
    }
    if (error instanceof import_client5.Prisma.PrismaClientKnownRequestError) {
      if (error.code === "P2002") {
        return res.status(409).json({
          error: "Une table avec ce nom existe d\xC3\u0192\xC2\xA9j\xC3\u0192\xC2\xA0 pour ce champ. Veuillez choisir un autre nom.",
          code: error.code
        });
      }
      return res.status(500).json({
        error: "Erreur de base de donn\xC3\u0192\xC2\xA9es lors de la cr\xC3\u0192\xC2\xA9ation de la table.",
        code: error.code,
        meta: error.meta
      });
    }
    res.status(500).json({ error: "Impossible de cr\xC3\u0192\xC2\xA9er la table" });
  }
});
router55.get("/tables/:id", async (req2, res) => {
  const { id } = req2.params;
  const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx2(req2);
  const page = parseInt(req2.query.page) || 1;
  const limit = parseInt(req2.query.limit) || 100;
  const offset = (page - 1) * limit;
  try {
    const table = await prisma30.treeBranchLeafNodeTable.findUnique({
      where: { id },
      include: {
        TreeBranchLeafNode: {
          select: {
            treeId: true,
            TreeBranchLeafTree: {
              select: { organizationId: true }
            }
          }
        }
      }
    });
    if (!table) {
      return res.status(404).json({ error: "Table non trouv\xC3\u0192\xC2\xA9e" });
    }
    const tableOrgId = table.TreeBranchLeafNode?.TreeBranchLeafTree?.organizationId;
    if (!isSuperAdmin2 && organizationId && tableOrgId !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC2\xA8s non autoris\xC3\u0192\xC2\xA9 \xC3\u0192\xC2\xA0 cette table" });
    }
    const columns = await prisma30.treeBranchLeafNodeTableColumn.findMany({
      where: { tableId: id },
      orderBy: { columnIndex: "asc" }
    });
    const rows = await prisma30.treeBranchLeafNodeTableRow.findMany({
      where: { tableId: id },
      orderBy: { rowIndex: "asc" },
      take: limit,
      skip: offset
    });
    res.json({
      id: table.id,
      nodeId: table.nodeId,
      name: table.name,
      description: table.description,
      type: table.type,
      columns: columns.map((c) => ({
        name: c.name,
        type: c.type,
        width: c.width,
        format: c.format,
        metadata: c.metadata
      })),
      rows: rows.map((r) => r.cells),
      page,
      limit,
      totalRows: table.rowCount,
      totalPages: Math.ceil(table.rowCount / limit),
      createdAt: table.createdAt,
      updatedAt: table.updatedAt
    });
  } catch (error) {
    console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 [NEW GET /tables/:id] Erreur lors de la r\xC3\u0192\xC2\xA9cup\xC3\u0192\xC2\xA9ration de la table:`, error);
    res.status(500).json({ error: "Impossible de r\xC3\u0192\xC2\xA9cup\xC3\u0192\xC2\xA9rer la table" });
  }
});
router55.put("/tables/:id", async (req2, res) => {
  const { id } = req2.params;
  const { name, description, columns, rows, type, lookupSelectColumn, lookupDisplayColumns } = req2.body;
  const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx2(req2);
  try {
    await prisma30.$transaction(async (tx) => {
      const table = await tx.treeBranchLeafNodeTable.findUnique({
        where: { id },
        include: {
          TreeBranchLeafNode: {
            include: { TreeBranchLeafTree: true }
          }
        }
      });
      if (!table) {
        throw new Error("Table non trouv\xC3\u0192\xC2\xA9e");
      }
      const tableOrgId = table.TreeBranchLeafNode?.TreeBranchLeafTree?.organizationId;
      if (!isSuperAdmin2 && organizationId && tableOrgId !== organizationId) {
        throw new Error("Acc\xC3\u0192\xC2\xA8s non autoris\xC3\u0192\xC2\xA9");
      }
      const updateData = {
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (name) updateData.name = name;
      if (description !== void 0) updateData.description = description;
      if (type) updateData.type = type;
      if (Array.isArray(columns)) updateData.columnCount = columns.length;
      if (Array.isArray(rows)) updateData.rowCount = rows.length;
      if (lookupSelectColumn !== void 0) updateData.lookupSelectColumn = lookupSelectColumn;
      if (Array.isArray(lookupDisplayColumns)) updateData.lookupDisplayColumns = lookupDisplayColumns;
      const tableUpdated = await tx.treeBranchLeafNodeTable.update({
        where: { id },
        data: updateData
      });
      if (Array.isArray(columns)) {
        await tx.treeBranchLeafNodeTableColumn.deleteMany({ where: { tableId: id } });
        if (columns.length > 0) {
          const newColumnsData = columns.map((col, index) => ({
            id: (0, import_crypto18.randomUUID)(),
            tableId: id,
            columnIndex: index,
            name: typeof col === "string" ? col : col.name || `Colonne ${index + 1}`,
            type: typeof col === "object" ? col.type : "text",
            width: typeof col === "object" ? col.width : null,
            format: typeof col === "object" ? col.format : null,
            metadata: toJsonSafe(typeof col === "object" && col.metadata ? col.metadata : {})
          }));
          await tx.treeBranchLeafNodeTableColumn.createMany({ data: newColumnsData });
        }
      }
      if (Array.isArray(rows)) {
        await tx.treeBranchLeafNodeTableRow.deleteMany({ where: { tableId: id } });
        if (rows.length > 0) {
          for (let index = 0; index < rows.length; index++) {
            const row = rows[index];
            await tx.treeBranchLeafNodeTableRow.create({
              data: {
                id: (0, import_crypto18.randomUUID)(),
                tableId: id,
                rowIndex: index,
                cells: toJsonSafe(row)
              }
            });
          }
        }
      }
      return tableUpdated;
    });
    const finalTableData = await prisma30.treeBranchLeafNodeTable.findUnique({ where: { id } });
    res.json(finalTableData);
  } catch (error) {
    console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 [NEW PUT /tables/:id] Erreur lors de la mise \xC3\u0192\xC2\xA0 jour:`, error);
    if (error instanceof Error && (error.message === "Table non trouv\xC3\u0192\xC2\xA9e" || error.message === "Acc\xC3\u0192\xC2\xA8s non autoris\xC3\u0192\xC2\xA9")) {
      const status = error.message === "Table non trouv\xC3\u0192\xC2\xA9e" ? 404 : 403;
      return res.status(status).json({ error: error.message });
    }
    res.status(500).json({ error: "Impossible de mettre \xC3\u0192\xC2\xA0 jour la table" });
  }
});
router55.delete("/tables/:id", async (req2, res) => {
  const { id } = req2.params;
  const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx2(req2);
  try {
    const table = await prisma30.treeBranchLeafNodeTable.findUnique({
      where: { id },
      include: {
        TreeBranchLeafNode: {
          include: { TreeBranchLeafTree: true }
        }
      }
    });
    if (!table) {
      return res.status(404).json({ error: "Table non trouv\xC3\u0192\xC2\xA9e" });
    }
    const tableOrgId = table.TreeBranchLeafNode?.TreeBranchLeafTree?.organizationId;
    if (!isSuperAdmin2 && organizationId && tableOrgId !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC2\xA8s non autoris\xC3\u0192\xC2\xA9" });
    }
    await prisma30.treeBranchLeafNodeTable.delete({ where: { id } });
    try {
      const selectConfigsUsingTable = await prisma30.treeBranchLeafSelectConfig.findMany({
        where: { tableReference: id },
        select: { nodeId: true }
      });
      if (selectConfigsUsingTable.length > 0) {
        for (const config of selectConfigsUsingTable) {
          const selectNode = await prisma30.treeBranchLeafNode.findUnique({
            where: { id: config.nodeId },
            select: {
              label: true,
              metadata: true
            }
          });
          if (selectNode) {
            const oldMetadata = selectNode.metadata || {};
            const oldCapabilities = oldMetadata.capabilities || {};
            const newCapabilities = {
              ...oldCapabilities,
              table: {
                enabled: false,
                activeId: null,
                instances: null,
                currentTable: null
              }
            };
            const newMetadata = {
              ...oldMetadata,
              capabilities: newCapabilities
            };
            await prisma30.treeBranchLeafNode.update({
              where: { id: config.nodeId },
              data: {
                hasTable: false,
                table_activeId: null,
                table_instances: null,
                table_name: null,
                table_type: null,
                table_meta: null,
                table_columns: null,
                table_rows: null,
                table_data: null,
                metadata: JSON.parse(JSON.stringify(newMetadata)),
                select_options: [],
                updatedAt: /* @__PURE__ */ new Date()
              }
            });
            await prisma30.treeBranchLeafSelectConfig.deleteMany({
              where: { nodeId: config.nodeId }
            });
          }
        }
      }
    } catch (selectConfigError) {
      console.error(`[NEW DELETE /tables/:id] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F Erreur d\xC3\u0192\xC2\xA9sactivation lookups:`, selectConfigError);
    }
    if (table.nodeId) {
      const node = await prisma30.treeBranchLeafNode.findUnique({
        where: { id: table.nodeId },
        select: {
          linkedTableIds: true,
          table_activeId: true,
          table_instances: true
        }
      });
      const currentLinkedIds = node?.linkedTableIds ?? [];
      const nextLinkedIds = currentLinkedIds.filter((x) => x !== id);
      const wasActiveTable = node?.table_activeId === id;
      let cleanedInstances = node?.table_instances ?? {};
      if (typeof cleanedInstances === "object" && cleanedInstances !== null) {
        const instances = cleanedInstances;
        if (instances[id]) {
          delete instances[id];
          cleanedInstances = instances;
        }
      }
      const remainingTables = await prisma30.treeBranchLeafNodeTable.count({
        where: { nodeId: table.nodeId }
      });
      await prisma30.treeBranchLeafNode.update({
        where: { id: table.nodeId },
        data: {
          hasTable: remainingTables > 0,
          linkedTableIds: { set: nextLinkedIds },
          table_activeId: wasActiveTable ? null : void 0,
          // R√É∆í√Ç¬©initialiser si c'√É∆í√Ç¬©tait la table active
          table_instances: cleanedInstances,
          // R√É∆í√Ç¬©initialiser les autres champs si plus de tables
          ...remainingTables === 0 && {
            table_name: null,
            table_type: null,
            table_meta: null,
            table_columns: null,
            table_rows: null,
            table_data: null,
            table_importSource: null,
            table_isImported: false
          }
        }
      });
    }
    res.json({ success: true, message: "Table supprim\xC3\u0192\xC2\xA9e avec succ\xC3\u0192\xC2\xA8s" });
  } catch (error) {
    console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 [NEW DELETE /tables/:id] Erreur lors de la suppression:`, error);
    res.status(500).json({ error: "Impossible de supprimer la table" });
  }
});
router55.put("/nodes/:nodeId/tables/:tableId", async (req2, res) => {
  const { tableId } = req2.params;
  const { name, description, columns, rows, type, meta } = req2.body;
  const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx2(req2);
  try {
    if (meta && !columns && !rows) {
      try {
        const metaObj = typeof meta === "string" ? JSON.parse(meta) : meta;
        const lookup = metaObj?.lookup || {};
        const selectors = lookup?.selectors || {};
        console.log("[MANUAL-SAVE][TABLE META] \u27A1\uFE0F PUT /nodes/:nodeId/tables/:tableId", {
          tableId,
          name,
          description,
          type,
          lookupSelectors: {
            columnFieldId: selectors.columnFieldId || null,
            rowFieldId: selectors.rowFieldId || null,
            comparisonColumn: lookup?.comparisonColumn || null,
            displayColumn: lookup?.displayColumn || null,
            displayRow: lookup?.displayRow || null
          },
          rawMetaKeys: Object.keys(metaObj || {})
        });
      } catch {
        console.log("[MANUAL-SAVE][TABLE META] \u26A0\uFE0F Impossible de parser meta pour logging, envoi brut");
        console.log("[MANUAL-SAVE][TABLE META] RAW:", typeof meta === "string" ? meta : JSON.stringify(meta));
      }
      const table2 = await prisma30.treeBranchLeafNodeTable.findUnique({
        where: { id: tableId },
        include: {
          TreeBranchLeafNode: {
            include: { TreeBranchLeafTree: true }
          }
        }
      });
      if (!table2) {
        return res.status(404).json({ error: "Table non trouv\xC3\u0192\xC2\xA9e" });
      }
      const tableOrgId = table2.TreeBranchLeafNode?.TreeBranchLeafTree?.organizationId;
      if (!isSuperAdmin2 && organizationId && tableOrgId !== organizationId) {
        return res.status(403).json({ error: "Acc\xC3\u0192\xC2\xA8s non autoris\xC3\u0192\xC2\xA9" });
      }
      const updatedTable2 = await prisma30.treeBranchLeafNodeTable.update({
        where: { id: tableId },
        data: {
          meta: toJsonSafe(meta),
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
      try {
        const persistedMeta = typeof updatedTable2.meta === "string" ? JSON.parse(updatedTable2.meta) : updatedTable2.meta;
        const lookup = persistedMeta?.lookup || {};
        const selectors = lookup?.selectors || {};
        console.log("[MANUAL-SAVE][TABLE META] \u2705 Persist\xE9", {
          tableId,
          lookupSelectors: {
            columnFieldId: selectors.columnFieldId || null,
            rowFieldId: selectors.rowFieldId || null,
            comparisonColumn: lookup?.comparisonColumn || null,
            displayColumn: lookup?.displayColumn || null,
            displayRow: lookup?.displayRow || null
          }
        });
      } catch {
        console.log("[MANUAL-SAVE][TABLE META] \u26A0\uFE0F Persist\xE9 (meta non pars\xE9)");
      }
      return res.json(updatedTable2);
    }
    const updatedTable = await prisma30.$transaction(async (tx) => {
      const table2 = await tx.treeBranchLeafNodeTable.findUnique({
        where: { id: tableId },
        include: {
          TreeBranchLeafNode: {
            include: { TreeBranchLeafTree: true }
          }
        }
      });
      if (!table2) {
        throw new Error("Table non trouv\xC3\u0192\xC2\xA9e");
      }
      const tableOrgId = table2.TreeBranchLeafNode?.TreeBranchLeafTree?.organizationId;
      if (!isSuperAdmin2 && organizationId && tableOrgId !== organizationId) {
        throw new Error("Acc\xC3\u0192\xC2\xA8s non autoris\xC3\u0192\xC2\xA9");
      }
      const updateData = {
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (name) updateData.name = name;
      if (description !== void 0) updateData.description = description;
      if (type) updateData.type = type;
      if (meta) updateData.meta = toJsonSafe(meta);
      if (Array.isArray(columns) && columns.length > 0) updateData.columnCount = columns.length;
      if (Array.isArray(rows) && rows.length > 0) updateData.rowCount = rows.length;
      const tableUpdated = await tx.treeBranchLeafNodeTable.update({
        where: { id: tableId },
        data: updateData
      });
      if (Array.isArray(columns) && columns.length > 0) {
        await tx.treeBranchLeafNodeTableColumn.deleteMany({ where: { tableId } });
        const newColumnsData = columns.map((col, index) => ({
          id: (0, import_crypto18.randomUUID)(),
          tableId,
          columnIndex: index,
          name: typeof col === "string" ? col : col.name || `Colonne ${index + 1}`,
          type: typeof col === "object" ? col.type : "text",
          width: typeof col === "object" ? col.width : null,
          format: typeof col === "object" ? col.format : null,
          metadata: toJsonSafe(typeof col === "object" && col.metadata ? col.metadata : {})
        }));
        await tx.treeBranchLeafNodeTableColumn.createMany({ data: newColumnsData });
      }
      if (Array.isArray(rows) && rows.length > 0) {
        await tx.treeBranchLeafNodeTableRow.deleteMany({ where: { tableId } });
        for (let index = 0; index < rows.length; index++) {
          const row = rows[index];
          await tx.treeBranchLeafNodeTableRow.create({
            data: {
              id: (0, import_crypto18.randomUUID)(),
              tableId,
              rowIndex: index,
              cells: toJsonSafe(row)
            }
          });
        }
      }
      return tableUpdated;
    });
    const table = await prisma30.treeBranchLeafNodeTable.findUnique({
      where: { id: tableId },
      select: { nodeId: true }
    });
    if (table?.nodeId) {
      await prisma30.treeBranchLeafNode.update({
        where: { id: table.nodeId },
        data: {
          hasTable: true,
          table_activeId: tableId
        }
      });
    }
    res.json(updatedTable);
  } catch (error) {
    console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 [NEW PUT /nodes/:nodeId/tables/:tableId] Erreur:`, error);
    if (error instanceof Error && (error.message === "Table non trouv\xC3\u0192\xC2\xA9e" || error.message === "Acc\xC3\u0192\xC2\xA8s non autoris\xC3\u0192\xC2\xA9")) {
      const status = error.message === "Table non trouv\xC3\u0192\xC2\xA9e" ? 404 : 403;
      return res.status(status).json({ error: error.message });
    }
    res.status(500).json({ error: "Impossible de mettre \xC3\u0192\xC2\xA0 jour la table" });
  }
});
router55.get("/nodes/:nodeId/tables", async (req2, res) => {
  const { nodeId } = req2.params;
  const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx2(req2);
  try {
    const node = await prisma30.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      include: { TreeBranchLeafTree: true }
    });
    if (!node) {
      return res.status(404).json({ error: "N\xC3\u2026\xE2\u20AC\u0153ud non trouv\xC3\u0192\xC2\xA9" });
    }
    if (!isSuperAdmin2 && organizationId && node.TreeBranchLeafTree.organizationId !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC2\xA8s non autoris\xC3\u0192\xC2\xA9 \xC3\u0192\xC2\xA0 ce n\xC3\u2026\xE2\u20AC\u0153ud" });
    }
    const tables = await prisma30.treeBranchLeafNodeTable.findMany({
      where: { nodeId },
      include: {
        tableColumns: {
          orderBy: { columnIndex: "asc" }
        },
        tableRows: {
          orderBy: { rowIndex: "asc" }
        }
      },
      orderBy: { createdAt: "asc" }
    });
    let activeTable = null;
    console.log(`[GET /nodes/:nodeId/tables] nodeId: ${nodeId}, table_activeId: ${node.table_activeId}`);
    if (node.table_activeId) {
      activeTable = await prisma30.treeBranchLeafNodeTable.findUnique({
        where: { id: node.table_activeId },
        include: {
          tableColumns: {
            orderBy: { columnIndex: "asc" }
          },
          tableRows: {
            orderBy: { rowIndex: "asc" }
          }
        }
      });
    }
    const allTables = [...tables];
    if (activeTable && !allTables.some((t) => t.id === activeTable.id)) {
      allTables.push(activeTable);
    }
    const suffixMatch = String(nodeId).match(/-(\d+)$/);
    const lookupSuffix = suffixMatch ? `-${suffixMatch[1]}` : null;
    if (lookupSuffix) {
      const isNumeric = (val) => /^-?\d+(\.\d+)?$/.test(val.trim());
      for (const table of allTables) {
        if (!table.meta || typeof table.meta !== "object") continue;
        const metaObj = JSON.parse(JSON.stringify(table.meta));
        if (!metaObj.lookup) continue;
        let changed = false;
        if (metaObj.lookup.tableRef && typeof metaObj.lookup.tableRef === "string" && !metaObj.lookup.tableRef.endsWith(lookupSuffix)) {
          metaObj.lookup.tableRef = `${metaObj.lookup.tableRef}${lookupSuffix}`;
          changed = true;
        }
        const selectors = metaObj.lookup.selectors || {};
        if (selectors.columnFieldId && typeof selectors.columnFieldId === "string" && !selectors.columnFieldId.endsWith(lookupSuffix)) {
          selectors.columnFieldId = `${selectors.columnFieldId}${lookupSuffix}`;
          changed = true;
        }
        if (selectors.rowFieldId && typeof selectors.rowFieldId === "string" && !selectors.rowFieldId.endsWith(lookupSuffix)) {
          selectors.rowFieldId = `${selectors.rowFieldId}${lookupSuffix}`;
          changed = true;
        }
        metaObj.lookup.selectors = selectors;
        const rowSource = metaObj.lookup.rowSourceOption || {};
        if (rowSource.sourceField && typeof rowSource.sourceField === "string" && !rowSource.sourceField.endsWith(lookupSuffix)) {
          rowSource.sourceField = `${rowSource.sourceField}${lookupSuffix}`;
          changed = true;
        }
        if (rowSource.comparisonColumn && typeof rowSource.comparisonColumn === "string" && !isNumeric(rowSource.comparisonColumn) && !rowSource.comparisonColumn.endsWith(lookupSuffix)) {
          rowSource.comparisonColumn = `${rowSource.comparisonColumn}${lookupSuffix}`;
          changed = true;
        }
        metaObj.lookup.rowSourceOption = rowSource;
        const colSource = metaObj.lookup.columnSourceOption || {};
        if (colSource.sourceField && typeof colSource.sourceField === "string" && !colSource.sourceField.endsWith(lookupSuffix)) {
          colSource.sourceField = `${colSource.sourceField}${lookupSuffix}`;
          changed = true;
        }
        if (colSource.comparisonColumn && typeof colSource.comparisonColumn === "string" && !isNumeric(colSource.comparisonColumn) && !colSource.comparisonColumn.endsWith(lookupSuffix)) {
          colSource.comparisonColumn = `${colSource.comparisonColumn}${lookupSuffix}`;
          changed = true;
        }
        metaObj.lookup.columnSourceOption = colSource;
        if (metaObj.lookup.displayColumn) {
          if (Array.isArray(metaObj.lookup.displayColumn)) {
            metaObj.lookup.displayColumn = metaObj.lookup.displayColumn.map((col) => {
              if (!col || isNumeric(col) || col.endsWith(lookupSuffix)) return col;
              changed = true;
              return `${col}${lookupSuffix}`;
            });
          } else if (typeof metaObj.lookup.displayColumn === "string" && !isNumeric(metaObj.lookup.displayColumn) && !metaObj.lookup.displayColumn.endsWith(lookupSuffix)) {
            metaObj.lookup.displayColumn = `${metaObj.lookup.displayColumn}${lookupSuffix}`;
            changed = true;
          }
        }
        if (metaObj.lookup.displayRow) {
          if (Array.isArray(metaObj.lookup.displayRow)) {
            metaObj.lookup.displayRow = metaObj.lookup.displayRow.map((row) => {
              if (!row || isNumeric(row) || row.endsWith(lookupSuffix)) return row;
              changed = true;
              return `${row}${lookupSuffix}`;
            });
          } else if (typeof metaObj.lookup.displayRow === "string" && !isNumeric(metaObj.lookup.displayRow) && !metaObj.lookup.displayRow.endsWith(lookupSuffix)) {
            metaObj.lookup.displayRow = `${metaObj.lookup.displayRow}${lookupSuffix}`;
            changed = true;
          }
        }
        if (!changed) continue;
        await prisma30.treeBranchLeafNodeTable.update({
          where: { id: table.id },
          data: { meta: metaObj, updatedAt: /* @__PURE__ */ new Date() }
        });
        table.meta = metaObj;
      }
    }
    const formattedTables = allTables.map((table) => ({
      id: table.id,
      name: table.name,
      description: table.description,
      type: table.type,
      columns: table.tableColumns.map((c) => c.name),
      rows: table.tableRows.map((r) => {
        const cells = r.cells;
        if (Array.isArray(cells)) {
          return cells;
        }
        if (typeof cells === "string") {
          try {
            const parsed = JSON.parse(cells);
            return Array.isArray(parsed) ? parsed : [String(parsed)];
          } catch {
            return [String(cells)];
          }
        }
        if (cells && typeof cells === "object") {
          return Object.values(cells);
        }
        return [String(cells || "")];
      }),
      meta: table.meta || {},
      order: table.createdAt ? new Date(table.createdAt).getTime() : 0,
      createdAt: table.createdAt,
      updatedAt: table.updatedAt
    }));
    console.log(`[GET /nodes/:nodeId/tables] Returning ${formattedTables.length} tables. First table columns: ${formattedTables[0]?.columns?.slice(0, 3).join(", ")}`);
    res.json(formattedTables);
  } catch (error) {
    console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 [NEW GET /nodes/:nodeId/tables] Erreur:`, error);
    res.status(500).json({ error: "Impossible de r\xC3\u0192\xC2\xA9cup\xC3\u0192\xC2\xA9rer les tables" });
  }
});
var table_routes_new_default = router55;

// src/components/TreeBranchLeaf/treebranchleaf-new/api/treebranchleaf-routes.ts
var router56 = (0, import_express57.Router)();
router56.use("/", table_routes_new_default);
registerSumDisplayFieldRoutes(router56);
var prisma31 = db;
var normalizeRolesMap = (rolesMap) => {
  if (!rolesMap || typeof rolesMap !== "object") {
    return {};
  }
  const normalized = {};
  for (const [rawKey, rawValue] of Object.entries(rolesMap)) {
    if (typeof rawKey !== "string") continue;
    const trimmedKey = rawKey.trim();
    if (!trimmedKey) continue;
    if (typeof rawValue === "string" && rawValue.trim()) {
      normalized[trimmedKey] = rawValue.trim();
    } else if (rawValue != null) {
      normalized[trimmedKey] = String(rawValue).trim() || trimmedKey;
    } else {
      normalized[trimmedKey] = trimmedKey;
    }
  }
  return normalized;
};
var createRolesProxy = (rolesMap) => {
  const normalized = normalizeRolesMap(rolesMap);
  return new Proxy(normalized, {
    get(target, prop) {
      if (typeof prop !== "string") {
        return void 0;
      }
      if (prop in target) {
        return target[prop];
      }
      const fallback = prop.trim();
      if (fallback) {
        target[fallback] = fallback;
        return fallback;
      }
      return fallback;
    }
  });
};
var coerceToNumber = (value) => {
  if (typeof value === "number" && Number.isFinite(value)) return value;
  if (typeof value === "boolean") return value ? 1 : 0;
  if (typeof value === "string") {
    const trimmed = value.trim();
    if (!trimmed) return null;
    const parsed = Number(trimmed);
    return Number.isFinite(parsed) ? parsed : null;
  }
  return null;
};
var computeLogicVersion = () => {
  const metrics = getLogicMetrics();
  const stats = getRpnCacheStats();
  const seed = JSON.stringify({
    evaluations: metrics.evaluations,
    parseErrors: metrics.parseErrors,
    divisionByZero: metrics.divisionByZero,
    unknownVariables: metrics.unknownVariables,
    entries: stats.entries,
    parseCount: stats.parseCount
  });
  const version = (0, import_crypto19.createHash)("sha1").update(seed).digest("hex").slice(0, 8);
  return { version, metrics, stats };
};
function getAuthCtx3(req2) {
  const user = req2 && req2.user || {};
  const headerOrg = req2?.headers?.["x-organization-id"] || req2?.headers?.["x-organization"] || req2?.headers?.["organization-id"];
  const role = user.role || user.userRole;
  const isSuperAdmin2 = Boolean(user.isSuperAdmin || role === "super_admin" || role === "superadmin");
  const organizationId = user.organizationId || headerOrg || null;
  return { organizationId, isSuperAdmin: isSuperAdmin2 };
}
var resolveNodeVariable = async (nodeId, linkedVariableIds) => {
  const directVariable = await prisma31.treeBranchLeafNodeVariable.findUnique({ where: { nodeId } });
  if (directVariable) {
    return { variable: directVariable, ownerNodeId: nodeId, proxiedFromNodeId: null };
  }
  const candidateIds = (linkedVariableIds || []).filter((value) => typeof value === "string" && Boolean(value.trim()));
  if (candidateIds.length === 0) {
    return { variable: null, ownerNodeId: null, proxiedFromNodeId: null };
  }
  const linkedVariable = await prisma31.treeBranchLeafNodeVariable.findFirst({
    where: { id: { in: candidateIds } }
  });
  if (!linkedVariable) {
    return { variable: null, ownerNodeId: null, proxiedFromNodeId: null };
  }
  return {
    variable: linkedVariable,
    ownerNodeId: linkedVariable.nodeId,
    proxiedFromNodeId: nodeId
  };
};
function normalizeRefId2(ref) {
  if (!ref) return ref;
  if (ref.startsWith("node-formula:")) return ref.replace(/^node-formula:/, "");
  return ref;
}
function extractNodeIdsFromConditionSet2(conditionSet) {
  const ids = /* @__PURE__ */ new Set();
  if (!conditionSet || typeof conditionSet !== "object") return ids;
  const obj = conditionSet;
  if (Array.isArray(obj.tokens)) {
    for (const t of obj.tokens) {
      const asStr = typeof t === "string" ? t : JSON.stringify(t);
      const re = /@value\.([a-f0-9-]{36})/gi;
      let m;
      while ((m = re.exec(asStr)) !== null) {
        ids.add(m[1]);
      }
    }
  }
  if (Array.isArray(obj.branches)) {
    for (const br of obj.branches) {
      const b = br;
      const when = b.when;
      const scanWhen = (node) => {
        if (!node) return;
        const ref = node.ref;
        if (typeof ref === "string") {
          const m = /@value\.([a-f0-9-]{36})/i.exec(ref);
          if (m && m[1]) ids.add(m[1]);
        }
        if (node.left && typeof node.left === "object") scanWhen(node.left);
        if (node.right && typeof node.right === "object") scanWhen(node.right);
      };
      scanWhen(when);
      const actions = b.actions;
      if (Array.isArray(actions)) {
        for (const a of actions) {
          const aa = a;
          const nodeIds = aa.nodeIds;
          if (Array.isArray(nodeIds)) {
            for (const nid of nodeIds) ids.add(normalizeRefId2(nid));
          }
        }
      }
    }
  }
  if (obj.fallback && typeof obj.fallback === "object") {
    const fb = obj.fallback;
    const actions = fb.actions;
    if (Array.isArray(actions)) {
      for (const a of actions) {
        const aa = a;
        const nodeIds = aa.nodeIds;
        if (Array.isArray(nodeIds)) {
          for (const nid of nodeIds) ids.add(normalizeRefId2(nid));
        }
      }
    }
  }
  const str = JSON.stringify(obj);
  if (str) {
    const re = /@value\.([a-f0-9-]{36})/gi;
    let m;
    while ((m = re.exec(str)) !== null) ids.add(m[1]);
  }
  return ids;
}
function extractNodeIdsFromTokens2(tokens2) {
  const ids = /* @__PURE__ */ new Set();
  if (!tokens2) return ids;
  const addFromString = (s) => {
    let m;
    const re = /@value\.([A-Za-z0-9_:-]+)/gi;
    while ((m = re.exec(s)) !== null) ids.add(m[1]);
  };
  if (Array.isArray(tokens2)) {
    for (const t of tokens2) {
      if (typeof t === "string") addFromString(t);
      else addFromString(JSON.stringify(t));
    }
  } else if (typeof tokens2 === "string") {
    addFromString(tokens2);
  } else {
    addFromString(JSON.stringify(tokens2));
  }
  return ids;
}
function buildResolvedRefs(nodeIds, labels, values) {
  return Array.from(nodeIds).map((nodeId) => ({
    nodeId,
    label: labels.get(nodeId) ?? null,
    value: values.get(nodeId) ?? null
  }));
}
function resolveActionsLabels(actions, labels) {
  if (!Array.isArray(actions)) return [];
  return actions.map((a) => {
    const aa = a;
    const nodeIds = Array.isArray(aa.nodeIds) ? aa.nodeIds.map(normalizeRefId2) : [];
    return {
      type: aa.type || null,
      nodeIds,
      labels: nodeIds.map((nid) => ({ nodeId: nid, label: labels.get(nid) ?? null }))
    };
  });
}
var uniq2 = (arr) => Array.from(new Set(arr));
async function getNodeLinkedField3(client, nodeId, field) {
  const node = await client.treeBranchLeafNode.findUnique({
    where: { id: nodeId },
    select: { [field]: true }
  });
  return node?.[field] ?? [];
}
async function setNodeLinkedField3(client, nodeId, field, values) {
  try {
    await client.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: { [field]: { set: uniq2(values) } }
    });
  } catch (e) {
    console.warn("[TreeBranchLeaf API] setNodeLinkedField skipped:", { nodeId, field, error: e.message });
  }
}
async function addToNodeLinkedField7(client, nodeId, field, idsToAdd) {
  if (!idsToAdd?.length) return;
  const current = await getNodeLinkedField3(client, nodeId, field);
  const next = uniq2([...current, ...idsToAdd.filter(Boolean)]);
  await setNodeLinkedField3(client, nodeId, field, next);
}
async function removeFromNodeLinkedField(client, nodeId, field, idsToRemove) {
  if (!idsToRemove?.length) return;
  const current = await getNodeLinkedField3(client, nodeId, field);
  const toRemove = new Set(idsToRemove.filter(Boolean));
  const next = current.filter((id) => !toRemove.has(id));
  await setNodeLinkedField3(client, nodeId, field, next);
}
function fmtLV(label, value) {
  return `${label ?? "\xC3\u0192\xC2\xA2\xC3\xA2\xE2\u20AC\u0161\xC2\xAC\xC3\xA2\xE2\u201A\xAC\xC2\x9D"}(${value ?? "\xC3\u0192\xC2\xA2\xC3\u2039\xE2\u20AC\xA0\xC3\xA2\xE2\u201A\xAC\xC2\xA6"})`;
}
function getTestValueForNode(nodeId, fixedValue, defaultValue) {
  if (fixedValue && fixedValue.trim() !== "") return fixedValue;
  if (defaultValue && defaultValue.trim() !== "") return defaultValue;
  const testValues = {
    // Prix Kw/h (devrait avoir 0.35)
    "702d1b09-abc9-4096-9aaa-77155ac5294f": "0.35",
    // Calcul du prix Kw/h (devrait avoir 4000)
    "d6212e5e-3fe9-4cce-b380-e6745524d011": "4000",
    // Consommation annuelle √É∆í√Ü‚Äô√É‚Äö√Ç¬©lectricit√É∆í√Ü‚Äô√É‚Äö√Ç¬© (devrait avoir 1000)
    "node_1757366229534_x6jxzmvmu": "1000",
    // Consommation annuelle (valeur test)
    "node_1757366229561_dyfsa3p7n": "2500",
    // Cout Annuelle chauffage (valeur test)  
    "node_1757366229564_z28kl0eb4": "1200",
    // Longueur fa√É∆í√Ü‚Äô√É‚Äö√Ç¬ßade avant (valeur test)
    "node_1757366229578_c9yf18eho": "12",
    // Hauteur fa√É∆í√Ü‚Äô√É‚Äö√Ç¬ßade avant (valeur test)
    "4fd0bb1d-836b-4cd0-9c2d-2f48808732eb": "3"
  };
  return testValues[nodeId] || null;
}
function buildTextFromTokens(tokens2, labels, values) {
  if (!tokens2) return "";
  const operatorSet = /* @__PURE__ */ new Set(["+", "-", "*", "/", "="]);
  const mapToken = (t) => {
    if (typeof t === "string") {
      if (operatorSet.has(t.trim())) {
        return `(${t.trim()})`;
      }
      const re = /@value\.([A-Za-z0-9_:-]+)/g;
      let out = "";
      let lastIndex = 0;
      let m;
      while ((m = re.exec(t)) !== null) {
        out += t.slice(lastIndex, m.index);
        const raw = m[1];
        const label = labels.get(raw) ?? null;
        const value = values.get(raw) ?? null;
        out += fmtLV(label, value);
        lastIndex = re.lastIndex;
      }
      if (lastIndex === 0) return t;
      return out + t.slice(lastIndex);
    }
    if (typeof t === "number" || typeof t === "boolean") return String(t);
    try {
      return JSON.stringify(t);
    } catch {
      return "";
    }
  };
  if (Array.isArray(tokens2)) return tokens2.map(mapToken).join(" ");
  return mapToken(tokens2);
}
function buildTextFromTableRecord(rec, labels, values) {
  const str = JSON.stringify(rec);
  const ids = /* @__PURE__ */ new Set();
  if (str) {
    let m;
    const re = /@value\.([a-f0-9-]{36})/gi;
    while ((m = re.exec(str)) !== null) ids.add(m[1]);
  }
  const parts = Array.from(ids).map((id) => fmtLV(labels.get(id) ?? null, values.get(id) ?? null));
  return parts.join(" & ");
}
function buildResultText(prefixExpr, resultValue, unit) {
  const right = [resultValue ?? ""].filter(Boolean).join("");
  const u = unit ? ` ${unit}` : "";
  if (prefixExpr && right) return `${prefixExpr}=${right}${u}`;
  if (prefixExpr) return prefixExpr;
  return right ? `${right}${u}` : "";
}
async function buildDetailAndResultForOperation(type, record, display, valueStr, unit, labelMap, valuesMap, prisma51, submissionId, organizationId, userId) {
  return {
    detail: {
      type: "legacy-disabled",
      message: "\xC3\u0192\xC2\xB0\xC3\u2026\xC2\xB8\xC3\xA2\xE2\u201A\xAC\xC2\x9D\xC3\xA2\xE2\u201A\xAC\xC5\xBE Fonction d\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9sactiv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e - utilisez TBL Prisma exclusivement",
      tblPrismaEndpoint: "/api/tbl/submissions/create-and-evaluate"
    },
    result: "\xC3\u0192\xC2\xB0\xC3\u2026\xC2\xB8\xC3\xA2\xE2\u201A\xAC\xC2\x9D\xC3\xA2\xE2\u201A\xAC\xC5\xBE \xC3\u0192\xC6\u2019\xC3\xA2\xE2\u201A\xAC\xC2\xB0valuation via TBL Prisma uniquement"
  };
}
function calculateResult(expression) {
  try {
    const mathPart = expression.split(" = ")[0];
    const valueMatches = mathPart.match(/\(([0-9.]+)\)/g);
    if (!valueMatches || valueMatches.length < 2) {
      return null;
    }
    const values = valueMatches.map((match) => parseFloat(match.slice(1, -1)));
    if (mathPart.includes("(+)") || mathPart.includes(" + ")) {
      return values.reduce((a, b) => a + b, 0);
    } else if (mathPart.includes("(-)") || mathPart.includes(" - ")) {
      return values.reduce((a, b) => a - b);
    } else if (mathPart.includes("(*)") || mathPart.includes(" * ")) {
      return values.reduce((a, b) => a * b, 1);
    } else if (mathPart.includes("(/)") || mathPart.includes(" / ")) {
      return values.reduce((a, b) => a / b);
    }
    return null;
  } catch (error) {
    console.error("Erreur lors du calcul:", error);
    return null;
  }
}
router56.use((req2, res, next) => {
  req2.user = {
    id: "1757366075163-2vdibc2ve",
    userId: "1757366075163-2vdibc2ve",
    email: "jonathan.dethier@2thier.be",
    organizationId: "1757366075154-i554z93kl",
    isSuperAdmin: true,
    role: "super_admin"
  };
  next();
});
router56.get("/trees", async (req2, res) => {
  try {
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const whereFilter = isSuperAdmin2 || !organizationId ? {} : { organizationId };
    const trees = await prisma31.treeBranchLeafTree.findMany({
      where: whereFilter,
      include: {
        _count: {
          select: {
            TreeBranchLeafNode: true
          }
        }
      },
      orderBy: { createdAt: "desc" }
    });
    if (trees.length > 0) {
    }
    res.json(trees);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching trees:", error);
    res.status(500).json({ error: "Impossible de r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rer les arbres" });
  }
});
router56.get("/trees/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const tree = await prisma31.treeBranchLeafTree.findFirst({
      where: isSuperAdmin2 || !organizationId ? { id } : { id, organizationId },
      include: {
        _count: {
          select: {
            TreeBranchLeafNode: true
          }
        }
      }
    });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    res.json(tree);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching tree:", error);
    res.status(500).json({ error: "Impossible de r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rer l'arbre" });
  }
});
router56.post("/trees", async (req2, res) => {
  try {
    const {
      name,
      description,
      category = "formulaire",
      icon,
      color = "#10b981",
      version = "1.0.0",
      status = "draft",
      settings = {},
      metadata = {},
      isPublic = false,
      organizationId: bodyOrgId
    } = req2.body || {};
    if (!name || typeof name !== "string" || !name.trim()) {
      return res.status(400).json({ error: "Le nom de l'arbre est requis" });
    }
    const targetOrgId = getAuthCtx3(req2).organizationId || (typeof bodyOrgId === "string" ? bodyOrgId : null);
    if (!targetOrgId) {
      return res.status(400).json({ error: "organizationId requis (en-t\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xAAte x-organization-id ou dans le corps)" });
    }
    const id = (0, import_crypto19.randomUUID)();
    const tree = await prisma31.treeBranchLeafTree.create({
      data: {
        id,
        organizationId: targetOrgId,
        name: name.trim(),
        description: description ?? null,
        category,
        icon: icon ?? null,
        color,
        version,
        status,
        settings,
        metadata,
        isPublic: Boolean(isPublic),
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    res.status(201).json(tree);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error creating tree:", error);
    res.status(500).json({ error: "Impossible de cr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9er l'arbre" });
  }
});
router56.put("/trees/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { organizationId } = req2.user;
    const updateData = req2.body;
    delete updateData.id;
    delete updateData.organizationId;
    delete updateData.createdAt;
    const tree = await prisma31.treeBranchLeafTree.updateMany({
      where: {
        id,
        organizationId
      },
      data: {
        ...updateData,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    if (tree.count === 0) {
      return res.status(404).json({ error: "Arbre non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const updatedTree = await prisma31.treeBranchLeafTree.findFirst({
      where: { id, organizationId }
    });
    res.json(updatedTree);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error updating tree:", error);
    res.status(500).json({ error: "Impossible de mettre \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 jour l'arbre" });
  }
});
router56.delete("/trees/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { organizationId } = req2.user;
    await prisma31.treeBranchLeafNode.deleteMany({
      where: { treeId: id }
    });
    const result = await prisma31.treeBranchLeafTree.deleteMany({
      where: {
        id,
        organizationId
      }
    });
    if (result.count === 0) {
      return res.status(404).json({ error: "Arbre non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    res.json({ success: true, message: "Arbre supprim\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 avec succ\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s" });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error deleting tree:", error);
    res.status(500).json({ error: "Impossible de supprimer l'arbre" });
  }
});
router56.get("/trees/:treeId/nodes", async (req2, res) => {
  try {
    const { treeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const treeWhereFilter = isSuperAdmin2 || !organizationId ? { id: treeId } : { id: treeId, organizationId };
    const tree = await prisma31.treeBranchLeafTree.findFirst({
      where: treeWhereFilter
    });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const nodes = await prisma31.treeBranchLeafNode.findMany({
      where: { treeId },
      include: {
        TreeBranchLeafNodeTable: {
          include: {
            tableColumns: {
              orderBy: { columnIndex: "asc" }
            },
            tableRows: {
              orderBy: { rowIndex: "asc" }
            }
          }
        }
      },
      orderBy: [
        { order: "asc" },
        { createdAt: "asc" }
      ]
    });
    const reconstructedNodes = nodes.map((node) => buildResponseFromColumns2(node));
    const nodesWithTooltips = reconstructedNodes.filter(
      (node) => node.text_helpTooltipType && node.text_helpTooltipType !== "none"
    );
    if (nodesWithTooltips.length > 0) {
    }
    res.json(reconstructedNodes);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching nodes:", error);
    res.status(500).json({ error: "Impossible de r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rer les n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cuds" });
  }
});
router56.get("/trees/:treeId/repeater-fields", async (req2, res) => {
  try {
    const { treeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const treeWhereFilter = isSuperAdmin2 || !organizationId ? { id: treeId } : { id: treeId, organizationId };
    const tree = await prisma31.treeBranchLeafTree.findFirst({
      where: treeWhereFilter
    });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const allNodesRaw = await prisma31.treeBranchLeafNode.findMany({
      where: { treeId }
    });
    const allNodes = allNodesRaw.map((node) => buildResponseFromColumns2(node));
    const _nodesById = new Map(allNodes.map((n) => [n.id, n]));
    const repeaterFields = [];
    for (const node of allNodes) {
      const metadata = node.metadata;
      if (!metadata?.repeater) continue;
      const repeaterMeta = metadata.repeater;
      const templateNodeIds = repeaterMeta.templateNodeIds || [];
      const _templateNodeLabels = repeaterMeta.templateNodeLabels || {};
      const physicalChildren = allNodes.filter((child) => {
        if (child.parentId !== node.id) return false;
        const childMeta = child.metadata;
        return childMeta?.sourceTemplateId && templateNodeIds.includes(childMeta.sourceTemplateId);
      });
      if (physicalChildren.length === 0) {
        continue;
      }
      for (const child of physicalChildren) {
        repeaterFields.push({
          id: child.id,
          // √É∆í√Ç¬¢√É‚Ä¶√¢‚Ç¨≈ì√É¬¢√¢‚Äö¬¨√Ç¬¶ VRAI UUID de l'enfant physique
          label: `${node.label} / ${child.label}`,
          // Label complet affich√É∆í√Ü‚Äô√É‚Äö√Ç¬©
          repeaterLabel: node.label,
          // Label du repeater parent
          repeaterParentId: node.id,
          // ID du n√É∆í√¢‚Ç¨¬¶√É¬¢√¢‚Äö¬¨√Ö‚Äúud repeater
          nodeLabel: child.label,
          // Label de l'enfant
          nodeId: child.id
          // √É∆í√Ç¬¢√É‚Ä¶√¢‚Ç¨≈ì√É¬¢√¢‚Äö¬¨√Ç¬¶ VRAI UUID de l'enfant
        });
      }
    }
    res.json(repeaterFields);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching repeater fields:", error);
    res.status(500).json({ error: "Impossible de r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rer les champs r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9p\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9titeurs" });
  }
});
router56.get("/trees/:treeId/shared-references", async (req2, res) => {
  try {
    const { treeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const treeWhereFilter = isSuperAdmin2 || !organizationId ? { id: treeId } : { id: treeId, organizationId };
    const tree = await prisma31.treeBranchLeafTree.findFirst({
      where: treeWhereFilter
    });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const sharedReferencesRaw = await prisma31.treeBranchLeafNode.findMany({
      where: {
        treeId,
        isSharedReference: true
      }
    });
    const sharedReferences = sharedReferencesRaw.map((node) => {
      const response = buildResponseFromColumns2(node);
      return {
        id: response.id,
        label: response.label || response.sharedReferenceName || "R\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9f\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rence sans nom",
        category: response.sharedReferenceCategory,
        description: response.sharedReferenceDescription,
        type: response.type,
        nodeLabel: response.label,
        nodeId: response.id
      };
    });
    res.json(sharedReferences);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching shared references:", error);
    res.status(500).json({ error: "Impossible de r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rer les r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9f\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rences partag\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9es" });
  }
});
router56.post("/nodes/:nodeId/duplicate-templates", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { templateNodeIds } = req2.body;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    if (!Array.isArray(templateNodeIds) || templateNodeIds.length === 0) {
      return res.status(400).json({ error: "templateNodeIds doit \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xAAtre un tableau non vide" });
    }
    const parentNode = await prisma31.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      include: { TreeBranchLeafTree: true }
    });
    if (!parentNode) {
      return res.status(404).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud parent non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    if (!isSuperAdmin2 && organizationId && parentNode.TreeBranchLeafTree.organizationId !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s non autoris\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 cet arbre" });
    }
    const existingChildrenByParent = await prisma31.treeBranchLeafNode.findMany({
      where: { parentId: nodeId },
      select: { id: true, metadata: true, parentId: true }
    });
    const newTemplateIds = templateNodeIds;
    const requestedNodes = await prisma31.treeBranchLeafNode.findMany({
      where: {
        id: { in: newTemplateIds },
        treeId: parentNode.treeId
      },
      select: { id: true, label: true, type: true, metadata: true }
    });
    if (requestedNodes.length === 0) {
      return res.status(404).json({ error: "Aucun template trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const resolveBaseTemplateId = (n) => {
      const md = n.metadata ?? {};
      const sourceTemplateId = md.sourceTemplateId;
      return typeof sourceTemplateId === "string" && sourceTemplateId.length > 0 ? sourceTemplateId : n.id;
    };
    const baseTemplateIdsInOrder = newTemplateIds.map((id) => {
      const found = requestedNodes.find((n) => n.id === id);
      return found ? resolveBaseTemplateId(found) : id;
    });
    const uniqueBaseTemplateIds = Array.from(new Set(baseTemplateIdsInOrder));
    const baseTemplateNodes = await prisma31.treeBranchLeafNode.findMany({
      where: {
        id: { in: uniqueBaseTemplateIds },
        treeId: parentNode.treeId
      },
      select: { id: true, label: true, type: true, metadata: true }
    });
    const baseById = new Map(baseTemplateNodes.map((n) => [n.id, n]));
    const templatesToDuplicateInOrder = baseTemplateIdsInOrder.map((baseId) => baseById.get(baseId)).filter((n) => Boolean(n));
    if (templatesToDuplicateInOrder.length === 0) {
      return res.status(404).json({ error: "Aucun template de base trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const duplicatedSummaries = [];
    const extractNumericSuffix3 = (candidate) => {
      if (typeof candidate === "number" && Number.isFinite(candidate)) return candidate;
      if (typeof candidate === "string" && /^\d+$/.test(candidate)) return Number(candidate);
      return null;
    };
    const extractSuffixFromId3 = (id) => {
      if (!id) return null;
      const match = /-(\d+)$/.exec(id);
      if (!match) return null;
      const parsed = Number(match[1]);
      return Number.isFinite(parsed) ? parsed : null;
    };
    const copyRootCandidates = await prisma31.treeBranchLeafNode.findMany({
      where: {
        treeId: parentNode.treeId,
        OR: uniqueBaseTemplateIds.map((t) => ({ id: { startsWith: `${t}-` } }))
      },
      select: { id: true, parentId: true }
    });
    let globalMax = 0;
    for (const root of copyRootCandidates) {
      const fromId = extractSuffixFromId3(root.id);
      const resolved = fromId ?? 0;
      if (resolved > globalMax) globalMax = resolved;
    }
    const nextSuffix = globalMax + 1;
    try {
      const sample = copyRootCandidates.slice(0, 10).map((c) => {
        const fromId = extractSuffixFromId3(c.id);
        return { id: c.id, parentId: c.parentId, fromId };
      });
    } catch {
    }
    for (const template of templatesToDuplicateInOrder) {
      const baseTemplateId = template.id;
      const copyNumber = nextSuffix;
      const labelSuffix = `-${copyNumber}`;
      const result = await deepCopyNodeInternal(prisma31, req2, template.id, {
        targetParentId: nodeId,
        suffixNum: copyNumber,
        preserveSharedReferences: true,
        isFromRepeaterDuplication: true
      });
      const newRootId = result.root.newId;
      const normalizedCopyLabel = `${template.label || baseTemplateId}-${copyNumber}`;
      await prisma31.treeBranchLeafNode.update({
        where: { id: newRootId },
        data: {
          label: normalizedCopyLabel,
          metadata: {
            ...typeof template.metadata === "object" ? template.metadata : {},
            sourceTemplateId: baseTemplateId,
            duplicatedAt: (/* @__PURE__ */ new Date()).toISOString(),
            duplicatedFromRepeater: nodeId,
            copiedFromNodeId: baseTemplateId,
            copySuffix: copyNumber
          }
        }
      });
      const created = await prisma31.treeBranchLeafNode.findUnique({
        where: { id: newRootId },
        select: { id: true, label: true, type: true, parentId: true }
      });
      if (created) {
        duplicatedSummaries.push({
          id: created.id,
          label: created.label,
          type: created.type,
          parentId: created.parentId,
          sourceTemplateId: baseTemplateId
        });
        try {
          const r = await applySharedReferencesFromOriginalInternal(req2, newRootId);
        } catch (e) {
          console.warn("\xC3\u0192\xC2\xA2\xC3\u2026\xC2\xA1\xC3\u201A\xC2\xA0\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xB8\xC3\u201A\xC2\x8F [DUPLICATE-TEMPLATES] \xC3\u0192\xC6\u2019\xC3\xA2\xE2\u201A\xAC\xC2\xB0chec application des r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9f\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rences partag\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9es pour", newRootId, e);
        }
        try {
          const selectorCopyOptions = {
            nodeIdMap: result.idMap,
            tableCopyCache: /* @__PURE__ */ new Map(),
            tableIdMap: new Map(Object.entries(result.tableIdMap))
            // ? Utiliser le tableIdMap peupl√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ω
          };
          await copySelectorTablesAfterNodeCopy(
            prisma31,
            newRootId,
            template.id,
            selectorCopyOptions,
            copyNumber
          );
        } catch (selectorErr) {
          console.warn("??  [DUPLICATE-TEMPLATES] Erreur lors de la copie des tables des s\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDlecteurs pour", newRootId, selectorErr);
        }
      }
    }
    res.status(201).json({
      duplicated: duplicatedSummaries.map((n) => ({ id: n.id, label: n.label, type: n.type, parentId: n.parentId, sourceTemplateId: n.sourceTemplateId })),
      count: duplicatedSummaries.length
    });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [DUPLICATE-TEMPLATES] Erreur:", error);
    const msg = error instanceof Error ? error.message : String(error);
    res.status(500).json({ error: "Erreur lors de la duplication des templates", details: msg });
  }
});
router56.post("/nodes/:nodeId/deep-copy", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { targetParentId, labelSuffix } = req2.body || {};
    const result = await deepCopyNodeInternal(prisma31, req2, nodeId, { targetParentId });
    const allCopiedNodeIds = [result.root.newId, ...result.displayNodeIds || []];
    console.log(`\u{1F504} [DEEP-COPY] D\xE9clenchement \xE9valuation pour ${allCopiedNodeIds.length} n\u0153uds copi\xE9s:`, allCopiedNodeIds);
    for (const copiedNodeId of allCopiedNodeIds) {
      try {
        const copiedNode = await prisma31.treeBranchLeafNode.findUnique({
          where: { id: copiedNodeId },
          select: {
            id: true,
            label: true,
            treeId: true,
            formulaId: true,
            tableConfig: true,
            data_activeId: true
          }
        });
        if (!copiedNode) continue;
        const needsEvaluation = copiedNode.formulaId || copiedNode.tableConfig && typeof copiedNode.tableConfig === "object";
        if (needsEvaluation) {
          console.log(`\u{1F3AF} [DEEP-COPY] \xC9valuation du n\u0153ud ${copiedNodeId} (${copiedNode.label})`);
          const submissionId = copiedNodeId;
          const evalResult = await evaluateVariableOperation(
            copiedNodeId,
            submissionId,
            prisma31
          );
          if (evalResult.success) {
            console.log(`\u2705 [DEEP-COPY] \xC9valuation r\xE9ussie pour ${copiedNodeId}:`, evalResult.result);
          } else {
            console.warn(`\u26A0\uFE0F [DEEP-COPY] \xC9valuation \xE9chou\xE9e pour ${copiedNodeId}:`, evalResult.error);
          }
        }
      } catch (evalError) {
        console.error(`\u274C [DEEP-COPY] Erreur \xE9valuation n\u0153ud ${copiedNodeId}:`, evalError);
      }
    }
    console.log(`\u2705 [DEEP-COPY] \xC9valuation initiale termin\xE9e pour ${allCopiedNodeIds.length} n\u0153uds`);
    res.json(result);
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [/nodes/:nodeId/deep-copy] Erreur:", error);
    res.status(500).json({ error: "Erreur lors de la copie profonde" });
  }
});
router56.post("/trees/:treeId/nodes", async (req2, res) => {
  try {
    const { treeId } = req2.params;
    const { organizationId } = req2.user;
    const nodeData = req2.body;
    const tree = await prisma31.treeBranchLeafTree.findFirst({
      where: { id: treeId, organizationId }
    });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    if (!nodeData.type || !nodeData.label) {
      return res.status(400).json({ error: "Les champs type et label sont obligatoires" });
    }
    const allowedTypes = [
      "branch",
      // Branche = conteneur hi√É∆í√Ü‚Äô√É‚Äö√Ç¬©rarchique
      "section",
      // Section = groupe de champs calcul√É∆í√Ü‚Äô√É‚Äö√Ç¬©s
      "leaf_field",
      // Champ standard (text, email, etc.)
      "leaf_option",
      // Option pour un champ SELECT
      "leaf_option_field",
      // Option + Champ (combin√É∆í√Ü‚Äô√É‚Äö√Ç¬©) √É∆í√Ç¬¢√É¬¢√¢‚Äö¬¨√Ç¬†√É‚Äö√Ç¬ê ajout√É∆í√Ü‚Äô√É‚Äö√Ç¬© pour d√É∆í√Ü‚Äô√É‚Äö√Ç¬©bloquer O+C
      "leaf_text",
      // Champ texte simple
      "leaf_email",
      // Champ email
      "leaf_phone",
      // Champ t√É∆í√Ü‚Äô√É‚Äö√Ç¬©l√É∆í√Ü‚Äô√É‚Äö√Ç¬©phone
      "leaf_date",
      // Champ date
      "leaf_number",
      // Champ num√É∆í√Ü‚Äô√É‚Äö√Ç¬©rique
      "leaf_checkbox",
      // Case √É∆í√Ü‚Äô√É‚Äö√Ç¬† cocher
      "leaf_select",
      // Liste d√É∆í√Ü‚Äô√É‚Äö√Ç¬©roulante
      "leaf_radio",
      // Boutons radio
      "leaf_repeater"
      // Bloc r√É∆í√Ü‚Äô√É‚Äö√Ç¬©p√É∆í√Ü‚Äô√É‚Äö√Ç¬©table (conteneur de champs r√É∆í√Ü‚Äô√É‚Äö√Ç¬©p√É∆í√Ü‚Äô√É‚Äö√Ç¬©tables)
    ];
    if (!allowedTypes.includes(nodeData.type)) {
      return res.status(400).json({
        error: `Type de n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud non autoris\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9: ${nodeData.type}. Types autoris\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9s: ${allowedTypes.join(", ")}`
      });
    }
    if (nodeData.parentId) {
      const parentNode = await prisma31.treeBranchLeafNode.findFirst({
        where: { id: nodeData.parentId, treeId }
      });
      if (!parentNode) {
        return res.status(400).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud parent non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
      }
      const parentType = parentNode.type;
      const parentSubType = parentNode.subType;
      const childType = nodeData.type;
      const childSubType = nodeData.subType || nodeData.fieldType || "data";
      const validationResult2 = validateParentChildRelation(
        parentType,
        parentSubType,
        childType,
        childSubType
      );
      if (!validationResult2.isValid) {
        const errorMessage = getValidationErrorMessage(
          parentType,
          parentSubType,
          childType,
          childSubType
        );
        return res.status(400).json({
          error: errorMessage
        });
      }
    } else {
      const childType = nodeData.type;
      const childSubType = nodeData.subType || nodeData.fieldType || "data";
      const validationResult2 = validateParentChildRelation(
        "tree",
        "data",
        childType,
        childSubType
      );
      if (!validationResult2.isValid) {
        const errorMessage = getValidationErrorMessage(
          "tree",
          "data",
          childType,
          childSubType
        );
        return res.status(400).json({
          error: errorMessage
        });
      }
    }
    const { randomUUID: randomUUID12 } = await import("crypto");
    const nodeId = randomUUID12();
    const node = await prisma31.treeBranchLeafNode.create({
      data: {
        id: nodeId,
        treeId,
        type: nodeData.type,
        subType: nodeData.subType || nodeData.fieldType || "data",
        label: nodeData.label,
        description: nodeData.description || null,
        parentId: nodeData.parentId || null,
        order: nodeData.order ?? 0,
        isVisible: nodeData.isVisible ?? true,
        isActive: nodeData.isActive ?? true,
        // Par d√É∆í√Ü‚Äô√É‚Äö√Ç¬©faut, AUCUNE capacit√É∆í√Ü‚Äô√É‚Äö√Ç¬© n'est activ√É∆í√Ü‚Äô√É‚Äö√Ç¬©e automatiquement
        hasData: nodeData.hasData ?? false,
        hasFormula: nodeData.hasFormula ?? false,
        hasCondition: nodeData.hasCondition ?? false,
        hasTable: nodeData.hasTable ?? false,
        hasAPI: nodeData.hasAPI ?? false,
        hasLink: nodeData.hasLink ?? false,
        hasMarkers: nodeData.hasMarkers ?? false,
        metadata: nodeData.metadata ?? {},
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    res.status(201).json(node);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error creating node:", error);
    res.status(500).json({ error: "Impossible de cr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9er le n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud" });
  }
});
function mapJSONToColumns(updateData) {
  const columnData = {};
  if (!updateData || typeof updateData !== "object") {
    return columnData;
  }
  const metadata = updateData.metadata && typeof updateData.metadata === "object" ? updateData.metadata : {};
  const fieldConfig = updateData.fieldConfig && typeof updateData.fieldConfig === "object" ? updateData.fieldConfig : {};
  const appearanceConfig = updateData.appearanceConfig && typeof updateData.appearanceConfig === "object" ? updateData.appearanceConfig : {};
  if (Object.keys(appearanceConfig).length > 0) {
    if (appearanceConfig.size) columnData.appearance_size = appearanceConfig.size;
    if (appearanceConfig.width) columnData.appearance_width = appearanceConfig.width;
    if (appearanceConfig.variant) columnData.appearance_variant = appearanceConfig.variant;
    if (appearanceConfig.textSize) columnData.appearance_size = appearanceConfig.textSize;
    if (appearanceConfig.fieldWidth) columnData.appearance_width = appearanceConfig.fieldWidth;
    if (appearanceConfig.fieldVariant) columnData.appearance_variant = appearanceConfig.fieldVariant;
    if (appearanceConfig.helpTooltipType) columnData.text_helpTooltipType = appearanceConfig.helpTooltipType;
    if (appearanceConfig.helpTooltipText) columnData.text_helpTooltipText = appearanceConfig.helpTooltipText;
    if (appearanceConfig.helpTooltipImage) columnData.text_helpTooltipImage = appearanceConfig.helpTooltipImage;
    if (appearanceConfig.collapsible !== void 0) columnData.section_collapsible = appearanceConfig.collapsible;
    if (appearanceConfig.defaultCollapsed !== void 0) columnData.section_defaultCollapsed = appearanceConfig.defaultCollapsed;
    if (appearanceConfig.showChildrenCount !== void 0) columnData.section_showChildrenCount = appearanceConfig.showChildrenCount;
    if (appearanceConfig.columnsDesktop !== void 0) columnData.section_columnsDesktop = appearanceConfig.columnsDesktop;
    if (appearanceConfig.columnsMobile !== void 0) columnData.section_columnsMobile = appearanceConfig.columnsMobile;
    if (appearanceConfig.gutter !== void 0) columnData.section_gutter = appearanceConfig.gutter;
    if (appearanceConfig.maxFileSize !== void 0) columnData.file_maxSize = appearanceConfig.maxFileSize;
    if (appearanceConfig.allowedTypes) columnData.file_allowedTypes = appearanceConfig.allowedTypes;
    if (appearanceConfig.multiple !== void 0) columnData.file_multiple = appearanceConfig.multiple;
    if (appearanceConfig.showPreview !== void 0) columnData.file_showPreview = appearanceConfig.showPreview;
    if (appearanceConfig.visibleToUser !== void 0) columnData.data_visibleToUser = appearanceConfig.visibleToUser;
    if (appearanceConfig.isRequired !== void 0) columnData.isRequired = appearanceConfig.isRequired;
    if (appearanceConfig.prefix !== void 0) columnData.number_prefix = appearanceConfig.prefix || null;
    if (appearanceConfig.suffix !== void 0) columnData.number_suffix = appearanceConfig.suffix || null;
    if (appearanceConfig.unit !== void 0) columnData.number_unit = appearanceConfig.unit || null;
    if (appearanceConfig.decimals !== void 0) columnData.number_decimals = appearanceConfig.decimals;
    if (appearanceConfig.min !== void 0) columnData.number_min = appearanceConfig.min;
    if (appearanceConfig.max !== void 0) columnData.number_max = appearanceConfig.max;
    if (appearanceConfig.step !== void 0) columnData.number_step = appearanceConfig.step;
  }
  if (metadata.appearance && typeof metadata.appearance === "object") {
    const metaAppearance = metadata.appearance;
    if (metaAppearance.size && !columnData.appearance_size) columnData.appearance_size = metaAppearance.size;
    if (metaAppearance.width && !columnData.appearance_width) columnData.appearance_width = metaAppearance.width;
    if (metaAppearance.variant && !columnData.appearance_variant) columnData.appearance_variant = metaAppearance.variant;
  }
  if (metadata.repeater && typeof metadata.repeater === "object") {
    const repeaterMeta = metadata.repeater;
    if ("templateNodeIds" in repeaterMeta) {
      if (Array.isArray(repeaterMeta.templateNodeIds)) {
        columnData.repeater_templateNodeIds = repeaterMeta.templateNodeIds.length > 0 ? JSON.stringify(repeaterMeta.templateNodeIds) : null;
      } else {
        columnData.repeater_templateNodeIds = null;
      }
    }
    if (repeaterMeta.templateNodeLabels && typeof repeaterMeta.templateNodeLabels === "object") {
      columnData.repeater_templateNodeLabels = JSON.stringify(repeaterMeta.templateNodeLabels);
    } else if ("templateNodeLabels" in repeaterMeta) {
      columnData.repeater_templateNodeLabels = null;
    }
    if (repeaterMeta.minItems !== void 0) columnData.repeater_minItems = repeaterMeta.minItems;
    if (repeaterMeta.maxItems !== void 0) columnData.repeater_maxItems = repeaterMeta.maxItems;
    if (repeaterMeta.addButtonLabel) columnData.repeater_addButtonLabel = repeaterMeta.addButtonLabel;
    if (repeaterMeta.buttonSize) columnData.repeater_buttonSize = repeaterMeta.buttonSize;
    if (repeaterMeta.buttonWidth) columnData.repeater_buttonWidth = repeaterMeta.buttonWidth;
    if (repeaterMeta.iconOnly !== void 0) columnData.repeater_iconOnly = repeaterMeta.iconOnly;
  }
  if ("subTabs" in metadata) {
    if (Array.isArray(metadata.subTabs) && metadata.subTabs.length > 0) {
      columnData.subtabs = JSON.stringify(metadata.subTabs);
    } else {
      columnData.subtabs = null;
    }
  }
  if ("subTab" in metadata) {
    const subTabValue = metadata.subTab;
    if (typeof subTabValue === "string" && subTabValue.trim().length > 0) {
      columnData.subtab = subTabValue;
    } else if (Array.isArray(subTabValue) && subTabValue.length > 0) {
      columnData.subtab = JSON.stringify(subTabValue);
    } else {
      columnData.subtab = null;
    }
  }
  const textConfig = metadata.textConfig || fieldConfig.text || fieldConfig.textConfig || {};
  if (Object.keys(textConfig).length > 0) {
    if (textConfig.placeholder) columnData.text_placeholder = textConfig.placeholder;
    if (textConfig.maxLength) columnData.text_maxLength = textConfig.maxLength;
    if (textConfig.minLength) columnData.text_minLength = textConfig.minLength;
    if (textConfig.mask) columnData.text_mask = textConfig.mask;
    if (textConfig.regex) columnData.text_regex = textConfig.regex;
    if (textConfig.rows) columnData.text_rows = textConfig.rows;
  }
  const numberConfig = metadata.numberConfig || fieldConfig.number || fieldConfig.numberConfig || {};
  if (Object.keys(numberConfig).length > 0) {
    if (numberConfig.min !== void 0) columnData.number_min = numberConfig.min;
    if (numberConfig.max !== void 0) columnData.number_max = numberConfig.max;
    if (numberConfig.step !== void 0) columnData.number_step = numberConfig.step;
    if (numberConfig.decimals !== void 0) columnData.number_decimals = numberConfig.decimals;
    if (numberConfig.prefix !== void 0) columnData.number_prefix = numberConfig.prefix || null;
    if (numberConfig.suffix !== void 0) columnData.number_suffix = numberConfig.suffix || null;
    if (numberConfig.unit !== void 0) columnData.number_unit = numberConfig.unit || null;
    if (numberConfig.defaultValue !== void 0) columnData.number_defaultValue = numberConfig.defaultValue;
  }
  const selectConfig = metadata.selectConfig || fieldConfig.select || fieldConfig.selectConfig || {};
  if (Object.keys(selectConfig).length > 0) {
    if (selectConfig.multiple !== void 0) columnData.select_multiple = selectConfig.multiple;
    if (selectConfig.searchable !== void 0) columnData.select_searchable = selectConfig.searchable;
    if (selectConfig.allowClear !== void 0) columnData.select_allowClear = selectConfig.allowClear;
    if (selectConfig.defaultValue) columnData.select_defaultValue = selectConfig.defaultValue;
    if (selectConfig.options) columnData.select_options = selectConfig.options;
  }
  const boolConfig = metadata.boolConfig || fieldConfig.bool || fieldConfig.boolConfig || {};
  if (Object.keys(boolConfig).length > 0) {
    if (boolConfig.trueLabel) columnData.bool_trueLabel = boolConfig.trueLabel;
    if (boolConfig.falseLabel) columnData.bool_falseLabel = boolConfig.falseLabel;
    if (boolConfig.defaultValue !== void 0) columnData.bool_defaultValue = boolConfig.defaultValue;
  }
  const dateConfig = metadata.dateConfig || fieldConfig.date || fieldConfig.dateConfig || {};
  if (Object.keys(dateConfig).length > 0) {
    if (dateConfig.format) columnData.date_format = dateConfig.format;
    if (dateConfig.showTime !== void 0) columnData.date_showTime = dateConfig.showTime;
    if (dateConfig.minDate) columnData.date_minDate = new Date(dateConfig.minDate);
    if (dateConfig.maxDate) columnData.date_maxDate = new Date(dateConfig.maxDate);
  }
  const imageConfig = metadata.imageConfig || fieldConfig.image || fieldConfig.imageConfig || {};
  if (Object.keys(imageConfig).length > 0) {
    if (imageConfig.maxSize) columnData.image_maxSize = imageConfig.maxSize;
    if (imageConfig.ratio) columnData.image_ratio = imageConfig.ratio;
    if (imageConfig.crop !== void 0) columnData.image_crop = imageConfig.crop;
    if (imageConfig.thumbnails) columnData.image_thumbnails = imageConfig.thumbnails;
  }
  if (Object.keys(appearanceConfig).length > 0) {
    if (appearanceConfig.helpTooltipType !== void 0) columnData.text_helpTooltipType = appearanceConfig.helpTooltipType;
    if (appearanceConfig.helpTooltipText !== void 0) columnData.text_helpTooltipText = appearanceConfig.helpTooltipText;
    if (appearanceConfig.helpTooltipImage !== void 0) columnData.text_helpTooltipImage = appearanceConfig.helpTooltipImage;
  }
  if (updateData.fieldType) columnData.fieldType = updateData.fieldType;
  if (updateData.fieldSubType) columnData.fieldSubType = updateData.fieldSubType;
  if (updateData.subType) columnData.fieldSubType = updateData.subType;
  if (updateData.type) columnData.fieldType = updateData.type;
  return columnData;
}
function buildResponseFromColumns2(node) {
  const appearance = {
    size: node.appearance_size || "md",
    width: node.appearance_width || null,
    variant: node.appearance_variant || null,
    // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É¬¢√¢‚Äö¬¨√Ç¬ù√É‚Äö√Ç¬• TOOLTIP FIX : Inclure les champs tooltip dans metadata.appearance
    helpTooltipType: node.text_helpTooltipType || "none",
    helpTooltipText: node.text_helpTooltipText || null,
    helpTooltipImage: node.text_helpTooltipImage || null
  };
  const legacyRepeater = (() => {
    if (node.metadata && typeof node.metadata === "object" && node.metadata.repeater) {
      const legacy = node.metadata.repeater;
      return typeof legacy === "object" && legacy !== null ? legacy : null;
    }
    return null;
  })();
  const repeater = {
    templateNodeIds: (() => {
      if (node.repeater_templateNodeIds) {
        try {
          const parsed = JSON.parse(node.repeater_templateNodeIds);
          return Array.isArray(parsed) ? parsed : [];
        } catch (e) {
          console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [buildResponseFromColumns] Erreur parse repeater_templateNodeIds:", e);
          return [];
        }
      }
      const legacyIds = legacyRepeater?.templateNodeIds;
      if (Array.isArray(legacyIds)) {
        return legacyIds;
      }
      return [];
    })(),
    templateNodeLabels: (() => {
      if (node.repeater_templateNodeLabels) {
        try {
          const parsedLabels = JSON.parse(node.repeater_templateNodeLabels);
          return parsedLabels && typeof parsedLabels === "object" ? parsedLabels : null;
        } catch (e) {
          console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [buildResponseFromColumns] Erreur parse repeater_templateNodeLabels:", e);
        }
      }
      const legacyLabels = legacyRepeater?.templateNodeLabels;
      if (legacyLabels && typeof legacyLabels === "object") {
        return legacyLabels;
      }
      return null;
    })(),
    minItems: node.repeater_minItems ?? legacyRepeater?.minItems ?? 0,
    maxItems: node.repeater_maxItems ?? legacyRepeater?.maxItems ?? null,
    addButtonLabel: node.repeater_addButtonLabel || legacyRepeater?.addButtonLabel || null,
    buttonSize: node.repeater_buttonSize || legacyRepeater?.buttonSize || "middle",
    buttonWidth: node.repeater_buttonWidth || legacyRepeater?.buttonWidth || "auto",
    iconOnly: node.repeater_iconOnly ?? legacyRepeater?.iconOnly ?? false
  };
  const appearanceConfig = {
    size: node.appearance_size || "md",
    variant: node.appearance_variant || "singleline",
    placeholder: node.text_placeholder || "",
    maxLength: node.text_maxLength || 255,
    mask: node.text_mask || "",
    regex: node.text_regex || "",
    helpTooltipType: node.text_helpTooltipType || "none",
    helpTooltipText: node.text_helpTooltipText || null,
    helpTooltipImage: node.text_helpTooltipImage || null
  };
  const fieldConfig = {
    text: {
      placeholder: node.text_placeholder || null,
      maxLength: node.text_maxLength || null,
      minLength: node.text_minLength || null,
      mask: node.text_mask || null,
      regex: node.text_regex || null,
      rows: node.text_rows || 3
    },
    number: {
      min: node.number_min || null,
      max: node.number_max || null,
      step: node.number_step || 1,
      // ?? FIX: Priorit√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ω √É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ω data_precision pour les champs d'affichage (cartes bleues), sinon number_decimals
      decimals: node.data_precision ?? node.number_decimals ?? 0,
      prefix: node.number_prefix || null,
      suffix: node.number_suffix || null,
      unit: node.number_unit ?? node.data_unit ?? null,
      defaultValue: node.number_defaultValue || null
    },
    select: {
      multiple: node.select_multiple || false,
      searchable: node.select_searchable !== false,
      // true par d√É∆í√Ü‚Äô√É‚Äö√Ç¬©faut
      allowClear: node.select_allowClear !== false,
      // true par d√É∆í√Ü‚Äô√É‚Äö√Ç¬©faut
      defaultValue: node.select_defaultValue || null,
      options: node.select_options || []
    },
    bool: {
      trueLabel: node.bool_trueLabel || null,
      falseLabel: node.bool_falseLabel || null,
      defaultValue: node.bool_defaultValue || null
    },
    date: {
      format: node.date_format || "DD/MM/YYYY",
      showTime: node.date_showTime || false,
      minDate: node.date_minDate || null,
      maxDate: node.date_maxDate || null
    },
    image: {
      maxSize: node.image_maxSize || null,
      ratio: node.image_ratio || null,
      crop: node.image_crop || false,
      thumbnails: node.image_thumbnails || null
    }
  };
  Object.keys(fieldConfig).forEach((key2) => {
    const config = fieldConfig[key2];
    const hasValues = Object.values(config).some((val) => val !== null && val !== void 0 && val !== false && val !== 0 && val !== "");
    if (!hasValues) delete fieldConfig[key2];
  });
  const cleanedMetadata = {
    ...node.metadata || {},
    appearance
  };
  if (node.metadata && node.metadata.triggerNodeIds) {
    cleanedMetadata.triggerNodeIds = node.metadata.triggerNodeIds;
  }
  if (node.id === "131a7b51-97d5-4f40-8a5a-9359f38939e8") {
  }
  const metadataWithRepeater = repeater.templateNodeIds && repeater.templateNodeIds.length > 0 ? { ...cleanedMetadata, repeater } : cleanedMetadata;
  if (repeater.templateNodeIds && repeater.templateNodeIds.length > 0) {
  }
  if (node.subtabs) {
    try {
      const parsedSubTabs = JSON.parse(node.subtabs);
      if (Array.isArray(parsedSubTabs)) {
        metadataWithRepeater.subTabs = parsedSubTabs;
      }
    } catch (e) {
      console.error("[buildResponseFromColumns] Erreur parse subtabs:", e);
    }
  }
  if (node.subtab) {
    try {
      let subTabValue = node.subtab;
      if (typeof node.subtab === "string" && node.subtab.startsWith('"')) {
        subTabValue = JSON.parse(node.subtab);
      }
      if (subTabValue && typeof subTabValue === "string") {
        metadataWithRepeater.subTab = subTabValue;
      }
    } catch (e) {
      console.error("[buildResponseFromColumns] Erreur parse subtab:", e);
    }
  }
  const result = {
    ...node,
    metadata: metadataWithRepeater,
    fieldConfig,
    // Ajouter les champs d'interface pour compatibilit√É∆í√Ü‚Äô√É‚Äö√Ç¬©
    appearance,
    appearanceConfig,
    // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É‚Ä¶√Ç¬Ω√É‚Äö√Ç¬Ø CORRECTION : Ajouter appearanceConfig pour l'interface Parameters
    // √É∆í√Ç¬¢√É‚Ä¶√Ç¬°√É‚Äö√Ç¬†√É∆í√Ç¬Ø√É‚Äö√Ç¬∏√É‚Äö√Ç¬è IMPORTANT : fieldType depuis les colonnes d√É∆í√Ü‚Äô√É‚Äö√Ç¬©di√É∆í√Ü‚Äô√É‚Äö√Ç¬©es
    fieldType: node.fieldType || node.type,
    fieldSubType: node.fieldSubType || node.subType,
    // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É¬¢√¢‚Äö¬¨√Ç¬ù√É‚Äö√Ç¬• TOOLTIP FIX : Ajouter les propri√É∆í√Ü‚Äô√É‚Äö√Ç¬©t√É∆í√Ü‚Äô√É‚Äö√Ç¬©s tooltip au niveau racine pour TBL
    text_helpTooltipType: node.text_helpTooltipType,
    text_helpTooltipText: node.text_helpTooltipText,
    text_helpTooltipImage: node.text_helpTooltipImage,
    // üîß AI MEASURE: Colonnes d√©di√©es pour la configuration IA Mesure
    aiMeasure_enabled: node.aiMeasure_enabled ?? false,
    aiMeasure_autoTrigger: node.aiMeasure_autoTrigger ?? true,
    aiMeasure_prompt: node.aiMeasure_prompt || null,
    aiMeasure_keys: node.aiMeasure_keys || null,
    // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É¬¢√¢‚Äö¬¨√Ç¬ù√É‚Äö√Ç¬• TABLES : Inclure les tables avec leurs colonnes/lignes pour le lookup
    tables: node.TreeBranchLeafNodeTable || [],
    // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É¬¢√¢‚Äö¬¨√Ç¬ù√É¬¢√¢‚Äö¬¨√¢‚Ç¨¬ù SHARED REFERENCES : Inclure les r√É∆í√Ü‚Äô√É‚Äö√Ç¬©f√É∆í√Ü‚Äô√É‚Äö√Ç¬©rences partag√É∆í√Ü‚Äô√É‚Äö√Ç¬©es pour les cascades
    sharedReferenceIds: node.sharedReferenceIds || void 0
  };
  try {
    const legacyMetaCaps = node.metadata && typeof node.metadata === "object" ? node.metadata.capabilities : void 0;
    const buildInstances = (raw) => {
      if (!raw) return void 0;
      if (typeof raw === "object" && raw !== null) return raw;
      return void 0;
    };
    const capabilities = {
      // Donn√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ωes dynamiques / variables
      data: node.hasData || node.data_activeId || node.data_instances ? {
        enabled: !!node.hasData,
        activeId: node.data_activeId || null,
        instances: buildInstances(node.data_instances) || {},
        unit: node.data_unit || null,
        precision: typeof node.data_precision === "number" ? node.data_precision : 2,
        exposedKey: node.data_exposedKey || null,
        displayFormat: node.data_displayFormat || null,
        visibleToUser: node.data_visibleToUser === true
      } : void 0,
      // Formules
      formula: node.hasFormula || node.formula_activeId || node.formula_instances ? {
        enabled: !!node.hasFormula,
        activeId: node.formula_activeId || null,
        instances: buildInstances(node.formula_instances) || {},
        tokens: buildInstances(node.formula_tokens) || void 0,
        name: node.formula_name || null
      } : void 0,
      // Table lookup
      table: node.hasTable || node.table_activeId || node.table_instances ? {
        enabled: !!node.hasTable,
        activeId: node.table_activeId || null,
        instances: buildInstances(node.table_instances) || {},
        name: node.table_name || null,
        meta: buildInstances(node.table_meta) || {},
        type: node.table_type || "columns",
        isImported: node.table_isImported === true,
        importSource: node.table_importSource || null,
        columns: Array.isArray(node.table_columns) ? node.table_columns : null,
        rows: Array.isArray(node.table_rows) ? node.table_rows : null
      } : void 0,
      // Select (options statiques ou dynamiques d√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ωj√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ω r√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ωsolues)
      select: node.select_options || node.select_defaultValue ? {
        options: Array.isArray(node.select_options) ? node.select_options : [],
        allowClear: node.select_allowClear !== false,
        multiple: node.select_multiple === true,
        searchable: node.select_searchable !== false,
        defaultValue: node.select_defaultValue || null
      } : void 0,
      // Nombre
      number: node.number_min !== void 0 || node.number_max !== void 0 || node.number_defaultValue !== void 0 ? {
        min: node.number_min ?? null,
        max: node.number_max ?? null,
        step: node.number_step ?? 1,
        // ?? FIX: Priorit√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ω √É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ω data_precision pour les champs d'affichage
        decimals: node.data_precision ?? node.number_decimals ?? 0,
        unit: node.number_unit ?? node.data_unit ?? null,
        prefix: node.number_prefix || null,
        suffix: node.number_suffix || null,
        defaultValue: node.number_defaultValue || null
      } : void 0,
      // Bool√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ωen
      bool: node.bool_trueLabel || node.bool_falseLabel || node.bool_defaultValue !== void 0 ? {
        trueLabel: node.bool_trueLabel || null,
        falseLabel: node.bool_falseLabel || null,
        defaultValue: node.bool_defaultValue ?? null
      } : void 0,
      // Date
      date: node.date_format || node.date_showTime || node.date_minDate || node.date_maxDate ? {
        format: node.date_format || "DD/MM/YYYY",
        showTime: node.date_showTime === true,
        minDate: node.date_minDate || null,
        maxDate: node.date_maxDate || null
      } : void 0,
      // Image
      image: node.image_maxSize || node.image_ratio || node.image_crop || node.image_thumbnails ? {
        maxSize: node.image_maxSize || null,
        ratio: node.image_ratio || null,
        crop: node.image_crop === true,
        thumbnails: node.image_thumbnails || null
      } : void 0,
      // Linking / navigation (simplifi√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ω)
      link: node.link_activeId || node.link_instances ? {
        enabled: !!node.hasLink,
        activeId: node.link_activeId || null,
        instances: buildInstances(node.link_instances) || {},
        mode: node.link_mode || "JUMP",
        name: node.link_name || null,
        carryContext: node.link_carryContext === true,
        params: buildInstances(node.link_params) || {},
        targetNodeId: node.link_targetNodeId || null,
        targetTreeId: node.link_targetTreeId || null
      } : void 0,
      // Markers
      markers: node.markers_activeId || node.markers_instances || node.markers_selectedIds ? {
        enabled: !!node.hasMarkers,
        activeId: node.markers_activeId || null,
        instances: buildInstances(node.markers_instances) || {},
        available: buildInstances(node.markers_available) || {},
        selectedIds: buildInstances(node.markers_selectedIds) || {}
      } : void 0,
      // API (legacy mapping minimal)
      api: node.api_activeId || node.api_instances ? {
        enabled: !!node.hasAPI,
        activeId: node.api_activeId || null,
        instances: buildInstances(node.api_instances) || {},
        bodyVars: buildInstances(node.api_bodyVars) || {},
        name: node.api_name || null
      } : void 0
    };
    Object.keys(capabilities).forEach((key2) => {
      if (capabilities[key2] === void 0) delete capabilities[key2];
    });
    let mergedCaps = capabilities;
    if (legacyMetaCaps && typeof legacyMetaCaps === "object") {
      mergedCaps = { ...legacyMetaCaps, ...capabilities };
    }
    result.capabilities = mergedCaps;
  } catch (e) {
    console.error("? [buildResponseFromColumns] Erreur adaptation legacy capabilities:", e);
  }
  if (node.sharedReferenceIds && node.sharedReferenceIds.length > 0) {
  }
  if (node.text_helpTooltipType && node.text_helpTooltipType !== "none") {
  }
  return result;
}
function removeJSONFromUpdate(updateData) {
  const { metadata, fieldConfig: _fieldConfig, appearanceConfig: _appearanceConfig, ...cleanData } = updateData;
  if (metadata && typeof metadata === "object") {
    const metaObj = metadata;
    const preservedMeta = {};
    if (metaObj.capabilities) {
      preservedMeta.capabilities = metaObj.capabilities;
    }
    if ("subTabs" in metaObj) {
      preservedMeta.subTabs = metaObj.subTabs;
    }
    if ("subTab" in metaObj) {
      preservedMeta.subTab = metaObj.subTab;
    }
    if ("aiMeasure" in metaObj) {
      preservedMeta.aiMeasure = metaObj.aiMeasure;
    }
    if ("repeater" in metaObj) {
      preservedMeta.repeater = metaObj.repeater;
    }
    if ("triggerNodeIds" in metaObj) {
      preservedMeta.triggerNodeIds = metaObj.triggerNodeIds;
    }
    if (Object.keys(preservedMeta).length > 0) {
      return {
        ...cleanData,
        metadata: preservedMeta
      };
    }
  }
  return cleanData;
}
function extractCopySuffixFromId(id) {
  if (!id) return null;
  const m = String(id).match(/-(\d+)$/);
  return m ? m[0] : null;
}
function applyCopySuffix(id, suffix) {
  const base = id.replace(/-(\d+)$/, "");
  return `${base}${suffix}`;
}
function normalizeSharedRefsForCopy(nodeId, updateObj) {
  const suffix = extractCopySuffixFromId(nodeId);
  if (!suffix) return;
  if (typeof updateObj.sharedReferenceId === "string" && updateObj.sharedReferenceId.length > 0) {
    updateObj.sharedReferenceId = applyCopySuffix(updateObj.sharedReferenceId, suffix);
  }
  if (Array.isArray(updateObj.sharedReferenceIds)) {
    const out = [];
    for (const raw of updateObj.sharedReferenceIds) {
      if (typeof raw !== "string" || raw.length === 0) continue;
      out.push(applyCopySuffix(raw, suffix));
    }
    const seen = /* @__PURE__ */ new Set();
    updateObj.sharedReferenceIds = out.filter((id) => seen.has(id) ? false : (seen.add(id), true));
  }
}
var updateOrMoveNode = async (req2, res) => {
  try {
    const { treeId, nodeId } = req2.params;
    const { organizationId } = req2.user;
    const updateData = req2.body || {};
    console.log("\u{1F50D} [updateOrMoveNode] Payload re\xE7u:", {
      nodeId,
      hasTriggerNodeIds: !!updateData.metadata?.triggerNodeIds,
      triggerNodeIds: updateData.metadata?.triggerNodeIds
    });
    const columnData = mapJSONToColumns(updateData);
    const cleanUpdateData = removeJSONFromUpdate(updateData);
    const updateObj = { ...cleanUpdateData, ...columnData };
    console.log("\u{1F50D} [updateOrMoveNode] Apr\xE8s removeJSONFromUpdate:", {
      hasTriggerNodeIds: !!cleanUpdateData.metadata?.triggerNodeIds,
      triggerNodeIds: cleanUpdateData.metadata?.triggerNodeIds
    });
    normalizeSharedRefsForCopy(nodeId, updateObj);
    for (const k of ["markers", "hasMarkers"]) {
      if (k in updateObj) delete updateObj[k];
    }
    const tree = await prisma31.treeBranchLeafTree.findFirst({
      where: { id: treeId, organizationId }
    });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    delete updateObj.id;
    delete updateObj.treeId;
    delete updateObj.createdAt;
    const existingNode = await prisma31.treeBranchLeafNode.findFirst({
      where: { id: nodeId, treeId }
    });
    if (!existingNode) {
      const nodeAnyTree = await prisma31.treeBranchLeafNode.findFirst({
        where: { id: nodeId }
      });
      console.error("? [updateOrMoveNode] N\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDud non trouv\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBD - DEBUG:", {
        nodeId,
        treeId,
        organizationId,
        nodeExistsElsewhere: !!nodeAnyTree,
        nodeActualTreeId: nodeAnyTree?.treeId,
        allNodesInTree: await prisma31.treeBranchLeafNode.count({ where: { treeId } })
      });
      return res.status(404).json({
        error: "N\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDud non trouv\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBD",
        debug: {
          nodeId,
          treeId,
          nodeExistsElsewhere: !!nodeAnyTree,
          nodeActualTreeId: nodeAnyTree?.treeId
        }
      });
    }
    const targetId = updateData.targetId;
    const position = updateData.position;
    let newParentId = updateData.parentId;
    let desiredIndex = void 0;
    if (targetId) {
      const targetNode = await prisma31.treeBranchLeafNode.findFirst({ where: { id: targetId, treeId } });
      if (!targetNode) {
        return res.status(400).json({ error: "Cible de d\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9placement non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
      }
      if (position === "child") {
        newParentId = targetNode.id;
        desiredIndex = void 0;
      } else {
        newParentId = targetNode.parentId || null;
        desiredIndex = -1;
      }
    }
    if (newParentId !== void 0) {
      if (newParentId) {
        const newParentNode = await prisma31.treeBranchLeafNode.findFirst({
          where: { id: newParentId, treeId }
        });
        if (!newParentNode) {
          return res.status(400).json({ error: "Parent non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
        }
        console.log("\u{1F50D} [DEBUG MOVE]", {
          nodeLabel: existingNode.label,
          nodeType: existingNode.type,
          newParentLabel: newParentNode.label,
          newParentType: newParentNode.type,
          newParentId
        });
        if (existingNode.type === "leaf_option") {
          const isSelectField = newParentNode.type.startsWith("leaf_") && newParentNode.subType === "SELECT";
          const isSelectBranch = newParentNode.type === "branch" && newParentNode.parentId !== null;
          if (!isSelectField && !isSelectBranch) {
            return res.status(400).json({
              error: "Les options ne peuvent \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xAAtre d\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9plac\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9es que sous des champs SELECT ou des branches de niveau 2+"
            });
          }
          console.log("\u{1F50D} [DEBUG] Validation pour leaf_:", {
            existingNodeType: existingNode.type,
            newParentNodeType: newParentNode.type,
            newParentId,
            isValidParent: newParentNode.type === "branch" || newParentNode.type.startsWith("leaf_") || newParentNode.type === "tree"
          });
        } else if (existingNode.type.startsWith("leaf_")) {
          console.log("\u{1F50D} [DEBUG MOVE] existingNode:", existingNode.type, "| newParentNode:", newParentNode?.type, "| newParentId:", newParentId);
          const isValidParent = newParentNode.type === "branch" || newParentNode.type === "section" || newParentNode.type.startsWith("leaf_") || newParentNode.type === "tree";
          if (!isValidParent) {
            return res.status(400).json({
              error: "Les champs ne peuvent \xEAtre d\xE9plac\xE9s que sous des branches, sections, autres champs ou ROOT (tree)"
            });
          }
        } else if (existingNode.type === "branch") {
          if (!(newParentNode.type === "tree" || newParentNode.type === "branch")) {
            return res.status(400).json({
              error: "Les branches doivent \xEAtre sous l'arbre ou sous une autre branche"
            });
          }
        }
      } else {
        const canBeAtRoot = existingNode.type === "branch" || existingNode.type.startsWith("leaf_");
        if (!canBeAtRoot) {
          return res.status(400).json({
            error: "Seules les branches et les champs peuvent \xEAtre d\xE9plac\xE9s directement sous ROOT"
          });
        }
      }
    }
    const isMoveOperation = targetId && position || newParentId !== void 0 || typeof updateObj.order === "number";
    if (isMoveOperation) {
      const destinationParentId = newParentId !== void 0 ? newParentId : existingNode.parentId;
      const siblings = await prisma31.treeBranchLeafNode.findMany({
        where: { treeId, parentId: destinationParentId || null, NOT: { id: nodeId } },
        orderBy: [{ order: "asc" }, { createdAt: "asc" }]
      });
      let insertIndex;
      if (targetId && (position === "before" || position === "after")) {
        const idx = siblings.findIndex((s) => s.id === targetId);
        if (idx >= 0) {
          insertIndex = position === "before" ? idx : idx + 1;
        } else {
          insertIndex = siblings.length;
        }
      } else if (position === "child") {
        insertIndex = siblings.length;
      } else if (typeof updateObj.order === "number") {
        insertIndex = Math.min(Math.max(Math.round(updateObj.order), 0), siblings.length);
      } else if (desiredIndex !== void 0 && desiredIndex >= 0) {
        insertIndex = Math.min(Math.max(desiredIndex, 0), siblings.length);
      } else {
        insertIndex = siblings.length;
      }
      const finalOrder = [...siblings.map((s) => s.id)];
      finalOrder.splice(insertIndex, 0, nodeId);
      await prisma31.$transaction(async (tx) => {
        if (destinationParentId !== existingNode.parentId) {
          await tx.treeBranchLeafNode.update({
            where: { id: nodeId },
            data: { parentId: destinationParentId || null, updatedAt: /* @__PURE__ */ new Date() }
          });
        }
        for (let i = 0; i < finalOrder.length; i++) {
          const id = finalOrder[i];
          await tx.treeBranchLeafNode.update({
            where: { id },
            data: { order: i, updatedAt: /* @__PURE__ */ new Date() }
          });
        }
      });
      const updatedNode2 = await prisma31.treeBranchLeafNode.findFirst({ where: { id: nodeId, treeId } });
      const responseData2 = updatedNode2 ? buildResponseFromColumns2(updatedNode2) : updatedNode2;
      return res.json(responseData2);
    }
    if (updateObj.repeater_buttonSize || updateObj.repeater_maxItems !== void 0 || updateObj.repeater_minItems !== void 0) {
      const currentMetadata = existingNode.metadata || {};
      const updatedRepeaterMetadata = {
        ...currentMetadata.repeater || {},
        ...updateObj.repeater_addButtonLabel !== void 0 ? { addButtonLabel: updateObj.repeater_addButtonLabel } : {},
        ...updateObj.repeater_buttonSize !== void 0 ? { buttonSize: updateObj.repeater_buttonSize } : {},
        ...updateObj.repeater_buttonWidth !== void 0 ? { buttonWidth: updateObj.repeater_buttonWidth } : {},
        ...updateObj.repeater_iconOnly !== void 0 ? { iconOnly: updateObj.repeater_iconOnly } : {},
        ...updateObj.repeater_minItems !== void 0 ? { minItems: updateObj.repeater_minItems } : {},
        ...updateObj.repeater_maxItems !== void 0 ? { maxItems: updateObj.repeater_maxItems } : {}
      };
      updateObj.metadata = {
        ...currentMetadata,
        repeater: updatedRepeaterMetadata
      };
      console.warn("\xC3\u0192\xC2\xB0\xC3\u2026\xC2\xB8\xC3\xA2\xE2\u201A\xAC\xC2\x9D\xC3\u201A\xC2\xA5 [updateOrMoveNode] Synchronisation metadata.repeater:", updatedRepeaterMetadata);
    }
    if (updateObj.metadata && typeof updateObj.metadata === "object") {
      const currentMetadata = existingNode.metadata || {};
      const newMetadata = updateObj.metadata;
      if (newMetadata.aiMeasure) {
        const aiConfig = newMetadata.aiMeasure;
        updateObj.aiMeasure_enabled = aiConfig.enabled ?? false;
        updateObj.aiMeasure_autoTrigger = aiConfig.autoTrigger ?? true;
        updateObj.aiMeasure_prompt = aiConfig.customPrompt || null;
        updateObj.aiMeasure_keys = aiConfig.keys && aiConfig.keys.length > 0 ? aiConfig.keys : null;
        console.log("\u{1F4CA} [updateOrMoveNode] AI Measure extrait vers colonnes d\xE9di\xE9es:", {
          enabled: updateObj.aiMeasure_enabled,
          autoTrigger: updateObj.aiMeasure_autoTrigger,
          prompt: updateObj.aiMeasure_prompt,
          keys: updateObj.aiMeasure_keys
        });
        delete newMetadata.aiMeasure;
      }
      updateObj.metadata = {
        ...currentMetadata,
        ...newMetadata
      };
      if (updateObj.metadata.aiMeasure) {
        delete updateObj.metadata.aiMeasure;
      }
      console.log("\u{1F500} [updateOrMoveNode] Fusion metadata:", {
        avant: currentMetadata,
        nouveau: newMetadata,
        resultat: updateObj.metadata
      });
    }
    if ("repeater_templateNodeIds" in updateObj && updateObj.repeater_templateNodeIds === null) {
      const currentMeta = updateObj.metadata || existingNode.metadata || {};
      if (currentMeta.repeater) {
        const { repeater, ...metadataWithoutRepeater } = currentMeta;
        updateObj.metadata = metadataWithoutRepeater;
        console.warn("[updateOrMoveNode] \u{1F5D1}\uFE0F Suppression explicite de metadata.repeater car repeater_templateNodeIds = NULL");
      }
    }
    console.log("\u{1F50D} [updateOrMoveNode] Sauvegarde AI Measure - donn\xE9es envoy\xE9es:", {
      aiMeasure_enabled: updateObj.aiMeasure_enabled,
      aiMeasure_autoTrigger: updateObj.aiMeasure_autoTrigger,
      aiMeasure_prompt: updateObj.aiMeasure_prompt,
      aiMeasure_keys: updateObj.aiMeasure_keys
    });
    await prisma31.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: { ...updateObj, updatedAt: /* @__PURE__ */ new Date() }
    });
    const updatedNode = await prisma31.treeBranchLeafNode.findFirst({ where: { id: nodeId, treeId } });
    console.log("\u{1F50D} [updateOrMoveNode] Sauvegarde AI Measure - donn\xE9es relues:", {
      aiMeasure_enabled: updatedNode?.aiMeasure_enabled,
      aiMeasure_autoTrigger: updatedNode?.aiMeasure_autoTrigger,
      aiMeasure_prompt: updatedNode?.aiMeasure_prompt,
      aiMeasure_keys: updatedNode?.aiMeasure_keys
    });
    const responseData = updatedNode ? buildResponseFromColumns2(updatedNode) : updatedNode;
    return res.json(responseData);
  } catch (error) {
    console.error("[TreeBranchLeaf API] \xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 ERREUR D\xC3\u0192\xC6\u2019\xC3\xA2\xE2\u201A\xAC\xC2\xB0TAILL\xC3\u0192\xC6\u2019\xC3\xA2\xE2\u201A\xAC\xC2\xB0E lors de updateOrMoveNode:", {
      error,
      message: error.message,
      stack: error.stack,
      treeId: req2.params?.treeId,
      nodeId: req2.params?.nodeId,
      updateDataKeys: Object.keys(req2.body || {}),
      organizationId: req2.user?.organizationId
    });
    res.status(500).json({ error: "Impossible de mettre \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 jour le n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud", details: error.message });
  }
};
router56.put("/trees/:treeId/nodes/:nodeId", updateOrMoveNode);
router56.patch("/trees/:treeId/nodes/:nodeId", updateOrMoveNode);
router56.put("/nodes/:nodeId", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    console.log("\u{1F3AF} [PUT /nodes/:nodeId] Requ\xEAte re\xE7ue pour nodeId:", nodeId);
    console.log("\u{1F4CB} [PUT /nodes/:nodeId] Body:", JSON.stringify(req2.body, null, 2));
    const node = await prisma31.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      select: { treeId: true }
    });
    if (!node) {
      return res.status(404).json({ error: "Noeud non trouve" });
    }
    req2.params.treeId = node.treeId;
    return updateOrMoveNode(req2, res);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Erreur PUT /nodes/:nodeId:", error);
    res.status(500).json({ error: "Erreur lors de la mise a jour du noeud", details: error.message });
  }
});
router56.delete("/trees/:treeId/nodes/:nodeId", async (req2, res) => {
  try {
    const { treeId, nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = req2.user;
    const tree = await prisma31.treeBranchLeafTree.findFirst({
      where: { id: treeId }
    });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    if (!isSuperAdmin2 && organizationId && tree.organizationId && tree.organizationId !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const allNodes = await prisma31.treeBranchLeafNode.findMany({ where: { treeId } });
    const childrenByParent = /* @__PURE__ */ new Map();
    for (const n of allNodes) {
      if (!n.parentId) continue;
      const arr = childrenByParent.get(n.parentId) || [];
      arr.push(n.id);
      childrenByParent.set(n.parentId, arr);
    }
    const exists = allNodes.find((n) => n.id === nodeId);
    if (!exists) {
      return res.status(404).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const toDelete = [];
    const queue = [nodeId];
    const depth = /* @__PURE__ */ new Map();
    depth.set(nodeId, 0);
    while (queue.length) {
      const cur = queue.shift();
      toDelete.push(cur);
      const children = childrenByParent.get(cur) || [];
      for (const c of children) {
        depth.set(c, (depth.get(cur) || 0) + 1);
        queue.push(c);
      }
    }
    const referencedIds = /* @__PURE__ */ new Set();
    for (const id of toDelete) {
      const n = allNodes.find((x) => x.id === id);
      if (!n) continue;
      if (n.sharedReferenceId) referencedIds.add(n.sharedReferenceId);
      if (Array.isArray(n.sharedReferenceIds)) n.sharedReferenceIds.forEach((rid) => rid && referencedIds.add(rid));
    }
    toDelete.sort((a, b) => depth.get(b) - depth.get(a));
    const deletedSubtreeIds = [];
    await prisma31.$transaction(async (tx) => {
      for (const id of toDelete) {
        try {
          await tx.treeBranchLeafNode.delete({ where: { id } });
          deletedSubtreeIds.push(id);
        } catch (err) {
          console.warn("[DELETE SUBTREE] Failed to delete node", id, err.message);
        }
      }
    });
    let deletedOrphans = 0;
    const deletedOrphansIds = [];
    let deletedExtra = 0;
    const deletedExtraIds = [];
    if (referencedIds.size > 0) {
      const remaining = await prisma31.treeBranchLeafNode.findMany({ where: { treeId } });
      const stillRef = /* @__PURE__ */ new Set();
      for (const n of remaining) {
        if (n.sharedReferenceId && referencedIds.has(n.sharedReferenceId)) stillRef.add(n.sharedReferenceId);
        if (Array.isArray(n.sharedReferenceIds)) {
          for (const rid of n.sharedReferenceIds) if (referencedIds.has(rid)) stillRef.add(rid);
        }
      }
      const isCopySuffixed = (id) => /-\d+$/.test(id);
      const orphanRoots = Array.from(referencedIds).filter((id) => !stillRef.has(id) && remaining.some((n) => n.id === id) && isCopySuffixed(id));
      if (orphanRoots.length > 0) {
        const byParent = /* @__PURE__ */ new Map();
        for (const n of remaining) {
          if (!n.parentId) continue;
          const arr = byParent.get(n.parentId) || [];
          arr.push(n.id);
          byParent.set(n.parentId, arr);
        }
        const delSet = /* @__PURE__ */ new Set();
        const ddepth = /* @__PURE__ */ new Map();
        for (const rid of orphanRoots) {
          const q = [rid];
          ddepth.set(rid, 0);
          while (q.length) {
            const cur = q.shift();
            if (delSet.has(cur)) continue;
            delSet.add(cur);
            const d = ddepth.get(cur);
            for (const c of byParent.get(cur) || []) {
              ddepth.set(c, d + 1);
              q.push(c);
            }
          }
        }
        const ordered = Array.from(delSet).sort((a, b) => ddepth.get(b) - ddepth.get(a));
        await prisma31.$transaction(async (tx) => {
          for (const id of ordered) {
            await tx.treeBranchLeafNode.delete({ where: { id } });
            deletedOrphans++;
            deletedOrphansIds.push(id);
          }
        });
      }
    }
    try {
      const remainingNodes = await prisma31.treeBranchLeafNode.findMany({ where: { treeId } });
      const nodesToScan = remainingNodes;
      const removedSet = new Set(toDelete);
      const removedRepeaterCopyPairs = /* @__PURE__ */ new Set();
      const removedRepeaterCopyObjects = [];
      const extractSuffixFromLabel = (label) => {
        if (!label) return null;
        const l = String(label);
        const m1 = /\(Copie\s*([0-9]+)\)$/i.exec(l);
        if (m1 && m1[1]) return m1[1];
        const m2 = /[-√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ω√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ω]\s*(\d+)$/i.exec(l);
        if (m2 && m2[1]) return m2[1];
        return null;
      };
      for (const rid of toDelete) {
        const n = allNodes.find((x) => x.id === rid);
        if (!n) continue;
        const dm = n.metadata || {};
        const rId = dm?.duplicatedFromRepeater || n.parentId || null;
        const cs = dm?.copySuffix ?? dm?.suffixNum ?? extractSuffixFromLabel(n.label) ?? null;
        if (rId && cs != null) {
          removedRepeaterCopyPairs.add(`${rId}|${String(cs)}`);
          removedRepeaterCopyObjects.push({ repeaterId: rId, copySuffix: String(cs) });
        } else {
          if (rId || n.label) {
            const fallbackSuffix = cs;
            removedRepeaterCopyObjects.push({ repeaterId: rId, copySuffix: fallbackSuffix });
          }
        }
      }
      const debugDelete = typeof process !== "undefined" && process.env && process.env.DEBUG_TBL_DELETE === "1";
      const extraCandidates = nodesToScan.filter((n) => {
        const meta = n.metadata || {};
        if (meta?.isSumDisplayField === true || n.id.endsWith("-sum-total")) {
          return false;
        }
        const looksLikeDisplay = !!(meta?.autoCreateDisplayNode || meta?.copiedFromNodeId || meta?.fromVariableId || meta?.sourceTemplateId);
        if (!looksLikeDisplay) return false;
        if (removedSet.has(n.id)) return false;
        if (meta.copiedFromNodeId) {
          try {
            const normalizedCopiedFrom = [];
            if (Array.isArray(meta.copiedFromNodeId)) {
              meta.copiedFromNodeId.forEach((v) => {
                if (v) normalizedCopiedFrom.push(String(v));
              });
            } else if (typeof meta.copiedFromNodeId === "string") {
              const s = String(meta.copiedFromNodeId);
              if (s.trim().startsWith("[")) {
                try {
                  const parsed = JSON.parse(s);
                  if (Array.isArray(parsed)) parsed.forEach((v) => {
                    if (v) normalizedCopiedFrom.push(String(v));
                  });
                } catch {
                  normalizedCopiedFrom.push(s);
                }
              } else normalizedCopiedFrom.push(s);
            } else {
              normalizedCopiedFrom.push(String(meta.copiedFromNodeId));
            }
            for (const rid of Array.from(removedSet)) {
              if (normalizedCopiedFrom.includes(String(rid))) {
                return true;
              }
            }
          } catch {
            if (removedSet.has(String(meta.copiedFromNodeId))) {
              return true;
            }
          }
        }
        if (meta.copiedFromNodeId) {
          try {
            const normalizedCopiedFromIds = [];
            if (Array.isArray(meta.copiedFromNodeId)) {
              meta.copiedFromNodeId.forEach((v) => {
                if (!v) return;
                if (typeof v === "object" && v.id) normalizedCopiedFromIds.push(String(v.id));
                else normalizedCopiedFromIds.push(String(v));
                if (debugDelete && looksLikeDisplay && !shouldDelete) {
                }
              });
            } else if (typeof meta.copiedFromNodeId === "string") {
              const s = String(meta.copiedFromNodeId);
              if (s.trim().startsWith("[")) {
                try {
                  const parsed = JSON.parse(s);
                  if (Array.isArray(parsed)) parsed.forEach((v) => {
                    if (!v) return;
                    if (typeof v === "object" && v.id) normalizedCopiedFromIds.push(String(v.id));
                    else normalizedCopiedFromIds.push(String(v));
                  });
                } catch {
                  normalizedCopiedFromIds.push(s);
                }
              } else normalizedCopiedFromIds.push(s);
            } else {
              normalizedCopiedFromIds.push(String(meta.copiedFromNodeId));
            }
            for (const rid of Array.from(removedSet)) {
              if (normalizedCopiedFromIds.includes(String(rid))) {
                return true;
              }
            }
          } catch {
            if (removedSet.has(String(meta.copiedFromNodeId))) {
              return true;
            }
          }
        }
        if (meta.copiedFromNodeId && meta.duplicatedFromRepeater && (meta.copySuffix != null || meta.suffixNum != null)) {
          const key2 = `${meta.duplicatedFromRepeater}|${String(meta.copySuffix ?? meta.suffixNum)}`;
          if (removedRepeaterCopyPairs.has(key2)) {
            return true;
          }
        }
        if (meta?.duplicatedFromRepeater && (meta?.copySuffix != null || meta?.suffixNum != null)) {
          const key2 = `${meta.duplicatedFromRepeater}|${String(meta.copySuffix ?? meta.suffixNum)}`;
          if (removedRepeaterCopyPairs.has(key2)) {
            return true;
          }
        }
        if (meta.fromVariableId) {
          try {
            const normalizedFromVariableIds = [];
            if (Array.isArray(meta.fromVariableId)) {
              meta.fromVariableId.forEach((v) => {
                if (!v) return;
                if (typeof v === "object" && v.id) normalizedFromVariableIds.push(String(v.id));
                else normalizedFromVariableIds.push(String(v));
              });
            } else if (typeof meta.fromVariableId === "string") {
              const s = String(meta.fromVariableId);
              if (s.trim().startsWith("[")) {
                try {
                  const parsed = JSON.parse(s);
                  if (Array.isArray(parsed)) parsed.forEach((v) => {
                    if (!v) return;
                    if (typeof v === "object" && v.id) normalizedFromVariableIds.push(String(v.id));
                    else normalizedFromVariableIds.push(String(v));
                  });
                } catch {
                  normalizedFromVariableIds.push(s);
                }
              } else {
                normalizedFromVariableIds.push(s);
              }
            } else {
              normalizedFromVariableIds.push(String(meta.fromVariableId));
            }
            for (const rid of Array.from(removedSet)) {
              if (normalizedFromVariableIds.some((v) => String(v).includes(String(rid)))) {
                return true;
              }
            }
          } catch {
            for (const rid of Array.from(removedSet)) {
              if (String(meta.fromVariableId).includes(String(rid))) {
                return true;
              }
            }
          }
        }
        if (!meta?.duplicatedFromRepeater && !meta?.copiedFromNodeId && !meta?.fromVariableId && (!meta?.copySuffix && !meta?.suffixNum)) {
          const label = String(n.label || "");
          for (const obj of removedRepeaterCopyObjects) {
            if (!obj.repeaterId || !obj.copySuffix) continue;
            if (n.parentId === obj.repeaterId) {
              const reCopie = new RegExp(`\\\\(Copie\\\\s*${obj.copySuffix}\\\\)$`, "i");
              const reDash = new RegExp(`-${obj.copySuffix}$`);
              if (reCopie.test(label) || reDash.test(label)) {
                return true;
              }
            }
          }
        }
        return false;
      });
      if (extraCandidates.length > 0) {
        const byParent = /* @__PURE__ */ new Map();
        for (const n of remainingNodes) {
          if (!n.parentId) continue;
          const arr = byParent.get(n.parentId) || [];
          arr.push(n.id);
          byParent.set(n.parentId, arr);
        }
        const delSet = /* @__PURE__ */ new Set();
        const ddepth = /* @__PURE__ */ new Map();
        for (const cand of extraCandidates) {
          const q = [cand.id];
          ddepth.set(cand.id, 0);
          while (q.length) {
            const cur = q.shift();
            if (delSet.has(cur)) continue;
            delSet.add(cur);
            const d = ddepth.get(cur);
            for (const c of byParent.get(cur) || []) {
              ddepth.set(c, d + 1);
              q.push(c);
            }
          }
        }
        const ordered = Array.from(delSet).sort((a, b) => ddepth.get(b) - ddepth.get(a));
        await prisma31.$transaction(async (tx) => {
          for (const id of ordered) {
            try {
              await tx.treeBranchLeafNode.delete({ where: { id } });
              deletedExtra++;
              deletedExtraIds.push(id);
            } catch (e) {
              console.warn("[DELETE EXTRA] Failed to delete node", id, e.message);
            }
          }
        });
      }
    } catch (e) {
      console.warn("[DELETE] Extra cleanup failed", e.message);
    }
    const allDeletedSet = /* @__PURE__ */ new Set([...deletedSubtreeIds, ...deletedOrphansIds, ...deletedExtraIds]);
    const allDeletedIds = Array.from(allDeletedSet);
    try {
      const variablesToCheck = await prisma31.treeBranchLeafNodeVariable.findMany({
        where: {
          nodeId: { in: allDeletedIds }
          // Variables attach√©es aux nodes supprim√©s
        },
        select: { id: true, nodeId: true }
      });
      const varIdsToDelete = [];
      const suffixPattern = /-\d+$/;
      for (const variable of variablesToCheck) {
        if (suffixPattern.test(variable.id)) {
          varIdsToDelete.push(variable.id);
        } else {
        }
      }
      if (varIdsToDelete.length > 0) {
        const deletedVarCount = await prisma31.treeBranchLeafNodeVariable.deleteMany({
          where: { id: { in: varIdsToDelete } }
        });
      } else {
      }
    } catch (varCleanError) {
    }
    try {
      const sumTotalNodeIds = allDeletedIds.map((id) => `${id}-sum-total`);
      const orphanedVariables = await prisma31.treeBranchLeafNodeVariable.deleteMany({
        where: {
          nodeId: { in: sumTotalNodeIds }
        }
      });
      if (orphanedVariables.count > 0) {
        console.log(`[DELETE] \u{1F9F9} Supprim\xE9 ${orphanedVariables.count} variable(s) -sum-total orpheline(s)`);
      }
    } catch (orphanCleanError) {
      console.warn("[DELETE] Erreur nettoyage variables orphelines:", orphanCleanError.message);
    }
    try {
      const remainingNodes = await prisma31.treeBranchLeafNode.findMany({
        where: { treeId },
        select: { id: true, metadata: true }
      });
      for (const node of remainingNodes) {
        const meta = node.metadata;
        if (meta?.isSumDisplayField === true && meta?.sourceNodeId) {
          updateSumDisplayFieldAfterCopyChange(String(meta.sourceNodeId), prisma31).catch((err) => {
            console.warn(`[DELETE] ?? Erreur mise \xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBD jour champ Total ${node.id}:`, err);
          });
        }
      }
    } catch (sumUpdateError) {
      console.warn("[DELETE] Erreur lors de la mise \xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBD jour des champs Total:", sumUpdateError.message);
    }
    res.json({
      success: true,
      message: `Sous-arbre supprim\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBD (${deletedSubtreeIds.length} n\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDud(s)), orphelines supprim\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDes: ${deletedOrphans}`,
      deletedCount: deletedSubtreeIds.length,
      deletedIds: allDeletedIds,
      // merged: subtree + orphan + extra display nodes
      deletedOrphansCount: deletedOrphans,
      deletedOrphansIds,
      deletedExtraCount: deletedExtra,
      deletedExtraIds
    });
    try {
      const remainingAfterFirstPass = await prisma31.treeBranchLeafNode.findMany({ where: { treeId } });
      const deeperDeletedIds = [];
      const removedIdStrings = allDeletedIds.map((i) => String(i));
      const containsRemovedId = (val) => {
        if (val == null) return false;
        if (typeof val === "string") {
          for (const rid of removedIdStrings) {
            if (val === rid) return true;
            if (val.includes(rid)) return true;
          }
          return false;
        }
        if (typeof val === "number" || typeof val === "boolean") return false;
        if (Array.isArray(val)) return val.some((v) => containsRemovedId(v));
        if (typeof val === "object") {
          for (const k of Object.keys(val)) {
            if (containsRemovedId(val[k])) return true;
          }
        }
        return false;
      };
      const extraToDelete = remainingAfterFirstPass.filter((n) => {
        if (!n.metadata) return false;
        const meta = n.metadata;
        if (meta?.isSumDisplayField === true) {
          return false;
        }
        if (n.id.endsWith("-sum-total")) {
          return false;
        }
        try {
          return containsRemovedId(n.metadata);
        } catch {
          return false;
        }
      }).map((x) => x.id);
      if (extraToDelete.length > 0) {
        const dd = [];
        await prisma31.$transaction(async (tx) => {
          for (const id of extraToDelete) {
            try {
              await tx.treeBranchLeafNode.delete({ where: { id } });
              dd.push(id);
            } catch (err) {
              console.warn("[AGGRESSIVE CLEANUP] Failed to delete node", id, err.message);
            }
          }
        });
        if (dd.length > 0) {
        }
      }
    } catch (e) {
      console.warn("[AGGRESSIVE CLEANUP] Failed aggressive metadata scan:", e.message);
    }
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error deleting node subtree:", error);
    res.status(500).json({ error: "Impossible de supprimer le n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud et ses descendants" });
  }
});
router56.get("/nodes/:nodeId", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = req2.user;
    const node = await prisma31.treeBranchLeafNode.findFirst({
      where: { id: nodeId },
      select: {
        id: true,
        treeId: true,
        parentId: true,
        type: true,
        subType: true,
        label: true,
        metadata: true,
        // Colonnes AI Measure d√©di√©es
        aiMeasure_enabled: true,
        aiMeasure_autoTrigger: true,
        aiMeasure_prompt: true,
        aiMeasure_keys: true,
        TreeBranchLeafTree: { select: { organizationId: true } }
      }
    });
    if (!node) return res.status(404).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    const nodeOrg = node.TreeBranchLeafTree?.organizationId;
    const hasOrgCtx = typeof organizationId === "string" && organizationId.length > 0;
    if (!isSuperAdmin2 && hasOrgCtx && nodeOrg && nodeOrg !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    return res.json({
      id: node.id,
      treeId: node.treeId,
      parentId: node.parentId,
      type: node.type,
      subType: node.subType,
      label: node.label,
      metadata: node.metadata,
      // Colonnes AI Measure d√©di√©es
      aiMeasure_enabled: node.aiMeasure_enabled,
      aiMeasure_autoTrigger: node.aiMeasure_autoTrigger,
      aiMeasure_prompt: node.aiMeasure_prompt,
      aiMeasure_keys: node.aiMeasure_keys
    });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching node info:", error);
    res.status(500).json({ error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration du n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud" });
  }
});
router56.get("/nodes/:nodeId/full", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const root = await prisma31.treeBranchLeafNode.findFirst({
      where: { id: nodeId },
      include: { TreeBranchLeafTree: { select: { id: true, organizationId: true } } }
    });
    if (!root) return res.status(404).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud introuvable" });
    if (!isSuperAdmin2 && organizationId && root.TreeBranchLeafTree?.organizationId && root.TreeBranchLeafTree.organizationId !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s non autoris\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const all = await prisma31.treeBranchLeafNode.findMany({ where: { treeId: root.treeId } });
    const byId = new Map(all.map((n) => [n.id, n]));
    const childrenByParent = /* @__PURE__ */ new Map();
    for (const n of all) {
      if (!n.parentId) continue;
      const arr = childrenByParent.get(n.parentId) || [];
      arr.push(n.id);
      childrenByParent.set(n.parentId, arr);
    }
    const collected = /* @__PURE__ */ new Set();
    const queue = [root.id];
    while (queue.length) {
      const cur = queue.shift();
      if (collected.has(cur)) continue;
      collected.add(cur);
      const children = childrenByParent.get(cur) || [];
      for (const c of children) queue.push(c);
    }
    const sharedIds = /* @__PURE__ */ new Set();
    for (const id of collected) {
      const n = byId.get(id);
      if (!n) continue;
      if (n.sharedReferenceId) sharedIds.add(n.sharedReferenceId);
      if (Array.isArray(n.sharedReferenceIds)) for (const rid of n.sharedReferenceIds) sharedIds.add(rid);
    }
    const sharedNodes = sharedIds.size > 0 ? await prisma31.treeBranchLeafNode.findMany({ where: { id: { in: Array.from(sharedIds) } } }) : [];
    const sharedById = new Map(sharedNodes.map((n) => [n.id, n]));
    const nodes = Array.from(collected).map((id) => {
      const node = byId.get(id);
      const response = buildResponseFromColumns2(node);
      const childIds = childrenByParent.get(id) || [];
      const optionChildrenIds = childIds.filter((cid) => (byId.get(cid)?.type || "").toLowerCase() === "leaf_option".toLowerCase());
      const resolvedShared = [];
      if (node.sharedReferenceId && sharedById.has(node.sharedReferenceId)) {
        resolvedShared.push(buildResponseFromColumns2(sharedById.get(node.sharedReferenceId)));
      }
      if (Array.isArray(node.sharedReferenceIds)) {
        for (const rid of node.sharedReferenceIds) {
          if (sharedById.has(rid)) resolvedShared.push(buildResponseFromColumns2(sharedById.get(rid)));
        }
      }
      return {
        ...response,
        childrenIds: childIds,
        optionChildrenIds,
        sharedReferencesResolved: resolvedShared
      };
    });
    res.json({
      rootId: root.id,
      treeId: root.treeId,
      count: nodes.length,
      nodes
    });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [/nodes/:nodeId/full] Erreur:", error);
    res.status(500).json({ error: "Erreur lors de l\xC3\u0192\xC2\xA2\xC3\xA2\xE2\u20AC\u0161\xC2\xAC\xC3\xA2\xE2\u20AC\u017E\xC2\xA2analyse compl\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8te de la branche" });
  }
});
router56.get("/nodes/:nodeId/shared-references", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const node = await prisma31.treeBranchLeafNode.findFirst({
      where: { id: nodeId },
      include: { TreeBranchLeafTree: { select: { id: true, organizationId: true } } }
    });
    if (!node) return res.status(404).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud introuvable" });
    if (!isSuperAdmin2 && organizationId && node.TreeBranchLeafTree?.organizationId && node.TreeBranchLeafTree.organizationId !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s non autoris\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const ids = /* @__PURE__ */ new Set();
    if (node.sharedReferenceId) ids.add(node.sharedReferenceId);
    if (Array.isArray(node.sharedReferenceIds)) for (const rid of node.sharedReferenceIds) ids.add(rid);
    if (ids.size === 0) {
      return res.json({ nodeId, count: 0, shared: { ids: { single: node.sharedReferenceId ?? null, multiple: [] }, resolved: [] } });
    }
    const refs = await prisma31.treeBranchLeafNode.findMany({ where: { id: { in: Array.from(ids) } } });
    const refIds = refs.map((r) => r.id);
    const conditionCounts = await prisma31.treeBranchLeafNodeCondition.groupBy({
      by: ["nodeId"],
      _count: { nodeId: true },
      where: { nodeId: { in: refIds } }
    });
    const condCountByNode = new Map(conditionCounts.map((c) => [c.nodeId, c._count.nodeId]));
    const resolved = refs.map((ref) => {
      const enriched = buildResponseFromColumns2(ref);
      const hasCondFlag = !!ref.hasCondition || (condCountByNode.get(ref.id) || 0) > 0;
      return { ...enriched, isConditional: hasCondFlag, conditionCount: condCountByNode.get(ref.id) || 0 };
    });
    res.json({
      nodeId,
      count: resolved.length,
      shared: {
        ids: {
          single: node.sharedReferenceId ?? null,
          multiple: Array.isArray(node.sharedReferenceIds) ? node.sharedReferenceIds : []
        },
        resolved
      }
    });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [/nodes/:nodeId/shared-references] Erreur:", error);
    res.status(500).json({ error: "Erreur lors de l\xC3\u0192\xC2\xA2\xC3\xA2\xE2\u20AC\u0161\xC2\xAC\xC3\xA2\xE2\u20AC\u017E\xC2\xA2analyse des r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9f\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rences partag\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9es" });
  }
});
async function applySharedReferencesFromOriginalInternal(req2, nodeId) {
  const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
  const copyRoot = await prisma31.treeBranchLeafNode.findFirst({
    where: { id: nodeId },
    include: { TreeBranchLeafTree: { select: { id: true, organizationId: true } } }
  });
  if (!copyRoot) throw new Error("N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud introuvable");
  if (!isSuperAdmin2 && organizationId && copyRoot.TreeBranchLeafTree?.organizationId && copyRoot.TreeBranchLeafTree.organizationId !== organizationId) {
    throw new Error("Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s non autoris\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9");
  }
  const all = await prisma31.treeBranchLeafNode.findMany({ where: { treeId: copyRoot.treeId } });
  const byId = new Map(all.map((n) => [n.id, n]));
  const childrenByParent = /* @__PURE__ */ new Map();
  for (const n of all) {
    if (!n.parentId) continue;
    const arr = childrenByParent.get(n.parentId) || [];
    arr.push(n.id);
    childrenByParent.set(n.parentId, arr);
  }
  const collectedCopyIds = /* @__PURE__ */ new Set();
  const queue = [copyRoot.id];
  while (queue.length) {
    const cur = queue.shift();
    if (collectedCopyIds.has(cur)) continue;
    collectedCopyIds.add(cur);
    for (const c of childrenByParent.get(cur) || []) queue.push(c);
  }
  const originalToCopy = /* @__PURE__ */ new Map();
  for (const id of collectedCopyIds) {
    const n = byId.get(id);
    if (!n) continue;
    const meta = n.metadata || {};
    const origId = String(meta.copiedFromNodeId || "");
    if (origId) originalToCopy.set(origId, n.id);
  }
  if (originalToCopy.size === 0) return { success: true, applied: 0, suffix: 0 };
  const originalIds = Array.from(originalToCopy.keys());
  const originals = await prisma31.treeBranchLeafNode.findMany({ where: { id: { in: originalIds } } });
  const allRefIds = /* @__PURE__ */ new Set();
  for (const orig of originals) {
    if (orig.sharedReferenceId) allRefIds.add(orig.sharedReferenceId);
    if (Array.isArray(orig.sharedReferenceIds)) orig.sharedReferenceIds.forEach((id) => id && allRefIds.add(id));
  }
  const metaRoot = copyRoot.metadata || {};
  let chosenSuffix = typeof metaRoot.copySuffix === "number" ? metaRoot.copySuffix : null;
  if (!chosenSuffix) {
    let maxSuffix = 0;
    const SUFFIX_RE = /^(shared-ref-[A-Za-z0-9_\-]+)-(\d+)$/;
    for (const n of all) {
      const m = typeof n.id === "string" ? n.id.match(SUFFIX_RE) : null;
      if (m) {
        const num = Number(m[2]);
        if (!Number.isNaN(num)) maxSuffix = Math.max(maxSuffix, num);
      }
    }
    chosenSuffix = maxSuffix + 1 || 1;
    await prisma31.treeBranchLeafNode.update({ where: { id: copyRoot.id }, data: { metadata: { ...metaRoot, copySuffix: chosenSuffix } } });
  }
  const refCopyIdByOriginal = /* @__PURE__ */ new Map();
  const desiredIds = Array.from(allRefIds).map((id) => `${id}-${chosenSuffix}`);
  const existingRefCopies = desiredIds.length > 0 ? await prisma31.treeBranchLeafNode.findMany({ where: { id: { in: desiredIds } } }) : [];
  const existingSet = new Set(existingRefCopies.map((n) => n.id));
  const ensureRefCopy = async (origRefId) => {
    const desiredRootId = `${origRefId}-${chosenSuffix}`;
    if (existingSet.has(desiredRootId)) {
      refCopyIdByOriginal.set(origRefId, desiredRootId);
      return desiredRootId;
    }
    const subtreeIds = [];
    const q = [origRefId];
    const seen = /* @__PURE__ */ new Set();
    while (q.length) {
      const cur = q.shift();
      if (seen.has(cur)) continue;
      seen.add(cur);
      subtreeIds.push(cur);
      const kids = childrenByParent.get(cur) || [];
      for (const cid of kids) q.push(cid);
    }
    const origSubtree = subtreeIds.map((id) => byId.get(id)).filter(Boolean);
    const desired = new Set(subtreeIds.map((id) => `${id}-${chosenSuffix}`));
    if (desired.size > 0) {
      const already = await prisma31.treeBranchLeafNode.findMany({ where: { id: { in: Array.from(desired) } } });
      for (const n of already) desired.delete(n.id);
    }
    const idMap = /* @__PURE__ */ new Map();
    for (const id of subtreeIds) idMap.set(id, `${id}-${chosenSuffix}`);
    for (const orig of origSubtree) {
      const newId = idMap.get(orig.id);
      if (!desired.has(newId)) continue;
      const newParentId = orig.parentId ? idMap.get(orig.parentId) ?? null : null;
      const toCreate = {
        id: newId,
        treeId: copyRoot.treeId,
        type: orig.type,
        subType: orig.subType,
        fieldType: orig.fieldType ?? "TEXT",
        label: orig.label,
        description: orig.description,
        parentId: newParentId,
        order: orig.order ?? 9999,
        isVisible: orig.isVisible ?? true,
        isActive: orig.isActive ?? true,
        isRequired: orig.isRequired ?? false,
        isMultiple: orig.isMultiple ?? false,
        // üîß IMPORTANT: pr√©server la table active lors d'une copie (sinon les lookups tombent √† 0/‚àÖ)
        table_activeId: orig.table_activeId ? `${orig.table_activeId}-${chosenSuffix}` : null,
        hasData: false,
        hasFormula: false,
        hasCondition: false,
        hasTable: false,
        hasAPI: false,
        hasLink: false,
        hasMarkers: false,
        isSharedReference: orig.id === origRefId ? true : orig.isSharedReference ?? false,
        sharedReferenceId: null,
        sharedReferenceIds: [],
        sharedReferenceName: orig.sharedReferenceName ?? orig.label ?? null,
        sharedReferenceDescription: orig.sharedReferenceDescription ?? orig.description ?? null,
        // ?? COLONNES LINKED*** : Copier les r√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ωf√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ωrences depuis le n√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ωud original avec IDs suffix√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ωs
        linkedFormulaIds: Array.isArray(orig.linkedFormulaIds) ? orig.linkedFormulaIds.map((id) => `${id}-${chosenSuffix}`).filter(Boolean) : [],
        linkedConditionIds: Array.isArray(orig.linkedConditionIds) ? orig.linkedConditionIds.map((id) => `${id}-${chosenSuffix}`).filter(Boolean) : [],
        linkedTableIds: Array.isArray(orig.linkedTableIds) ? orig.linkedTableIds.map((id) => `${id}-${chosenSuffix}`).filter(Boolean) : [],
        linkedVariableIds: Array.isArray(orig.linkedVariableIds) ? orig.linkedVariableIds.map((id) => `${id}-${chosenSuffix}`).filter(Boolean) : [],
        metadata: { ...orig.metadata || {}, copiedFromNodeId: orig.id },
        updatedAt: /* @__PURE__ */ new Date()
      };
      await prisma31.treeBranchLeafNode.create({ data: toCreate });
      if (Array.isArray(orig.linkedVariableIds) && orig.linkedVariableIds.length > 0) {
        const variableCopyCache = /* @__PURE__ */ new Map();
        const formulaIdMap = /* @__PURE__ */ new Map();
        const conditionIdMap = /* @__PURE__ */ new Map();
        const tableIdMap2 = /* @__PURE__ */ new Map();
        const globalNodeIdMap = new Map([...originalToCopy, ...idMap]);
        for (const originalVarId of orig.linkedVariableIds) {
          try {
            const copyResult = await copyVariableWithCapacities(
              originalVarId,
              chosenSuffix,
              newId,
              // Le nouveau n√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ωud qui poss√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ωde cette variable
              prisma31,
              {
                formulaIdMap,
                conditionIdMap,
                tableIdMap: tableIdMap2,
                nodeIdMap: globalNodeIdMap,
                // Utiliser le mapping global
                variableCopyCache,
                autoCreateDisplayNode: true
              }
            );
            if (copyResult.success) {
            } else {
              console.warn(`  ?? [SHARED-REF] \xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDchec copie variable ${originalVarId}: ${copyResult.error}`);
            }
          } catch (e) {
            console.warn(`  ?? [SHARED-REF] Erreur copie variable ${originalVarId}:`, e.message);
          }
        }
      }
    }
    refCopyIdByOriginal.set(origRefId, desiredRootId);
    return desiredRootId;
  };
  for (const rid of allRefIds) await ensureRefCopy(rid);
  const updates = [];
  let applied = 0;
  for (const orig of originals) {
    const copyId = originalToCopy.get(orig.id);
    const origMultiple = Array.isArray(orig.sharedReferenceIds) ? orig.sharedReferenceIds.filter(Boolean) : [];
    const origSingle = orig.sharedReferenceId ?? null;
    const mappedMultiple = origMultiple.map((id) => refCopyIdByOriginal.get(id) || `${id}-${chosenSuffix}`);
    const mappedSingle = origSingle ? refCopyIdByOriginal.get(origSingle) || `${origSingle}-${chosenSuffix}` : null;
    const finalArray = mappedMultiple.length > 0 ? mappedMultiple : mappedSingle ? [mappedSingle] : [];
    const finalSingle = finalArray.length > 0 ? finalArray[0] : null;
    updates.push(prisma31.treeBranchLeafNode.update({
      where: { id: copyId },
      data: {
        sharedReferenceId: finalSingle,
        sharedReferenceIds: finalArray,
        sharedReferenceName: orig.sharedReferenceName ?? null,
        sharedReferenceDescription: orig.sharedReferenceDescription ?? null,
        isSharedReference: false,
        hasData: orig.hasData,
        updatedAt: /* @__PURE__ */ new Date()
      }
    }));
    applied++;
  }
  await prisma31.$transaction(updates);
  return { success: true, applied, suffix: chosenSuffix };
}
router56.post("/nodes/:nodeId/apply-shared-references-from-original", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const result = await applySharedReferencesFromOriginalInternal(req2, nodeId);
    return res.json(result);
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [/nodes/:nodeId/apply-shared-references-from-original] Erreur:", error);
    res.status(500).json({ error: "Erreur lors de l'application des r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9f\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rences partag\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9es" });
  }
});
router56.post("/nodes/:nodeId/unlink-shared-references", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { deleteOrphans } = req2.body || {};
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const root = await prisma31.treeBranchLeafNode.findFirst({
      where: { id: nodeId },
      include: { TreeBranchLeafTree: { select: { id: true, organizationId: true } } }
    });
    if (!root) return res.status(404).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud introuvable" });
    if (!isSuperAdmin2 && organizationId && root.TreeBranchLeafTree?.organizationId && root.TreeBranchLeafTree.organizationId !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s non autoris\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const all = await prisma31.treeBranchLeafNode.findMany({ where: { treeId: root.treeId } });
    const byId = new Map(all.map((n) => [n.id, n]));
    const childrenByParent = /* @__PURE__ */ new Map();
    for (const n of all) {
      if (!n.parentId) continue;
      const arr = childrenByParent.get(n.parentId) || [];
      arr.push(n.id);
      childrenByParent.set(n.parentId, arr);
    }
    const collected = /* @__PURE__ */ new Set();
    const queue = [root.id];
    while (queue.length) {
      const cur = queue.shift();
      if (collected.has(cur)) continue;
      collected.add(cur);
      for (const c of childrenByParent.get(cur) || []) queue.push(c);
    }
    const referencedIds = /* @__PURE__ */ new Set();
    for (const id of collected) {
      const n = byId.get(id);
      if (!n) continue;
      if (n.sharedReferenceId) referencedIds.add(n.sharedReferenceId);
      if (Array.isArray(n.sharedReferenceIds)) n.sharedReferenceIds.forEach((rid) => rid && referencedIds.add(rid));
    }
    const updates = [];
    for (const id of collected) {
      updates.push(prisma31.treeBranchLeafNode.update({ where: { id }, data: { sharedReferenceId: null, sharedReferenceIds: [] } }));
    }
    await prisma31.$transaction(updates);
    let deletedCount = 0;
    let orphanCandidates = [];
    if (deleteOrphans && referencedIds.size > 0) {
      orphanCandidates = Array.from(referencedIds).filter((id) => byId.has(id));
      const elsewhereRefers = /* @__PURE__ */ new Set();
      for (const n of all) {
        if (collected.has(n.id)) continue;
        if (n.sharedReferenceId && referencedIds.has(n.sharedReferenceId)) elsewhereRefers.add(n.sharedReferenceId);
        if (Array.isArray(n.sharedReferenceIds)) {
          for (const rid of n.sharedReferenceIds) if (referencedIds.has(rid)) elsewhereRefers.add(rid);
        }
      }
      const toDeleteRoots = orphanCandidates.filter((id) => !elsewhereRefers.has(id));
      if (toDeleteRoots.length > 0) {
        const delSet = /* @__PURE__ */ new Set();
        const depth = /* @__PURE__ */ new Map();
        for (const rid of toDeleteRoots) {
          const q = [rid];
          depth.set(rid, 0);
          while (q.length) {
            const cur = q.shift();
            if (delSet.has(cur)) continue;
            delSet.add(cur);
            const d = depth.get(cur);
            for (const c of childrenByParent.get(cur) || []) {
              depth.set(c, d + 1);
              q.push(c);
            }
          }
        }
        const ordered = Array.from(delSet);
        ordered.sort((a, b) => depth.get(b) - depth.get(a));
        await prisma31.$transaction(async (tx) => {
          for (const id of ordered) {
            await tx.treeBranchLeafNode.delete({ where: { id } });
            deletedCount++;
          }
        });
      }
    }
    return res.json({ success: true, unlinked: collected.size, orphanCandidates, deletedOrphans: deletedCount });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [/nodes/:nodeId/unlink-shared-references] Erreur:", error);
    res.status(500).json({ error: "Erreur lors du d\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9lier/suppression des r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9f\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rences partag\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9es" });
  }
});
router56.get("/trees/:treeId/nodes/:nodeId/data", async (req2, res) => {
  try {
    const { treeId, nodeId } = req2.params;
    const { organizationId } = req2.user;
    const tree = await prisma31.treeBranchLeafTree.findFirst({
      where: organizationId ? { id: treeId, organizationId } : { id: treeId }
    });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBD" });
    }
    const node = await prisma31.treeBranchLeafNode.findFirst({
      where: { id: nodeId, treeId },
      select: { id: true, data_activeId: true, linkedVariableIds: true }
    });
    if (!node) {
      return res.status(404).json({ error: "Noeud non trouve" });
    }
    const { variable, ownerNodeId, proxiedFromNodeId } = await resolveNodeVariable(nodeId, node.linkedVariableIds);
    if (variable) {
      const { sourceType, sourceRef, fixedValue, selectedNodeId, exposedKey } = variable;
      if (!sourceType && !sourceRef) {
      }
    } else {
    }
    const usedVariableId = node.data_activeId || variable?.id || null;
    if (variable) {
      return res.json({ ...variable, usedVariableId, ownerNodeId, proxiedFromNodeId });
    }
    return res.json({ usedVariableId, ownerNodeId, proxiedFromNodeId });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching node data:", error);
    res.status(500).json({ error: "Erreur lors de la recuperation de la donnee du noeud" });
  }
});
router56.put("/trees/:treeId/nodes/:nodeId/data", async (req2, res) => {
  try {
    const { treeId, nodeId } = req2.params;
    const { organizationId } = req2.user;
    const {
      exposedKey,
      displayFormat,
      unit,
      precision,
      visibleToUser,
      isReadonly,
      defaultValue,
      metadata,
      // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É‚Ä¶√Ç¬Ω√É‚Äö√Ç¬Ø NOUVEAUX CHAMPS pour sourceType/sourceRef/fixedValue
      sourceType,
      sourceRef,
      fixedValue,
      selectedNodeId
    } = req2.body || {};
    const tree = await prisma31.treeBranchLeafTree.findFirst({
      where: organizationId ? { id: treeId, organizationId } : { id: treeId }
    });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const node = await prisma31.treeBranchLeafNode.findFirst({
      where: {
        id: nodeId,
        treeId
      },
      select: { id: true, label: true, linkedVariableIds: true }
    });
    if (!node) {
      return res.status(404).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const safeExposedKey = typeof exposedKey === "string" && exposedKey.trim() ? exposedKey.trim() : null;
    const displayName = safeExposedKey || node.label || `var_${String(nodeId).slice(0, 4)}`;
    const { variable: previousVariable, ownerNodeId } = await resolveNodeVariable(
      nodeId,
      node.linkedVariableIds
    );
    const targetNodeId = ownerNodeId ?? nodeId;
    const proxiedTargetNodeId = nodeId === targetNodeId ? null : nodeId;
    if (proxiedTargetNodeId) {
    }
    const updated = await prisma31.$transaction(async (tx) => {
      const variable = await tx.treeBranchLeafNodeVariable.upsert({
        where: { nodeId: targetNodeId },
        update: {
          exposedKey: safeExposedKey || void 0,
          displayName,
          displayFormat: typeof displayFormat === "string" ? displayFormat : void 0,
          unit: typeof unit === "string" ? unit : void 0,
          precision: typeof precision === "number" ? precision : void 0,
          visibleToUser: typeof visibleToUser === "boolean" ? visibleToUser : void 0,
          isReadonly: typeof isReadonly === "boolean" ? isReadonly : void 0,
          defaultValue: typeof defaultValue === "string" ? defaultValue : void 0,
          metadata: metadata && typeof metadata === "object" ? metadata : void 0,
          // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É‚Ä¶√Ç¬Ω√É‚Äö√Ç¬Ø NOUVEAUX CHAMPS source
          sourceType: typeof sourceType === "string" ? sourceType : void 0,
          sourceRef: typeof sourceRef === "string" ? sourceRef : void 0,
          fixedValue: typeof fixedValue === "string" ? fixedValue : void 0,
          selectedNodeId: typeof selectedNodeId === "string" ? selectedNodeId : void 0,
          updatedAt: /* @__PURE__ */ new Date()
        },
        create: {
          id: (0, import_crypto19.randomUUID)(),
          nodeId: targetNodeId,
          exposedKey: safeExposedKey || `var_${String(nodeId).slice(0, 4)}`,
          displayName,
          displayFormat: typeof displayFormat === "string" ? displayFormat : "number",
          unit: typeof unit === "string" ? unit : null,
          precision: typeof precision === "number" ? precision : 2,
          visibleToUser: typeof visibleToUser === "boolean" ? visibleToUser : true,
          isReadonly: typeof isReadonly === "boolean" ? isReadonly : false,
          defaultValue: typeof defaultValue === "string" ? defaultValue : null,
          metadata: metadata && typeof metadata === "object" ? metadata : {},
          // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É‚Ä¶√Ç¬Ω√É‚Äö√Ç¬Ø NOUVEAUX CHAMPS source
          sourceType: typeof sourceType === "string" ? sourceType : "fixed",
          sourceRef: typeof sourceRef === "string" ? sourceRef : null,
          fixedValue: typeof fixedValue === "string" ? fixedValue : null,
          selectedNodeId: typeof selectedNodeId === "string" ? selectedNodeId : null,
          updatedAt: /* @__PURE__ */ new Date()
        },
        select: {
          id: true,
          exposedKey: true,
          displayFormat: true,
          unit: true,
          precision: true,
          visibleToUser: true,
          isReadonly: true,
          defaultValue: true,
          metadata: true,
          // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É‚Ä¶√Ç¬Ω√É‚Äö√Ç¬Ø NOUVEAUX CHAMPS source
          sourceType: true,
          sourceRef: true,
          fixedValue: true,
          selectedNodeId: true
        }
      });
      const nodeUpdateData = {
        hasData: true,
        updatedAt: /* @__PURE__ */ new Date(),
        // ?? FIX: Toujours synchroniser unit et precision de la variable vers le n√É∆í√Ç¬Ø√É‚Äö√Ç¬ø√É‚Äö√Ç¬Ωud
        data_unit: variable.unit ?? null,
        data_precision: variable.precision ?? null,
        data_displayFormat: variable.displayFormat ?? null,
        data_exposedKey: variable.exposedKey ?? null,
        data_visibleToUser: variable.visibleToUser ?? true,
        data_activeId: variable.id
      };
      if (variable.sourceRef && variable.sourceRef.startsWith("@table.")) {
        const tableId = variable.sourceRef.replace("@table.", "");
        const instanceConfig = {
          sourceType: variable.sourceType || "tree",
          sourceRef: variable.sourceRef,
          displayFormat: variable.displayFormat || null,
          unit: variable.unit ?? null,
          precision: variable.precision ?? null,
          visibleToUser: variable.visibleToUser ?? true,
          exposedKey: variable.exposedKey || null,
          metadata: {
            sourceType: variable.sourceType || "tree",
            sourceRef: variable.sourceRef,
            fixedValue: variable.fixedValue ?? null,
            selectedNodeId: variable.selectedNodeId ?? null,
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
          }
        };
        nodeUpdateData.data_activeId = tableId;
        nodeUpdateData.data_instances = { [tableId]: instanceConfig };
        nodeUpdateData.table_activeId = tableId;
        nodeUpdateData.table_instances = { [tableId]: instanceConfig };
        nodeUpdateData.hasTable = true;
      }
      const nodesToUpdate = /* @__PURE__ */ new Set([targetNodeId]);
      if (nodeId !== targetNodeId) {
        nodesToUpdate.add(nodeId);
      }
      for (const target of nodesToUpdate) {
        await tx.treeBranchLeafNode.update({
          where: { id: target },
          data: nodeUpdateData
        });
      }
      try {
        await addToNodeLinkedField7(tx, targetNodeId, "linkedVariableIds", [variable.id]);
        if (nodeId !== targetNodeId) {
          await addToNodeLinkedField7(tx, nodeId, "linkedVariableIds", [variable.id]);
        }
      } catch (e) {
        console.warn("[TreeBranchLeaf API] Warning updating owner linkedVariableIds:", e.message);
      }
      if (variable.sourceRef) {
        try {
          await linkVariableToAllCapacityNodes(tx, variable.id, variable.sourceRef);
        } catch (e) {
          console.warn(`?? [TreeBranchLeaf API] \xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDchec liaison automatique linkedVariableIds pour ${variable.id}:`, e.message);
        }
      }
      try {
        const getReferencedIds = async (varData) => {
          const ids = /* @__PURE__ */ new Set();
          if (!varData) return ids;
          const { sourceRef: sourceRef2, metadata: metadata2 } = varData;
          if (metadata2?.selectedNodeId) {
            ids.add(normalizeRefId2(metadata2.selectedNodeId));
          }
          const parsedRef = parseSourceRef(sourceRef2);
          if (parsedRef) {
            if (parsedRef.type === "formula") {
              const formula = await tx.treeBranchLeafNodeFormula.findUnique({ where: { id: parsedRef.id }, select: { tokens: true } });
              if (formula) {
                extractNodeIdsFromTokens2(formula.tokens).forEach((id) => ids.add(normalizeRefId2(id)));
              }
            } else if (parsedRef.type === "condition") {
              const condition = await tx.treeBranchLeafNodeCondition.findUnique({ where: { id: parsedRef.id }, select: { conditionSet: true } });
              if (condition) {
                extractNodeIdsFromConditionSet2(condition.conditionSet).forEach((id) => ids.add(normalizeRefId2(id)));
              }
            } else {
              ids.add(normalizeRefId2(parsedRef.id));
            }
          } else if (sourceRef2) {
            ids.add(normalizeRefId2(sourceRef2));
          }
          return ids;
        };
        const oldIds = await getReferencedIds(previousVariable);
        const newIds = await getReferencedIds(variable);
        const idsToAdd = [...newIds].filter((id) => !oldIds.has(id));
        const idsToRemove = [...oldIds].filter((id) => !newIds.has(id));
        if (idsToAdd.length > 0) {
          for (const refId of idsToAdd) {
            await addToNodeLinkedField7(tx, refId, "linkedVariableIds", [variable.id]);
          }
        }
        if (idsToRemove.length > 0) {
          for (const refId of idsToRemove) {
            await removeFromNodeLinkedField(tx, refId, "linkedVariableIds", [variable.id]);
          }
        }
        const getNodeReferencedVariableIds = async (varData) => {
          const variableIds = /* @__PURE__ */ new Set();
          const referencedNodeIds = await getReferencedIds(varData);
          for (const refNodeId of referencedNodeIds) {
            const refVariable = await tx.treeBranchLeafNodeVariable.findUnique({
              where: { nodeId: refNodeId },
              select: { id: true }
            });
            if (refVariable) {
              variableIds.add(refVariable.id);
            }
          }
          return variableIds;
        };
        const oldVariableRefs = await getNodeReferencedVariableIds(previousVariable);
        const newVariableRefs = await getNodeReferencedVariableIds(variable);
        const variableIdsToAdd = [...newVariableRefs].filter((id) => !oldVariableRefs.has(id));
        const variableIdsToRemove = [...oldVariableRefs].filter((id) => !newVariableRefs.has(id));
        if (variableIdsToAdd.length > 0) {
          await addToNodeLinkedField7(tx, targetNodeId, "linkedVariableIds", variableIdsToAdd);
        }
        if (variableIdsToRemove.length > 0) {
          await removeFromNodeLinkedField(tx, targetNodeId, "linkedVariableIds", variableIdsToRemove);
        }
        try {
          const nodeData = await tx.treeBranchLeafNode.findUnique({
            where: { id: targetNodeId },
            select: { linkedTableIds: true }
          });
          if (nodeData && nodeData.linkedTableIds && nodeData.linkedTableIds.length > 0) {
            for (const tableId of nodeData.linkedTableIds) {
              const table = await tx.treeBranchLeafNodeTable.findUnique({
                where: { id: tableId },
                select: {
                  id: true,
                  name: true,
                  nodeId: true,
                  lookupSelectColumn: true,
                  lookupDisplayColumns: true
                }
              });
              if (table) {
                const selectConfigsUsingTable = await tx.treeBranchLeafSelectConfig.findMany({
                  where: { tableReference: table.id },
                  select: { nodeId: true }
                });
                if (selectConfigsUsingTable.length > 0) {
                  for (const config of selectConfigsUsingTable) {
                    const selectNode = await tx.treeBranchLeafNode.findUnique({
                      where: { id: config.nodeId },
                      select: {
                        id: true,
                        label: true,
                        linkedVariableIds: true
                      }
                    });
                    if (selectNode) {
                      const currentLinkedIds = selectNode.linkedVariableIds || [];
                      if (!currentLinkedIds.includes(variable.id)) {
                        const updatedLinkedIds = [...currentLinkedIds, variable.id];
                        await tx.treeBranchLeafNode.update({
                          where: { id: selectNode.id },
                          data: {
                            linkedVariableIds: updatedLinkedIds,
                            updatedAt: /* @__PURE__ */ new Date()
                          }
                        });
                      } else {
                      }
                    }
                  }
                }
              }
            }
          }
        } catch (e) {
          console.warn("[TreeBranchLeaf API] Warning updating lookup linkedVariableIds:", e.message);
        }
      } catch (e) {
        console.warn("[TreeBranchLeaf API] Warning updating inverse linkedVariableIds:", e.message);
      }
      return variable;
    });
    const ownerIdForResponse = targetNodeId;
    const proxiedNodeIdForResponse = proxiedTargetNodeId;
    try {
      const nodeAfter = await prisma31.treeBranchLeafNode.findUnique({
        where: { id: nodeId },
        select: { data_activeId: true }
      });
      const usedVariableId = nodeAfter?.data_activeId || updated.id || null;
      return res.json({ ...updated, usedVariableId, ownerNodeId: ownerIdForResponse, proxiedFromNodeId: proxiedNodeIdForResponse });
    } catch {
      return res.json({ ...updated, ownerNodeId: ownerIdForResponse, proxiedFromNodeId: proxiedNodeIdForResponse });
    }
  } catch (error) {
    const err = error;
    if (err && err.code === "P2002") {
      return res.status(409).json({ error: "La variable expos\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e (exposedKey) existe d\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9j\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0" });
    }
    console.error("[TreeBranchLeaf API] Error updating node data:", error);
    res.status(500).json({ error: "Erreur lors de la mise \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 jour de la donn\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e du n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud" });
  }
});
router56.delete("/trees/:treeId/nodes/:nodeId/data", async (req2, res) => {
  try {
    const { treeId, nodeId } = req2.params;
    const { organizationId } = req2.user;
    const tree = await prisma31.treeBranchLeafTree.findFirst({
      where: organizationId ? { id: treeId, organizationId } : { id: treeId }
    });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const node = await prisma31.treeBranchLeafNode.findFirst({
      where: { id: nodeId, treeId },
      select: { id: true, linkedVariableIds: true }
    });
    if (!node) {
      return res.status(404).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const { variable, ownerNodeId, proxiedFromNodeId } = await resolveNodeVariable(nodeId, node.linkedVariableIds);
    if (!variable || !ownerNodeId) {
      return res.status(200).json({ success: true, message: "Variable d\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9j\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 supprim\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
    }
    await prisma31.treeBranchLeafNodeVariable.delete({
      where: { nodeId: ownerNodeId }
    });
    const nodesToDisable = Array.from(new Set([ownerNodeId, proxiedFromNodeId].filter(Boolean)));
    if (nodesToDisable.length > 0) {
      await prisma31.treeBranchLeafNode.updateMany({
        where: { id: { in: nodesToDisable } },
        data: { hasData: false, updatedAt: /* @__PURE__ */ new Date() }
      });
    }
    try {
      const dependentNodes = await prisma31.treeBranchLeafNode.findMany({
        where: {
          treeId,
          linkedVariableIds: { has: variable.id }
          // On cherche les n√É∆í√¢‚Ç¨¬¶√É¬¢√¢‚Äö¬¨√Ö‚Äúuds qui ont l'ID de notre variable
        },
        select: { id: true, linkedVariableIds: true }
      });
      for (const nodeToClean of dependentNodes) {
        const updatedLinkedIds = nodeToClean.linkedVariableIds.filter((id) => id !== variable.id);
        await prisma31.treeBranchLeafNode.update({
          where: { id: nodeToClean.id },
          data: { linkedVariableIds: updatedLinkedIds }
        });
      }
    } catch (e) {
      console.warn("[DELETE Variable] Avertissement lors du nettoyage des linkedVariableIds:", e.message);
    }
    return res.json({ success: true, message: "Variable supprim\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e avec succ\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s" });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [DELETE Variable] Erreur lors de la suppression:", error);
    res.status(500).json({ error: "Erreur lors de la suppression de la variable" });
  }
});
router56.put("/nodes/:nodeId/conditions", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = req2.user;
    const payload = req2.body ?? {};
    const isObject = payload && typeof payload === "object" && !Array.isArray(payload);
    if (!isObject) {
      return res.status(400).json({ error: "Payload de conditions invalide" });
    }
    const node = await prisma31.treeBranchLeafNode.findFirst({
      where: { id: nodeId },
      select: { id: true, TreeBranchLeafTree: { select: { organizationId: true } } }
    });
    if (!node) {
      return res.status(404).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const nodeOrg = node.TreeBranchLeafTree?.organizationId;
    const hasOrgCtx = typeof organizationId === "string" && organizationId.length > 0;
    if (!isSuperAdmin2 && hasOrgCtx && nodeOrg && nodeOrg !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const updated = await prisma31.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: {
        conditionConfig: payload,
        hasCondition: true,
        updatedAt: /* @__PURE__ */ new Date()
      },
      select: { conditionConfig: true, hasCondition: true }
    });
    return res.json(updated.conditionConfig || {});
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error updating node conditions:", error);
    res.status(500).json({ error: "Erreur lors de la mise \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 jour des conditions du n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud" });
  }
});
router56.get("/nodes/:nodeId/formula", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = req2.user;
    const node = await prisma31.treeBranchLeafNode.findFirst({
      where: { id: nodeId },
      select: {
        formulaConfig: true,
        TreeBranchLeafTree: { select: { organizationId: true } }
      }
    });
    if (!node) {
      return res.status(404).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const nodeOrg = node.TreeBranchLeafTree?.organizationId;
    const hasOrgCtx = typeof organizationId === "string" && organizationId.length > 0;
    if (!isSuperAdmin2 && hasOrgCtx && nodeOrg && nodeOrg !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    return res.json(node.formulaConfig || {});
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching node formula:", error);
    res.status(500).json({ error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration de la formule du n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud" });
  }
});
router56.put("/nodes/:nodeId/formula", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = req2.user;
    const payload = req2.body ?? {};
    const isObject = payload && typeof payload === "object" && !Array.isArray(payload);
    if (!isObject) {
      return res.status(400).json({ error: "Payload de formule invalide" });
    }
    const node = await prisma31.treeBranchLeafNode.findFirst({
      where: { id: nodeId },
      select: { id: true, TreeBranchLeafTree: { select: { organizationId: true } } }
    });
    if (!node) {
      return res.status(404).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const nodeOrg = node.TreeBranchLeafTree?.organizationId;
    const hasOrgCtx = typeof organizationId === "string" && organizationId.length > 0;
    if (!isSuperAdmin2 && hasOrgCtx && nodeOrg && nodeOrg !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const updated = await prisma31.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: {
        formulaConfig: payload,
        hasFormula: true,
        updatedAt: /* @__PURE__ */ new Date()
      },
      select: { formulaConfig: true, hasFormula: true }
    });
    return res.json(updated.formulaConfig || {});
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error updating node formula:", error);
    res.status(500).json({ error: "Erreur lors de la mise \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 jour de la formule du n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud" });
  }
});
router56.get("/nodes/:nodeId/formulas", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const access = await ensureNodeOrgAccess(prisma31, nodeId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) return res.status(access.status).json({ error: access.error });
    const formulas = await prisma31.treeBranchLeafNodeFormula.findMany({
      where: { nodeId },
      orderBy: { createdAt: "asc" }
    });
    return res.json({ formulas });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching node formulas:", error);
    res.status(500).json({ error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration des formules du n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud" });
  }
});
router56.post("/nodes/:nodeId/formulas", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const { name, tokens: tokens2, description, targetProperty, constraintMessage } = req2.body || {};
    const access = await ensureNodeOrgAccess(prisma31, nodeId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) return res.status(access.status).json({ error: access.error });
    if (!name || !Array.isArray(tokens2)) {
      return res.status(400).json({ error: "Name et tokens requis" });
    }
    let uniqueName = String(name);
    let counter = 1;
    while (true) {
      try {
        const existingFormula = await prisma31.treeBranchLeafNodeFormula.findFirst({
          where: {
            nodeId,
            name: uniqueName
          }
        });
        if (!existingFormula) {
          break;
        }
        uniqueName = `${name} (${counter})`;
        counter++;
      } catch (error) {
        console.error("Erreur lors de la v\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rification du nom de formule:", error);
        break;
      }
    }
    const formula = await prisma31.treeBranchLeafNodeFormula.create({
      data: {
        id: (0, import_crypto19.randomUUID)(),
        nodeId,
        organizationId: organizationId || null,
        name: uniqueName,
        tokens: tokens2,
        description: description ? String(description) : null,
        targetProperty: targetProperty ? String(targetProperty) : null,
        // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É¬¢√¢‚Äö¬¨√Ç¬†√É¬¢√¢‚Äö¬¨√Ç¬¢ Propri√É∆í√Ü‚Äô√É‚Äö√Ç¬©t√É∆í√Ü‚Äô√É‚Äö√Ç¬© cible
        constraintMessage: constraintMessage ? String(constraintMessage) : null,
        // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É¬¢√¢‚Äö¬¨√Ç¬†√É¬¢√¢‚Äö¬¨√Ç¬¢ Message de contrainte
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    await prisma31.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: {
        hasFormula: true,
        formula_activeId: formula.id
        // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É‚Ä¶√Ç¬Ω√É‚Äö√Ç¬Ø NOUVEAU : Activer automatiquement la formule
      }
    });
    try {
      await addToNodeLinkedField7(prisma31, nodeId, "linkedFormulaIds", [formula.id]);
      const refIds = Array.from(extractNodeIdsFromTokens2(tokens2));
      for (const refId of refIds) {
        await addToNodeLinkedField7(prisma31, normalizeRefId2(refId), "linkedFormulaIds", [formula.id]);
      }
    } catch (e) {
      console.warn("[TreeBranchLeaf API] Warning updating linkedFormulaIds after create:", e.message);
    }
    return res.status(201).json(formula);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error creating node formula:", error);
    res.status(500).json({ error: "Erreur lors de la cr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ation de la formule" });
  }
});
router56.put("/nodes/:nodeId/formulas/:formulaId", async (req2, res) => {
  try {
    const { nodeId, formulaId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const { name, tokens: tokens2, description, targetProperty, constraintMessage } = req2.body || {};
    const access = await ensureNodeOrgAccess(prisma31, nodeId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) return res.status(access.status).json({ error: access.error });
    const existingFormula = await prisma31.treeBranchLeafNodeFormula.findFirst({
      where: { id: formulaId, nodeId }
    });
    if (!existingFormula) {
      return res.status(404).json({ error: "Formule non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
    }
    const updated = await prisma31.treeBranchLeafNodeFormula.update({
      where: { id: formulaId },
      data: {
        name: name ? String(name) : void 0,
        tokens: Array.isArray(tokens2) ? tokens2 : void 0,
        description: description !== void 0 ? description ? String(description) : null : void 0,
        targetProperty: targetProperty !== void 0 ? targetProperty ? String(targetProperty) : null : void 0,
        // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É¬¢√¢‚Äö¬¨√Ç¬†√É¬¢√¢‚Äö¬¨√Ç¬¢ Propri√É∆í√Ü‚Äô√É‚Äö√Ç¬©t√É∆í√Ü‚Äô√É‚Äö√Ç¬© cible
        constraintMessage: constraintMessage !== void 0 ? constraintMessage ? String(constraintMessage) : null : void 0,
        // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É¬¢√¢‚Äö¬¨√Ç¬†√É¬¢√¢‚Äö¬¨√Ç¬¢ Message de contrainte
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    try {
      const oldRefs = extractNodeIdsFromTokens2(existingFormula.tokens);
      const newRefs = extractNodeIdsFromTokens2(Array.isArray(tokens2) ? tokens2 : existingFormula.tokens);
      const oldSet = new Set(Array.from(oldRefs).map(normalizeRefId2));
      const newSet = new Set(Array.from(newRefs).map(normalizeRefId2));
      const toAdd = Array.from(newSet).filter((id) => !oldSet.has(id));
      const toRemove = Array.from(oldSet).filter((id) => !newSet.has(id));
      if (toAdd.length) {
        for (const refId of toAdd) await addToNodeLinkedField7(prisma31, refId, "linkedFormulaIds", [formulaId]);
      }
      if (toRemove.length) {
        for (const refId of toRemove) await removeFromNodeLinkedField(prisma31, refId, "linkedFormulaIds", [formulaId]);
      }
      await addToNodeLinkedField7(prisma31, nodeId, "linkedFormulaIds", [formulaId]);
    } catch (e) {
      console.warn("[TreeBranchLeaf API] Warning updating inverse linkedFormulaIds after update:", e.message);
    }
    return res.json(updated);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error updating node formula:", error);
    res.status(500).json({ error: "Erreur lors de la mise \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 jour de la formule" });
  }
});
router56.delete("/nodes/:nodeId/formulas/:formulaId", async (req2, res) => {
  try {
    const { nodeId, formulaId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const access = await ensureNodeOrgAccess(prisma31, nodeId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) return res.status(access.status).json({ error: access.error });
    const existingFormula = await prisma31.treeBranchLeafNodeFormula.findFirst({
      where: { id: formulaId, nodeId }
    });
    if (!existingFormula) {
      return res.status(404).json({ error: "Formule non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
    }
    await prisma31.treeBranchLeafNodeFormula.delete({
      where: { id: formulaId }
    });
    try {
      const variableWithFormula = await prisma31.treeBranchLeafNodeVariable.findFirst({
        where: {
          nodeId,
          sourceRef: `node-formula:${formulaId}`
        }
      });
      if (variableWithFormula) {
        await prisma31.treeBranchLeafNodeVariable.delete({
          where: { nodeId }
        });
      }
    } catch (e) {
      console.warn("[TreeBranchLeaf API] Warning deleting associated variable:", e.message);
    }
    try {
      await removeFromNodeLinkedField(prisma31, nodeId, "linkedFormulaIds", [formulaId]);
      const refIds = Array.from(extractNodeIdsFromTokens2(existingFormula.tokens));
      for (const refId of refIds) {
        await removeFromNodeLinkedField(prisma31, normalizeRefId2(refId), "linkedFormulaIds", [formulaId]);
      }
    } catch (e) {
      console.warn("[TreeBranchLeaf API] Warning cleaning linkedFormulaIds after delete:", e.message);
    }
    const remainingFormulas = await prisma31.treeBranchLeafNodeFormula.count({ where: { nodeId } });
    await prisma31.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: { hasFormula: remainingFormulas > 0 }
    });
    return res.json({ success: true, message: "Formule supprim\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e avec succ\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s" });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error deleting node formula:", error);
    res.status(500).json({ error: "Erreur lors de la suppression de la formule" });
  }
});
router56.get("/reusables/formulas", async (req2, res) => {
  try {
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const hasOrg = typeof organizationId === "string" && organizationId.length > 0;
    const whereFilter = isSuperAdmin2 ? {} : {
      OR: [
        { organizationId: null },
        ...hasOrg ? [{ organizationId }] : []
      ]
    };
    const allFormulas = await prisma31.treeBranchLeafNodeFormula.findMany({
      where: whereFilter,
      orderBy: { createdAt: "desc" }
    });
    const nodeIds = [...new Set(allFormulas.map((f) => f.nodeId))];
    const nodes = await prisma31.treeBranchLeafNode.findMany({
      where: { id: { in: nodeIds } },
      select: { id: true, label: true, treeId: true }
    });
    const nodeMap = new Map(nodes.map((n) => [n.id, n]));
    const items = allFormulas.map((f) => {
      const node = nodeMap.get(f.nodeId);
      return {
        ...f,
        type: "node",
        nodeLabel: node?.label || "Noeud inconnu",
        treeId: node?.treeId || null
      };
    });
    return res.json({ items });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error listing all formulas:", error);
    res.status(500).json({ error: "Erreur lors de la recuperation des formules" });
  }
});
router56.get("/reusables/formulas/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const item = await prisma31.treeBranchLeafNodeFormula.findUnique({
      where: { id }
    });
    if (!item) return res.status(404).json({ error: "Formule non trouvee" });
    if (!isSuperAdmin2) {
      if (item.organizationId && item.organizationId !== organizationId) {
        return res.status(403).json({ error: "Acces refuse" });
      }
    }
    const node = await prisma31.treeBranchLeafNode.findUnique({
      where: { id: item.nodeId },
      select: { label: true, treeId: true }
    });
    return res.json({
      ...item,
      type: "node",
      nodeLabel: node?.label || "Noeud inconnu",
      treeId: node?.treeId || null
    });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error getting formula:", error);
    res.status(500).json({ error: "Erreur lors de la recuperation de la formule" });
  }
});
router56.get("/reusables/conditions", async (req2, res) => {
  try {
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const hasOrg = typeof organizationId === "string" && organizationId.length > 0;
    const whereFilter = isSuperAdmin2 ? {} : {
      OR: [
        { organizationId: null },
        ...hasOrg ? [{ organizationId }] : []
      ]
    };
    const allConditions = await prisma31.treeBranchLeafNodeCondition.findMany({
      where: whereFilter,
      orderBy: { createdAt: "desc" }
    });
    const nodeIds = [...new Set(allConditions.map((c) => c.nodeId))];
    const nodes = await prisma31.treeBranchLeafNode.findMany({
      where: { id: { in: nodeIds } },
      select: { id: true, label: true, treeId: true }
    });
    const nodeMap = new Map(nodes.map((n) => [n.id, n]));
    const items = allConditions.map((c) => {
      const node = nodeMap.get(c.nodeId);
      return {
        ...c,
        type: "node",
        nodeLabel: node?.label || "Noeud inconnu",
        treeId: node?.treeId || null,
        nodeId: c.nodeId
      };
    });
    return res.json({ items });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error listing reusable conditions:", error);
    res.status(500).json({ error: "Erreur lors de la recuperation des conditions reutilisables" });
  }
});
router56.get("/reusables/conditions/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const item = await prisma31.treeBranchLeafNodeCondition.findUnique({
      where: { id }
    });
    if (!item) return res.status(404).json({ error: "Condition non trouvee" });
    if (!isSuperAdmin2) {
      if (item.organizationId && item.organizationId !== organizationId) {
        return res.status(403).json({ error: "Acces refuse" });
      }
    }
    const node = await prisma31.treeBranchLeafNode.findUnique({
      where: { id: item.nodeId },
      select: { label: true, treeId: true }
    });
    return res.json({
      ...item,
      type: "node",
      nodeLabel: node?.label || "Noeud inconnu",
      treeId: node?.treeId || null
    });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error getting condition:", error);
    res.status(500).json({ error: "Erreur lors de la recuperation de la condition" });
  }
});
router56.get("/reusables/tables", async (req2, res) => {
  try {
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const hasOrg = typeof organizationId === "string" && organizationId.length > 0;
    const whereFilter = isSuperAdmin2 ? {} : {
      OR: [
        { organizationId: null },
        ...hasOrg ? [{ organizationId }] : []
      ]
    };
    const allTables = await prisma31.treeBranchLeafNodeTable.findMany({
      where: whereFilter,
      orderBy: { createdAt: "desc" }
    });
    const nodeIds = [...new Set(allTables.map((t) => t.nodeId))];
    const nodes = await prisma31.treeBranchLeafNode.findMany({
      where: { id: { in: nodeIds } },
      select: { id: true, label: true, treeId: true }
    });
    const nodeMap = new Map(nodes.map((n) => [n.id, n]));
    const items = allTables.map((t) => {
      const node = nodeMap.get(t.nodeId);
      return {
        id: t.id,
        name: t.name,
        type: t.type,
        description: t.description,
        nodeLabel: node?.label || "Noeud inconnu",
        treeId: node?.treeId || null,
        nodeId: t.nodeId,
        createdAt: t.createdAt,
        updatedAt: t.updatedAt
      };
    });
    return res.json({ items });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error listing reusable tables:", error);
    res.status(500).json({ error: "Erreur lors de la recuperation des tables reutilisables" });
  }
});
router56.get("/nodes/:nodeId/conditions", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const access = await ensureNodeOrgAccess(prisma31, nodeId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) return res.status(access.status).json({ error: access.error });
    const whereClause = { nodeId };
    if (!isSuperAdmin2 && organizationId) {
      whereClause.organizationId = organizationId;
    }
    const conditions = await prisma31.treeBranchLeafNodeCondition.findMany({
      where: whereClause,
      orderBy: { createdAt: "asc" }
    });
    return res.json({ conditions });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching node conditions:", error);
    res.status(500).json({ error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration des conditions du n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud" });
  }
});
router56.post("/evaluate/condition/:conditionId", async (req2, res) => {
  try {
    const { conditionId } = req2.params;
    const { fieldValues = {}, values = {}, submissionId, testMode = true } = req2.body;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const allValues = { ...fieldValues, ...values };
    const condition = await prisma31.treeBranchLeafNodeCondition.findUnique({
      where: { id: conditionId },
      include: {
        TreeBranchLeafNode: {
          select: {
            label: true,
            treeId: true
          }
        }
      }
    });
    if (!condition) {
      return res.status(404).json({ error: "Condition non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
    }
    if (!isSuperAdmin2 && condition.organizationId !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 cette condition" });
    }
    try {
      const { evaluateVariableOperation: evaluateVariableOperation2 } = await Promise.resolve().then(() => (init_operation_interpreter(), operation_interpreter_exports));
      const valueMapLocal = /* @__PURE__ */ new Map();
      Object.entries(allValues).forEach(([nodeId, value]) => {
        valueMapLocal.set(nodeId, value);
      });
      const calculationResult = await evaluateVariableOperation2(
        condition.nodeId,
        submissionId || conditionId,
        prisma31,
        valueMapLocal
      );
      const result = {
        conditionId: condition.id,
        conditionName: condition.name,
        nodeLabel: condition.TreeBranchLeafNode?.label || "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud inconnu",
        operationSource: calculationResult.operationSource,
        operationDetail: calculationResult.operationDetail,
        operationResult: calculationResult.operationResult,
        evaluation: {
          success: true,
          mode: "tbl-prisma",
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          testMode
        }
      };
      return res.json(result);
    } catch (error) {
      console.error("[TBL-PRISMA] \xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 Erreur \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valuation TBL-prisma:", error);
      return res.status(500).json({
        error: "Erreur lors de l'\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valuation TBL-prisma",
        details: error instanceof Error ? error.message : "Erreur inconnue"
      });
    }
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error evaluating condition:", error);
    res.status(500).json({ error: "Erreur lors de l'\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valuation de la condition" });
  }
});
router56.post("/nodes/:nodeId/conditions", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const { name, conditionSet, description } = req2.body || {};
    const access = await ensureNodeOrgAccess(prisma31, nodeId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) return res.status(access.status).json({ error: access.error });
    if (!name || !conditionSet) {
      return res.status(400).json({ error: "Name et conditionSet requis" });
    }
    let uniqueName = String(name);
    let counter = 1;
    while (true) {
      const existingCondition = await prisma31.treeBranchLeafNodeCondition.findFirst({
        where: {
          nodeId,
          name: uniqueName,
          organizationId: organizationId || null
        }
      });
      if (!existingCondition) {
        break;
      }
      uniqueName = `${name} (${counter})`;
      counter++;
      if (counter > 100) {
        uniqueName = `${name} (${Date.now()})`;
        break;
      }
    }
    const condition = await prisma31.treeBranchLeafNodeCondition.create({
      data: {
        id: (0, import_crypto19.randomUUID)(),
        nodeId,
        organizationId: organizationId || null,
        name: uniqueName,
        conditionSet,
        description: description ? String(description) : null,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    await prisma31.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: {
        hasCondition: true,
        condition_activeId: condition.id
        // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É‚Ä¶√Ç¬Ω√É‚Äö√Ç¬Ø NOUVEAU : Activer automatiquement la condition
      }
    });
    try {
      await addToNodeLinkedField7(prisma31, nodeId, "linkedConditionIds", [condition.id]);
      const refIds = Array.from(extractNodeIdsFromConditionSet2(conditionSet));
      for (const refId of refIds) {
        await addToNodeLinkedField7(prisma31, normalizeRefId2(refId), "linkedConditionIds", [condition.id]);
      }
    } catch (e) {
      console.warn("[TreeBranchLeaf API] Warning updating linkedConditionIds after create:", e.message);
    }
    return res.status(201).json(condition);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error creating node condition:", error);
    res.status(500).json({ error: "Erreur lors de la cr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ation de la condition" });
  }
});
router56.put("/nodes/:nodeId/conditions/:conditionId", async (req2, res) => {
  try {
    const { nodeId, conditionId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const { name, conditionSet, description } = req2.body || {};
    const access = await ensureNodeOrgAccess(prisma31, nodeId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) return res.status(access.status).json({ error: access.error });
    const existingCondition = await prisma31.treeBranchLeafNodeCondition.findFirst({
      where: { id: conditionId, nodeId }
    });
    if (!existingCondition) {
      return res.status(404).json({ error: "Condition non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
    }
    const updated = await prisma31.treeBranchLeafNodeCondition.update({
      where: { id: conditionId },
      data: {
        name: name ? String(name) : void 0,
        conditionSet: conditionSet ? conditionSet : void 0,
        description: description !== void 0 ? description ? String(description) : null : void 0,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    try {
      const oldRefs = extractNodeIdsFromConditionSet2(existingCondition.conditionSet);
      const newRefs = extractNodeIdsFromConditionSet2(conditionSet ?? existingCondition.conditionSet);
      const oldSet = new Set(Array.from(oldRefs).map(normalizeRefId2));
      const newSet = new Set(Array.from(newRefs).map(normalizeRefId2));
      const toAdd = Array.from(newSet).filter((id) => !oldSet.has(id));
      const toRemove = Array.from(oldSet).filter((id) => !newSet.has(id));
      if (toAdd.length) {
        for (const refId of toAdd) await addToNodeLinkedField7(prisma31, refId, "linkedConditionIds", [conditionId]);
      }
      if (toRemove.length) {
        for (const refId of toRemove) await removeFromNodeLinkedField(prisma31, refId, "linkedConditionIds", [conditionId]);
      }
      await addToNodeLinkedField7(prisma31, nodeId, "linkedConditionIds", [conditionId]);
    } catch (e) {
      console.warn("[TreeBranchLeaf API] Warning updating inverse linkedConditionIds after update:", e.message);
    }
    return res.json(updated);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error updating node condition:", error);
    res.status(500).json({ error: "Erreur lors de la mise \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 jour de la condition" });
  }
});
router56.delete("/nodes/:nodeId/conditions/:conditionId", async (req2, res) => {
  try {
    const { nodeId, conditionId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const access = await ensureNodeOrgAccess(prisma31, nodeId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) return res.status(access.status).json({ error: access.error });
    const existingCondition = await prisma31.treeBranchLeafNodeCondition.findFirst({
      where: { id: conditionId, nodeId }
    });
    if (!existingCondition) {
      return res.status(404).json({ error: "Condition non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
    }
    await prisma31.treeBranchLeafNodeCondition.delete({
      where: { id: conditionId }
    });
    try {
      const variableWithCondition = await prisma31.treeBranchLeafNodeVariable.findFirst({
        where: {
          nodeId,
          sourceRef: `node-condition:${conditionId}`
        }
      });
      if (variableWithCondition) {
        await prisma31.treeBranchLeafNodeVariable.delete({
          where: { nodeId }
        });
      }
    } catch (e) {
      console.warn("[TreeBranchLeaf API] Warning deleting associated variable:", e.message);
    }
    try {
      await removeFromNodeLinkedField(prisma31, nodeId, "linkedConditionIds", [conditionId]);
      const refIds = Array.from(extractNodeIdsFromConditionSet2(existingCondition.conditionSet));
      for (const refId of refIds) {
        await removeFromNodeLinkedField(prisma31, normalizeRefId2(refId), "linkedConditionIds", [conditionId]);
      }
    } catch (e) {
      console.warn("[TreeBranchLeaf API] Warning cleaning linkedConditionIds after delete:", e.message);
    }
    const remainingConditions = await prisma31.treeBranchLeafNodeCondition.count({ where: { nodeId } });
    await prisma31.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: { hasCondition: remainingConditions > 0 }
    });
    return res.json({ success: true, message: "Condition supprim\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e avec succ\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s" });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error deleting node condition:", error);
    res.status(500).json({ error: "Erreur lors de la suppression de la condition" });
  }
});
router56.get("/tables/:id", async (req2, res) => {
  const { id } = req2.params;
  const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
  const page = parseInt(req2.query.page) || 1;
  const limit = parseInt(req2.query.limit) || 100;
  const offset = (page - 1) * limit;
  try {
    const table = await prisma31.treeBranchLeafNodeTable.findUnique({
      where: { id },
      include: {
        node: {
          select: {
            treeId: true,
            TreeBranchLeafTree: {
              select: {
                organizationId: true
              }
            }
          }
        }
      }
    });
    if (!table) {
      return res.status(404).json({ error: "Table non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
    }
    const tableOrgId = table.node?.TreeBranchLeafTree?.organizationId;
    if (!isSuperAdmin2 && organizationId && tableOrgId !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s non autoris\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 cette table" });
    }
    const rows = await prisma31.treeBranchLeafNodeTableRow.findMany({
      where: { tableId: id },
      orderBy: { rowIndex: "asc" },
      take: limit,
      skip: offset
    });
    res.json({
      ...table,
      rows: rows.map((r) => r.cells),
      // Renvoyer uniquement les donn√É∆í√Ü‚Äô√É‚Äö√Ç¬©es des cellules
      page,
      limit,
      totalRows: table.rowCount,
      totalPages: Math.ceil(table.rowCount / limit)
    });
  } catch (error) {
    console.error(`\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [GET /tables/:id] Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration de la table ${id}:`, error);
    res.status(500).json({ error: "Impossible de r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rer la table" });
  }
});
var isJsonObject = (value) => !!value && typeof value === "object" && !Array.isArray(value);
var jsonClone = (value) => JSON.parse(JSON.stringify(value ?? null));
var readMeta = (value) => {
  if (!value) return {};
  if (!isJsonObject(value)) return {};
  return jsonClone(value);
};
var buildRecordRows = (columns, matrix) => {
  const result = matrix.map((row) => {
    const obj = {};
    columns.forEach((col, index) => {
      obj[col] = index < row.length ? row[index] ?? null : null;
    });
    return obj;
  });
  return result;
};
var normalizeTableInstance = (table) => {
  try {
    const columns = (table.tableColumns || []).sort((a, b) => a.columnIndex - b.columnIndex).map((col) => col.name);
    const rows = (table.tableRows || []).sort((a, b) => a.rowIndex - b.rowIndex).map((row) => {
      let cells;
      if (Array.isArray(row.cells)) {
        cells = row.cells;
      } else if (typeof row.cells === "string") {
        return row.cells;
      } else if (row.cells === null || row.cells === void 0) {
        return "";
      } else {
        cells = [];
      }
      return Array.isArray(cells) && cells.length > 0 ? String(cells[0]) : "";
    });
    const matrix = (table.tableRows || []).sort((a, b) => a.rowIndex - b.rowIndex).map((row) => {
      let cells;
      if (Array.isArray(row.cells)) {
        cells = row.cells;
      } else if (typeof row.cells === "string") {
        return [];
      } else {
        cells = [];
      }
      return Array.isArray(cells) ? cells.slice(1) : [];
    });
    const meta = readMeta(table.meta);
    const result = {
      id: table.id,
      name: table.name,
      description: table.description ?? null,
      type: table.type ?? "columns",
      columns,
      rows,
      matrix,
      data: { matrix },
      records: buildRecordRows(columns, matrix),
      meta,
      order: table.order ?? 0,
      isDefault: Boolean(table.isDefault)
    };
    return result;
  } catch (error) {
    console.error("[normalizeTableInstance] \xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 ERREUR FATALE:", error);
    console.error("[normalizeTableInstance] table.id:", table?.id);
    console.error("[normalizeTableInstance] table structure:", JSON.stringify(table, null, 2));
    throw error;
  }
};
var fetchNormalizedTable = async (nodeId, options = {}, client = prisma31) => {
  const tablesRaw = await client.treeBranchLeafNodeTable.findMany({
    where: { nodeId },
    orderBy: [{ order: "asc" }, { createdAt: "asc" }]
  });
  if (!tablesRaw.length) {
    return null;
  }
  const tables = tablesRaw.map(normalizeTableInstance);
  let target = options.tableId ? tables.find((tbl) => tbl.id === options.tableId) : void 0;
  if (!target) {
    const nodeInfo = await client.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      select: { table_activeId: true }
    });
    if (nodeInfo?.table_activeId) {
      target = tables.find((tbl) => tbl.id === nodeInfo.table_activeId) ?? target;
    }
  }
  const table = target ?? tables[0];
  return { table, tables };
};
async function applyTableFilters(matrix, columns, filters, formValues) {
  if (!filters || filters.length === 0) {
    return matrix.map((_, i) => i);
  }
  const validFilters = filters.filter((f) => f.column && f.valueRef && f.operator);
  if (validFilters.length === 0) {
    return matrix.map((_, i) => i);
  }
  const resolvedFilters = await Promise.all(
    validFilters.map(async (filter) => {
      const value = await resolveFilterValueRef(filter.valueRef, formValues);
      return { ...filter, resolvedValue: value };
    })
  );
  const activeFilters = resolvedFilters.filter((f) => f.resolvedValue !== null && f.resolvedValue !== void 0);
  if (activeFilters.length === 0) {
    return matrix.map((_, i) => i);
  }
  if (activeFilters.length < resolvedFilters.length) {
  }
  const matchingIndices = [];
  for (let rowIndex = 0; rowIndex < matrix.length; rowIndex++) {
    const row = matrix[rowIndex];
    let passesAllFilters = true;
    for (const filter of activeFilters) {
      const columnIndex = columns.indexOf(filter.column);
      if (columnIndex === -1) {
        console.warn(`[applyTableFilters] \xC3\u0192\xC2\xA2\xC3\u2026\xC2\xA1\xC3\u201A\xC2\xA0\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xB8\xC3\u201A\xC2\x8F Colonne "${filter.column}" introuvable dans:`, columns);
        passesAllFilters = false;
        break;
      }
      const cellValue = row[columnIndex];
      const passes = compareFilterValues(cellValue, filter.operator, filter.resolvedValue);
      if (!passes) {
        passesAllFilters = false;
        break;
      }
    }
    if (passesAllFilters) {
      matchingIndices.push(rowIndex);
    }
  }
  return matchingIndices;
}
async function resolveFilterValueRef(valueRef, formValues) {
  if (!valueRef) return null;
  if (valueRef.startsWith("@calculated.") || valueRef.startsWith("@calculated:")) {
    const nodeId = valueRef.replace(/^@calculated[.:]/, "");
    if (formValues[nodeId] !== void 0 && formValues[nodeId] !== null) {
      let value = formValues[nodeId];
      if (value && typeof value === "object" && "value" in value) {
        const objValue = value.value;
        value = objValue;
      }
      return value;
    }
    const node = await prisma31.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      select: { id: true, label: true, calculatedValue: true }
    });
    if (node) {
      return node.calculatedValue ?? null;
    }
    return null;
  }
  if (valueRef.startsWith("@select.") || valueRef.startsWith("@select:")) {
    const nodeId = valueRef.replace(/^@select[.:]/, "");
    let value = formValues[nodeId] ?? null;
    if (value && typeof value === "object" && "value" in value) {
      const objValue = value.value;
      value = objValue;
    }
    if (value && typeof value === "string" && value.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)) {
      const optionNode = await prisma31.treeBranchLeafNode.findUnique({
        where: { id: value },
        select: { id: true, label: true, value: true }
      });
      if (optionNode) {
        const labelValue = optionNode.label || optionNode.value || value;
        value = labelValue;
      } else {
      }
    }
    return value;
  }
  if (valueRef.startsWith("@value.") || valueRef.startsWith("@value:")) {
    const nodeId = valueRef.replace(/^@value[.:]/, "");
    let value = formValues[nodeId] ?? null;
    if (value && typeof value === "object" && "value" in value) {
      const objValue = value.value;
      value = objValue;
    }
    return value;
  }
  return valueRef;
}
function compareFilterValues(cellValue, operator, compareValue) {
  const normalizedCell = normalizeForFilterComparison(cellValue);
  const normalizedCompare = normalizeForFilterComparison(compareValue);
  switch (operator) {
    case "equals":
    case "=":
      if (normalizedCell === normalizedCompare) {
        return true;
      }
      if (typeof normalizedCell === "string" && typeof normalizedCompare === "string") {
        const cellLower = normalizedCell.toLowerCase().trim();
        const compareLower = normalizedCompare.toLowerCase().trim();
        return cellLower.startsWith(compareLower) || compareLower.startsWith(cellLower);
      }
      return false;
    case "notEquals":
    case "!=":
      return normalizedCell !== normalizedCompare;
    case "greaterThan":
    case ">":
      if (typeof normalizedCell === "number" && typeof normalizedCompare === "number") {
        return normalizedCell > normalizedCompare;
      }
      return String(normalizedCell) > String(normalizedCompare);
    case "greaterOrEqual":
    case "greaterThanOrEqual":
    case ">=":
      if (typeof normalizedCell === "number" && typeof normalizedCompare === "number") {
        return normalizedCell >= normalizedCompare;
      }
      return String(normalizedCell) >= String(normalizedCompare);
    case "lessThan":
    case "<":
      if (typeof normalizedCell === "number" && typeof normalizedCompare === "number") {
        return normalizedCell < normalizedCompare;
      }
      return String(normalizedCell) < String(normalizedCompare);
    case "lessOrEqual":
    case "lessThanOrEqual":
    case "<=":
      if (typeof normalizedCell === "number" && typeof normalizedCompare === "number") {
        return normalizedCell <= normalizedCompare;
      }
      return String(normalizedCell) <= String(normalizedCompare);
    case "contains":
      return String(normalizedCell).toLowerCase().includes(String(normalizedCompare).toLowerCase());
    case "notContains":
      return !String(normalizedCell).toLowerCase().includes(String(normalizedCompare).toLowerCase());
    case "startsWith":
      return String(normalizedCell).toLowerCase().startsWith(String(normalizedCompare).toLowerCase());
    case "endsWith":
      return String(normalizedCell).toLowerCase().endsWith(String(normalizedCompare).toLowerCase());
    default:
      console.warn(`[compareFilterValues] \xC3\u0192\xC2\xA2\xC3\u2026\xC2\xA1\xC3\u201A\xC2\xA0\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xB8\xC3\u201A\xC2\x8F Op\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rateur inconnu: ${operator}`);
      return false;
  }
}
function normalizeForFilterComparison(value) {
  if (value === null || value === void 0) return null;
  if (typeof value === "number") return value;
  const str = String(value).trim();
  const num = Number(str);
  if (!isNaN(num) && isFinite(num)) return num;
  return str;
}
router56.get("/nodes/:nodeId/tables", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const access = await ensureNodeOrgAccess(prisma31, nodeId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) return res.status(access.status).json({ error: access.error });
    const tables = await prisma31.treeBranchLeafNodeTable.findMany({
      where: { nodeId },
      include: {
        tableColumns: {
          orderBy: { columnIndex: "asc" }
        },
        tableRows: {
          orderBy: { rowIndex: "asc" }
        }
      },
      orderBy: [{ order: "asc" }, { createdAt: "asc" }]
    });
    const normalized = tables.map(normalizeTableInstance);
    return res.json(normalized);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching node tables:", error);
    res.status(500).json({ error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration des tableaux" });
  }
});
router56.delete("/nodes/:nodeId/tables/:tableId", async (req2, res) => {
  const { tableId } = req2.params;
  try {
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const table = await prisma31.treeBranchLeafNodeTable.findUnique({
      where: { id: tableId },
      include: {
        TreeBranchLeafNode: {
          include: { TreeBranchLeafTree: true }
        }
      }
    });
    if (!table) {
      return res.status(404).json({ error: "Table non trouv\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDe" });
    }
    const tableOrgId = table.TreeBranchLeafNode?.TreeBranchLeafTree?.organizationId;
    if (!isSuperAdmin2 && organizationId && tableOrgId !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDs non autoris\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBD" });
    }
    await prisma31.treeBranchLeafNodeTable.delete({ where: { id: tableId } });
    try {
      const selectConfigsUsingTable = await prisma31.treeBranchLeafSelectConfig.findMany({
        where: { tableReference: tableId },
        select: { nodeId: true }
      });
      if (selectConfigsUsingTable.length > 0) {
        for (const config of selectConfigsUsingTable) {
          const selectNode = await prisma31.treeBranchLeafNode.findUnique({
            where: { id: config.nodeId },
            select: {
              label: true,
              metadata: true
            }
          });
          if (selectNode) {
            const oldMetadata = selectNode.metadata || {};
            const oldCapabilities = oldMetadata.capabilities || {};
            const newCapabilities = {
              ...oldCapabilities,
              table: {
                enabled: false,
                activeId: null,
                instances: null,
                currentTable: null
              }
            };
            const newMetadata = {
              ...oldMetadata,
              capabilities: newCapabilities
            };
            await prisma31.treeBranchLeafNode.update({
              where: { id: config.nodeId },
              data: {
                hasTable: false,
                table_activeId: null,
                table_instances: null,
                table_name: null,
                table_type: null,
                table_meta: null,
                table_columns: null,
                table_rows: null,
                table_data: null,
                metadata: JSON.parse(JSON.stringify(newMetadata)),
                select_options: [],
                updatedAt: /* @__PURE__ */ new Date()
              }
            });
            await prisma31.treeBranchLeafSelectConfig.deleteMany({
              where: { nodeId: config.nodeId }
            });
          }
        }
      }
    } catch (selectConfigError) {
      console.error(`[DELETE Table] ?? Erreur d\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDsactivation lookups:`, selectConfigError);
    }
    if (table.nodeId) {
      const node = await prisma31.treeBranchLeafNode.findUnique({
        where: { id: table.nodeId },
        select: {
          linkedTableIds: true,
          table_activeId: true,
          table_instances: true
        }
      });
      const currentLinkedIds = node?.linkedTableIds ?? [];
      const nextLinkedIds = currentLinkedIds.filter((x) => x !== tableId);
      const wasActiveTable = node?.table_activeId === tableId;
      let cleanedInstances = node?.table_instances ?? {};
      if (typeof cleanedInstances === "object" && cleanedInstances !== null) {
        const instances = cleanedInstances;
        if (instances[tableId]) {
          delete instances[tableId];
          cleanedInstances = instances;
        }
      }
      const remainingTables = await prisma31.treeBranchLeafNodeTable.count({
        where: { nodeId: table.nodeId }
      });
      await prisma31.treeBranchLeafNode.update({
        where: { id: table.nodeId },
        data: {
          hasTable: remainingTables > 0,
          linkedTableIds: { set: nextLinkedIds },
          table_activeId: wasActiveTable ? null : void 0,
          table_instances: cleanedInstances,
          ...remainingTables === 0 && {
            table_name: null,
            table_type: null,
            table_meta: null,
            table_columns: null,
            table_rows: null,
            table_data: null,
            table_importSource: null,
            table_isImported: false
          }
        }
      });
    }
    return res.json({ success: true, message: "Tableau supprim\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBD avec succ\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDs" });
  } catch (error) {
    console.error("[DELETE Table] ? Erreur lors de la suppression:", error);
    res.status(500).json({ error: "Erreur lors de la suppression du tableau" });
  }
});
router56.get("/nodes/:nodeId/tables/options", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const { tableId, dimension = "columns" } = req2.query;
    const access = await ensureNodeOrgAccess(prisma31, nodeId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) return res.status(access.status).json({ error: access.error });
    const normalized = await fetchNormalizedTable(nodeId, {
      tableId: typeof tableId === "string" && tableId ? tableId : void 0
    });
    if (!normalized) {
      return res.json({ items: [], table: null });
    }
    const { table, tables } = normalized;
    if (dimension === "rows") {
      const items2 = table.rows.map((label, index) => ({ value: label, label, index }));
      return res.json({ items: items2, table: { id: table.id, type: table.type, name: table.name }, tables });
    }
    if (dimension === "records") {
      return res.json({
        items: table.records,
        table: { id: table.id, type: table.type, name: table.name },
        tables
      });
    }
    const items = table.columns.map((label, index) => ({ value: label, label, index }));
    return res.json({ items, table: { id: table.id, type: table.type, name: table.name }, tables });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching table options:", error);
    res.status(500).json({ error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration des options du tableau" });
  }
});
router56.get("/nodes/:nodeId/tables/lookup", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const {
      tableId,
      column,
      row,
      key: key2,
      keyColumn,
      keyValue,
      valueColumn
    } = req2.query;
    const access = await ensureNodeOrgAccess(prisma31, nodeId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) return res.status(access.status).json({ error: access.error });
    const normalized = await fetchNormalizedTable(nodeId, {
      tableId: tableId && tableId.length ? tableId : void 0
    });
    if (!normalized) {
      return res.status(404).json({ error: "Aucun tableau disponible pour ce n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud" });
    }
    const { table } = normalized;
    const rawLookup = table.meta && typeof table.meta.lookup === "object" ? table.meta.lookup : void 0;
    if (table.type === "matrix") {
      const colLabel = column || (valueColumn && valueColumn === "column" ? valueColumn : void 0);
      const rowLabel = row;
      if (!colLabel || !rowLabel) {
        return res.status(400).json({ error: "Param\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8tres column et row requis pour un tableau crois\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
      }
      const columnIndex = table.columns.findIndex((c) => c === colLabel);
      const rowIndex = table.rows.findIndex((r) => r === rowLabel);
      if (columnIndex === -1) {
        return res.status(404).json({ error: `Colonne "${colLabel}" introuvable` });
      }
      if (rowIndex === -1) {
        return res.status(404).json({ error: `Ligne "${rowLabel}" introuvable` });
      }
      const value = table.matrix[rowIndex]?.[columnIndex] ?? null;
      return res.json({
        value,
        rowIndex,
        columnIndex,
        column: table.columns[columnIndex],
        row: table.rows[rowIndex],
        table: { id: table.id, name: table.name, type: table.type },
        meta: table.meta
      });
    }
    const resolvedKeyColumn = (keyColumn && keyColumn.length ? keyColumn : void 0) ?? (rawLookup && typeof rawLookup.keyColumn === "string" ? rawLookup.keyColumn : void 0);
    if (!resolvedKeyColumn) {
      return res.status(400).json({ error: "Colonne cl\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 non d\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9finie pour ce tableau" });
    }
    const lookupValue = (keyValue && keyValue.length ? keyValue : void 0) ?? (key2 && key2.length ? key2 : void 0) ?? (column && !table.columns.includes(column) ? column : void 0);
    if (lookupValue === void 0) {
      return res.status(400).json({ error: "Valeur de cl\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 requise" });
    }
    const keyIndex = table.columns.findIndex((colName) => colName === resolvedKeyColumn);
    if (keyIndex === -1) {
      return res.status(404).json({ error: `Colonne cl\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 "${resolvedKeyColumn}" introuvable` });
    }
    let matchedIndex = -1;
    for (let i = 0; i < table.matrix.length; i += 1) {
      const current = table.matrix[i]?.[keyIndex];
      if (current != null && String(current) === String(lookupValue)) {
        matchedIndex = i;
        break;
      }
    }
    if (matchedIndex === -1) {
      return res.status(404).json({ error: "Aucune ligne correspondant \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 cette cl\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const matchedRow = table.matrix[matchedIndex] ?? [];
    const matchedRecord = table.records[matchedIndex] ?? null;
    const resolvedValueColumn = (valueColumn && valueColumn.length ? valueColumn : void 0) ?? (rawLookup && typeof rawLookup.valueColumn === "string" ? rawLookup.valueColumn : void 0);
    let resolvedValue = matchedRecord;
    if (resolvedValueColumn) {
      const valueIdx = table.columns.findIndex((colName) => colName === resolvedValueColumn);
      if (valueIdx === -1) {
        return res.status(404).json({ error: `Colonne "${resolvedValueColumn}" introuvable` });
      }
      resolvedValue = matchedRow[valueIdx] ?? null;
    }
    const exposeColumns = Array.isArray(rawLookup?.exposeColumns) ? rawLookup?.exposeColumns : [];
    return res.json({
      value: resolvedValue ?? null,
      row: matchedRecord,
      rowIndex: matchedIndex,
      keyColumn: resolvedKeyColumn,
      keyValue: lookupValue,
      table: { id: table.id, name: table.name, type: table.type },
      meta: table.meta,
      exposeColumns
    });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error performing table lookup:", error);
    res.status(500).json({ error: "Erreur lors du lookup dans le tableau" });
  }
});
router56.post("/nodes/:nodeId/table/generate-selects", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const {
      tableId: requestedTableId,
      labelColumns,
      labelRows
    } = req2.body || {};
    const access = await ensureNodeOrgAccess(prisma31, nodeId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) return res.status(access.status).json({ error: access.error });
    const normalized = await fetchNormalizedTable(nodeId, {
      tableId: typeof requestedTableId === "string" && requestedTableId.trim().length ? requestedTableId.trim() : void 0
    });
    if (!normalized) {
      return res.status(404).json({ error: "Aucun tableau disponible pour ce n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud" });
    }
    const { table } = normalized;
    if (!table.columns.length) {
      return res.status(400).json({ error: "Le tableau ne contient aucune colonne exploitable" });
    }
    const baseNode = await prisma31.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      select: { id: true, treeId: true, parentId: true }
    });
    if (!baseNode) {
      return res.status(404).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud de base introuvable" });
    }
    const parentId = baseNode.parentId ?? null;
    const siblingsCount = await prisma31.treeBranchLeafNode.count({
      where: { treeId: baseNode.treeId, parentId }
    });
    const tableMeta = table.meta || {};
    const metaNameRaw = typeof tableMeta["name"] === "string" ? tableMeta["name"] : void 0;
    const baseLabel = metaNameRaw && metaNameRaw.trim() || table.name && table.name.trim() || "Tableau";
    const fallbackColumnsLabel = typeof labelColumns === "string" && labelColumns.trim().length ? labelColumns.trim() : `${baseLabel} - colonne`;
    const fallbackRowsLabel = typeof labelRows === "string" && labelRows.trim().length ? labelRows.trim() : `${baseLabel} - ligne`;
    const toCreate = [];
    if (table.columns.length) {
      toCreate.push({ label: fallbackColumnsLabel, dimension: "columns" });
    }
    if (table.rows.length) {
      toCreate.push({ label: fallbackRowsLabel, dimension: "rows" });
    }
    if (!toCreate.length) {
      return res.status(400).json({ error: "Aucune dimension exploitable pour g\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9n\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rer des champs SELECT" });
    }
    const created = [];
    let insertOrder = siblingsCount;
    const now = /* @__PURE__ */ new Date();
    for (const item of toCreate) {
      const newNodeId = (0, import_crypto19.randomUUID)();
      const nodeMetadata = {
        generatedFrom: "table_lookup",
        tableNodeId: baseNode.id,
        tableId: table.id,
        tableDimension: item.dimension
      };
      const newNode = await prisma31.treeBranchLeafNode.create({
        data: {
          id: newNodeId,
          treeId: baseNode.treeId,
          parentId,
          type: "leaf_select",
          subType: "SELECT",
          fieldType: "SELECT",
          fieldSubType: "SELECT",
          label: item.label,
          order: insertOrder,
          isVisible: true,
          isActive: true,
          hasData: false,
          hasFormula: false,
          hasCondition: false,
          hasTable: false,
          hasAPI: false,
          hasLink: false,
          hasMarkers: false,
          select_allowClear: true,
          select_defaultValue: null,
          select_multiple: false,
          select_options: [],
          select_searchable: false,
          metadata: nodeMetadata,
          tbl_auto_generated: true,
          updatedAt: now
        }
      });
      await prisma31.treeBranchLeafSelectConfig.create({
        data: {
          id: (0, import_crypto19.randomUUID)(),
          nodeId: newNode.id,
          options: [],
          multiple: false,
          searchable: false,
          allowCustom: false,
          optionsSource: `table_${item.dimension}`,
          tableReference: `node-table:${table.id}`,
          dependsOnNodeId: baseNode.id,
          createdAt: now,
          updatedAt: now
        }
      });
      created.push({ id: newNode.id, label: newNode.label, dimension: item.dimension });
      insertOrder += 1;
    }
    return res.json({
      created,
      table: { id: table.id, name: table.name, type: table.type }
    });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error generating selects from table:", error);
    res.status(500).json({ error: "Erreur lors de la g\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9n\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration des champs d\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9pendants" });
  }
});
router56.get("/effective-values", async (req2, res) => {
  try {
    const idsParam = String(req2.query.ids || "").trim();
    if (!idsParam) return res.json({ success: true, data: {} });
    const ids = idsParam.split(",").map((s) => s.trim()).filter(Boolean);
    if (!ids.length) return res.json({ success: true, data: {} });
    const nodes = await prisma31.treeBranchLeafNode.findMany({
      where: { id: { in: ids } },
      include: { TreeBranchLeafNodeVariable: true }
    });
    const result = {};
    for (const node of nodes) {
      result[node.id] = {
        value: null,
        source: "not_implemented",
        manualApplied: false
      };
    }
    return res.json({ success: true, data: result });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error getting effective values:", error);
    res.status(500).json({ error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration des valeurs effectives" });
  }
});
router56.get("/debug/formula-vars", async (req2, res) => {
  try {
    const vars = await prisma31.treeBranchLeafNodeVariable.findMany({
      include: {
        node: {
          select: {
            id: true,
            label: true,
            treeId: true,
            organizationId: true
          }
        }
      },
      orderBy: {
        updatedAt: "desc"
      }
    });
    return res.json(vars);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching formula variables:", error);
    res.status(500).json({ error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration des variables de formule" });
  }
});
router56.get("/debug/formula-eval", async (req2, res) => {
  try {
    const { formulaId, nodeId } = req2.query;
    if (typeof formulaId !== "string" || typeof nodeId !== "string") {
      return res.status(400).json({ error: "formulaId et nodeId requis" });
    }
    const formula = await prisma31.treeBranchLeafNodeFormula.findUnique({
      where: { id: formulaId }
    });
    if (!formula) {
      return res.status(404).json({ error: "Formule non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
    }
    const node = await prisma31.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      include: { TreeBranchLeafNodeVariable: true }
    });
    if (!node) {
      return res.status(404).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const fieldValues = {
      ...node.TreeBranchLeafNodeVariable?.reduce((acc, v) => {
        if (v.exposedKey) {
          acc[v.exposedKey] = v.fixedValue || null;
        }
        return acc;
      }, {})
      // Ajouter des valeurs de test suppl√É∆í√Ü‚Äô√É‚Äö√Ç¬©mentaires si n√É∆í√Ü‚Äô√É‚Äö√Ç¬©cessaire
    };
    const { value, errors } = await evaluateTokens(formula.tokens, {
      resolveVariable: async (nodeId2) => {
        const found = Object.values(fieldValues).find((v) => v.nodeId === nodeId2);
        return found ? found.value : 0;
      },
      divisionByZeroValue: 0
    });
    return res.json({ value, errors });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error evaluating formula in debug:", error);
    res.status(500).json({ error: "Erreur lors de l'\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valuation de la formule en mode d\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9bogage" });
  }
});
router56.get("/formulas-version", async (req2, res) => {
  try {
    res.setHeader("X-TBL-Legacy-Deprecated", "true");
    if (process.env.NODE_ENV !== "production") {
      console.warn("[TBL LEGACY] /api/treebranchleaf/formulas-version appel\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 (d\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9pr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ci\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9). Utiliser /api/tbl/evaluate avec futur cache d\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9pendances.");
    }
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const version = {
      version: Date.now(),
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      organizationId: organizationId || null,
      isSuperAdmin: Boolean(isSuperAdmin2)
    };
    return res.json(version);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error getting formulas version:", error);
    res.status(500).json({ error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration de la version des formules" });
  }
});
router56.post("/formulas/validate", (req2, res) => {
  try {
    const { expression, rolesMap } = req2.body ?? {};
    if (typeof expression !== "string" || !expression.trim()) {
      return res.status(400).json({ error: "expression_required" });
    }
    const tokens2 = parseExpression(expression, createRolesProxy(rolesMap), { enableCache: false });
    const rpn = toRPN(tokens2);
    return res.json({
      tokens: tokens2,
      rpn,
      complexity: tokens2.length
    });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error validating formula:", error);
    return res.status(400).json({
      error: "Parse error",
      details: error instanceof Error ? error.message : String(error)
    });
  }
});
router56.get("/logic/version", (_req, res) => {
  const payload = computeLogicVersion();
  return res.json(payload);
});
router56.post("/formulas/cache/clear", (_req, res) => {
  clearRpnCache();
  const stats = getRpnCacheStats();
  return res.json({ cleared: true, stats });
});
router56.post("/nodes/:nodeId/table/evaluate", (req2, res) => {
  return res.status(404).json({ error: "node_not_found", nodeId: req2.params.nodeId });
});
router56.post("/evaluate/formula", async (req2, res) => {
  try {
    const { expr, rolesMap, values, options } = req2.body ?? {};
    if (typeof expr !== "string" || !expr.trim()) {
      return res.status(400).json({ error: "expr_required" });
    }
    const strict = Boolean(options?.strict);
    const enableCache = options?.enableCache !== void 0 ? Boolean(options.enableCache) : true;
    const divisionByZeroValue = typeof options?.divisionByZeroValue === "number" ? options.divisionByZeroValue : 0;
    const precisionScale = typeof options?.precisionScale === "number" ? options.precisionScale : void 0;
    const valueStore = values && typeof values === "object" ? values : {};
    const evaluation = await evaluateExpression(expr, createRolesProxy(rolesMap), {
      resolveVariable: (nodeId) => coerceToNumber(valueStore[nodeId] ?? valueStore[nodeId.toLowerCase()]),
      strictVariables: strict,
      enableCache,
      divisionByZeroValue,
      precisionScale
    });
    const stats = getRpnCacheStats();
    const metrics = getLogicMetrics();
    return res.json({
      value: evaluation.value,
      errors: evaluation.errors,
      stats,
      metrics
    });
  } catch (error) {
    if (error instanceof Error) {
      return res.status(400).json({ error: "Parse error", details: error.message });
    }
    console.error("[TreeBranchLeaf API] Error evaluating inline formula:", error);
    return res.status(500).json({ error: "Erreur \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valuation inline" });
  }
});
router56.post("/evaluate/formula/:formulaId", async (req2, res) => {
  try {
    res.setHeader("X-TBL-Legacy-Deprecated", "true");
    if (process.env.NODE_ENV !== "production") {
      console.warn("[TBL LEGACY] /api/treebranchleaf/evaluate/formula/:id appel\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 (d\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9pr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ci\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9). Utiliser POST /api/tbl/evaluate elementId=<exposedKey>.");
    }
    const { formulaId } = req2.params;
    const { fieldValues = {}, testMode = true } = req2.body;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const formula = await prisma31.treeBranchLeafNodeFormula.findUnique({
      where: { id: formulaId },
      include: {
        TreeBranchLeafNode: {
          select: {
            label: true,
            treeId: true,
            TreeBranchLeafTree: {
              select: { organizationId: true }
            }
          }
        }
      }
    });
    if (!formula) {
      return res.status(404).json({ error: "Formule non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
    }
    const nodeOrg = formula.TreeBranchLeafNode?.TreeBranchLeafTree?.organizationId;
    if (!isSuperAdmin2 && nodeOrg && nodeOrg !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 cette formule" });
    }
    try {
      const isDebugMode = process.env.NODE_ENV === "development";
      if (isDebugMode && formula) {
        if (Array.isArray(formula.tokens)) {
          formula.tokens.forEach((token, index) => {
          });
        }
        Object.entries(fieldValues).forEach(([k, v]) => {
        });
      }
      const tokens2 = Array.isArray(formula.tokens) ? formula.tokens : [];
      const tokenVariables = tokens2.filter((t) => Boolean(t) && t.type === "variable").map((t) => t.name).filter(Boolean);
      const rawExpression = formula?.expression || formula?.rawExpression || "";
      let orchestrated2 = null;
      try {
        orchestrated2 = evaluateFormulaOrchestrated({
          fieldValues,
          tokens: tokens2,
          rawExpression,
          variableMap: req2.body?.variableMap,
          hasOperatorsOverride: req2.body?.hasOperators
        });
        if (process.env.NODE_ENV === "development") {
          const variableCount = Object.keys(orchestrated2.resolvedVariables).filter((k) => orchestrated2.resolvedVariables[k] !== 0).length;
          if (variableCount === 1) {
            const singleValue = Object.values(orchestrated2.resolvedVariables).find((v) => v !== 0);
          } else if (variableCount >= 2) {
            const values = Object.values(orchestrated2.resolvedVariables);
          }
        }
      } catch (orchestratorError) {
        console.error("[TreeBranchLeaf API] \xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 Erreur orchestrateur:", orchestratorError);
        return res.status(500).json({
          error: "Erreur orchestrateur formule",
          details: orchestratorError.message || "unknown",
          debug: {
            formulaId: formula.id,
            rawExpression,
            tokensCount: tokens2.length,
            receivedFieldValuesKeys: Object.keys(fieldValues)
          }
        });
      }
      const resolvedVariables = orchestrated2.resolvedVariables;
      const universalAnalyzer = (fieldValues2) => {
        const classified2 = {
          userInputs: {},
          systemRefs: {},
          calculations: {},
          conditions: {},
          metadata: {}
        };
        Object.entries(fieldValues2).forEach(([key2, value]) => {
          if (value == null || value === "") return;
          const strValue = String(value);
          if (key2.includes("_field")) {
            classified2.userInputs[key2] = value;
          } else if (key2.startsWith("node_") || key2.includes("-") && key2.length > 10) {
            classified2.systemRefs[key2] = value;
          } else if (key2.startsWith("__mirror_")) {
            classified2.metadata[key2] = value;
          } else {
            classified2.calculations[key2] = value;
          }
        });
        return classified2;
      };
      const intelligentStrategy = (classified2, resolvedVariables2, context) => {
        const userInputCount = Object.keys(classified2.userInputs).length;
        const systemRefCount = Object.keys(classified2.systemRefs).length;
        const calculationCount = Object.keys(classified2.calculations).length;
        const tokenVariableCount = context.tokenVariablesCount;
        const variableCount = Object.keys(resolvedVariables2).filter((k) => resolvedVariables2[k] !== 0).length;
        if (userInputCount > 0 && context.tokenVariablesCount === 0) {
          const userValue = Object.values(classified2.userInputs)[0];
          return {
            strategy: "USER_PRIORITY",
            value: userValue,
            reason: "L'utilisateur a entr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 une valeur directe"
          };
        }
        if (tokenVariableCount >= 2) {
          return {
            strategy: "AUTO_CALCULATION",
            value: null,
            reason: `Calcul automatique avec ${tokenVariableCount} variables dans les tokens`
          };
        }
        if (tokenVariableCount === 1) {
          const singleValue = Object.values(resolvedVariables2).find((v) => v !== 0);
          return {
            strategy: "SINGLE_VALUE",
            value: singleValue,
            reason: "Une seule variable dans les tokens"
          };
        }
        return {
          strategy: "NEUTRAL",
          value: 0,
          reason: "Aucune donn\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e disponible"
        };
      };
      const classified = universalAnalyzer(fieldValues);
      const strategy = intelligentStrategy(classified, resolvedVariables, { tokenVariablesCount: tokenVariables.length, tokensCount: tokens2.length });
      if (strategy.strategy === "USER_PRIORITY" || strategy.strategy === "SINGLE_VALUE") {
        const rawValue = strategy.value;
        const cleanedString = String(rawValue).replace(/\s+/g, "").replace(/,/g, ".");
        const numValue = parseFloat(cleanedString);
        const finalValue = isNaN(numValue) ? 0 : numValue;
        return res.json({
          success: true,
          result: finalValue,
          strategy: strategy.strategy,
          reason: strategy.reason,
          source: rawValue,
          analysis: classified,
          orchestrator: orchestrated2 ? {
            strategy: orchestrated2.strategy,
            operatorsDetected: orchestrated2.operatorsDetected,
            trace: orchestrated2.trace,
            resolvedVariables: orchestrated2.resolvedVariables
          } : null
        });
      }
      if (strategy.strategy === "NEUTRAL") {
        return res.json({
          success: true,
          result: 0,
          strategy: strategy.strategy,
          reason: strategy.reason,
          analysis: classified,
          orchestrator: orchestrated2 ? {
            strategy: orchestrated2.strategy,
            operatorsDetected: orchestrated2.operatorsDetected,
            trace: orchestrated2.trace,
            resolvedVariables: orchestrated2.resolvedVariables
          } : null
        });
      }
      if (strategy.strategy === "AUTO_CALCULATION") {
      }
      const evaluateTokens2 = (tokens3) => {
        const stack = [];
        const operations = [];
        const convertToPostfix = (tokens4) => {
          const outputQueue = [];
          const operatorStack = [];
          const precedence = { "+": 1, "-": 1, "*": 2, "/": 2 };
          for (const token of tokens4) {
            if (token.type === "value" || token.type === "variable") {
              outputQueue.push(token);
            } else if (token.type === "operator" && token.value && precedence[token.value]) {
              while (operatorStack.length > 0 && operatorStack[operatorStack.length - 1].type === "operator" && operatorStack[operatorStack.length - 1].value && precedence[operatorStack[operatorStack.length - 1].value] >= precedence[token.value]) {
                outputQueue.push(operatorStack.pop());
              }
              operatorStack.push(token);
            }
          }
          while (operatorStack.length > 0) {
            outputQueue.push(operatorStack.pop());
          }
          return outputQueue;
        };
        const postfixTokens = convertToPostfix(tokens3);
        for (let i = 0; i < postfixTokens.length; i++) {
          const token = postfixTokens[i];
          if (!token) continue;
          if (token.type === "value") {
            const value = parseFloat(String(token.value));
            const finalValue = isNaN(value) ? 0 : value;
            stack.push(finalValue);
            operations.push(`PUSH(${finalValue})`);
          } else if (token.type === "variable") {
            const varName = token.variableId || token.name || "";
            const value = resolvedVariables[varName] || 0;
            stack.push(value);
            operations.push(`PUSH(${varName}=${value})`);
          } else if (token.type === "operator" && ["+", "-", "*", "/"].includes(String(token.value))) {
            if (stack.length >= 2) {
              const b = stack.pop();
              const a = stack.pop();
              let result2 = 0;
              const operator = String(token.value);
              switch (operator) {
                case "+":
                  result2 = a + b;
                  operations.push(`${a} + ${b} = ${result2}`);
                  break;
                case "-":
                  result2 = a - b;
                  operations.push(`${a} - ${b} = ${result2}`);
                  break;
                case "*":
                  result2 = a * b;
                  operations.push(`${a} * ${b} = ${result2}`);
                  break;
                case "/":
                  if (b !== 0) {
                    result2 = a / b;
                    operations.push(`${a} / ${b} = ${result2}`);
                  } else {
                    result2 = 0;
                    operations.push(`${a} / ${b} = 0 (division par z\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ro \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9vit\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e)`);
                  }
                  break;
              }
              stack.push(result2);
            } else {
              operations.push(`ERREUR: Pile insuffisante pour ${token.value}`);
            }
          } else {
          }
        }
        const finalResult = stack.length > 0 ? stack[0] : 0;
        return finalResult;
      };
      let result = null;
      if (tokens2.length > 0) {
        result = evaluateTokens2(tokens2);
      } else {
        result = 0;
      }
      const responseData = {
        formulaId: formula.id,
        formulaName: formula.name,
        nodeLabel: formula.TreeBranchLeafNode?.label || "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud inconnu",
        evaluation: {
          success: result !== null,
          result,
          tokens: tokens2,
          resolvedVariables,
          details: {
            fieldValues,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            testMode,
            tokenCount: tokens2.length,
            variableCount: tokenVariables.length
          }
        },
        orchestrator: orchestrated2 ? {
          strategy: orchestrated2.strategy,
          operatorsDetected: orchestrated2.operatorsDetected,
          trace: orchestrated2.trace,
          resolvedVariables: orchestrated2.resolvedVariables
        } : null
      };
      return res.json(responseData);
    } catch (evaluationError) {
      console.error(`[TreeBranchLeaf API] Erreur lors de l'\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valuation:`, evaluationError);
      return res.status(500).json({
        error: "Erreur lors de l'\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valuation de la formule",
        details: evaluationError.message,
        debug: {
          formulaId,
          hasTokens: (() => {
            const maybeErr = evaluationError;
            if (maybeErr && Array.isArray(maybeErr.tokens)) return maybeErr.tokens.length;
            return tokens.length;
          })(),
          receivedFieldValuesKeys: Object.keys(fieldValues),
          orchestratorTrace: orchestrated?.trace?.slice?.(0, 10) || null
        }
      });
    }
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error evaluating formula:", error);
    res.status(500).json({ error: "Erreur lors de l'\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valuation de la formule" });
  }
});
router56.post("/evaluate/batch", async (req2, res) => {
  try {
    const { requests = [], nodeIds = [], fieldValues = {} } = req2.body;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    let finalRequests = [];
    if (Array.isArray(requests) && requests.length > 0) {
      finalRequests = requests;
    } else if (Array.isArray(nodeIds) && nodeIds.length > 0) {
      for (const nodeId of nodeIds) {
        const nodeFormulas = await prisma31.treeBranchLeafNodeFormula.findMany({
          where: { nodeId },
          select: { id: true, name: true }
        });
        for (const formula of nodeFormulas) {
          finalRequests.push({
            formulaId: formula.id,
            fieldValues,
            testMode: false
          });
        }
      }
    }
    if (finalRequests.length === 0) {
      return res.status(400).json({ error: "Aucune formule \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valuer dans la requ\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xAAte batch" });
    }
    const results = [];
    for (const request of finalRequests) {
      const { formulaId, fieldValues: fieldValues2 = {}, testMode = true } = request;
      if (!formulaId) {
        results.push({
          formulaId: null,
          error: "formulaId manquant",
          success: false
        });
        continue;
      }
      try {
        const formula = await prisma31.treeBranchLeafNodeFormula.findUnique({
          where: { id: formulaId },
          include: {
            TreeBranchLeafNode: {
              select: {
                label: true,
                treeId: true,
                TreeBranchLeafTree: {
                  select: { organizationId: true }
                }
              }
            }
          }
        });
        if (!formula) {
          results.push({
            formulaId,
            error: "Formule non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e",
            success: false
          });
          continue;
        }
        const nodeOrg = formula.TreeBranchLeafNode?.TreeBranchLeafTree?.organizationId;
        if (!isSuperAdmin2 && nodeOrg && nodeOrg !== organizationId) {
          results.push({
            formulaId,
            error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 cette formule",
            success: false
          });
          continue;
        }
        const tokens2 = Array.isArray(formula.tokens) ? formula.tokens : [];
        const tokenVariables = tokens2.filter((t) => Boolean(t) && t.type === "variable").map((t) => t.name).filter(Boolean);
        const resolvedVariables = {};
        for (const varName of tokenVariables) {
          const rawValue = fieldValues2[varName];
          const numValue = rawValue != null && rawValue !== "" ? parseFloat(String(rawValue).replace(/\s+/g, "").replace(/,/g, ".")) : 0;
          resolvedVariables[varName] = isNaN(numValue) ? 0 : numValue;
        }
        const evaluateTokens2 = (tokens3) => {
          const stack = [];
          for (const token of tokens3) {
            if (!token) continue;
            if (token.type === "value") {
              const value = parseFloat(String(token.value));
              stack.push(isNaN(value) ? 0 : value);
            } else if (token.type === "variable") {
              const varName = token.variableId || token.name || "";
              const value = resolvedVariables[varName] || 0;
              stack.push(value);
            } else if (token.type === "operator" && ["+", "-", "*", "/"].includes(String(token.value))) {
              if (stack.length >= 2) {
                const b = stack.pop();
                const a = stack.pop();
                let result2 = 0;
                switch (token.value) {
                  case "+":
                    result2 = a + b;
                    break;
                  case "-":
                    result2 = a - b;
                    break;
                  case "*":
                    result2 = a * b;
                    break;
                  case "/":
                    result2 = b !== 0 ? a / b : 0;
                    break;
                }
                stack.push(result2);
              }
            }
          }
          return stack.length > 0 ? stack[0] : 0;
        };
        let result = null;
        if (tokens2.length > 0) {
          result = evaluateTokens2(tokens2);
        } else {
          result = 0;
        }
        results.push({
          formulaId: formula.id,
          formulaName: formula.name,
          nodeLabel: formula.TreeBranchLeafNode?.label || "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud inconnu",
          success: true,
          evaluation: {
            success: result !== null,
            result,
            tokens: tokens2,
            resolvedVariables,
            details: {
              fieldValues: fieldValues2,
              timestamp: (/* @__PURE__ */ new Date()).toISOString(),
              testMode,
              tokenCount: tokens2.length,
              variableCount: tokenVariables.length
            }
          }
        });
      } catch (evaluationError) {
        console.error(`[TreeBranchLeaf API] Erreur \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valuation batch formule ${formulaId}:`, evaluationError);
        results.push({
          formulaId,
          error: `Erreur d'\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valuation: ${evaluationError.message}`,
          success: false
        });
      }
    }
    return res.json({
      success: true,
      totalRequests: finalRequests.length,
      successCount: results.filter((r) => r.success).length,
      results
    });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error in batch evaluation:", error);
    res.status(500).json({ error: "Erreur lors de l'\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valuation batch" });
  }
});
async function ensureNodeOrgAccess(prisma51, nodeId, auth) {
  try {
    const node = await prisma51.treeBranchLeafNode.findFirst({
      where: { id: nodeId },
      select: { treeId: true }
    });
    if (!node) {
      return { ok: false, status: 404, error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" };
    }
    if (auth.isSuperAdmin) {
      return { ok: true };
    }
    const tree = await prisma51.treeBranchLeafTree.findFirst({
      where: { id: node.treeId },
      select: { organizationId: true }
    });
    if (!tree) {
      return { ok: false, status: 404, error: "Arbre non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" };
    }
    if (tree.organizationId && tree.organizationId !== auth.organizationId) {
      return { ok: false, status: 403, error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" };
    }
    return { ok: true };
  } catch (error) {
    console.error("Error checking node org access:", error);
    return { ok: false, status: 500, error: "Erreur de v\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rification d'acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s" };
  }
}
router56.get("/conditions/:conditionId", async (req2, res) => {
  try {
    const { conditionId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const condition = await prisma31.treeBranchLeafNodeCondition.findUnique({
      where: { id: conditionId },
      include: {
        TreeBranchLeafNode: {
          select: {
            label: true,
            treeId: true,
            TreeBranchLeafTree: {
              select: { organizationId: true }
            }
          }
        }
      }
    });
    if (!condition) {
      return res.status(404).json({ error: "Condition non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
    }
    const nodeOrg = condition.TreeBranchLeafNode?.TreeBranchLeafTree?.organizationId;
    if (!isSuperAdmin2 && nodeOrg && nodeOrg !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 cette condition" });
    }
    return res.json(condition);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error getting condition by ID:", error);
    res.status(500).json({ error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration de la condition" });
  }
});
router56.get("/formulas/:formulaId", async (req2, res) => {
  try {
    const { formulaId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const formula = await prisma31.treeBranchLeafNodeFormula.findUnique({
      where: { id: formulaId },
      include: {
        TreeBranchLeafNode: {
          select: {
            label: true,
            treeId: true,
            TreeBranchLeafTree: {
              select: { organizationId: true }
            }
          }
        }
      }
    });
    if (!formula) {
      return res.status(404).json({ error: "Formule non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
    }
    const nodeOrg = formula.TreeBranchLeafNode?.TreeBranchLeafTree?.organizationId;
    if (!isSuperAdmin2 && nodeOrg && nodeOrg !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 cette formule" });
    }
    return res.json(formula);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error getting formula by ID:", error);
    res.status(500).json({ error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration de la formule" });
  }
});
router56.get("/submissions", async (req2, res) => {
  try {
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const { treeId, leadId, userId, status } = req2.query;
    const whereClause = {};
    if (treeId) whereClause.treeId = treeId;
    if (leadId) whereClause.leadId = leadId;
    if (userId) whereClause.userId = userId;
    if (status) whereClause.status = status;
    if (!isSuperAdmin2 && organizationId) {
      whereClause.organizationId = organizationId;
    }
    const submissions = await prisma31.treeBranchLeafSubmission.findMany({
      where: whereClause,
      orderBy: { createdAt: "desc" }
    });
    const leadIds = [...new Set(submissions.map((s) => s.leadId).filter(Boolean))];
    const userIds = [...new Set(submissions.map((s) => s.userId).filter(Boolean))];
    const [leads, users] = await Promise.all([
      leadIds.length > 0 ? prisma31.lead.findMany({
        where: { id: { in: leadIds } },
        select: { id: true, firstName: true, lastName: true, email: true, company: true }
      }) : Promise.resolve([]),
      userIds.length > 0 ? prisma31.user.findMany({
        where: { id: { in: userIds } },
        select: { id: true, email: true, firstName: true, lastName: true }
      }) : Promise.resolve([])
    ]);
    const leadMap = new Map(leads.map((l) => [l.id, l]));
    const userMap = new Map(users.map((u) => [u.id, u]));
    const enrichedSubmissions = submissions.map((submission) => ({
      ...submission,
      Lead: submission.leadId ? leadMap.get(submission.leadId) || null : null,
      User_TreeBranchLeafSubmission_userIdToUser: submission.userId ? userMap.get(submission.userId) || null : null
    }));
    res.json(enrichedSubmissions);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching submissions:", error);
    res.status(500).json({ error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration des soumissions" });
  }
});
router56.get("/submissions/by-leads", async (req2, res) => {
  try {
    const authCtx = getAuthCtx3(req2);
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = authCtx;
    const { treeId, search, leadId } = req2.query;
    const submissionWhere = {};
    if (treeId) {
      submissionWhere.treeId = treeId;
    }
    if (leadId) {
      submissionWhere.leadId = leadId;
    }
    if (!isSuperAdmin2) {
      submissionWhere.TreeBranchLeafTree = {
        organizationId
      };
    }
    const leadWhere = {};
    if (leadId) {
      leadWhere.id = leadId;
    }
    if (!isSuperAdmin2) {
      leadWhere.organizationId = organizationId;
    }
    if (search) {
      leadWhere.OR = [
        { firstName: { contains: search, mode: "insensitive" } },
        { lastName: { contains: search, mode: "insensitive" } },
        { email: { contains: search, mode: "insensitive" } }
      ];
    }
    const submissions = await prisma31.treeBranchLeafSubmission.findMany({
      where: {
        ...submissionWhere,
        leadId: { not: null },
        status: { in: ["completed", "default-draft"] }
      },
      select: {
        id: true,
        leadId: true,
        status: true,
        summary: true,
        createdAt: true,
        updatedAt: true,
        treeId: true
      },
      orderBy: { createdAt: "desc" }
    });
    const treeIds = [...new Set(submissions.map((s) => s.treeId))];
    const trees = await prisma31.treeBranchLeafTree.findMany({
      where: { id: { in: treeIds } },
      select: { id: true, name: true }
    });
    const treeMap = new Map(trees.map((t) => [t.id, t.name]));
    const leadIds = [...new Set(submissions.map((s) => s.leadId).filter(Boolean))];
    const leads = await prisma31.lead.findMany({
      where: {
        ...leadWhere,
        id: { in: leadIds }
      },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        company: true
      },
      orderBy: [
        { firstName: "asc" },
        { lastName: "asc" }
      ]
    });
    const submissionsByLead = /* @__PURE__ */ new Map();
    for (const submission of submissions) {
      if (submission.leadId) {
        const existing = submissionsByLead.get(submission.leadId) || [];
        existing.push(submission);
        submissionsByLead.set(submission.leadId, existing);
      }
    }
    const formattedData = leads.map((lead) => ({
      id: lead.id,
      firstName: lead.firstName,
      lastName: lead.lastName,
      email: lead.email,
      company: lead.company,
      submissions: (submissionsByLead.get(lead.id) || []).map((submission) => ({
        id: submission.id,
        name: submission.status === "default-draft" ? "Brouillon" : submission.summary?.name || `Devis ${new Date(submission.createdAt).toLocaleDateString("fr-FR")}`,
        status: submission.status,
        createdAt: submission.createdAt,
        updatedAt: submission.updatedAt,
        treeName: treeMap.get(submission.treeId)
      }))
    }));
    res.json(formattedData);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error getting submissions by leads:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des devis par leads" });
  }
});
router56.get("/submissions/:id/fields", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    console.log(`[TBL-FIELDS] \u25B6\uFE0F GET /submissions/${id}/fields`);
    let submission = null;
    try {
      submission = await prisma31.treeBranchLeafSubmission.findUnique({ where: { id } });
    } catch (e) {
      const msg = e instanceof Error ? e.message : String(e);
      console.warn("[TBL-FIELDS] \u26A0\uFE0F findUnique submission \xE9chou\xE9:", msg);
      submission = null;
    }
    if (!submission) {
      return res.status(404).json({ error: "Soumission non trouv\xE9e" });
    }
    let tree = null;
    if (submission.treeId) {
      try {
        tree = await prisma31.treeBranchLeafTree.findUnique({
          where: { id: submission.treeId },
          select: { id: true, organizationId: true }
        });
      } catch (e) {
        console.warn("[TBL-FIELDS] \u26A0\uFE0F findUnique tree \xE9chou\xE9:", e instanceof Error ? e.message : String(e));
        tree = null;
      }
    }
    const treeOrg = tree?.organizationId;
    if (!isSuperAdmin2 && treeOrg && treeOrg !== organizationId) {
      return res.status(403).json({ error: "Acc\xE8s refus\xE9" });
    }
    let lead = null;
    if (submission.leadId) {
      try {
        lead = await prisma31.lead.findUnique({
          where: { id: submission.leadId },
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            phone: true,
            company: true
          }
        });
      } catch (e) {
        console.warn("[TBL-FIELDS] \u26A0\uFE0F findUnique lead \xE9chou\xE9:", e instanceof Error ? e.message : String(e));
        lead = null;
      }
    }
    let dataRows = [];
    try {
      dataRows = await prisma31.treeBranchLeafSubmissionData.findMany({
        where: { submissionId: id },
        orderBy: { createdAt: "asc" }
      });
    } catch (e) {
      console.warn("[TBL-FIELDS] \u26A0\uFE0F findMany submissionData \xE9chou\xE9:", e instanceof Error ? e.message : String(e));
      dataRows = [];
    }
    console.log(`[TBL-FIELDS] \u2139\uFE0F dataRows=${dataRows.length}`);
    const nodeIds = [...new Set(
      dataRows.map((r) => r?.nodeId).filter((nid) => typeof nid === "string" && nid.length > 0)
    )];
    console.log(`[TBL-FIELDS] \u2139\uFE0F nodeIds=${nodeIds.length}`);
    let nodes = [];
    if (nodeIds.length > 0) {
      try {
        nodes = await prisma31.treeBranchLeafNode.findMany({
          where: { id: { in: nodeIds } },
          select: { id: true, type: true, label: true, fieldType: true, fieldSubType: true }
        });
      } catch (e) {
        console.warn("[TreeBranchLeaf API] \u26A0\uFE0F findMany nodes \xE9chou\xE9, retour des champs vides.", e instanceof Error ? e.message : String(e));
        nodes = [];
      }
    }
    console.log(`[TBL-FIELDS] \u2139\uFE0F nodes=${nodes.length}`);
    const nodesMap = new Map(nodes.map((n) => [n.id, n]));
    const fieldsMap = {};
    for (const row of dataRows) {
      const node = nodesMap.get(row.nodeId);
      if (!node) continue;
      const isDisplayField = node.fieldType === "DISPLAY" || node.type === "leaf_field" && ["display", "DISPLAY", "Display"].includes(node.fieldSubType || "");
      if (isDisplayField) {
        console.log(`[TBL-FIELDS] \u23F8\uFE0F Champ DISPLAY exclu: ${node.label} (${node.id})`);
        continue;
      }
      const key2 = node.id;
      const raw = typeof row.value === "string" ? row.value : JSON.stringify(row.value ?? null);
      fieldsMap[key2] = {
        nodeId: node.id,
        label: node.label || "",
        type: node.type || "unknown",
        fieldType: node.fieldType || void 0,
        fieldSubType: node.fieldSubType || void 0,
        value: row.value,
        rawValue: raw ?? "",
        calculatedBy: row.operationSource || void 0
      };
    }
    const response = {
      submissionId: submission.id,
      treeId: submission.treeId,
      treeName: tree?.id || null,
      leadId: submission.leadId,
      lead: lead ? {
        id: lead.id,
        firstName: lead.firstName,
        lastName: lead.lastName,
        fullName: `${lead.firstName || ""} ${lead.lastName || ""}`.trim(),
        email: lead.email,
        phone: lead.phone,
        company: lead.company,
        fullAddress: null
      } : null,
      status: submission.status,
      createdAt: submission.createdAt,
      updatedAt: submission.updatedAt,
      fields: fieldsMap,
      totalFields: Object.keys(fieldsMap).length
    };
    return res.json(response);
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    console.error("[TreeBranchLeaf API] \u{1F4A5} Erreur GET /submissions/:id/fields:", errorMsg);
    console.error("[TreeBranchLeaf API] Stack:", error instanceof Error ? error.stack : "");
    return res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration des champs", details: errorMsg });
  }
});
router56.get("/submissions/:id", async (req2, res) => {
  try {
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const { id } = req2.params;
    console.log(`[TBL-API] \u25B6\uFE0F GET /submissions/${id}`);
    const submission = await prisma31.treeBranchLeafSubmission.findUnique({
      where: { id }
    });
    if (!submission) {
      return res.status(404).json({ error: "Soumission non trouv\xE9e" });
    }
    const tree = await prisma31.treeBranchLeafTree.findUnique({
      where: { id: submission.treeId },
      select: { id: true, organizationId: true }
    });
    const treeOrg = tree?.organizationId ?? null;
    if (!isSuperAdmin2 && treeOrg && treeOrg !== organizationId) {
      return res.status(403).json({ error: "Acc\xE8s refus\xE9 \xE0 cette soumission" });
    }
    const submissionData = await prisma31.treeBranchLeafSubmissionData.findMany({
      where: { submissionId: id }
    });
    const nodeIds = [...new Set(submissionData.map((d) => d.nodeId))];
    const nodes = nodeIds.length > 0 ? await prisma31.treeBranchLeafNode.findMany({
      where: { id: { in: nodeIds } },
      select: { id: true, label: true, type: true, calculatedValue: true }
    }) : [];
    const nodesMap = new Map(nodes.map((n) => [n.id, n]));
    const enrichedData = submissionData.map((d) => ({
      ...d,
      TreeBranchLeafNode: nodesMap.get(d.nodeId) || null
    }));
    let leadBasic = null;
    if (submission.leadId) {
      const lead = await prisma31.lead.findUnique({
        where: { id: submission.leadId },
        select: { id: true, firstName: true, lastName: true, email: true, company: true }
      });
      leadBasic = lead ?? null;
    }
    return res.json({
      ...submission,
      TreeBranchLeafSubmissionData: enrichedData,
      Lead: leadBasic
    });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching submission:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration de la soumission" });
  }
});
router56.get("/submissions/:id/summary", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const submission = await prisma31.treeBranchLeafSubmission.findUnique({
      where: { id }
    });
    if (!submission) {
      return res.status(404).json({ error: "Soumission non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
    }
    const tree = submission ? await prisma31.treeBranchLeafTree.findUnique({
      where: { id: submission.treeId },
      select: { id: true, organizationId: true }
    }) : null;
    const treeOrg = tree?.organizationId;
    if (!isSuperAdmin2 && treeOrg && treeOrg !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 cette soumission" });
    }
    const dataRows = await prisma31.treeBranchLeafSubmissionData.findMany({
      where: { submissionId: id },
      include: {
        TreeBranchLeafNode: { select: { id: true, type: true, label: true } }
      }
    });
    const isFilled = (v) => v != null && String(v).trim() !== "";
    const total = dataRows.length;
    const filled = dataRows.filter((r) => isFilled(r.value)).length;
    const empty = total - filled;
    const optionRows = dataRows.filter((r) => {
      const node = r.TreeBranchLeafNode;
      const t = node?.type;
      return t === "leaf_option_field" || t === "option_field" || t === 5;
    });
    const optionTotal = optionRows.length;
    const optionFilled = optionRows.filter((r) => isFilled(r.value)).length;
    const optionEmpty = optionTotal - optionFilled;
    const variablesTotal = dataRows.filter((r) => r.isVariable === true).length;
    const completion = total > 0 ? Math.round(filled / total * 100) : 0;
    return res.json({
      submissionId: id,
      treeId: submission.treeId,
      status: submission.status,
      updatedAt: submission.updatedAt,
      counts: {
        total,
        filled,
        empty,
        optionFields: { total: optionTotal, filled: optionFilled, empty: optionEmpty },
        variables: { total: variablesTotal }
      },
      completion
    });
  } catch (error) {
    console.error("[TreeBranchLeaf API] \xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 Erreur GET /submissions/:id/summary:", error);
    return res.status(500).json({ error: "Erreur lors du calcul du r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9sum\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 de la soumission" });
  }
});
router56.get("/submissions/:id/operations", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const submission = await prisma31.treeBranchLeafSubmission.findUnique({
      where: { id },
      select: {
        id: true,
        treeId: true,
        TreeBranchLeafTree: { select: { id: true, organizationId: true } }
      }
    });
    if (!submission) return res.status(404).json({ error: "Soumission non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
    const treeOrg = submission.TreeBranchLeafTree?.organizationId;
    if (!isSuperAdmin2 && treeOrg && treeOrg !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 cette soumission" });
    }
    const rows = await prisma31.treeBranchLeafSubmissionData.findMany({
      where: { submissionId: id },
      include: {
        TreeBranchLeafNode: { select: { id: true, label: true, type: true } }
      },
      // TreeBranchLeafSubmissionData n'a pas de colonne updatedAt -> trier par lastResolved puis createdAt
      orderBy: [
        { lastResolved: "desc" },
        { createdAt: "desc" }
      ]
    });
    if (rows.length === 0) {
      if (submission?.treeId) {
        const treeVariables = await prisma31.treeBranchLeafNodeVariable.findMany({
          where: { TreeBranchLeafNode: { treeId: submission.treeId } },
          select: {
            id: true,
            nodeId: true,
            exposedKey: true,
            displayName: true,
            unit: true,
            defaultValue: true,
            fixedValue: true,
            sourceRef: true,
            TreeBranchLeafNode: { select: { id: true, label: true, type: true } }
          }
        });
        const pseudoRows = treeVariables.map((v) => ({
          nodeId: v.nodeId,
          submissionId: id,
          isVariable: true,
          fieldLabel: v.TreeBranchLeafNode?.label || null,
          variableDisplayName: v.displayName,
          variableKey: v.exposedKey,
          variableUnit: v.unit,
          sourceRef: v.sourceRef,
          // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É‚Ä¶√Ç¬Ω√É‚Äö√Ç¬Ø CORRECTION: Utiliser fixedValue ou defaultValue comme valeur
          // √É∆í√Ç¬∞√É‚Ä¶√Ç¬∏√É‚Ä¶√Ç¬°√É‚Äö√Ç¬ß TEMPORAIRE: Valeurs de test hardcod√É∆í√Ü‚Äô√É‚Äö√Ç¬©es pour validation
          value: getTestValueForNode(v.nodeId, v.fixedValue, v.defaultValue),
          operationSource: null,
          operationDetail: null,
          operationResult: null,
          lastResolved: null,
          createdAt: /* @__PURE__ */ new Date(),
          TreeBranchLeafNode: v.TreeBranchLeafNode
        }));
        rows.push(...pseudoRows);
      }
    }
    const inferSource = (sourceRef) => {
      const s = (sourceRef || "").toLowerCase();
      if (s.includes("formula") || s.includes("formule")) return "formula";
      if (s.includes("condition")) return "condition";
      if (s.includes("table")) return "table";
      return "neutral";
    };
    const treeId = submission?.treeId;
    if (!treeId) {
      return res.status(404).json({ error: "Soumission non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
    }
    const allTreeNodes = await prisma31.treeBranchLeafNode.findMany({
      where: { treeId },
      select: { id: true, label: true }
    });
    const labelMap = new Map(allTreeNodes.map((n) => [n.id, n.label || null]));
    const valuesMap = new Map(rows.map((r) => [r.nodeId, r.value == null ? null : String(r.value)]));
    for (const r of rows) {
      const nodeLabel = r.TreeBranchLeafNode?.label || r.fieldLabel;
      if (nodeLabel && nodeLabel !== labelMap.get(r.nodeId)) {
        labelMap.set(r.nodeId, nodeLabel);
      }
    }
    const ensureNodeLabels = async (ids) => {
      const list = Array.isArray(ids) ? ids : Array.from(ids);
      const missing = list.filter((id2) => !!id2 && !labelMap.has(id2));
      if (missing.length === 0) return;
      const extra = await prisma31.treeBranchLeafNode.findMany({ where: { id: { in: missing } }, select: { id: true, label: true } });
      for (const n of extra) labelMap.set(n.id, n.label || null);
    };
    const resolveDetailForRow = async (r) => {
      const det = r.operationDetail;
      if (det && det.type) {
        const parsed2 = parseSourceRef(r.sourceRef);
        if (parsed2?.type === "condition") {
          const rec = await prisma31.treeBranchLeafNodeCondition.findUnique({ where: { id: parsed2.id }, select: { id: true, name: true, description: true, conditionSet: true, nodeId: true } });
          return buildOperationDetail("condition", rec);
        }
        if (parsed2?.type === "formula") {
          const rec = await prisma31.treeBranchLeafNodeFormula.findUnique({ where: { id: parsed2.id }, select: { id: true, name: true, description: true, tokens: true, nodeId: true } });
          return buildOperationDetail("formula", rec);
        }
        if (parsed2?.type === "table") {
          const rec = await prisma31.treeBranchLeafNodeTable.findUnique({ where: { id: parsed2.id }, select: { id: true, name: true, description: true, type: true, nodeId: true } });
          return buildOperationDetail("table", rec);
        }
        return det;
      }
      const parsed = parseSourceRef(r.sourceRef);
      if (!parsed) return det || null;
      if (parsed.type === "condition") {
        const rec = await prisma31.treeBranchLeafNodeCondition.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, conditionSet: true, nodeId: true } });
        return buildOperationDetail("condition", rec);
      }
      if (parsed.type === "formula") {
        const rec = await prisma31.treeBranchLeafNodeFormula.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, tokens: true, nodeId: true } });
        return buildOperationDetail("formula", rec);
      }
      if (parsed.type === "table") {
        const rec = await prisma31.treeBranchLeafNodeTable.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, type: true, nodeId: true } });
        return buildOperationDetail("table", rec);
      }
      return det || null;
    };
    const items = await Promise.all(rows.map(async (r) => {
      const nodeLabel = r.fieldLabel || r.TreeBranchLeafNode?.label || labelMap.get(r.nodeId) || null;
      const unit = r.variableUnit || null;
      const val = r.value == null ? null : String(r.value);
      const displayName = r.variableDisplayName || nodeLabel;
      const response = val;
      const source = r.isVariable ? inferSource(r.sourceRef) : "neutral";
      const operationDetail = r.operationDetail ?? (r.isVariable ? r.sourceRef || void 0 : nodeLabel || void 0);
      const labelForResult = displayName || nodeLabel || labelMap.get(r.nodeId) || r.TreeBranchLeafNode?.id || "\xC3\u0192\xC2\xA2\xC3\xA2\xE2\u20AC\u0161\xC2\xAC\xC3\xA2\xE2\u201A\xAC\xC2\x9D";
      const operationResult = unit && response ? `${labelForResult}: ${response} ${unit}` : `${labelForResult}: ${response ?? ""}`;
      const detNormalized = await resolveDetailForRow(r);
      let operationDetailResolved = void 0;
      let operationResultResolved = void 0;
      let operationHumanText = void 0;
      const det = detNormalized;
      if (det && det.type) {
        if (det.type === "condition") {
          const set = det.conditionSet;
          const refIds = extractNodeIdsFromConditionSet2(set);
          await ensureNodeLabels(refIds);
          const _resolvedRefs = buildResolvedRefs(refIds, labelMap, valuesMap);
          const extendLabelsWithFormulas = async (conditionSet, baseLabels) => {
            const extended = new Map(baseLabels);
            try {
              const str = JSON.stringify(conditionSet) || "";
              const ids = /* @__PURE__ */ new Set();
              let m;
              const re = /node-formula:([a-f0-9-]{36})/gi;
              while ((m = re.exec(str)) !== null) ids.add(m[1]);
              if (ids.size === 0) return extended;
              const list = Array.from(ids);
              const formulas = await prisma31.treeBranchLeafNodeFormula.findMany({ where: { id: { in: list } }, select: { id: true, nodeId: true } });
              for (const f of formulas) {
                const nodeLbl = labelMap.get(f.nodeId) ?? null;
                if (nodeLbl) extended.set(f.id, nodeLbl);
              }
            } catch {
            }
            return extended;
          };
          const labelsForText = await extendLabelsWithFormulas(set, labelMap);
          const setObj2 = set && typeof set === "object" ? set : {};
          const branches = Array.isArray(setObj2.branches) ? setObj2.branches : [];
          const _branchesResolved = branches.map((b) => {
            const bb = b;
            const actions = bb.actions;
            return {
              label: bb.label || null,
              when: bb.when || null,
              actions: resolveActionsLabels(actions, labelsForText)
            };
          });
          operationHumanText = "\xC3\u0192\xC2\xB0\xC3\u2026\xC2\xB8\xC3\xA2\xE2\u201A\xAC\xC2\x9D\xC3\xA2\xE2\u201A\xAC\xC5\xBE Condition \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valu\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e via TBL Prisma (ligne 4755)";
          const { detail, result } = buildDetailAndResultForOperation(det, operationHumanText, unit, labelForResult, response);
          operationDetailResolved = detail;
          operationResultResolved = result;
        } else if (det.type === "formula") {
          const refIds = extractNodeIdsFromTokens2(det.tokens);
          await ensureNodeLabels(refIds);
          const _resolvedRefs = buildResolvedRefs(refIds, labelMap, valuesMap);
          {
            let expr = buildTextFromTokens(det.tokens, labelMap, valuesMap);
            operationHumanText = expr;
          }
          const { detail, result } = buildDetailAndResultForOperation(det, operationHumanText, unit, labelForResult, response);
          operationDetailResolved = detail;
          operationResultResolved = result;
        } else if (det.type === "table") {
          const refIds = /* @__PURE__ */ new Set();
          const str = JSON.stringify(det);
          if (str) {
            let m;
            const re = /@value\.([a-f0-9-]{36})/gi;
            while ((m = re.exec(str)) !== null) refIds.add(m[1]);
          }
          await ensureNodeLabels(refIds);
          {
            const expr = buildTextFromTableRecord(det, labelMap, valuesMap);
            const unitSuffix = unit ? ` ${unit}` : "";
            operationHumanText = expr ? `${expr} (=) ${labelForResult} (${response ?? ""}${unitSuffix})` : `${labelForResult} (${response ?? ""}${unitSuffix})`;
          }
          const { detail, result } = buildDetailAndResultForOperation(det, operationHumanText, unit, labelForResult, response);
          operationDetailResolved = detail;
          operationResultResolved = result;
        }
      }
      return {
        nodeId: r.nodeId,
        isVariable: r.isVariable,
        fieldLabel: nodeLabel,
        variableDisplayName: r.variableDisplayName || null,
        variableKey: r.variableKey || null,
        unit,
        sourceRef: r.sourceRef || null,
        operationSource: source,
        operationDetail: operationDetailResolved || detNormalized || operationDetail,
        operationResult: operationResultResolved || operationResult,
        // Pour les conditions, operationHumanText contient d√É∆í√Ü‚Äô√É‚Äö√Ç¬©j√É∆í√Ü‚Äô√É‚Äö√Ç¬† l'expression compl√É∆í√Ü‚Äô√É‚Äö√Ç¬®te souhait√É∆í√Ü‚Äô√É‚Äö√Ç¬©e
        operationResultText: operationHumanText ? operationHumanText : null,
        operationResultResolved,
        operationDetailResolved,
        response,
        lastResolved: r.lastResolved
      };
    }));
    return res.json({ submissionId: id, items });
  } catch (error) {
    console.error("[TreeBranchLeaf API] \xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 Erreur GET /submissions/:id/operations:", error);
    return res.status(500).json({ error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration des op\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rations" });
  }
});
router56.post("/submissions/:id/repair-ops", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const submission = await prisma31.treeBranchLeafSubmission.findUnique({
      where: { id },
      include: { TreeBranchLeafTree: { select: { id: true, organizationId: true } } }
    });
    if (!submission) return res.status(404).json({ error: "Soumission non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
    const treeId = submission.treeId;
    const treeOrg = submission.TreeBranchLeafTree?.organizationId;
    if (!isSuperAdmin2 && treeOrg && treeOrg !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 cette soumission" });
    }
    const nodes = await prisma31.treeBranchLeafNode.findMany({ where: { treeId }, select: { id: true, label: true } });
    const labelMap = new Map(nodes.map((n) => [n.id, n.label]));
    const variables = await prisma31.treeBranchLeafNodeVariable.findMany({
      where: { TreeBranchLeafNode: { treeId } },
      include: { TreeBranchLeafNode: { select: { label: true } } }
    });
    const varMetaByNodeId = new Map(
      variables.map((v) => [
        v.nodeId,
        {
          displayName: v.displayName || v.TreeBranchLeafNode?.label || v.exposedKey || v.nodeId,
          unit: v.unit || null,
          sourceRef: v.sourceRef || null
        }
      ])
    );
    const inferSource = (sourceRef) => {
      const s = (sourceRef || "").toLowerCase();
      if (s.includes("formula") || s.includes("formule")) return "formula";
      if (s.includes("condition")) return "condition";
      if (s.includes("table")) return "table";
      return "neutral";
    };
    const rows = await prisma31.treeBranchLeafSubmissionData.findMany({
      where: { submissionId: id },
      select: { nodeId: true, isVariable: true, value: true, sourceRef: true }
    });
    const submissionValues = await prisma31.treeBranchLeafSubmissionData.findMany({
      where: { submissionId: id },
      select: { nodeId: true, value: true }
    });
    const valuesMapAll = new Map(submissionValues.map((r) => [r.nodeId, r.value == null ? null : String(r.value)]));
    const now = /* @__PURE__ */ new Date();
    for (const row of rows) {
      const isVar = row.isVariable;
      const meta = isVar ? varMetaByNodeId.get(row.nodeId) : void 0;
      const label = labelMap.get(row.nodeId) || void 0;
      const valueStr = row.value == null ? null : String(row.value);
      const opSrc = isVar ? inferSource(meta?.sourceRef || null) : "neutral";
      const display = isVar ? meta?.displayName || label || row.nodeId : label || row.nodeId;
      let opRes = meta?.unit && valueStr ? `${display}: ${valueStr} ${meta.unit}` : `${display}: ${valueStr ?? ""}`;
      let opDetail = void 0;
      const parsed = parseSourceRef(row.sourceRef);
      if (isVar && parsed) {
        if (parsed.type === "condition") {
          const rec = await prisma31.treeBranchLeafNodeCondition.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, conditionSet: true, nodeId: true } });
          const { detail, result } = await buildDetailAndResultForOperation("condition", rec, display, valueStr, meta?.unit || null, labelMap, valuesMapAll, prisma31, id, organizationId || "", req2.user?.id || "");
          opDetail = detail;
          opRes = result;
        } else if (parsed.type === "formula") {
          const rec = await prisma31.treeBranchLeafNodeFormula.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, tokens: true, nodeId: true } });
          const { detail, result } = await buildDetailAndResultForOperation("formula", rec, display, valueStr, meta?.unit || null, labelMap, valuesMapAll, prisma31, id, organizationId || "", req2.user?.id || "");
          opDetail = detail;
          opRes = result;
        } else if (parsed.type === "table") {
          const rec = await prisma31.treeBranchLeafNodeTable.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, type: true, nodeId: true } });
          const { detail, result } = await buildDetailAndResultForOperation("table", rec, display, valueStr, meta?.unit || null, labelMap, valuesMapAll, prisma31, id, organizationId || "", req2.user?.id || "");
          opDetail = detail;
          opRes = result;
        }
      }
      await prisma31.treeBranchLeafSubmissionData.updateMany({
        where: { submissionId: id, nodeId: row.nodeId },
        data: {
          operationSource: opSrc,
          // Fallback prioritaire: row.sourceRef (pr√É∆í√Ü‚Äô√É‚Äö√Ç¬©sent c√É∆í√Ü‚Äô√É‚Äö√Ç¬¥t√É∆í√Ü‚Äô√É‚Äö√Ç¬© submissionData), puis meta.sourceRef, sinon label
          operationDetail: isVar ? opDetail ?? (row.sourceRef || meta?.sourceRef || void 0) : label || void 0,
          operationResult: opRes,
          lastResolved: now
        }
      });
    }
    return res.json({ success: true, updated: rows.length });
  } catch (error) {
    console.error("[TreeBranchLeaf API] \xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 Erreur POST /submissions/:id/repair-ops:", error);
    return res.status(500).json({ error: "Erreur lors du backfill des op\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rations" });
  }
});
router56.post("/submissions", async (req2, res) => {
  const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
  const userId = req2.user?.id;
  const { treeId, leadId, name, data } = req2.body;
  const normalizedTreeId = treeId != null ? String(treeId) : "";
  const normalizedLeadId = leadId != null && leadId !== "" ? String(leadId) : null;
  try {
    const approxBytes = (() => {
      try {
        return JSON.stringify(data)?.length ?? 0;
      } catch {
        return 0;
      }
    })();
    if (!normalizedTreeId) {
      return res.status(400).json({ error: "treeId est requis" });
    }
    if (!userId) {
      console.warn("[TreeBranchLeaf API] \xC3\u0192\xC2\xA2\xC3\u2026\xC2\xA1\xC3\u201A\xC2\xA0\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xB8\xC3\u201A\xC2\x8F Aucun userId dans la requ\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xAAte (mode anonyme/mock) \xC3\u0192\xC2\xA2\xC3\xA2\xE2\u20AC\u0161\xC2\xAC\xC3\xA2\xE2\u201A\xAC\xC5\u201C poursuite sans liaison utilisateur");
    }
    if (!name || typeof name !== "string") {
      return res.status(400).json({ error: "name est requis et doit \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xAAtre une cha\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xAEne" });
    }
    const tree = await prisma31.treeBranchLeafTree.findFirst({
      where: {
        id: normalizedTreeId,
        ...isSuperAdmin2 ? {} : { organizationId }
      }
    });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 ou acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    let lead = null;
    if (normalizedLeadId) {
      lead = await prisma31.lead.findFirst({
        where: {
          id: normalizedLeadId,
          ...isSuperAdmin2 ? {} : { organizationId }
        }
      });
      if (!lead) {
        return res.status(404).json({ error: "Lead non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 ou acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
      }
    } else {
    }
    const validNodes = await prisma31.treeBranchLeafNode.findMany({
      where: { treeId: normalizedTreeId },
      select: { id: true }
    });
    const validNodeIds = new Set(validNodes.map((node) => node.id));
    const rawEntries = (() => {
      if (Array.isArray(data)) {
        return data.map((it) => {
          if (it && typeof it === "object" && "nodeId" in it) {
            const obj = it;
            return { nodeId: String(obj.nodeId), value: obj.value, calculatedValue: obj.calculatedValue };
          }
          return null;
        }).filter((x) => !!x);
      }
      if (data && typeof data === "object") {
        return Object.entries(data).map(([nodeId, value]) => ({ nodeId, value }));
      }
      return [];
    })();
    const filteredEntries = rawEntries.filter(({ nodeId }) => {
      const isValid = validNodeIds.has(nodeId);
      return isValid;
    });
    try {
      let safeUserId = null;
      if (userId) {
        try {
          const existingUser = await prisma31.user.findUnique({ where: { id: userId } });
          if (existingUser) {
            safeUserId = userId;
          } else {
            console.warn("[TreeBranchLeaf API] \xC3\u0192\xC2\xA2\xC3\u2026\xC2\xA1\xC3\u201A\xC2\xA0\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xB8\xC3\u201A\xC2\x8F userId fourni mais introuvable en base \xC3\u0192\xC2\xA2\xC3\xA2\xE2\u20AC\u0161\xC2\xAC\xC3\xA2\xE2\u201A\xAC\xC5\u201C cr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ation avec userId NULL");
          }
        } catch (checkErr) {
          console.warn("[TreeBranchLeaf API] \xC3\u0192\xC2\xA2\xC3\u2026\xC2\xA1\xC3\u201A\xC2\xA0\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xB8\xC3\u201A\xC2\x8F \xC3\u0192\xC6\u2019\xC3\xA2\xE2\u201A\xAC\xC2\xB0chec de v\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rification userId \xC3\u0192\xC2\xA2\xC3\xA2\xE2\u20AC\u0161\xC2\xAC\xC3\xA2\xE2\u201A\xAC\xC5\u201C cr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ation avec userId NULL:", checkErr?.message);
        }
      }
      const now = /* @__PURE__ */ new Date();
      const created = await prisma31.treeBranchLeafSubmission.create({
        data: {
          id: (0, import_crypto19.randomUUID)(),
          treeId: normalizedTreeId,
          userId: safeUserId,
          leadId: normalizedLeadId,
          status: "draft",
          updatedAt: now
        }
      });
      if (filteredEntries.length > 0) {
        const keys = filteredEntries.map(({ nodeId }) => nodeId);
        const nodesForLabels = await prisma31.treeBranchLeafNode.findMany({
          where: { id: { in: keys } },
          select: { id: true, label: true }
        });
        const labelMap = new Map(nodesForLabels.map((n) => [n.id, n.label]));
        const existing = await prisma31.treeBranchLeafSubmissionData.findMany({
          where: { submissionId: created.id, nodeId: { in: keys } },
          select: { nodeId: true }
        });
        const existingSet = new Set(existing.map((e) => e.nodeId));
        const toCreate = filteredEntries.filter(({ nodeId }) => !existingSet.has(nodeId));
        const toUpdate = filteredEntries.filter(({ nodeId }) => existingSet.has(nodeId));
        await prisma31.$transaction(async (tx) => {
          if (toCreate.length > 0) {
            await tx.treeBranchLeafSubmissionData.createMany({
              data: toCreate.map(({ nodeId, value: raw }) => ({
                id: (0, import_crypto19.randomUUID)(),
                submissionId: created.id,
                nodeId,
                value: raw == null ? null : String(raw),
                fieldLabel: labelMap.get(nodeId) || null,
                isVariable: false
              }))
            });
          }
          if (toUpdate.length > 0) {
            for (const { nodeId, value: raw } of toUpdate) {
              try {
                await tx.treeBranchLeafSubmissionData.update({
                  where: { submissionId_nodeId: { submissionId: created.id, nodeId } },
                  data: { value: raw == null ? null : String(raw), fieldLabel: labelMap.get(nodeId) || void 0 }
                });
              } catch {
                await tx.treeBranchLeafSubmissionData.updateMany({
                  where: { submissionId: created.id, nodeId },
                  data: { value: raw == null ? null : String(raw), fieldLabel: labelMap.get(nodeId) || void 0 }
                });
              }
            }
          }
        });
      } else {
      }
      try {
        const treeIdForBackfill = created.treeId;
        const [nodesForBackfill, varsForBackfill] = await Promise.all([
          prisma31.treeBranchLeafNode.findMany({ where: { treeId: treeIdForBackfill }, select: { id: true, label: true } }),
          prisma31.treeBranchLeafNodeVariable.findMany({ where: { TreeBranchLeafNode: { treeId: treeIdForBackfill } }, include: { TreeBranchLeafNode: { select: { label: true } } } })
        ]);
        const labelMapBF = new Map(nodesForBackfill.map((n) => [n.id, n.label]));
        const varMetaByNodeIdBF = new Map(
          varsForBackfill.map((v) => [
            v.nodeId,
            {
              displayName: v.displayName || v.TreeBranchLeafNode?.label || v.exposedKey || v.nodeId,
              unit: v.unit || null,
              sourceRef: v.sourceRef || null
            }
          ])
        );
        const rowsBF = await prisma31.treeBranchLeafSubmissionData.findMany({
          where: { submissionId: created.id },
          select: { nodeId: true, isVariable: true, value: true, sourceRef: true }
        });
        const valuesMapBF = new Map(rowsBF.map((r) => [r.nodeId, r.value == null ? null : String(r.value)]));
        const nowBF = /* @__PURE__ */ new Date();
        for (const row of rowsBF) {
          if (!row.isVariable) continue;
          const meta = varMetaByNodeIdBF.get(row.nodeId);
          const label = labelMapBF.get(row.nodeId) || void 0;
          const valueStr = row.value == null ? null : String(row.value);
          const opSrc = (() => {
            const s = (meta?.sourceRef || "").toLowerCase();
            if (s.includes("formula") || s.includes("formule")) return "formula";
            if (s.includes("condition")) return "condition";
            if (s.includes("table")) return "table";
            return "neutral";
          })();
          const display = meta?.displayName || label || row.nodeId;
          let opRes = meta?.unit && valueStr ? `${display}: ${valueStr} ${meta.unit}` : `${display}: ${valueStr ?? ""}`;
          let opDetail = void 0;
          const parsed = parseSourceRef(row.sourceRef || meta?.sourceRef || null);
          if (parsed) {
            if (parsed.type === "condition") {
              const rec = await prisma31.treeBranchLeafNodeCondition.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, conditionSet: true, nodeId: true } });
              const { detail, result } = await buildDetailAndResultForOperation("condition", rec, display, valueStr, meta?.unit || null, labelMapBF, valuesMapBF, prisma31, created.id, organizationId || "", userId || "");
              opDetail = detail;
              opRes = result;
            } else if (parsed.type === "formula") {
              const rec = await prisma31.treeBranchLeafNodeFormula.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, tokens: true, nodeId: true } });
              const { detail, result } = await buildDetailAndResultForOperation("formula", rec, display, valueStr, meta?.unit || null, labelMapBF, valuesMapBF, prisma31, created.id, organizationId || "", userId || "");
              opDetail = detail;
              opRes = result;
            } else if (parsed.type === "table") {
              const rec = await prisma31.treeBranchLeafNodeTable.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, type: true, nodeId: true } });
              const { detail, result } = await buildDetailAndResultForOperation("table", rec, display, valueStr, meta?.unit || null, labelMapBF, valuesMapBF, prisma31, created.id, organizationId || "", userId || "");
              opDetail = detail;
              opRes = result;
            }
          }
          await prisma31.treeBranchLeafSubmissionData.updateMany({
            where: { submissionId: created.id, nodeId: row.nodeId },
            data: {
              operationSource: opSrc,
              operationDetail: opDetail ?? (row.sourceRef || meta?.sourceRef || void 0),
              operationResult: opRes,
              lastResolved: nowBF
            }
          });
        }
      } catch (enrichErr) {
        console.warn("[TreeBranchLeaf API] \xC3\u0192\xC2\xA2\xC3\u2026\xC2\xA1\xC3\u201A\xC2\xA0\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xB8\xC3\u201A\xC2\x8F Backfill post-cr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ation des op\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rations non critique a \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9chou\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9:", enrichErr?.message);
      }
      const full = await prisma31.treeBranchLeafSubmission.findUnique({
        where: { id: created.id },
        include: {
          TreeBranchLeafTree: { select: { id: true, name: true } },
          Lead: { select: { id: true, firstName: true, lastName: true, email: true } },
          TreeBranchLeafSubmissionData: {
            include: {
              TreeBranchLeafNode: { select: { id: true, label: true, type: true } }
            }
          }
        }
      });
      if (!full) {
        throw new Error("Soumission non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e apr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s cr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ation");
      }
      const responsePayload = {
        id: full.id,
        treeId: full.treeId,
        userId: full.userId,
        leadId: full.leadId,
        status: full.status,
        summary: full.summary,
        updatedAt: full.updatedAt,
        TreeBranchLeafTree: full.TreeBranchLeafTree,
        Lead: full.Lead || null,
        TreeBranchLeafSubmissionData: full.TreeBranchLeafSubmissionData
      };
      res.status(201).json(responsePayload);
    } catch (error) {
      const err = error;
      console.error("[TreeBranchLeaf API] \xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 ERREUR D\xC3\u0192\xC6\u2019\xC3\xA2\xE2\u201A\xAC\xC2\xB0TAILL\xC3\u0192\xC6\u2019\xC3\xA2\xE2\u201A\xAC\xC2\xB0E lors de la cr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ation:", {
        message: err?.message,
        code: err?.code,
        meta: err?.meta
      });
      if (err?.stack) console.error(err.stack);
      if (err && err.code) {
        console.error("[TreeBranchLeaf API] \xC3\u0192\xC2\xB0\xC3\u2026\xC2\xB8\xC3\xA2\xE2\u201A\xAC\xC2\x9D\xC3\u201A\xC2\x8D Code erreur Prisma:", err.code);
        if (err.meta) {
          console.error("[TreeBranchLeaf API] \xC3\u0192\xC2\xB0\xC3\u2026\xC2\xB8\xC3\xA2\xE2\u201A\xAC\xC2\x9D\xC3\u201A\xC2\x8D M\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9tadonn\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9es:", err.meta);
        }
      }
      return res.status(500).json({
        error: "Erreur lors de la cr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ation de la soumission",
        details: process.env.NODE_ENV === "development" ? err?.message : void 0
      });
    }
  } catch (outerErr) {
    const e = outerErr;
    console.error("[TreeBranchLeaf API] \xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 Erreur inattendue en entr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e de route /submissions:", e?.message);
    return res.status(500).json({ error: "Erreur interne inattendue" });
  }
});
router56.delete("/submissions/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const submission = await prisma31.treeBranchLeafSubmission.findUnique({
      where: { id }
    });
    if (!submission) {
      return res.status(404).json({ error: "Soumission non trouvee" });
    }
    if (!isSuperAdmin2) {
      if (submission.leadId) {
        const lead = await prisma31.lead.findFirst({
          where: { id: submission.leadId, organizationId }
        });
        if (!lead) {
          return res.status(403).json({ error: "Acces refuse: le lead n'appartient pas a votre organisation" });
        }
      }
    }
    await prisma31.treeBranchLeafSubmissionData.deleteMany({
      where: { submissionId: id }
    });
    await prisma31.treeBranchLeafSubmissionVersion.deleteMany({
      where: { submissionId: id }
    });
    await prisma31.treeBranchLeafSubmission.delete({
      where: { id }
    });
    console.log(`[TreeBranchLeaf API] Soumission ${id} supprimee avec succes`);
    res.json({ success: true, message: "Soumission supprimee avec succes" });
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error deleting submission:", error);
    res.status(500).json({ error: "Erreur lors de la suppression de la soumission" });
  }
});
router56.get("/nodes/:fieldId/select-config", async (req2, res) => {
  try {
    const { fieldId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const access = await ensureNodeOrgAccess(prisma31, fieldId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) {
      return res.status(access.status).json({ error: access.error });
    }
    let selectConfig = await prisma31.treeBranchLeafSelectConfig.findFirst({
      where: { nodeId: fieldId }
    });
    if (!selectConfig) {
      const node = await prisma31.treeBranchLeafNode.findUnique({
        where: { id: fieldId },
        select: {
          id: true,
          hasTable: true,
          table_activeId: true,
          table_instances: true
        }
      });
      if (node?.hasTable && node.table_activeId && node.table_instances) {
        const instances = node.table_instances;
        const activeInstance = instances[node.table_activeId];
        const isRowBased = activeInstance?.rowBased === true;
        const isColumnBased = activeInstance?.columnBased === true;
        if (isRowBased || isColumnBased) {
          selectConfig = await prisma31.treeBranchLeafSelectConfig.create({
            data: {
              id: (0, import_crypto19.randomUUID)(),
              nodeId: fieldId,
              options: [],
              multiple: false,
              searchable: true,
              allowCustom: false,
              optionsSource: "table",
              tableReference: node.table_activeId,
              keyColumn: null,
              valueColumn: null,
              displayColumn: null,
              dependsOnNodeId: null,
              createdAt: /* @__PURE__ */ new Date(),
              updatedAt: /* @__PURE__ */ new Date()
            }
          });
        }
      }
      if (!selectConfig) {
        return res.status(404).json({ error: "Configuration SELECT introuvable" });
      }
    }
    return res.json(selectConfig);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching select config:", error);
    res.status(500).json({ error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration de la configuration SELECT" });
  }
});
router56.post("/nodes/:fieldId/select-config", async (req2, res) => {
  try {
    const { fieldId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const {
      optionsSource,
      tableReference,
      keyColumn,
      keyRow,
      valueColumn,
      valueRow,
      displayColumn,
      displayRow,
      dependsOnNodeId
    } = req2.body;
    console.log("[MANUAL-SAVE][SELECT-CONFIG] \u27A1\uFE0F POST /nodes/:fieldId/select-config", {
      fieldId,
      optionsSource,
      tableReference,
      keyColumn,
      keyRow,
      valueColumn,
      valueRow,
      displayColumn,
      displayRow,
      dependsOnNodeId
    });
    const access = await ensureNodeOrgAccess(prisma31, fieldId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) {
      return res.status(access.status).json({ error: access.error });
    }
    const selectConfig = await prisma31.treeBranchLeafSelectConfig.upsert({
      where: { nodeId: fieldId },
      create: {
        id: (0, import_crypto19.randomUUID)(),
        nodeId: fieldId,
        options: [],
        multiple: false,
        searchable: true,
        allowCustom: false,
        optionsSource: optionsSource || "table",
        tableReference: tableReference || null,
        keyColumn: keyColumn || null,
        keyRow: keyRow || null,
        valueColumn: valueColumn || null,
        valueRow: valueRow || null,
        displayColumn: displayColumn || null,
        displayRow: displayRow || null,
        dependsOnNodeId: dependsOnNodeId || null,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      },
      update: {
        optionsSource: optionsSource || "table",
        tableReference: tableReference || null,
        keyColumn: keyColumn || null,
        keyRow: keyRow || null,
        valueColumn: valueColumn || null,
        valueRow: valueRow || null,
        displayColumn: displayColumn || null,
        displayRow: displayRow || null,
        dependsOnNodeId: dependsOnNodeId || null,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log("[MANUAL-SAVE][SELECT-CONFIG] \u2705 Persist\xE9", {
      fieldId,
      id: selectConfig.id,
      tableReference: selectConfig.tableReference,
      keyColumn: selectConfig.keyColumn,
      keyRow: selectConfig.keyRow,
      valueColumn: selectConfig.valueColumn,
      valueRow: selectConfig.valueRow,
      displayColumn: selectConfig.displayColumn,
      displayRow: selectConfig.displayRow,
      dependsOnNodeId: selectConfig.dependsOnNodeId
    });
    return res.json(selectConfig);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error creating select config:", error);
    res.status(500).json({ error: "Erreur lors de la cr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ation de la configuration SELECT" });
  }
});
router56.post("/nodes/:nodeId/normalize-step4", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const { tableId: bodyTableId, displayColumn: bodyDisplayColumn } = req2.body || {};
    console.log("[STEP4-AUTO] \u27A1\uFE0F START normalize-step4", { nodeId, bodyTableId, bodyDisplayColumn });
    const access = await ensureNodeOrgAccess(prisma31, nodeId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) {
      return res.status(access.status).json({ error: access.error });
    }
    const node = await prisma31.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      select: { table_activeId: true, hasTable: true }
    });
    let tableId = bodyTableId || node?.table_activeId || null;
    if (!tableId) {
      const sc2 = await prisma31.treeBranchLeafSelectConfig.findFirst({ where: { nodeId } });
      tableId = sc2?.tableReference || null;
    }
    if (!tableId) {
      console.warn("[STEP4-AUTO] \u274C No tableId found for node", { nodeId });
      return res.status(404).json({ error: "Aucune table active pour ce champ" });
    }
    const table = await prisma31.treeBranchLeafNodeTable.findUnique({
      where: { id: tableId },
      include: { tableColumns: { orderBy: { columnIndex: "asc" } } }
    });
    if (!table) {
      return res.status(404).json({ error: "Table introuvable" });
    }
    const firstColName = table.tableColumns[0]?.name || null;
    const chosenDisplayColumn = bodyDisplayColumn || firstColName || null;
    if (!chosenDisplayColumn) {
      console.warn("[STEP4-AUTO] \u274C No displayColumn candidate", { tableId });
      return res.status(400).json({ error: "Impossible de d\xE9terminer displayColumn" });
    }
    console.log("[STEP4-AUTO] \u{1F3AF} Selected displayColumn", { tableId, displayColumn: chosenDisplayColumn });
    try {
      const metaObj = table.meta ? typeof table.meta === "string" ? JSON.parse(table.meta) : JSON.parse(JSON.stringify(table.meta)) : {};
      const nextMeta = {
        ...metaObj,
        lookup: {
          ...metaObj?.lookup || {},
          displayColumn: chosenDisplayColumn
        }
      };
      await prisma31.treeBranchLeafNodeTable.update({
        where: { id: tableId },
        data: { meta: nextMeta, updatedAt: /* @__PURE__ */ new Date() }
      });
      console.log("[STEP4-AUTO] \u2705 META updated", { tableId, displayColumn: chosenDisplayColumn });
    } catch (e) {
      console.warn("[STEP4-AUTO] \u26A0\uFE0F META update failed (non-bloquant):", e.message);
    }
    const sc = await prisma31.treeBranchLeafSelectConfig.upsert({
      where: { nodeId },
      create: {
        id: (0, import_crypto19.randomUUID)(),
        nodeId,
        options: [],
        multiple: false,
        searchable: true,
        allowCustom: false,
        optionsSource: "table",
        tableReference: tableId,
        keyColumn: null,
        keyRow: null,
        valueColumn: null,
        valueRow: null,
        displayColumn: chosenDisplayColumn,
        displayRow: null,
        dependsOnNodeId: null,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      },
      update: {
        optionsSource: "table",
        tableReference: tableId,
        displayColumn: chosenDisplayColumn,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log("[STEP4-AUTO] \u2705 SelectConfig upserted", {
      nodeId,
      tableReference: sc.tableReference,
      displayColumn: sc.displayColumn
    });
    return res.json({
      success: true,
      nodeId,
      tableId,
      displayColumn: chosenDisplayColumn
    });
  } catch (error) {
    console.error("[STEP4-AUTO] Error normalize-step4:", error);
    res.status(500).json({ error: "Erreur lors de la normalisation \xC9tape 4" });
  }
});
router56.get("/nodes/:nodeId/table/lookup", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const { formValues: formValuesParam } = req2.query;
    let formValues = {};
    if (formValuesParam) {
      try {
        formValues = JSON.parse(formValuesParam);
      } catch (e) {
        console.warn(`[TreeBranchLeaf API] \xC3\u0192\xC2\xA2\xC3\u2026\xC2\xA1\xC3\u201A\xC2\xA0\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xB8\xC3\u201A\xC2\x8F Erreur parsing formValues:`, e);
      }
    }
    const access = await ensureNodeOrgAccess(prisma31, nodeId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) {
      return res.status(access.status).json({ error: access.error });
    }
    let selectConfig = await prisma31.treeBranchLeafSelectConfig.findFirst({
      where: { nodeId },
      select: {
        tableReference: true,
        keyColumn: true,
        keyRow: true,
        valueColumn: true,
        valueRow: true,
        displayColumn: true,
        displayRow: true
      }
    });
    if (!selectConfig?.tableReference) {
      const node = await prisma31.treeBranchLeafNode.findUnique({
        where: { id: nodeId },
        select: { hasTable: true, table_activeId: true, table_instances: true }
      });
      if (node?.hasTable && node.table_activeId) {
        await prisma31.treeBranchLeafSelectConfig.upsert({
          where: { nodeId },
          create: {
            id: (0, import_crypto19.randomUUID)(),
            nodeId,
            options: [],
            multiple: false,
            searchable: true,
            allowCustom: false,
            optionsSource: "table",
            tableReference: node.table_activeId,
            keyColumn: null,
            keyRow: null,
            valueColumn: null,
            valueRow: null,
            displayColumn: null,
            displayRow: null,
            dependsOnNodeId: null,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          },
          update: {
            optionsSource: "table",
            tableReference: node.table_activeId,
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
        selectConfig = await prisma31.treeBranchLeafSelectConfig.findFirst({
          where: { nodeId },
          select: {
            tableReference: true,
            keyColumn: true,
            keyRow: true,
            valueColumn: true,
            valueRow: true,
            displayColumn: true,
            displayRow: true
          }
        });
      }
    }
    if (!selectConfig?.tableReference) {
      return res.json({ tableColumns: [], tableRows: [], options: [] });
    }
    const table = await prisma31.treeBranchLeafNodeTable.findUnique({
      where: { id: selectConfig.tableReference },
      select: {
        id: true,
        nodeId: true,
        name: true,
        type: true,
        meta: true,
        tableColumns: {
          select: { id: true, name: true, columnIndex: true },
          orderBy: { columnIndex: "asc" }
        },
        tableRows: {
          select: { id: true, rowIndex: true, cells: true },
          orderBy: { rowIndex: "asc" }
        }
      }
    });
    if (!table) {
      return res.status(404).json({ error: "Tableau introuvable" });
    }
    const columns = table.tableColumns.map((col) => col.name);
    const rows = [];
    const data = [];
    table.tableRows.forEach((row) => {
      try {
        let cellsData;
        if (typeof row.cells === "string") {
          try {
            cellsData = JSON.parse(row.cells);
          } catch {
            cellsData = [row.cells];
          }
        } else {
          cellsData = row.cells || [];
        }
        if (Array.isArray(cellsData) && cellsData.length > 0) {
          rows.push(String(cellsData[0] || ""));
          data.push(cellsData.slice(1));
        } else {
          rows.push("");
          data.push([]);
        }
      } catch (error) {
        console.error("[TreeBranchLeaf API] Erreur parsing cells:", error);
        rows.push("");
        data.push([]);
      }
    });
    const rawLookup = table.meta && typeof table.meta === "object" && "lookup" in table.meta ? table.meta.lookup : void 0;
    const fullMatrix = rows.map((rowLabel, idx) => [rowLabel, ...data[idx] || []]);
    let filters = [];
    if (rawLookup) {
      const columnSourceOption = rawLookup.columnSourceOption;
      const rowSourceOption = rawLookup.rowSourceOption;
      if (columnSourceOption?.filters && Array.isArray(columnSourceOption.filters)) {
        filters = columnSourceOption.filters;
      } else if (rowSourceOption?.filters && Array.isArray(rowSourceOption.filters)) {
        filters = rowSourceOption.filters;
      }
    }
    const fullMatrixForFilters = table.tableRows.map((row) => {
      try {
        let cellsData;
        if (typeof row.cells === "string") {
          try {
            cellsData = JSON.parse(row.cells);
          } catch {
            cellsData = [row.cells];
          }
        } else {
          cellsData = row.cells || [];
        }
        return Array.isArray(cellsData) ? cellsData : [];
      } catch {
        return [];
      }
    });
    let filteredRowIndices = fullMatrix.map((_, i) => i);
    if (filters.length > 0 && Object.keys(formValues).length > 0) {
      filteredRowIndices = await applyTableFilters(fullMatrixForFilters, columns, filters, formValues);
    }
    if (table.type === "matrix") {
      if (selectConfig?.keyRow) {
        const rowIndex = rows.indexOf(selectConfig.keyRow);
        if (rowIndex === -1) {
          console.warn(`\xC3\u0192\xC2\xA2\xC3\u2026\xC2\xA1\xC3\u201A\xC2\xA0\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xB8\xC3\u201A\xC2\x8F [TreeBranchLeaf API] Ligne "${selectConfig.keyRow}" introuvable`);
          return res.json({ options: [] });
        }
        let options;
        if (rowIndex === 0) {
          options = columns.slice(1).map((colName) => {
            return {
              value: colName,
              label: selectConfig.displayRow ? colName : colName
            };
          }).filter((opt) => opt.value !== "undefined" && opt.value !== "null" && opt.value !== "");
        } else {
          const dataRowIndex = rowIndex - 1;
          const rowData = data[dataRowIndex] || [];
          options = columns.slice(1).map((colName, colIdx) => {
            const value = rowData[colIdx];
            return {
              value: String(value),
              label: selectConfig.displayRow ? `${colName}: ${value}` : String(value)
            };
          }).filter((opt) => opt.value !== "undefined" && opt.value !== "null" && opt.value !== "");
        }
        return res.json({ options });
      }
      if (selectConfig?.keyColumn) {
        const colIndex = columns.indexOf(selectConfig.keyColumn);
        if (colIndex === -1) {
          console.warn(`\xC3\u0192\xC2\xA2\xC3\u2026\xC2\xA1\xC3\u201A\xC2\xA0\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xB8\xC3\u201A\xC2\x8F [TreeBranchLeaf API] Colonne "${selectConfig.keyColumn}" introuvable`);
          return res.json({ options: [] });
        }
        let options;
        if (colIndex === 0) {
          options = filteredRowIndices.filter((idx) => idx > 0).map((rowIdx) => {
            const rowLabel = rows[rowIdx];
            return {
              value: rowLabel,
              label: selectConfig.displayColumn ? rowLabel : rowLabel
            };
          }).filter((opt) => opt.value !== "undefined" && opt.value !== "null" && opt.value !== "");
        } else {
          const dataColIndex = colIndex - 1;
          options = filteredRowIndices.map((rowIdx) => {
            const row = data[rowIdx] || [];
            const value = row[dataColIndex];
            const rowLabel = rows[rowIdx] || "";
            return {
              value: String(value),
              label: selectConfig.displayColumn ? `${rowLabel}: ${value}` : String(value)
            };
          }).filter((opt) => opt.value !== "undefined" && opt.value !== "null" && opt.value !== "");
        }
        return res.json({ options });
      }
    }
    if (table.type === "matrix") {
      const hasNoConfig = !selectConfig?.keyRow && !selectConfig?.keyColumn;
      const a1 = rows[0];
      const firstColHeader = columns[0];
      const lookupMeta = rawLookup;
      const rowFieldId = lookupMeta?.selectors && typeof lookupMeta.selectors === "object" ? lookupMeta.selectors.rowFieldId : void 0;
      const columnFieldId = lookupMeta?.selectors && typeof lookupMeta.selectors === "object" ? lookupMeta.selectors.columnFieldId : void 0;
      const isRowField = rowFieldId === nodeId;
      const isColumnField = columnFieldId === nodeId;
      if (hasNoConfig && firstColHeader && a1) {
        let autoOptions = [];
        let keyColumnValue = null;
        let keyRowValue = null;
        if (isRowField) {
          autoOptions = columns.slice(1).filter((c) => c && c !== "undefined" && c !== "null" && c !== "").map((c) => ({ value: String(c), label: String(c) }));
          keyRowValue = a1;
        } else if (isColumnField || !isRowField && !isColumnField) {
          autoOptions = filteredRowIndices.filter((idx) => idx > 0).map((idx) => rows[idx]).filter((r) => r && r !== "undefined" && r !== "null").map((r) => ({ value: r, label: r }));
          keyColumnValue = firstColHeader;
        }
        try {
          await prisma31.treeBranchLeafSelectConfig.upsert({
            where: { nodeId },
            create: {
              id: (0, import_crypto19.randomUUID)(),
              nodeId,
              options: [],
              multiple: false,
              searchable: true,
              allowCustom: false,
              optionsSource: "table",
              tableReference: table.id,
              keyColumn: keyColumnValue,
              keyRow: keyRowValue,
              valueColumn: null,
              valueRow: null,
              displayColumn: null,
              displayRow: null,
              dependsOnNodeId: null,
              createdAt: /* @__PURE__ */ new Date(),
              updatedAt: /* @__PURE__ */ new Date()
            },
            update: {
              optionsSource: "table",
              tableReference: table.id,
              keyColumn: keyColumnValue,
              keyRow: keyRowValue,
              valueColumn: null,
              valueRow: null,
              displayColumn: null,
              displayRow: null,
              updatedAt: /* @__PURE__ */ new Date()
            }
          });
        } catch (e) {
          console.warn(`[TreeBranchLeaf API] \u26A0\uFE0F Auto-upsert select-config a \xE9chou\xE9 (non bloquant):`, e);
        }
        console.log(`[TreeBranchLeaf API] \u{1F3AF} AUTO-DEFAULT pour nodeId=${nodeId}:`, {
          optionsCount: autoOptions.length,
          firstFive: autoOptions.slice(0, 5),
          detectedRole: isRowField ? "rowField" : isColumnField ? "columnField" : "fallback"
        });
        return res.json({
          options: autoOptions,
          autoDefault: {
            source: isRowField ? "rowA1" : "columnA",
            keyColumnCandidate: keyColumnValue,
            keyRowCandidate: keyRowValue,
            detectedRole: isRowField ? "rowField" : isColumnField ? "columnField" : "fallback"
          }
        });
      }
    }
    return res.json(table);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching table for lookup:", error);
    res.status(500).json({ error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration du tableau" });
  }
});
router56.patch("/nodes/:nodeId", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const access = await ensureNodeOrgAccess(prisma31, nodeId, { organizationId, isSuperAdmin: isSuperAdmin2 });
    if (!access.ok) {
      return res.status(access.status).json({ error: access.error });
    }
    const updatedNode = await prisma31.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: {
        ...req2.body,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    return res.json(updatedNode);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error updating node:", error);
    res.status(500).json({ error: "Erreur lors de la mise \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 jour du n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud" });
  }
});
router56.put("/nodes/:nodeId/capabilities/table", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { enabled, activeId, currentTable } = req2.body;
    const node = await prisma31.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      select: {
        id: true,
        hasTable: true,
        metadata: true
      }
    });
    if (!node) {
      return res.status(404).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9" });
    }
    const oldMetadata = node.metadata || {};
    const oldCapabilities = oldMetadata.capabilities || {};
    const tableInstances = enabled && activeId ? {
      [activeId]: currentTable || { mode: "matrix", tableId: activeId }
    } : null;
    const newCapabilities = {
      ...oldCapabilities,
      table: {
        enabled: enabled === true,
        activeId: enabled ? activeId || null : null,
        instances: tableInstances,
        currentTable: enabled ? currentTable || null : null
      }
    };
    const newMetadata = {
      ...oldMetadata,
      capabilities: newCapabilities
    };
    await prisma31.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: {
        hasTable: enabled === true,
        table_activeId: enabled ? activeId || null : null,
        table_instances: tableInstances ? JSON.parse(JSON.stringify(tableInstances)) : null,
        metadata: JSON.parse(JSON.stringify(newMetadata)),
        // Force serialization
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    if (enabled && activeId) {
      const keyColumn = currentTable?.keyColumn || null;
      const keyRow = currentTable?.keyRow || null;
      const valueColumn = currentTable?.valueColumn || null;
      const valueRow = currentTable?.valueRow || null;
      const displayColumn = currentTable?.displayColumn || null;
      const displayRow = currentTable?.displayRow || null;
      try {
        await prisma31.treeBranchLeafSelectConfig.upsert({
          where: { nodeId },
          create: {
            id: (0, import_crypto19.randomUUID)(),
            nodeId,
            options: [],
            multiple: false,
            searchable: true,
            allowCustom: false,
            optionsSource: "table",
            tableReference: activeId,
            keyColumn,
            keyRow,
            valueColumn,
            valueRow,
            displayColumn,
            displayRow,
            dependsOnNodeId: null,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          },
          update: {
            tableReference: activeId,
            keyColumn,
            keyRow,
            valueColumn,
            valueRow,
            displayColumn,
            displayRow,
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
      } catch (selectConfigError) {
        console.error(`\xC3\u0192\xC2\xA2\xC3\u2026\xC2\xA1\xC3\u201A\xC2\xA0\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xB8\xC3\u201A\xC2\x8F [TablePanel API] Erreur upsert config SELECT (non-bloquant):`, selectConfigError);
      }
    } else if (!enabled) {
      try {
        await prisma31.treeBranchLeafSelectConfig.deleteMany({
          where: { nodeId }
        });
      } catch (deleteError) {
        console.error(`\xC3\u0192\xC2\xA2\xC3\u2026\xC2\xA1\xC3\u201A\xC2\xA0\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xB8\xC3\u201A\xC2\x8F [TablePanel API] Erreur suppression config SELECT (non-bloquant):`, deleteError);
      }
    }
    const verifyNode = await prisma31.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      select: { metadata: true, hasTable: true }
    });
    return res.json({
      success: true,
      nodeId,
      capabilities: {
        table: newCapabilities.table
      }
    });
  } catch (error) {
    console.error("[TablePanel API] \xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 Erreur PUT /nodes/:nodeId/capabilities/table:", error);
    return res.status(500).json({ error: "Erreur lors de la mise \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 jour de la capacit\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 Table" });
  }
});
router56.patch("/submissions/:id", async (req2, res) => {
  const { id } = req2.params;
  const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
  const { clientId, status, name, formData } = req2.body;
  try {
    console.log("[TreeBranchLeaf API] PATCH /submissions/:id payload", {
      id,
      clientId,
      status,
      namePresent: name !== void 0,
      formDataPresent: formData !== void 0,
      organizationId,
      isSuperAdmin: isSuperAdmin2
    });
    const submission = await prisma31.treeBranchLeafSubmission.findUnique({
      where: { id },
      select: { id: true, treeId: true, leadId: true, organizationId: true }
    });
    if (!submission) {
      return res.status(404).json({ error: "Soumission non trouv\xE9e" });
    }
    const treeOrg = submission.organizationId ?? (await prisma31.treeBranchLeafTree.findUnique({
      where: { id: submission.treeId },
      select: { organizationId: true }
    }))?.organizationId ?? null;
    if (!isSuperAdmin2 && treeOrg && treeOrg !== organizationId) {
      return res.status(403).json({ error: "Acc\xE8s refus\xE9 \xE0 cette soumission" });
    }
    if (clientId !== void 0) {
      if (clientId !== null && typeof clientId !== "string") {
        return res.status(400).json({ error: "clientId doit \xEAtre une cha\xEEne ou null" });
      }
      if (typeof clientId === "string") {
        const lead = await prisma31.lead.findUnique({
          where: { id: clientId },
          select: { id: true, organizationId: true }
        });
        if (!lead) {
          return res.status(404).json({ error: "Lead non trouv\xE9" });
        }
        if (!isSuperAdmin2 && lead.organizationId && treeOrg && lead.organizationId !== treeOrg) {
          return res.status(403).json({ error: "Lead et soumission appartiennent \xE0 des organisations diff\xE9rentes" });
        }
      }
      if ((clientId ?? null) === (submission.leadId ?? null) && status === void 0 && name === void 0 && formData === void 0) {
        console.log(`[TreeBranchLeaf API] PATCH /submissions/${id} - aucun changement (clientId inchang\xE9)`);
        return res.json(submission);
      }
    }
    const updateData = {
      updatedAt: /* @__PURE__ */ new Date()
    };
    if (clientId !== void 0) {
      updateData.leadId = clientId;
    }
    if (status !== void 0) {
      updateData.status = status;
    }
    if (name !== void 0) {
      updateData.name = name;
    }
    if (formData !== void 0) {
      updateData.formData = formData;
    }
    const updatedSubmission = await prisma31.treeBranchLeafSubmission.update({
      where: { id },
      data: updateData
    });
    console.log(`[TreeBranchLeaf API] \u2705 PATCH /submissions/${id} - clientId: ${clientId}, status: ${status}`);
    res.json(updatedSubmission);
  } catch (error) {
    if (error && error.code) {
      const e = error;
      console.error("[TreeBranchLeaf API] \u274C Prisma error PATCH /submissions/:id:", e);
      return res.status(400).json({ error: `Erreur de requ\xEAte (${e.code})`, message: e.message });
    }
    const err = error;
    console.error("[TreeBranchLeaf API] \u274C Erreur PATCH /submissions/:id:", { message: err?.message, stack: err?.stack });
    return res.status(400).json({ error: "PATCH_UPDATE_ERROR", message: err?.message || "Erreur lors de la mise \xE0 jour de la soumission" });
  }
});
router56.post("/submissions/:id/reset-data", async (req2, res) => {
  const { id } = req2.params;
  const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
  const { status } = req2.body;
  try {
    const submission = await prisma31.treeBranchLeafSubmission.findUnique({
      where: { id },
      select: { id: true, treeId: true, organizationId: true, status: true }
    });
    if (!submission) {
      return res.status(404).json({ error: "Soumission non trouv\xE9e" });
    }
    if (submission.status === "completed") {
      return res.status(400).json({
        error: "RESET_NOT_ALLOWED",
        message: "Impossible de r\xE9initialiser un devis enregistr\xE9 (completed)."
      });
    }
    const treeOrg = submission.organizationId ?? (await prisma31.treeBranchLeafTree.findUnique({
      where: { id: submission.treeId },
      select: { organizationId: true }
    }))?.organizationId ?? null;
    if (!isSuperAdmin2 && treeOrg && treeOrg !== organizationId) {
      return res.status(403).json({ error: "Acc\xE8s refus\xE9 \xE0 cette soumission" });
    }
    await prisma31.$transaction(async (tx) => {
      await tx.treeBranchLeafSubmissionData.deleteMany({ where: { submissionId: id } });
      await tx.treeBranchLeafSubmission.update({
        where: { id },
        data: {
          leadId: null,
          status: status ?? "default-draft",
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    });
    return res.json({ success: true });
  } catch (error) {
    console.error("[TreeBranchLeaf API] \u274C Erreur POST /submissions/:id/reset-data:", error);
    return res.status(500).json({ error: "Erreur lors de la r\xE9initialisation de la soumission" });
  }
});
router56.put("/submissions/:id", async (req2, res) => {
  const { id } = req2.params;
  const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
  const { data, status } = req2.body;
  try {
    const submission = await prisma31.treeBranchLeafSubmission.findUnique({
      where: { id },
      select: { id: true, treeId: true, organizationId: true }
    });
    if (!submission) {
      return res.status(404).json({ error: "Soumission non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e" });
    }
    const treeId = submission.treeId;
    const treeOrg = submission.organizationId ?? (await prisma31.treeBranchLeafTree.findUnique({
      where: { id: treeId },
      select: { organizationId: true }
    }))?.organizationId ?? null;
    if (!isSuperAdmin2 && treeOrg && treeOrg !== organizationId) {
      return res.status(403).json({ error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 cette soumission" });
    }
    const nodes = await prisma31.treeBranchLeafNode.findMany({ where: { treeId }, select: { id: true, label: true } });
    const validNodeIds = new Set(nodes.map((n) => n.id));
    const labelMap = new Map(nodes.map((n) => [n.id, n.label]));
    const variablesMeta = await prisma31.treeBranchLeafNodeVariable.findMany({
      where: { TreeBranchLeafNode: { treeId } },
      include: { TreeBranchLeafNode: { select: { label: true } } }
    });
    const varByExposedKey = new Map(
      variablesMeta.filter((v) => !!v.exposedKey).map((v) => [
        v.exposedKey,
        {
          nodeId: v.nodeId,
          displayName: v.displayName || v.TreeBranchLeafNode?.label || v.exposedKey || v.nodeId,
          unit: v.unit || null,
          sourceRef: v.sourceRef || null
        }
      ])
    );
    const varMetaByNodeId = new Map(
      variablesMeta.map((v) => [
        v.nodeId,
        {
          displayName: v.displayName || v.TreeBranchLeafNode?.label || v.exposedKey || v.nodeId,
          unit: v.unit || null,
          sourceRef: v.sourceRef || null
        }
      ])
    );
    const rawEntries = (() => {
      if (Array.isArray(data)) {
        return data.map((it) => {
          if (it && typeof it === "object" && "nodeId" in it) {
            const obj = it;
            return { nodeId: String(obj.nodeId), value: obj.value, calculatedValue: obj.calculatedValue };
          }
          return null;
        }).filter((x) => !!x);
      }
      if (data && typeof data === "object") {
        return Object.entries(data).map(([nodeId, value]) => ({ nodeId, value }));
      }
      return [];
    })();
    const mappedEntries = rawEntries.map((e) => {
      if (!validNodeIds.has(e.nodeId) && varByExposedKey.has(e.nodeId)) {
        const vm = varByExposedKey.get(e.nodeId);
        return { nodeId: vm.nodeId, value: e.value, calculatedValue: e.calculatedValue };
      }
      return e;
    });
    const entries = mappedEntries.filter(({ nodeId }) => validNodeIds.has(nodeId)).map((e) => ({ ...e, effectiveValue: e.calculatedValue !== void 0 ? e.calculatedValue : e.value }));
    await prisma31.$transaction(async (tx) => {
      const now = /* @__PURE__ */ new Date();
      const inferSource = (sourceRef) => {
        const s = (sourceRef || "").toLowerCase();
        if (s.includes("formula") || s.includes("formule")) return "formula";
        if (s.includes("condition")) return "condition";
        if (s.includes("table")) return "table";
        return "neutral";
      };
      const resolveOperationDetail = async (sourceRef) => {
        const parsed = parseSourceRef(sourceRef);
        if (!parsed) return null;
        if (parsed.type === "condition") {
          const rec = await tx.treeBranchLeafNodeCondition.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, conditionSet: true, nodeId: true } });
          return buildOperationDetail("condition", rec);
        }
        if (parsed.type === "formula") {
          const rec = await tx.treeBranchLeafNodeFormula.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, tokens: true, nodeId: true } });
          return buildOperationDetail("formula", rec);
        }
        if (parsed.type === "table") {
          const rec = await tx.treeBranchLeafNodeTable.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, type: true, nodeId: true } });
          return buildOperationDetail("table", rec);
        }
        return null;
      };
      if (entries.length > 0) {
        const existing = await tx.treeBranchLeafSubmissionData.findMany({
          where: { submissionId: id, nodeId: { in: entries.map(({ nodeId }) => nodeId) } },
          select: { nodeId: true, fieldLabel: true }
        });
        const existingLabelMap = new Map(existing.map((e) => [e.nodeId, e.fieldLabel]));
        const existingSet = new Set(existing.map((e) => e.nodeId));
        const toCreate = entries.filter(({ nodeId }) => !existingSet.has(nodeId));
        const toUpdate = entries.filter(({ nodeId }) => existingSet.has(nodeId));
        if (toCreate.length > 0) {
          const existingAll = await tx.treeBranchLeafSubmissionData.findMany({ where: { submissionId: id }, select: { nodeId: true, value: true } });
          const valuesMapTx = new Map(existingAll.map((r) => [r.nodeId, r.value == null ? null : String(r.value)]));
          const createRows = await Promise.all(toCreate.map(async ({ nodeId, effectiveValue }) => {
            const isVar = varMetaByNodeId.has(nodeId);
            const meta = isVar ? varMetaByNodeId.get(nodeId) : void 0;
            const label = labelMap.get(nodeId) || existingLabelMap.get(nodeId) || null;
            const valueStr = effectiveValue == null ? null : String(effectiveValue);
            const opSrc = isVar ? inferSource(meta?.sourceRef || null) : "neutral";
            const display = isVar ? meta?.displayName || label || nodeId : label || nodeId;
            let opRes = meta?.unit && valueStr ? `${display}: ${valueStr} ${meta.unit}` : `${display}: ${valueStr ?? ""}`;
            const opDetail = isVar ? await resolveOperationDetail(meta?.sourceRef || null) : label;
            if (isVar && meta?.sourceRef) {
              const parsed = parseSourceRef(meta.sourceRef);
              if (parsed?.type === "condition") {
                const rec = await tx.treeBranchLeafNodeCondition.findUnique({ where: { id: parsed.id }, select: { conditionSet: true } });
                const ids = extractNodeIdsFromConditionSet2(rec?.conditionSet);
                valuesMapTx.set(nodeId, valueStr);
                const refsRaw = buildResolvedRefs(ids, labelMap, valuesMapTx);
                const refs = refsRaw.map((r) => ({ label: r.label ?? null, value: r.value ?? null }));
                const expr = "\xC3\u0192\xC2\xB0\xC3\u2026\xC2\xB8\xC3\xA2\xE2\u201A\xAC\xC2\x9D\xC3\xA2\xE2\u201A\xAC\xC5\xBE Condition \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valu\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e via TBL Prisma (ligne 5456)";
                opRes = { type: "condition", label: display, value: valueStr, unit: meta?.unit || null, refs, text: expr };
              } else if (parsed?.type === "formula") {
                const rec = await tx.treeBranchLeafNodeFormula.findUnique({ where: { id: parsed.id }, select: { tokens: true } });
                const ids = extractNodeIdsFromTokens2(rec?.tokens);
                valuesMapTx.set(nodeId, valueStr);
                const refsRaw = buildResolvedRefs(ids, labelMap, valuesMapTx);
                const refs = refsRaw.map((r) => ({ label: r.label ?? null, value: r.value ?? null }));
                let expr = buildTextFromTokens(rec?.tokens, labelMap, valuesMapTx);
                const calculatedResult = calculateResult(expr);
                if (calculatedResult !== null) {
                  expr += ` = ${calculatedResult}`;
                }
                const finalText = expr;
                opRes = { type: "formula", label: display, value: valueStr, unit: meta?.unit || null, refs, text: finalText };
              } else if (parsed?.type === "table") {
                const rec = await tx.treeBranchLeafNodeTable.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, type: true, nodeId: true } });
                const str = JSON.stringify(rec);
                const ids = /* @__PURE__ */ new Set();
                if (str) {
                  let m;
                  const re = /@value\.([a-f0-9-]{36})/gi;
                  while ((m = re.exec(str)) !== null) ids.add(m[1]);
                }
                valuesMapTx.set(nodeId, valueStr);
                const refsRaw = buildResolvedRefs(ids, labelMap, valuesMapTx);
                const refs = refsRaw.map((r) => ({ label: r.label ?? null, value: r.value ?? null }));
                const expr = buildTextFromTableRecord(rec, labelMap, valuesMapTx);
                const unitSuffix = meta?.unit ? ` ${meta.unit}` : "";
                const finalText = expr ? `${expr} (=) ${display} (${valueStr ?? ""}${unitSuffix})` : `${display} (${valueStr ?? ""}${unitSuffix})`;
                opRes = { type: "table", label: display, value: valueStr, unit: meta?.unit || null, refs, text: finalText };
              }
            }
            return {
              id: (0, import_crypto19.randomUUID)(),
              submissionId: id,
              nodeId,
              value: valueStr,
              fieldLabel: label,
              isVariable: isVar,
              variableDisplayName: isVar ? meta?.displayName ?? null : null,
              variableKey: null,
              variableUnit: isVar ? meta?.unit ?? null : null,
              sourceRef: isVar ? meta?.sourceRef ?? null : null,
              operationSource: opSrc,
              operationDetail: opDetail,
              operationResult: opRes,
              lastResolved: now
            };
          }));
          await tx.treeBranchLeafSubmissionData.createMany({ data: createRows });
        }
        for (const { nodeId, effectiveValue } of toUpdate) {
          const isVar = varMetaByNodeId.has(nodeId);
          const meta = isVar ? varMetaByNodeId.get(nodeId) : void 0;
          const label = labelMap.get(nodeId) || existingLabelMap.get(nodeId) || void 0;
          const valueStr = effectiveValue == null ? null : String(effectiveValue);
          const existingAll = await tx.treeBranchLeafSubmissionData.findMany({ where: { submissionId: id }, select: { nodeId: true, value: true } });
          const valuesMapTx = new Map(existingAll.map((r) => [r.nodeId, r.value == null ? null : String(r.value)]));
          valuesMapTx.set(nodeId, valueStr);
          try {
            await tx.treeBranchLeafSubmissionData.update({
              where: { submissionId_nodeId: { submissionId: id, nodeId } },
              data: {
                value: valueStr,
                fieldLabel: label,
                operationSource: isVar ? inferSource(meta?.sourceRef || null) : "neutral",
                operationDetail: isVar ? await resolveOperationDetail(meta?.sourceRef || null) ?? void 0 : label || void 0,
                operationResult: (() => {
                  const display = isVar ? meta?.displayName || label || nodeId : label || nodeId;
                  if (!isVar || !meta?.sourceRef) {
                    return meta?.unit && valueStr ? `${display}: ${valueStr} ${meta.unit}` : `${display}: ${valueStr ?? ""}`;
                  }
                  const parsed = parseSourceRef(meta.sourceRef);
                  if (parsed?.type === "condition") {
                    return (async () => {
                      const rec = await tx.treeBranchLeafNodeCondition.findUnique({ where: { id: parsed.id }, select: { conditionSet: true } });
                      const ids = extractNodeIdsFromConditionSet2(rec?.conditionSet);
                      const refsRaw = buildResolvedRefs(ids, labelMap, valuesMapTx);
                      const refs = refsRaw.map((r) => ({ label: r.label ?? null, value: r.value ?? null }));
                      const expr = "\xC3\u0192\xC2\xB0\xC3\u2026\xC2\xB8\xC3\xA2\xE2\u201A\xAC\xC2\x9D\xC3\xA2\xE2\u201A\xAC\xC5\xBE Condition \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valu\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e via TBL Prisma (ligne 5545)";
                      return { type: "condition", label: display, value: valueStr, unit: meta?.unit || null, refs, text: expr };
                    })();
                  }
                  if (parsed?.type === "formula") {
                    return (async () => {
                      const rec = await tx.treeBranchLeafNodeFormula.findUnique({ where: { id: parsed.id }, select: { tokens: true } });
                      const ids = extractNodeIdsFromTokens2(rec?.tokens);
                      const refsRaw = buildResolvedRefs(ids, labelMap, valuesMapTx);
                      const refs = refsRaw.map((r) => ({ label: r.label ?? null, value: r.value ?? null }));
                      let expr = buildTextFromTokens(rec?.tokens, labelMap, valuesMapTx);
                      const calculatedResult = calculateResult(expr);
                      if (calculatedResult !== null) {
                        expr += ` = ${calculatedResult}`;
                      }
                      return { type: "formula", label: display, value: valueStr, unit: meta?.unit || null, refs, text: expr };
                    })();
                  }
                  if (parsed?.type === "table") {
                    return (async () => {
                      const rec = await tx.treeBranchLeafNodeTable.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, type: true, nodeId: true } });
                      const str = JSON.stringify(rec);
                      const ids = /* @__PURE__ */ new Set();
                      if (str) {
                        let m;
                        const re = /@value\.([a-f0-9-]{36})/gi;
                        while ((m = re.exec(str)) !== null) ids.add(m[1]);
                      }
                      const refsRaw = buildResolvedRefs(ids, labelMap, valuesMapTx);
                      const refs = refsRaw.map((r) => ({ label: r.label ?? null, value: r.value ?? null }));
                      const expr = buildTextFromTableRecord(rec, labelMap, valuesMapTx);
                      const unitSuffix = meta?.unit ? ` ${meta.unit}` : "";
                      const finalText = expr ? `${expr} (=) ${display} (${valueStr ?? ""}${unitSuffix})` : `${display} (${valueStr ?? ""}${unitSuffix})`;
                      return { type: "table", label: display, value: valueStr, unit: meta?.unit || null, refs, text: finalText };
                    })();
                  }
                  return meta?.unit && valueStr ? `${display}: ${valueStr} ${meta.unit}` : `${display}: ${valueStr ?? ""}`;
                })(),
                lastResolved: now
              }
            });
          } catch {
            await tx.treeBranchLeafSubmissionData.updateMany({
              where: { submissionId: id, nodeId },
              data: {
                value: valueStr,
                fieldLabel: label,
                operationSource: isVar ? inferSource(meta?.sourceRef || null) : "neutral",
                operationDetail: isVar ? await resolveOperationDetail(meta?.sourceRef || null) ?? void 0 : label || void 0,
                operationResult: (() => {
                  const display = isVar ? meta?.displayName || label || nodeId : label || nodeId;
                  if (!isVar || !meta?.sourceRef) {
                    return meta?.unit && valueStr ? `${display}: ${valueStr} ${meta.unit}` : `${display}: ${valueStr ?? ""}`;
                  }
                  const parsed = parseSourceRef(meta.sourceRef);
                  if (parsed?.type === "condition") {
                    return (async () => {
                      const rec = await tx.treeBranchLeafNodeCondition.findUnique({ where: { id: parsed.id }, select: { conditionSet: true } });
                      const ids = extractNodeIdsFromConditionSet2(rec?.conditionSet);
                      const refs = buildResolvedRefs(ids, labelMap, valuesMapTx);
                      return { type: "condition", label: display, value: valueStr, unit: meta?.unit || null, refs };
                    })();
                  }
                  if (parsed?.type === "formula") {
                    return (async () => {
                      const rec = await tx.treeBranchLeafNodeFormula.findUnique({ where: { id: parsed.id }, select: { tokens: true } });
                      const ids = extractNodeIdsFromTokens2(rec?.tokens);
                      const refs = buildResolvedRefs(ids, labelMap, valuesMapTx);
                      return { type: "formula", label: display, value: valueStr, unit: meta?.unit || null, refs };
                    })();
                  }
                  if (parsed?.type === "table") {
                    return (async () => {
                      const rec = await tx.treeBranchLeafNodeTable.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, type: true, nodeId: true } });
                      const str = JSON.stringify(rec);
                      const ids = /* @__PURE__ */ new Set();
                      if (str) {
                        let m;
                        const re = /@value\.([a-f0-9-]{36})/gi;
                        while ((m = re.exec(str)) !== null) ids.add(m[1]);
                      }
                      const refs = buildResolvedRefs(ids, labelMap, valuesMapTx);
                      return { type: "table", label: display, value: valueStr, unit: meta?.unit || null, refs };
                    })();
                  }
                  return meta?.unit && valueStr ? `${display}: ${valueStr} ${meta.unit}` : `${display}: ${valueStr ?? ""}`;
                })(),
                lastResolved: now
              }
            });
          }
        }
      }
      const variables = await tx.treeBranchLeafNodeVariable.findMany({
        where: { TreeBranchLeafNode: { treeId } },
        include: { TreeBranchLeafNode: { select: { id: true, label: true } } }
      });
      const existingVarRows = await tx.treeBranchLeafSubmissionData.findMany({ where: { submissionId: id, nodeId: { in: variables.map((v) => v.nodeId) } }, select: { nodeId: true } });
      const existingVarSet = new Set(existingVarRows.map((r) => r.nodeId));
      const missingVars = variables.filter((v) => !existingVarSet.has(v.nodeId));
      if (missingVars.length > 0) {
        const allRows2 = await tx.treeBranchLeafSubmissionData.findMany({ where: { submissionId: id }, select: { nodeId: true, value: true } });
        const valuesMapTxAll = new Map(allRows2.map((r) => [r.nodeId, r.value == null ? null : String(r.value)]));
        const missingRows = await Promise.all(missingVars.map(async (v) => ({
          id: (0, import_crypto19.randomUUID)(),
          submissionId: id,
          nodeId: v.nodeId,
          value: null,
          fieldLabel: v.TreeBranchLeafNode?.label || null,
          isVariable: true,
          variableDisplayName: v.displayName,
          variableKey: v.exposedKey,
          variableUnit: v.unit,
          sourceRef: v.sourceRef || null,
          operationSource: inferSource(v.sourceRef || null),
          operationDetail: await resolveOperationDetail(v.sourceRef || null),
          operationResult: (() => {
            const display = v.displayName || v.TreeBranchLeafNode?.label || v.exposedKey || v.nodeId;
            if (!v.sourceRef) return `${display}: `;
            const parsed = parseSourceRef(v.sourceRef);
            if (parsed?.type === "condition") {
              return (async () => {
                const rec = await tx.treeBranchLeafNodeCondition.findUnique({ where: { id: parsed.id }, select: { conditionSet: true } });
                const ids = extractNodeIdsFromConditionSet2(rec?.conditionSet);
                const refs = buildResolvedRefs(ids, labelMap, valuesMapTxAll);
                const human = `${display}`;
                return { type: "condition", label: display, value: null, unit: v.unit || null, refs, text: buildResultText(human, null, v.unit || null) };
              })();
            }
            if (parsed?.type === "formula") {
              return (async () => {
                const rec = await tx.treeBranchLeafNodeFormula.findUnique({ where: { id: parsed.id }, select: { tokens: true } });
                const ids = extractNodeIdsFromTokens2(rec?.tokens);
                const refs = buildResolvedRefs(ids, labelMap, valuesMapTxAll);
                const human = `${display}`;
                return { type: "formula", label: display, value: null, unit: v.unit || null, refs, text: buildResultText(human, null, v.unit || null) };
              })();
            }
            if (parsed?.type === "table") {
              return (async () => {
                const rec = await tx.treeBranchLeafNodeTable.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, type: true, nodeId: true } });
                const str = JSON.stringify(rec);
                const ids = /* @__PURE__ */ new Set();
                if (str) {
                  let m;
                  const re = /@value\.([a-f0-9-]{36})/gi;
                  while ((m = re.exec(str)) !== null) ids.add(m[1]);
                }
                const refs = buildResolvedRefs(ids, labelMap, valuesMapTxAll);
                const human = `${display}`;
                return { type: "table", label: display, value: null, unit: v.unit || null, refs, text: buildResultText(human, null, v.unit || null) };
              })();
            }
            return `${display}: `;
          })(),
          lastResolved: now
        })));
        await tx.treeBranchLeafSubmissionData.createMany({ data: missingRows });
      }
      const allRows = await tx.treeBranchLeafSubmissionData.findMany({
        where: {
          submissionId: id
        },
        select: {
          nodeId: true,
          isVariable: true,
          value: true,
          sourceRef: true,
          operationDetail: true,
          operationResult: true,
          lastResolved: true
        }
      });
      const rowsNeeding = allRows.filter(
        (row) => row.operationDetail === null || row.operationResult === null || row.lastResolved === null
      );
      for (const row of rowsNeeding) {
        const isVar = row.isVariable;
        const meta = isVar ? varMetaByNodeId.get(row.nodeId) : void 0;
        const label = labelMap.get(row.nodeId) || void 0;
        const valueStr = row.value == null ? null : String(row.value);
        const opSrc = isVar ? inferSource(meta?.sourceRef || null) : "neutral";
        const display = isVar ? meta?.displayName || label || row.nodeId : label || row.nodeId;
        const allRows2 = await tx.treeBranchLeafSubmissionData.findMany({ where: { submissionId: id }, select: { nodeId: true, value: true } });
        const valuesMapTxAll = new Map(allRows2.map((r) => [r.nodeId, r.value == null ? null : String(r.value)]));
        valuesMapTxAll.set(row.nodeId, valueStr);
        let opRes = meta?.unit && valueStr ? `${display}: ${valueStr} ${meta.unit}` : `${display}: ${valueStr ?? ""}`;
        const opDetail = isVar ? await resolveOperationDetail(row.sourceRef || null) : label;
        if (isVar && (row.sourceRef || meta?.sourceRef)) {
          try {
            const evaluation = await evaluateVariableOperation(
              row.nodeId,
              id,
              // submissionId
              tx
              // Utiliser la transaction Prisma
            );
            opRes = evaluation.operationResult;
            await tx.treeBranchLeafSubmissionData.updateMany({
              where: { submissionId: id, nodeId: row.nodeId },
              data: { value: evaluation.value }
            });
          } catch (error) {
            const parsed = parseSourceRef(row.sourceRef || meta?.sourceRef || null);
            if (parsed?.type === "condition") {
              const rec = await tx.treeBranchLeafNodeCondition.findUnique({ where: { id: parsed.id }, select: { conditionSet: true } });
              const ids = extractNodeIdsFromConditionSet2(rec?.conditionSet);
              const refs = buildResolvedRefs(ids, labelMap, valuesMapTxAll);
              const human = `${display}`;
              opRes = { type: "condition", label: display, value: valueStr, unit: meta?.unit || null, refs, text: buildResultText(human, valueStr, meta?.unit || null) };
            } else if (parsed?.type === "formula") {
              const rec = await tx.treeBranchLeafNodeFormula.findUnique({ where: { id: parsed.id }, select: { tokens: true } });
              const ids = extractNodeIdsFromTokens2(rec?.tokens);
              const refs = buildResolvedRefs(ids, labelMap, valuesMapTxAll);
              const human = `${display}`;
              opRes = { type: "formula", label: display, value: valueStr, unit: meta?.unit || null, refs, text: buildResultText(human, valueStr, meta?.unit || null) };
            } else if (parsed?.type === "table") {
              const rec = await tx.treeBranchLeafNodeTable.findUnique({ where: { id: parsed.id }, select: { id: true, name: true, description: true, type: true, nodeId: true } });
              const str = JSON.stringify(rec);
              const ids = /* @__PURE__ */ new Set();
              if (str) {
                let m;
                const re = /@value\.([a-f0-9-]{36})/gi;
                while ((m = re.exec(str)) !== null) ids.add(m[1]);
              }
              const refs = buildResolvedRefs(ids, labelMap, valuesMapTxAll);
              const human = `${display}`;
              opRes = { type: "table", label: display, value: valueStr, unit: meta?.unit || null, refs, text: buildResultText(human, valueStr, meta?.unit || null) };
            }
          }
        }
        await tx.treeBranchLeafSubmissionData.updateMany({
          where: { submissionId: id, nodeId: row.nodeId },
          data: {
            operationSource: opSrc,
            operationDetail: opDetail ?? (isVar ? meta?.sourceRef || void 0 : label || void 0),
            operationResult: opRes,
            lastResolved: now
          }
        });
      }
      if (status && typeof status === "string") {
        await tx.treeBranchLeafSubmission.update({ where: { id }, data: { status, updatedAt: /* @__PURE__ */ new Date() } });
      } else {
        await tx.treeBranchLeafSubmission.update({ where: { id }, data: { updatedAt: /* @__PURE__ */ new Date() } });
      }
    });
    const full = await prisma31.treeBranchLeafSubmission.findUnique({
      where: { id },
      include: {
        TreeBranchLeafTree: { select: { id: true, name: true } },
        Lead: { select: { id: true, firstName: true, lastName: true, email: true } },
        TreeBranchLeafSubmissionData: { include: { TreeBranchLeafNode: { select: { id: true, label: true, type: true } } } }
      }
    });
    return res.json(full);
  } catch (error) {
    console.error("[TreeBranchLeaf API] \xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 Erreur PUT /submissions/:id:", error);
    return res.status(500).json({ error: "Erreur lors de la mise \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 jour de la soumission" });
  }
});
router56.post("/v2/variables/:variableNodeId/evaluate", async (req2, res) => {
  try {
    const { variableNodeId } = req2.params;
    const { submissionId } = req2.body;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    if (!variableNodeId) {
      console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [V2 API] variableNodeId manquant");
      return res.status(400).json({
        success: false,
        error: "variableNodeId requis"
      });
    }
    if (!submissionId) {
      console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [V2 API] submissionId manquant");
      return res.status(400).json({
        success: false,
        error: "submissionId requis dans le body"
      });
    }
    const node = await prisma31.treeBranchLeafNode.findUnique({
      where: { id: variableNodeId },
      include: {
        TreeBranchLeafTree: {
          select: {
            id: true,
            name: true,
            organizationId: true
          }
        },
        TreeBranchLeafNodeVariable: {
          select: {
            id: true,
            nodeId: true,
            exposedKey: true,
            displayName: true,
            sourceType: true,
            sourceRef: true,
            fixedValue: true,
            defaultValue: true
          }
        }
      }
    });
    if (!node) {
      console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [V2 API] N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud introuvable:", variableNodeId);
      return res.status(404).json({
        success: false,
        error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud introuvable"
      });
    }
    if (!isSuperAdmin2 && node.TreeBranchLeafTree?.organizationId !== organizationId) {
      console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [V2 API] Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 - mauvaise organisation");
      return res.status(403).json({
        success: false,
        error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 ce n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud"
      });
    }
    const variable = node.TreeBranchLeafNodeVariable?.[0];
    if (!variable) {
      console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [V2 API] Pas de variable associ\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 ce n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud");
      return res.status(400).json({
        success: false,
        error: "Ce n\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud ne contient pas de variable"
      });
    }
    const submission = await prisma31.treeBranchLeafSubmission.findUnique({
      where: { id: submissionId },
      select: {
        id: true,
        treeId: true,
        leadId: true,
        status: true
      }
    });
    if (!submission) {
      console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [V2 API] Soumission introuvable:", submissionId);
      return res.status(404).json({
        success: false,
        error: "Soumission introuvable"
      });
    }
    const startTime = Date.now();
    const evaluationResult = await evaluateVariableOperation(
      variableNodeId,
      submissionId,
      prisma31
    );
    const duration = Date.now() - startTime;
    await prisma31.treeBranchLeafSubmissionData.upsert({
      where: {
        submissionId_nodeId: {
          submissionId,
          nodeId: variableNodeId
        }
      },
      update: {
        value: evaluationResult.value,
        operationDetail: evaluationResult.operationDetail,
        operationResult: evaluationResult.operationResult,
        operationSource: evaluationResult.operationSource,
        lastResolved: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      },
      create: {
        submissionId,
        nodeId: variableNodeId,
        value: evaluationResult.value,
        operationDetail: evaluationResult.operationDetail,
        operationResult: evaluationResult.operationResult,
        operationSource: evaluationResult.operationSource,
        lastResolved: /* @__PURE__ */ new Date(),
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    const response = {
      success: true,
      variable: {
        nodeId: variable.nodeId,
        displayName: variable.displayName,
        exposedKey: variable.exposedKey,
        sourceType: variable.sourceType,
        sourceRef: variable.sourceRef
      },
      result: {
        value: evaluationResult.value,
        operationDetail: evaluationResult.operationDetail,
        operationResult: evaluationResult.operationResult,
        operationSource: evaluationResult.operationSource,
        sourceRef: evaluationResult.sourceRef
      },
      evaluation: {
        mode: "universal-interpreter",
        version: "1.0.0",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        duration: `${duration}ms`,
        submissionId,
        nodeLabel: node.label
      }
    };
    return res.json(response);
  } catch (error) {
    console.error("\n" + "\xC3\u0192\xC2\xA2\xC3\xA2\xE2\u201A\xAC\xC2\xA2\xC3\u201A\xC2\x90".repeat(80));
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [V2 API] ERREUR CRITIQUE");
    console.error("\xC3\u0192\xC2\xA2\xC3\xA2\xE2\u201A\xAC\xC2\xA2\xC3\u201A\xC2\x90".repeat(80));
    console.error(error);
    console.error("\xC3\u0192\xC2\xA2\xC3\xA2\xE2\u201A\xAC\xC2\xA2\xC3\u201A\xC2\x90".repeat(80) + "\n");
    return res.status(500).json({
      success: false,
      error: "Erreur lors de l'\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valuation de la variable",
      details: error instanceof Error ? error.message : "Erreur inconnue",
      stack: process.env.NODE_ENV === "development" && error instanceof Error ? error.stack : void 0
    });
  }
});
router56.get("/v2/submissions/:submissionId/variables", async (req2, res) => {
  try {
    const { submissionId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const submission = await prisma31.treeBranchLeafSubmission.findUnique({
      where: { id: submissionId },
      include: {
        TreeBranchLeafTree: {
          select: {
            id: true,
            name: true,
            organizationId: true
          }
        }
      }
    });
    if (!submission) {
      return res.status(404).json({
        success: false,
        error: "Soumission introuvable"
      });
    }
    if (!isSuperAdmin2 && submission.TreeBranchLeafTree?.organizationId !== organizationId) {
      return res.status(403).json({
        success: false,
        error: "Acc\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s refus\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA0 cette soumission"
      });
    }
    const variables = await prisma31.treeBranchLeafNodeVariable.findMany({
      where: {
        TreeBranchLeafNode: {
          treeId: submission.treeId
        }
      },
      include: {
        TreeBranchLeafNode: {
          select: {
            id: true,
            label: true,
            type: true
          }
        }
      }
    });
    const submissionData = await prisma31.treeBranchLeafSubmissionData.findMany({
      where: {
        submissionId,
        nodeId: {
          in: variables.map((v) => v.nodeId)
        }
      }
    });
    const dataMap = new Map(
      submissionData.map((d) => [d.nodeId, d])
    );
    const variablesResponse = variables.map((variable) => {
      const data = dataMap.get(variable.nodeId);
      return {
        nodeId: variable.nodeId,
        displayName: variable.displayName,
        exposedKey: variable.exposedKey,
        sourceType: variable.sourceType,
        sourceRef: variable.sourceRef,
        value: data?.value || null,
        operationResult: data?.operationResult || null,
        operationSource: data?.operationSource || null,
        operationDetail: data?.operationDetail || null,
        lastResolved: data?.lastResolved || null,
        nodeLabel: variable.TreeBranchLeafNode?.label || "Inconnu",
        nodeType: variable.TreeBranchLeafNode?.type || "unknown"
      };
    });
    return res.json({
      success: true,
      submissionId,
      tree: {
        id: submission.TreeBranchLeafTree?.id,
        name: submission.TreeBranchLeafTree?.name
      },
      variables: variablesResponse,
      meta: {
        totalVariables: variables.length,
        evaluatedVariables: submissionData.length
      }
    });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [V2 API] Erreur r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration variables:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration des variables",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router56.post("/submissions/stage", async (req2, res) => {
  try {
    const { stageId, treeId, submissionId, leadId, formData, baseVersion } = req2.body;
    const userId = req2.user?.id || "system";
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1e3);
    let stage;
    if (stageId) {
      stage = await prisma31.treeBranchLeafStage.update({
        where: { id: stageId },
        data: {
          formData: formData || {},
          lastActivity: /* @__PURE__ */ new Date(),
          expiresAt
          // Renouvelle l'expiration
        }
      });
    } else {
      if (!treeId || !leadId) {
        return res.status(400).json({
          success: false,
          error: "treeId et leadId sont requis pour cr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9er un stage"
        });
      }
      let currentBaseVersion = baseVersion || 1;
      if (submissionId && !baseVersion) {
        const submission = await prisma31.treeBranchLeafSubmission.findUnique({
          where: { id: submissionId },
          select: { currentVersion: true }
        });
        currentBaseVersion = submission?.currentVersion || 1;
      }
      stage = await prisma31.treeBranchLeafStage.create({
        data: {
          id: (0, import_crypto19.randomUUID)(),
          treeId,
          submissionId,
          leadId,
          userId,
          formData: formData || {},
          baseVersion: currentBaseVersion,
          expiresAt
        }
      });
    }
    return res.json({
      success: true,
      stage: {
        id: stage.id,
        expiresAt: stage.expiresAt,
        lastActivity: stage.lastActivity
      }
    });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [STAGE] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors de la gestion du brouillon",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router56.post("/submissions/stage/preview", async (req2, res) => {
  try {
    const { stageId } = req2.body;
    if (!stageId) {
      return res.status(400).json({
        success: false,
        error: "stageId requis"
      });
    }
    const stage = await prisma31.treeBranchLeafStage.findUnique({
      where: { id: stageId }
    });
    if (!stage) {
      return res.status(404).json({
        success: false,
        error: "Stage non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9"
      });
    }
    const { evaluateVariableOperation: evaluateVariableOperation2 } = await Promise.resolve().then(() => (init_operation_interpreter(), operation_interpreter_exports));
    const variableNodes = await prisma31.treeBranchLeafNode.findMany({
      where: {
        treeId: stage.treeId,
        subType: "variable"
      },
      select: { id: true, label: true }
    });
    const valueMapLocal = /* @__PURE__ */ new Map();
    Object.entries(stage.formData).forEach(([nodeId, value]) => {
      valueMapLocal.set(nodeId, value);
    });
    const results = await Promise.all(
      variableNodes.map(async (node) => {
        try {
          const evalResult = await evaluateVariableOperation2(
            node.id,
            stage.submissionId || stage.id,
            prisma31,
            valueMapLocal
          );
          return {
            nodeId: node.id,
            nodeLabel: node.label,
            sourceRef: evalResult.sourceRef,
            operationSource: evalResult.operationSource,
            operationResult: evalResult.operationResult,
            operationDetail: evalResult.operationDetail
          };
        } catch (error) {
          console.error(`\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 Erreur \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valuation ${node.id}:`, error);
          return {
            nodeId: node.id,
            nodeLabel: node.label,
            sourceRef: "",
            operationSource: "field",
            operationResult: "ERROR",
            operationDetail: null
          };
        }
      })
    );
    return res.json({
      success: true,
      stageId: stage.id,
      results: results.map((r) => ({
        nodeId: r.nodeId,
        nodeLabel: r.nodeLabel,
        sourceRef: r.sourceRef,
        operationSource: r.operationSource,
        operationResult: r.operationResult,
        operationDetail: r.operationDetail
      }))
    });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [STAGE PREVIEW] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors de la pr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9visualisation",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router56.post("/submissions/stage/commit", async (req2, res) => {
  try {
    const { stageId, asNew } = req2.body;
    const userId = req2.user?.id || "system";
    if (!stageId) {
      return res.status(400).json({
        success: false,
        error: "stageId requis"
      });
    }
    const stage = await prisma31.treeBranchLeafStage.findUnique({
      where: { id: stageId }
    });
    if (!stage) {
      return res.status(404).json({
        success: false,
        error: "Stage non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9"
      });
    }
    if (stage.expiresAt < /* @__PURE__ */ new Date()) {
      return res.status(410).json({
        success: false,
        error: "Ce brouillon a expir\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9",
        expired: true
      });
    }
    let submissionId;
    let newVersion = 1;
    if (asNew || !stage.submissionId) {
      const { evaluateVariableOperation: evaluateVariableOperation2 } = await Promise.resolve().then(() => (init_operation_interpreter(), operation_interpreter_exports));
      const variableNodes = await prisma31.treeBranchLeafNode.findMany({
        where: {
          treeId: stage.treeId,
          subType: "variable"
        },
        select: { id: true, label: true }
      });
      const valueMapLocal = /* @__PURE__ */ new Map();
      Object.entries(stage.formData).forEach(([nodeId, value]) => {
        valueMapLocal.set(nodeId, value);
      });
      const results = await Promise.all(
        variableNodes.map(async (node) => {
          try {
            const evalResult = await evaluateVariableOperation2(
              node.id,
              stage.id,
              prisma31,
              valueMapLocal
            );
            return {
              nodeId: node.id,
              nodeLabel: node.label,
              value: evalResult.value,
              operationSource: evalResult.operationSource,
              operationResult: evalResult.operationResult,
              operationDetail: evalResult.operationDetail
            };
          } catch (error) {
            console.error(`\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 Erreur \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valuation ${node.id}:`, error);
            return null;
          }
        })
      ).then((res2) => res2.filter((r) => r !== null));
      const result = await prisma31.$transaction(async (tx) => {
        const submission = await tx.treeBranchLeafSubmission.create({
          data: {
            id: (0, import_crypto19.randomUUID)(),
            treeId: stage.treeId,
            userId: stage.userId,
            leadId: stage.leadId,
            status: "draft",
            currentVersion: 1,
            lastEditedBy: userId,
            summary: {},
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
        if (results.length > 0) {
          await tx.treeBranchLeafSubmissionData.createMany({
            data: results.map((r) => ({
              id: (0, import_crypto19.randomUUID)(),
              submissionId: submission.id,
              nodeId: r.nodeId,
              value: String(r.operationResult || ""),
              fieldLabel: r.nodeLabel,
              sourceRef: r.sourceRef,
              operationSource: r.operationSource,
              operationResult: r.operationResult,
              operationDetail: r.operationDetail,
              lastResolved: /* @__PURE__ */ new Date()
            }))
          });
        }
        await tx.treeBranchLeafSubmissionVersion.create({
          data: {
            id: (0, import_crypto19.randomUUID)(),
            submissionId: submission.id,
            version: 1,
            formData: stage.formData,
            summary: "Version initiale",
            createdBy: userId
          }
        });
        await tx.treeBranchLeafStage.delete({
          where: { id: stageId }
        });
        return submission;
      });
      submissionId = result.id;
      newVersion = 1;
    } else {
      const currentSubmission = await prisma31.treeBranchLeafSubmission.findUnique({
        where: { id: stage.submissionId },
        select: {
          id: true,
          currentVersion: true,
          lastEditedBy: true,
          updatedAt: true,
          lockedBy: true,
          lockedAt: true
        }
      });
      if (!currentSubmission) {
        return res.status(404).json({
          success: false,
          error: "Submission originale non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e"
        });
      }
      if (currentSubmission.currentVersion > stage.baseVersion) {
        const currentData = await prisma31.treeBranchLeafSubmissionData.findMany({
          where: { submissionId: stage.submissionId },
          select: { nodeId: true, value: true }
        });
        const currentDataMap = new Map(currentData.map((d) => [d.nodeId, d.value]));
        const stageFormData = stage.formData;
        const conflicts = [];
        for (const [nodeId, stageValue] of Object.entries(stageFormData)) {
          const currentValue = currentDataMap.get(nodeId);
          if (currentValue !== void 0 && String(stageValue) !== currentValue) {
            conflicts.push({
              nodeId,
              yourValue: stageValue,
              theirValue: currentValue
            });
          }
        }
        if (conflicts.length > 0) {
          return res.status(409).json({
            success: false,
            conflict: true,
            conflicts,
            lastEditedBy: currentSubmission.lastEditedBy,
            lastEditedAt: currentSubmission.updatedAt,
            message: "Des modifications ont \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9t\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 faites par un autre utilisateur"
          });
        }
      }
      if (currentSubmission.lockedBy && currentSubmission.lockedBy !== userId) {
        const lockAge = currentSubmission.lockedAt ? Date.now() - new Date(currentSubmission.lockedAt).getTime() : 0;
        if (lockAge < 60 * 60 * 1e3) {
          return res.status(423).json({
            success: false,
            locked: true,
            lockedBy: currentSubmission.lockedBy,
            message: "Ce devis est en cours d'\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9dition par un autre utilisateur"
          });
        }
      }
      const result = await prisma31.$transaction(async (tx) => {
        const { evaluateVariableOperation: evaluateVariableOperation2 } = await Promise.resolve().then(() => (init_operation_interpreter(), operation_interpreter_exports));
        const variableNodes = await tx.treeBranchLeafNode.findMany({
          where: {
            treeId: stage.treeId,
            subType: "variable"
          },
          select: { id: true, label: true }
        });
        const valueMapLocal = /* @__PURE__ */ new Map();
        Object.entries(stage.formData).forEach(([nodeId, value]) => {
          valueMapLocal.set(nodeId, value);
        });
        const results = await Promise.all(
          variableNodes.map(async (node) => {
            try {
              const evalResult = await evaluateVariableOperation2(
                node.id,
                stage.submissionId,
                tx,
                valueMapLocal
              );
              return {
                nodeId: node.id,
                nodeLabel: node.label,
                value: evalResult.value,
                operationSource: evalResult.operationSource,
                operationResult: evalResult.operationResult,
                operationDetail: evalResult.operationDetail
              };
            } catch (error) {
              console.error(`\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 Erreur \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9valuation ${node.id}:`, error);
              return null;
            }
          })
        ).then((res2) => res2.filter((r) => r !== null));
        const nextVersion = currentSubmission.currentVersion + 1;
        const updated = await tx.treeBranchLeafSubmission.update({
          where: { id: stage.submissionId },
          data: {
            currentVersion: nextVersion,
            lastEditedBy: userId,
            lockedBy: null,
            // Lib√É∆í√Ü‚Äô√É‚Äö√Ç¬©rer le lock
            lockedAt: null,
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
        await tx.treeBranchLeafSubmissionData.deleteMany({
          where: { submissionId: stage.submissionId }
        });
        if (results.length > 0) {
          await tx.treeBranchLeafSubmissionData.createMany({
            data: results.map((r) => ({
              id: (0, import_crypto19.randomUUID)(),
              submissionId: updated.id,
              nodeId: r.nodeId,
              value: String(r.operationResult || ""),
              fieldLabel: r.nodeLabel,
              sourceRef: r.sourceRef,
              operationSource: r.operationSource,
              operationResult: r.operationResult,
              operationDetail: r.operationDetail,
              lastResolved: /* @__PURE__ */ new Date()
            }))
          });
        }
        await tx.treeBranchLeafSubmissionVersion.create({
          data: {
            id: (0, import_crypto19.randomUUID)(),
            submissionId: updated.id,
            version: nextVersion,
            formData: stage.formData,
            createdBy: userId
          }
        });
        const versions = await tx.treeBranchLeafSubmissionVersion.findMany({
          where: { submissionId: updated.id },
          orderBy: { version: "desc" },
          skip: 20,
          select: { id: true }
        });
        if (versions.length > 0) {
          await tx.treeBranchLeafSubmissionVersion.deleteMany({
            where: { id: { in: versions.map((v) => v.id) } }
          });
        }
        await tx.treeBranchLeafStage.delete({
          where: { id: stageId }
        });
        return { submission: updated, version: nextVersion };
      });
      submissionId = result.submission.id;
      newVersion = result.version;
    }
    return res.json({
      success: true,
      submissionId,
      version: newVersion,
      message: "Devis enregistr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9 avec succ\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s"
    });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [STAGE COMMIT] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors de la sauvegarde",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router56.post("/submissions/stage/discard", async (req2, res) => {
  try {
    const { stageId } = req2.body;
    if (!stageId) {
      return res.status(400).json({
        success: false,
        error: "stageId requis"
      });
    }
    await prisma31.treeBranchLeafStage.delete({
      where: { id: stageId }
    });
    return res.json({
      success: true,
      message: "Brouillon supprim\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9"
    });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [STAGE DISCARD] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors de la suppression du brouillon",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router56.get("/submissions/my-drafts", async (req2, res) => {
  try {
    const userId = req2.user?.id || "system";
    const { leadId, treeId } = req2.query;
    const where = {
      userId,
      expiresAt: { gt: /* @__PURE__ */ new Date() }
      // Seulement les non-expir√É∆í√Ü‚Äô√É‚Äö√Ç¬©s
    };
    if (leadId) where.leadId = leadId;
    if (treeId) where.treeId = treeId;
    const drafts = await prisma31.treeBranchLeafStage.findMany({
      where,
      orderBy: { lastActivity: "desc" },
      include: {
        Lead: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            company: true
          }
        }
      }
    });
    return res.json({
      success: true,
      drafts: drafts.map((d) => ({
        stageId: d.id,
        treeId: d.treeId,
        submissionId: d.submissionId,
        leadId: d.leadId,
        leadName: d.Lead ? `${d.Lead.firstName || ""} ${d.Lead.lastName || ""}`.trim() || d.Lead.company || "Lead" : "Lead",
        lastActivity: d.lastActivity,
        expiresAt: d.expiresAt,
        formData: d.formData
      }))
    });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [MY DRAFTS] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration des brouillons",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router56.get("/submissions/:id/versions", async (req2, res) => {
  try {
    const { id } = req2.params;
    const versions = await prisma31.treeBranchLeafSubmissionVersion.findMany({
      where: { submissionId: id },
      orderBy: { version: "desc" },
      include: {
        User: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        }
      }
    });
    return res.json({
      success: true,
      submissionId: id,
      versions: versions.map((v) => ({
        id: v.id,
        version: v.version,
        summary: v.summary,
        createdAt: v.createdAt,
        createdBy: {
          id: v.User.id,
          name: `${v.User.firstName || ""} ${v.User.lastName || ""}`.trim() || v.User.email
        }
      }))
    });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [VERSIONS] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors de la r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9cup\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ration de l'historique",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router56.post("/submissions/:id/restore/:version", async (req2, res) => {
  try {
    const { id, version } = req2.params;
    const userId = req2.user?.id || "system";
    const versionToRestore = await prisma31.treeBranchLeafSubmissionVersion.findUnique({
      where: {
        submissionId_version: {
          submissionId: id,
          version: parseInt(version)
        }
      }
    });
    if (!versionToRestore) {
      return res.status(404).json({
        success: false,
        error: "Version non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e"
      });
    }
    const submission = await prisma31.treeBranchLeafSubmission.findUnique({
      where: { id },
      select: { treeId: true, leadId: true, currentVersion: true }
    });
    if (!submission) {
      return res.status(404).json({
        success: false,
        error: "Submission non trouv\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e"
      });
    }
    const stage = await prisma31.treeBranchLeafStage.create({
      data: {
        id: (0, import_crypto19.randomUUID)(),
        treeId: submission.treeId,
        submissionId: id,
        leadId: submission.leadId || "unknown",
        userId,
        formData: versionToRestore.formData,
        baseVersion: submission.currentVersion,
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1e3)
      }
    });
    return res.json({
      success: true,
      stageId: stage.id,
      message: `Version ${version} charg\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e en brouillon. Enregistrez pour confirmer la restauration.`
    });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [RESTORE] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors de la restauration",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router56.get("/shared-references", async (req2, res) => {
  try {
    const { organizationId } = getAuthCtx3(req2);
    const templates = await prisma31.treeBranchLeafNode.findMany({
      where: {
        isSharedReference: true,
        sharedReferenceId: null,
        // C'est une source, pas une r√É∆í√Ü‚Äô√É‚Äö√Ç¬©f√É∆í√Ü‚Äô√É‚Äö√Ç¬©rence
        type: {
          not: "leaf_option"
          // √É∆í√Ç¬¢√É‚Äö√Ç¬ù√É‚Ä¶√¢‚Ç¨‚Ñ¢ Exclure les options de SELECT
        },
        TreeBranchLeafTree: {
          organizationId
        }
      },
      select: {
        id: true,
        label: true,
        sharedReferenceName: true,
        // √É∆í√Ç¬¢√É‚Ä¶√¢‚Ç¨≈ì√É¬¢√¢‚Äö¬¨√Ç¬¶ sharedReferenceCategory SUPPRIM√É∆í√Ü‚Äô√É¬¢√¢‚Äö¬¨√Ç¬∞
        sharedReferenceDescription: true
      }
    });
    const templateIds = templates.map((t) => t.id);
    const usageCounts = await prisma31.treeBranchLeafNode.groupBy({
      by: ["sharedReferenceId"],
      where: {
        sharedReferenceId: { in: templateIds }
      },
      _count: { id: true }
    });
    const usageMap2 = new Map(usageCounts.map((u) => [u.sharedReferenceId, u._count.id]));
    const formatted = templates.map((template) => ({
      id: template.id,
      label: template.sharedReferenceName || template.label,
      // √É∆í√Ç¬¢√É‚Ä¶√¢‚Ç¨≈ì√É¬¢√¢‚Äö¬¨√Ç¬¶ category SUPPRIM√É∆í√Ü‚Äô√É¬¢√¢‚Äö¬¨√Ç¬∞
      description: template.sharedReferenceDescription,
      usageCount: usageMap2.get(template.id) || 0,
      usages: []
    }));
    res.json(formatted);
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [SHARED REF] Erreur liste:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router56.get("/shared-references/:refId", async (req2, res) => {
  try {
    const { refId } = req2.params;
    const { organizationId } = getAuthCtx3(req2);
    const template = await prisma31.treeBranchLeafNode.findFirst({
      where: {
        id: refId,
        isSharedReference: true,
        sharedReferenceId: null,
        TreeBranchLeafTree: {
          organizationId
        }
      },
      select: {
        id: true,
        label: true,
        sharedReferenceName: true,
        // √É∆í√Ç¬¢√É‚Ä¶√¢‚Ç¨≈ì√É¬¢√¢‚Äö¬¨√Ç¬¶ sharedReferenceCategory SUPPRIM√É∆í√Ü‚Äô√É¬¢√¢‚Äö¬¨√Ç¬∞
        sharedReferenceDescription: true
      }
    });
    if (!template) {
      return res.status(404).json({ error: "R\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9f\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rence introuvable" });
    }
    res.json({
      id: template.id,
      label: template.sharedReferenceName || template.label,
      // √É∆í√Ç¬¢√É‚Ä¶√¢‚Ç¨≈ì√É¬¢√¢‚Äö¬¨√Ç¬¶ category SUPPRIM√É∆í√Ü‚Äô√É¬¢√¢‚Äö¬¨√Ç¬∞
      description: template.sharedReferenceDescription,
      usageCount: usageMap.get(template.id) || 0,
      usages: []
    });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [SHARED REF] Erreur d\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9tails:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router56.put("/shared-references/:refId", async (req2, res) => {
  try {
    const { refId } = req2.params;
    const { name, description } = req2.body;
    const { organizationId } = getAuthCtx3(req2);
    const template = await prisma31.treeBranchLeafNode.findFirst({
      where: {
        id: refId,
        isSharedReference: true,
        sharedReferenceId: null,
        TreeBranchLeafTree: {
          organizationId
        }
      }
    });
    if (!template) {
      return res.status(404).json({ error: "R\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9f\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rence introuvable" });
    }
    const updated = await prisma31.treeBranchLeafNode.update({
      where: { id: refId },
      data: {
        sharedReferenceName: name || template.sharedReferenceName,
        sharedReferenceDescription: description !== void 0 ? description : template.sharedReferenceDescription,
        label: name || template.label,
        updatedAt: /* @__PURE__ */ new Date()
      },
      select: {
        id: true,
        label: true,
        sharedReferenceName: true,
        sharedReferenceDescription: true
      }
    });
    res.json({ success: true, reference: updated });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [SHARED REF] Erreur modification:", error);
    res.status(500).json({ error: "Erreur lors de la modification" });
  }
});
router56.delete("/shared-references/:refId", async (req2, res) => {
  try {
    const { refId } = req2.params;
    const { organizationId } = getAuthCtx3(req2);
    const template = await prisma31.treeBranchLeafNode.findFirst({
      where: {
        id: refId,
        isSharedReference: true,
        sharedReferenceId: null,
        TreeBranchLeafTree: {
          organizationId
        }
      }
    });
    if (!template) {
      return res.status(404).json({ error: "R\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9f\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rence introuvable" });
    }
    const usageCount = await prisma31.treeBranchLeafNode.count({
      where: { sharedReferenceId: refId }
    });
    if (usageCount > 0) {
      await prisma31.treeBranchLeafNode.updateMany({
        where: {
          sharedReferenceId: refId
        },
        data: {
          sharedReferenceId: null,
          sharedReferenceName: null,
          sharedReferenceDescription: null,
          isSharedReference: false
        }
      });
    }
    await prisma31.treeBranchLeafNode.delete({
      where: { id: refId }
    });
    res.json({ success: true, message: "R\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9f\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rence supprim\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e avec succ\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s" });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [SHARED REF] Erreur suppression:", error);
    res.status(500).json({ error: "Erreur lors de la suppression" });
  }
});
router56.post("/trees/:treeId/create-shared-reference", async (req2, res) => {
  try {
    const { treeId } = req2.params;
    const { name, description, fieldType, label } = req2.body;
    const { organizationId } = getAuthCtx3(req2);
    const tree = await prisma31.treeBranchLeafTree.findFirst({
      where: {
        id: treeId,
        organizationId
      }
    });
    if (!tree) {
      return res.status(404).json({ error: "Arbre introuvable" });
    }
    const newNodeId = `shared-ref-${Date.now()}-${Math.random().toString(36).substring(7)}`;
    const newNode = await prisma31.treeBranchLeafNode.create({
      data: {
        id: newNodeId,
        treeId,
        type: "leaf_field",
        // √É∆í√Ç¬¢√É‚Ä¶√¢‚Ç¨≈ì√É¬¢√¢‚Äö¬¨√Ç¬¶ OBLIGATOIRE : type du n√É∆í√¢‚Ç¨¬¶√É¬¢√¢‚Äö¬¨√Ö‚Äúud
        label: label || name,
        fieldType: fieldType || "TEXT",
        parentId: null,
        // √É∆í√Ç¬¢√É‚Ä¶√¢‚Ç¨≈ì√É¬¢√¢‚Äö¬¨√Ç¬¶ CORRECTION: null au lieu de 'ROOT' (contrainte de cl√É∆í√Ü‚Äô√É‚Äö√Ç¬© √É∆í√Ü‚Äô√É‚Äö√Ç¬©trang√É∆í√Ü‚Äô√É‚Äö√Ç¬®re)
        order: 9999,
        // Ordre √É∆í√Ü‚Äô√É‚Äö√Ç¬©lev√É∆í√Ü‚Äô√É‚Äö√Ç¬© pour les mettre √É∆í√Ü‚Äô√É‚Äö√Ç¬† la fin
        isSharedReference: true,
        sharedReferenceId: null,
        // C'est une source
        sharedReferenceName: name,
        sharedReferenceDescription: description,
        updatedAt: /* @__PURE__ */ new Date()
        // √É∆í√Ç¬¢√É‚Ä¶√¢‚Ç¨≈ì√É¬¢√¢‚Äö¬¨√Ç¬¶ OBLIGATOIRE : timestamp de mise √É∆í√Ü‚Äô√É‚Äö√Ç¬† jour
      }
    });
    res.json({
      success: true,
      id: newNode.id,
      node: {
        id: newNode.id,
        label: newNode.label,
        fieldType: newNode.fieldType,
        sharedReferenceName: newNode.sharedReferenceName,
        sharedReferenceDescription: newNode.sharedReferenceDescription
      },
      message: "R\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9f\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rence partag\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e cr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e avec succ\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s"
    });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [SHARED REF] Erreur cr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9ation:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router56.post("/nodes/:nodeId/link-shared-references", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { referenceIds } = req2.body;
    const { organizationId } = getAuthCtx3(req2);
    const node = await prisma31.treeBranchLeafNode.findFirst({
      where: {
        id: nodeId,
        TreeBranchLeafTree: {
          organizationId
        }
      }
    });
    if (!node) {
      return res.status(404).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud introuvable" });
    }
    await prisma31.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: {
        sharedReferenceIds: referenceIds
      }
    });
    res.json({
      success: true,
      message: `${referenceIds.length} r\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9f\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rence(s) li\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e(s) avec succ\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s`
    });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [SHARED REF] Erreur liaison:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router56.post("/nodes/:nodeId/convert-to-reference", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { name, description } = req2.body;
    const { organizationId } = getAuthCtx3(req2);
    const node = await prisma31.treeBranchLeafNode.findFirst({
      where: {
        id: nodeId,
        TreeBranchLeafTree: {
          organizationId
        }
      }
    });
    if (!node) {
      return res.status(404).json({ error: "N\xC3\u0192\xE2\u20AC\xA6\xC3\xA2\xE2\u201A\xAC\xC5\u201Cud introuvable" });
    }
    await prisma31.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: {
        isSharedReference: true,
        sharedReferenceId: null,
        // C'est une source
        sharedReferenceName: name,
        // √É∆í√Ç¬¢√É‚Ä¶√¢‚Ç¨≈ì√É¬¢√¢‚Äö¬¨√Ç¬¶ sharedReferenceCategory SUPPRIM√É∆í√Ü‚Äô√É¬¢√¢‚Äö¬¨√Ç¬∞
        sharedReferenceDescription: description
      }
    });
    res.json({
      success: true,
      id: nodeId,
      message: "R\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9f\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9rence cr\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA9e avec succ\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xA8s"
    });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [SHARED REF] Erreur conversion:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router56.post("/nodes/:nodeId/copy-linked-variable", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { variableId, newSuffix, duplicateNode, targetNodeId: bodyTargetNodeId } = req2.body;
    console.warn("?? [COPY-LINKED-VAR] DEPRECATED route: please use the registry/repeat API endpoints (POST /api/repeat) instead. This legacy route will be removed in a future release.");
    res.set("X-Deprecated-API", "/api/repeat");
    if (!variableId || newSuffix === void 0) {
      return res.status(400).json({
        error: "variableId et newSuffix requis dans le corps de la requ\xC3\u0192\xC6\u2019\xC3\u201A\xC2\xAAte"
      });
    }
    if (!Number.isInteger(newSuffix) || newSuffix < 1) {
      return res.status(400).json({
        error: "newSuffix doit \xC3\u0192\xC6\u2019\xC3\u201A\xC2\xAAtre un nombre entier positif"
      });
    }
    const node = await prisma31.treeBranchLeafNode.findFirst({
      where: {
        id: nodeId,
        TreeBranchLeafTree: {
          organizationId: getAuthCtx3(req2).organizationId
        }
      },
      include: { TreeBranchLeafTree: true }
    });
    if (!node) {
      return res.status(404).json({ error: "Noeud introuvable" });
    }
    let targetNodeId = nodeId;
    const shouldDuplicateNode = duplicateNode === void 0 ? true : Boolean(duplicateNode);
    let ownerNodeIdForMap = null;
    let didCreateTargetNode = false;
    let ownerNodeForDuplication = null;
    const ensureSuffixLocal = (id) => {
      return /-\d+$/.test(id) ? id.replace(/-\d+$/, `-${newSuffix}`) : `${id}-${newSuffix}`;
    };
    if (!shouldDuplicateNode && bodyTargetNodeId) {
      const targetNode = await prisma31.treeBranchLeafNode.findUnique({ where: { id: bodyTargetNodeId } });
      if (!targetNode) {
        return res.status(404).json({ error: "targetNodeId introuvable" });
      }
      if (targetNode.treeId !== node.treeId) {
        return res.status(400).json({ error: "targetNodeId doit appartenir au m\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDme arbre" });
      }
      targetNodeId = targetNode.id;
      if (variableId) {
        const originalVarForMap = await prisma31.treeBranchLeafNodeVariable.findUnique({ where: { id: variableId } });
        if (originalVarForMap) ownerNodeIdForMap = originalVarForMap.nodeId;
      }
    } else if (shouldDuplicateNode) {
      const originalVar = await prisma31.treeBranchLeafNodeVariable.findUnique({ where: { id: variableId } });
      if (!originalVar) {
        return res.status(404).json({ error: "Variable introuvable" });
      }
      const ownerNode = await prisma31.treeBranchLeafNode.findUnique({ where: { id: originalVar.nodeId } });
      if (!ownerNode) {
        return res.status(404).json({ error: "N\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDud propri\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDtaire introuvable" });
      }
      ownerNodeForDuplication = {
        id: ownerNode.id,
        table_activeId: ownerNode.table_activeId,
        formula_activeId: ownerNode.formula_activeId,
        condition_activeId: ownerNode.condition_activeId,
        variable_activeId: ownerNode.variable_activeId
      };
      ownerNodeIdForMap = ownerNode.id;
      const candidateId = `${ownerNode.id}-${newSuffix}`;
      const exists = await prisma31.treeBranchLeafNode.findUnique({ where: { id: candidateId } });
      targetNodeId = exists ? `${candidateId}-${Date.now()}` : candidateId;
      const rewriter = (json) => {
        if (!json) return json ?? {};
        const str = JSON.stringify(json);
        const rewritten = rewriteReferences(str, {
          nodeIdMap: /* @__PURE__ */ new Map(),
          formulaIdMap: /* @__PURE__ */ new Map(),
          conditionIdMap: /* @__PURE__ */ new Map(),
          tableIdMap: /* @__PURE__ */ new Map()
        }, newSuffix);
        return JSON.parse(rewritten);
      };
      await prisma31.treeBranchLeafNode.create({
        data: {
          id: targetNodeId,
          treeId: ownerNode.treeId,
          parentId: ownerNode.parentId,
          type: ownerNode.type,
          subType: ownerNode.subType,
          label: `${ownerNode.label || "Node"}-${newSuffix}`,
          description: ownerNode.description,
          value: ownerNode.value,
          calculatedValue: ownerNode.calculatedValue,
          order: (ownerNode.order ?? 0) + 1,
          isRequired: ownerNode.isRequired ?? false,
          isVisible: ownerNode.isVisible ?? true,
          isActive: ownerNode.isActive ?? true,
          isMultiple: ownerNode.isMultiple ?? false,
          hasData: ownerNode.hasData ?? false,
          metadata: rewriter(ownerNode.metadata),
          tableConfig: rewriter(ownerNode.tableConfig),
          formulaConfig: rewriter(ownerNode.formulaConfig),
          conditionConfig: rewriter(ownerNode.conditionConfig),
          apiConfig: rewriter(ownerNode.apiConfig),
          linkConfig: rewriter(ownerNode.linkConfig),
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
      didCreateTargetNode = true;
    }
    const nodeIdMap = /* @__PURE__ */ new Map();
    if (ownerNodeIdForMap) nodeIdMap.set(ownerNodeIdForMap, targetNodeId);
    const formulaIdMap = /* @__PURE__ */ new Map();
    const conditionIdMap = /* @__PURE__ */ new Map();
    const tableIdMap2 = /* @__PURE__ */ new Map();
    const result = await copyVariableWithCapacities(
      variableId,
      newSuffix,
      targetNodeId,
      prisma31,
      {
        autoCreateDisplayNode: true,
        nodeIdMap,
        formulaIdMap,
        conditionIdMap,
        tableIdMap: tableIdMap2
      }
    );
    if (!result.success) {
      return res.status(400).json({ error: result.error || "Erreur lors de la copie" });
    }
    if (didCreateTargetNode && ownerNodeForDuplication) {
      const newTableActiveId = ownerNodeForDuplication.table_activeId ? tableIdMap2.get(ownerNodeForDuplication.table_activeId) ?? ensureSuffixLocal(ownerNodeForDuplication.table_activeId) : null;
      const newFormulaActiveId = ownerNodeForDuplication.formula_activeId ? formulaIdMap.get(ownerNodeForDuplication.formula_activeId) ?? ensureSuffixLocal(ownerNodeForDuplication.formula_activeId) : null;
      const newConditionActiveId = ownerNodeForDuplication.condition_activeId ? conditionIdMap.get(ownerNodeForDuplication.condition_activeId) ?? ensureSuffixLocal(ownerNodeForDuplication.condition_activeId) : null;
      const shouldUpdateVariableActiveId = !ownerNodeForDuplication.variable_activeId || ownerNodeForDuplication.variable_activeId === variableId;
      const updateData = {
        table_activeId: newTableActiveId,
        formula_activeId: newFormulaActiveId,
        condition_activeId: newConditionActiveId,
        updatedAt: /* @__PURE__ */ new Date()
      };
      if (shouldUpdateVariableActiveId) {
        updateData.variable_activeId = result.variableId;
      }
      await prisma31.treeBranchLeafNode.update({
        where: { id: targetNodeId },
        data: updateData
      });
    }
    try {
      await addToNodeLinkedField7(prisma31, targetNodeId, "linkedVariableIds", [result.variableId]);
    } catch (e) {
      console.warn("?? [COPY-LINKED-VAR] \xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDchec MAJ linkedVariableIds:", e.message);
    }
    try {
      console.log(`\u{1F504} [COPY-LINKED-VAR] D\xE9clenchement \xE9valuation initiale pour ${targetNodeId}...`);
      const copiedNode = await prisma31.treeBranchLeafNode.findUnique({
        where: { id: targetNodeId },
        select: { treeId: true, calculatedValue: true }
      });
      if (copiedNode?.treeId) {
        const activeSubmission = await prisma31.treeBranchLeafSubmission.findFirst({
          where: {
            treeId: copiedNode.treeId,
            status: { not: "archived" }
          },
          orderBy: { updatedAt: "desc" },
          select: { id: true }
        });
        if (activeSubmission) {
          const evaluationResult = await evaluateVariableOperation(
            targetNodeId,
            activeSubmission.id,
            prisma31
          );
          await prisma31.treeBranchLeafNode.update({
            where: { id: targetNodeId },
            data: {
              calculatedValue: evaluationResult.value,
              updatedAt: /* @__PURE__ */ new Date()
            }
          });
          console.log(`\u2705 [COPY-LINKED-VAR] \xC9valuation initiale termin\xE9e: ${targetNodeId} = ${evaluationResult.value}`);
        } else {
          console.warn(`\u26A0\uFE0F [COPY-LINKED-VAR] Pas de submission active trouv\xE9e pour \xE9valuation de ${targetNodeId}`);
        }
      }
    } catch (evalError) {
      console.error("\u26A0\uFE0F [COPY-LINKED-VAR] Erreur lors de l'\xE9valuation initiale:", evalError);
    }
    res.status(201).json({ ...result, targetNodeId });
  } catch (error) {
    console.error("\xC3\u0192\xC2\xA2\xC3\u201A\xC2\x9D\xC3\u2026\xE2\u20AC\u2122 [COPY-LINKED-VAR] Erreur:", error);
    const msg = error instanceof Error ? error.message : String(error);
    res.status(500).json({ error: msg });
  }
});
router56.post("/variables/:variableId/create-display", async (req2, res) => {
  try {
    const { variableId } = req2.params;
    const { label, suffix } = req2.body || {};
    const result = await createDisplayNodeForExistingVariable(variableId, prisma31, label || "Nouveau Section", suffix ?? "nouveau");
    res.status(201).json(result);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    console.error("? [/variables/:variableId/create-display] Erreur:", msg);
    res.status(400).json({ error: msg });
  }
});
router56.get("/variables/search", async (req2, res) => {
  try {
    const q = String(req2.query.displayName || "").trim();
    if (!q) return res.status(400).json({ error: "displayName query string requis" });
    const found = await prisma31.treeBranchLeafNodeVariable.findMany({
      where: { displayName: { contains: q, mode: "insensitive" } },
      select: { id: true, nodeId: true, exposedKey: true, displayName: true, sourceType: true, sourceRef: true }
    });
    res.json({ count: found.length, items: found });
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    res.status(500).json({ error: msg });
  }
});
router56.get("/trees/:treeId/calculated-values", async (req2, res) => {
  try {
    const { treeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx3(req2);
    const treeWhereFilter = isSuperAdmin2 || !organizationId ? { id: treeId } : { id: treeId, organizationId };
    const tree = await prisma31.treeBranchLeafTree.findFirst({
      where: treeWhereFilter
    });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBD" });
    }
    const nodesWithCalculatedValue = await prisma31.treeBranchLeafNode.findMany({
      where: {
        treeId,
        calculatedValue: {
          not: null
        }
      },
      select: {
        id: true,
        label: true,
        type: true,
        calculatedValue: true,
        calculatedBy: true,
        parentId: true
      }
    });
    const parentIds = nodesWithCalculatedValue.map((n) => n.parentId).filter((id) => !!id);
    const parentNodes = await prisma31.treeBranchLeafNode.findMany({
      where: { id: { in: parentIds } },
      select: { id: true, label: true }
    });
    const parentLabelsMap = new Map(parentNodes.map((p) => [p.id, p.label]));
    const calculatedValues = nodesWithCalculatedValue.map((node) => ({
      id: node.id,
      label: node.label || "Champ sans nom",
      calculatedValue: node.calculatedValue,
      calculatedBy: node.calculatedBy || void 0,
      type: node.type,
      parentLabel: node.parentId ? parentLabelsMap.get(node.parentId) : void 0
    }));
    res.json(calculatedValues);
  } catch (error) {
    console.error("[TreeBranchLeaf API] Error fetching calculated values:", error);
    res.status(500).json({ error: "Impossible de r\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDcup\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDrer les valeurs calcul\xC3\u0192\xC2\xAF\xC3\u201A\xC2\xBF\xC3\u201A\xC2\xBDes" });
  }
});
var treebranchleaf_routes_default = router56;

// src/components/TreeBranchLeaf/treebranchleaf-new/TBL/routes/tbl-routes.ts
var import_express58 = __toESM(require("express"), 1);
init_database();
var router57 = import_express58.default.Router();
var prisma32 = db;
function getAuthCtx4(req2) {
  const role = (req2.user?.role || "").toLowerCase();
  const possibleFlag = req2.user?.isSuperAdmin;
  const isSuperAdmin2 = role === "super_admin" || possibleFlag === true;
  const organizationId = req2.user?.organizationId || null;
  return { isSuperAdmin: isSuperAdmin2, organizationId };
}
router57.get("/variables", authMiddleware, requireRole(["user", "admin", "super_admin"]), async (req2, res) => {
  try {
    const { isSuperAdmin: isSuperAdmin2, organizationId } = getAuthCtx4(req2);
    const existingNodes = await prisma32.treeBranchLeafNode.findMany({
      select: {
        id: true,
        treeId: true,
        TreeBranchLeafTree: { select: { organizationId: true } }
      }
    });
    const existingNodeIds = new Set(existingNodes.map((n) => n.id));
    const nodeOrgMap = new Map(existingNodes.map((n) => [n.id, n.TreeBranchLeafTree?.organizationId]));
    const raw = await prisma32.treeBranchLeafNodeVariable.findMany({
      orderBy: { updatedAt: "desc" }
    });
    const variables = raw.filter((v) => existingNodeIds.has(v.nodeId)).filter((v) => {
      if (isSuperAdmin2) return true;
      const nodeOrg = nodeOrgMap.get(v.nodeId);
      return !organizationId || !nodeOrg || nodeOrg === organizationId;
    }).map((v) => ({
      id: v.id,
      nodeId: v.nodeId,
      exposedKey: v.exposedKey,
      displayName: v.displayName,
      sourceRef: v.sourceRef ?? null,
      sourceType: v.sourceType ?? null,
      displayFormat: v.displayFormat,
      unit: v.unit ?? null,
      precision: v.precision ?? null,
      updatedAt: v.updatedAt
    }));
    return res.json({ variables, count: variables.length, source: "database" });
  } catch (e) {
    const err = e;
    console.error("\u274C [TBL API] Erreur GET /variables:", err.message, err.stack);
    return res.status(500).json({ error: "Erreur serveur variables", details: err.message });
  }
});
router57.get(["/calculation-modes", "/modes"], authMiddleware, requireRole(["user", "admin", "super_admin"]), async (req2, res) => {
  try {
    let detectCapacity = function(sourceRef) {
      if (!sourceRef) return "1";
      if (sourceRef.startsWith("formula:")) return "2";
      if (sourceRef.startsWith("condition:")) return "3";
      if (sourceRef.startsWith("table:")) return "4";
      return "1";
    };
    const { isSuperAdmin: isSuperAdmin2, organizationId } = getAuthCtx4(req2);
    const existingNodes = await prisma32.treeBranchLeafNode.findMany({
      select: {
        id: true,
        treeId: true,
        parentId: true,
        type: true,
        TreeBranchLeafTree: { select: { organizationId: true } }
      }
    });
    const existingNodeIds = new Set(existingNodes.map((n) => n.id));
    const nodeOrgMap = new Map(existingNodes.map((n) => [n.id, n.TreeBranchLeafTree?.organizationId]));
    const rawVariables = await prisma32.treeBranchLeafNodeVariable.findMany();
    const accessible = rawVariables.filter((v) => existingNodeIds.has(v.nodeId)).filter((v) => {
      if (isSuperAdmin2) return true;
      const nodeOrg = nodeOrgMap.get(v.nodeId);
      return !organizationId || !nodeOrg || nodeOrg === organizationId;
    });
    const capacityBuckets = { "1": [], "2": [], "3": [], "4": [] };
    for (const v of accessible) {
      const capacity = detectCapacity(v.sourceRef);
      const fieldType = (v.displayFormat || "").startsWith("number") ? "number" : "text";
      const f = {
        id: v.id,
        code: v.exposedKey || v.id,
        label: v.displayName || v.exposedKey || v.id,
        type: fieldType,
        capacity,
        sourceRef: v.sourceRef || null
      };
      capacityBuckets[capacity].push(f);
    }
    const capacityMeta = {
      "1": { code: "neutral", label: "Variables neutres" },
      "2": { code: "formulas", label: "Formules" },
      "3": { code: "conditions", label: "Conditions" },
      "4": { code: "tables", label: "Tableaux" }
    };
    const modes = Object.entries(capacityBuckets).filter(([, list]) => list.length > 0).map(([cap, list]) => ({
      id: `capacity_${cap}`,
      code: capacityMeta[cap].code,
      label: capacityMeta[cap].label,
      capacity: cap,
      fields: list.slice(0, 100)
      // limite de s√©curit√©
    }));
    if (modes.length === 0) {
      modes.push({ id: "capacity_1", code: "neutral", label: "Variables neutres", capacity: "1", fields: [] });
    }
    return res.json({ modes, count: modes.length, source: "derived_capacity", generatedAt: (/* @__PURE__ */ new Date()).toISOString() });
  } catch (e) {
    const err = e;
    console.error("\u274C [TBL API] Erreur GET /calculation-modes (capacity detection):", err.message, err.stack);
    return res.status(500).json({ error: "Erreur serveur calculation-modes", details: err.message });
  }
});
router57.get("/fields", authMiddleware, requireRole(["user", "admin", "super_admin"]), async (req2, res) => {
  try {
    const { isSuperAdmin: isSuperAdmin2, organizationId } = getAuthCtx4(req2);
    const nodes = await prisma32.treeBranchLeafNode.findMany({
      where: {
        OR: [
          { type: { startsWith: "leaf_" } },
          { hasData: true }
        ]
      },
      select: {
        id: true,
        label: true,
        type: true,
        fieldType: true,
        fieldSubType: true,
        hasData: true,
        treeId: true,
        parentId: true,
        order: true,
        // üè∑Ô∏è COLONNES TOOLTIP - CRITIQUES POUR TBL
        text_helpTooltipType: true,
        text_helpTooltipText: true,
        text_helpTooltipImage: true,
        TreeBranchLeafTree: { select: { organizationId: true } }
      },
      orderBy: { updatedAt: "desc" }
    });
    const filtered = nodes.filter((n) => {
      if (isSuperAdmin2) return true;
      const nodeOrg = n.TreeBranchLeafTree?.organizationId;
      return !organizationId || !nodeOrg || nodeOrg === organizationId;
    });
    const fields = filtered.map((n) => ({
      id: n.id,
      nodeId: n.id,
      type: (n.fieldType || n.fieldSubType || n.type || "").replace(/^leaf_/, "") || "text",
      label: n.label || n.id,
      required: false,
      defaultValue: null,
      category: n.fieldSubType || null,
      order: n.order,
      // üè∑Ô∏è DONN√âES TOOLTIP - ESSENTIELLES POUR TBL
      text_helpTooltipType: n.text_helpTooltipType,
      text_helpTooltipText: n.text_helpTooltipText,
      text_helpTooltipImage: n.text_helpTooltipImage
    }));
    return res.json({ fields, count: fields.length, source: "database" });
  } catch (e) {
    console.error("\u274C [TBL API] Erreur GET /fields:", e);
    return res.status(500).json({ error: "Erreur serveur fields" });
  }
});
router57.post("/devis", authMiddleware, requireRole(["user", "admin", "super_admin"]), async (req2, res) => {
  try {
    const { clientId, treeId, organizationId, userId, projectName, notes, isDraft, formData, metadata } = req2.body || {};
    if (req2.user?.organizationId && organizationId && req2.user.organizationId !== organizationId) {
      return res.status(403).json({ success: false, error: "Acc\xE8s refus\xE9 \xE0 cette organisation" });
    }
    const devisId = `tbl_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
    const payload = {
      devisId,
      clientId: clientId || null,
      treeId: treeId || null,
      organizationId: organizationId || req2.user?.organizationId || null,
      userId: userId || req2.user?.id || null,
      projectName: projectName || `Projet TBL ${(/* @__PURE__ */ new Date()).toLocaleDateString()}`,
      notes: notes || "",
      isDraft: Boolean(isDraft),
      formData: typeof formData === "object" && formData ? formData : {},
      metadata: { ...metadata || {}, savedAt: (/* @__PURE__ */ new Date()).toISOString(), version: "1.0" },
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    return res.json({ success: true, ...payload, message: "Devis TBL sauvegard\xE9 (simulation)" });
  } catch (error) {
    console.error("\u274C [TBL API] Erreur sauvegarde devis:", error);
    return res.status(500).json({ success: false, error: "Erreur serveur lors de la sauvegarde du devis" });
  }
});
router57.get("/config/health", authMiddleware, requireRole(["user", "admin", "super_admin"]), async (req2, res) => {
  try {
    const [varCount, formulaCount, conditionCount, tableCount] = await Promise.all([
      prisma32.treeBranchLeafNodeVariable.count(),
      prisma32.treeBranchLeafNodeFormula.count().catch(() => 0),
      // @ts-expect-error table potentielle condition pas toujours g√©n√©r√©e
      prisma32.treeBranchLeafNodeCondition?.count?.().catch?.(() => 0) || 0,
      // @ts-expect-error table potentielle table pas toujours g√©n√©r√©e
      prisma32.treeBranchLeafNodeTable?.count?.().catch?.(() => 0) || 0
    ]);
    const sample = await prisma32.treeBranchLeafNodeVariable.findMany({
      select: { id: true, sourceRef: true },
      take: 500,
      orderBy: { updatedAt: "desc" }
    });
    const capacityCounts = { "1": 0, "2": 0, "3": 0, "4": 0 };
    for (const v of sample) {
      const sr = v.sourceRef || "";
      if (sr.startsWith("formula:")) capacityCounts["2"]++;
      else if (sr.startsWith("condition:")) capacityCounts["3"]++;
      else if (sr.startsWith("table:")) capacityCounts["4"]++;
      else capacityCounts["1"]++;
    }
    return res.json({
      success: true,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      counts: {
        variables: varCount,
        formulas: formulaCount,
        conditions: conditionCount,
        tables: tableCount
      },
      capacitySample: capacityCounts,
      sampleSize: sample.length
    });
  } catch (e) {
    const err = e;
    return res.status(500).json({ success: false, error: "Erreur health config", details: err.message });
  }
});
router57.get("/devis/client/:clientId", authMiddleware, requireRole(["user", "admin", "super_admin"]), async (_req, res) => {
  try {
    res.json([]);
  } catch (error) {
    console.error("\u274C [TBL API] Erreur r\xE9cup\xE9ration devis client:", error);
    res.status(500).json({
      error: "Erreur serveur lors de la r\xE9cup\xE9ration des devis"
    });
  }
});
router57.get("/devis/:devisId", authMiddleware, requireRole(["user", "admin", "super_admin"]), async (req2, res) => {
  try {
    const { devisId } = req2.params;
    res.json({
      devisId,
      clientId: null,
      treeId: null,
      organizationId: null,
      userId: null,
      projectName: "",
      notes: "",
      isDraft: true,
      formData: {},
      metadata: {},
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("\u274C [TBL API] Erreur chargement devis:", error);
    res.status(500).json({
      error: "Erreur serveur lors du chargement du devis"
    });
  }
});
router57.get("/clients/:clientId/access-check", authMiddleware, requireRole(["user", "admin", "super_admin"]), async (req2, res) => {
  try {
    const { clientId } = req2.params;
    const { role } = req2.user || {};
    res.json({
      hasAccess: true,
      clientId,
      userRole: role
    });
  } catch (error) {
    console.error("\u274C [TBL API] Erreur v\xE9rification acc\xE8s client:", error);
    res.status(500).json({
      error: "Erreur serveur lors de la v\xE9rification d'acc\xE8s"
    });
  }
});
var tbl_routes_default = router57;

// src/components/TreeBranchLeaf/tbl-bridge/routes/tbl-intelligence-routes.ts
var import_express59 = __toESM(require("express"), 1);

// src/components/TreeBranchLeaf/tbl-bridge/intelligence/TBLIntelligence.ts
init_database();
var TBLIntelligence = class {
  prisma;
  elementRegistry = /* @__PURE__ */ new Map();
  formulaRegistry = /* @__PURE__ */ new Map();
  conditionRegistry = /* @__PURE__ */ new Map();
  tableRegistry = /* @__PURE__ */ new Map();
  dataCache = /* @__PURE__ */ new Map();
  constructor() {
    this.prisma = db;
  }
  /**
   * üìñ LECTURE ET D√âCODAGE DES DONN√âES ENCOD√âES
   * Lit les donn√©es stock√©es dans la base et les d√©code pour √©valuation
   */
  async readAndDecodeElementData(elementId, elementType) {
    const cacheKey = `${elementType}_${elementId}`;
    if (this.dataCache.has(cacheKey)) {
      console.log(`\u{1F4D6} [TBL Intelligence] Donn\xE9es en cache pour ${cacheKey}`);
      return this.dataCache.get(cacheKey);
    }
    console.log(`\u{1F4D6} [TBL Intelligence] Lecture donn\xE9es encod\xE9es pour ${elementType} ${elementId}`);
    let decodedData = {};
    try {
      switch (elementType) {
        case "formula":
          decodedData = await this.readFormulaData(elementId);
          break;
        case "condition":
          decodedData = await this.readConditionData(elementId);
          break;
        case "table":
          decodedData = await this.readTableData(elementId);
          break;
        case "field":
          decodedData = await this.readFieldData(elementId);
          break;
        default:
          console.warn(`Type d'\xE9l\xE9ment non support\xE9 pour lecture donn\xE9es: ${elementType}`);
      }
      this.dataCache.set(cacheKey, decodedData);
      console.log(`\u{1F4D6} [TBL Intelligence] Donn\xE9es d\xE9cod\xE9es pour ${cacheKey}:`, decodedData);
      return decodedData;
    } catch (error) {
      console.error(`\u{1F4D6} [TBL Intelligence] Erreur lecture donn\xE9es ${cacheKey}:`, error);
      return {};
    }
  }
  /**
   * üßÆ LECTURE DES DONN√âES DE FORMULE
   */
  async readFormulaData(formulaId) {
    const formula = await this.prisma.treeBranchLeafNodeFormula.findFirst({
      where: { nodeId: formulaId }
    });
    if (!formula) return {};
    let tokens2 = [];
    try {
      tokens2 = formula.tokens ? JSON.parse(formula.tokens) : [];
    } catch (e) {
      console.warn("Erreur d\xE9codage tokens formule:", e);
    }
    const variables = {};
    const sequence = [];
    for (const token of tokens2) {
      if (token.type === "variable" && token.variable_name && token.value !== null) {
        variables[token.variable_name] = this.parseValue(token.value);
      }
      sequence.push(token.value || token.variable_name || token.operator);
    }
    return {
      formula_content: formula.name || "",
      tokens: tokens2,
      sequence,
      variables,
      description: formula.description
    };
  }
  /**
   * üîß PARSEUR DE VALEURS
   */
  parseValue(value) {
    if (value === null || value === void 0) return null;
    if (typeof value === "number" || typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      if (value.startsWith("{") && value.endsWith("}") || value.startsWith("[") && value.endsWith("]")) {
        try {
          return JSON.parse(value);
        } catch (e) {
          return value;
        }
      }
      const num = parseFloat(value);
      if (!isNaN(num) && isFinite(num)) {
        return num;
      }
      const lower = value.toLowerCase();
      if (lower === "true") return true;
      if (lower === "false") return false;
      return value;
    }
    return value;
  }
  /**
   * ‚öñÔ∏è LECTURE DES DONN√âES DE CONDITION
   */
  async readConditionData(conditionId) {
    const condition = await this.prisma.treeBranchLeafNodeCondition.findFirst({
      where: { nodeId: conditionId }
    });
    if (!condition) return {};
    let conditionSet = {};
    try {
      conditionSet = condition.conditionSet ? JSON.parse(condition.conditionSet) : {};
    } catch (e) {
      console.warn("Erreur d\xE9codage conditionSet:", e);
    }
    const rules = Array.isArray(conditionSet.rules) ? conditionSet.rules : [];
    return {
      condition_type: condition.name,
      conditionSet,
      rules,
      logic: conditionSet.logic || "AND"
    };
  }
  /**
   * üìä LECTURE DES DONN√âES DE TABLEAU
   */
  async readTableData(tableId) {
    const table = await this.prisma.treeBranchLeafNodeTable.findFirst({
      where: { nodeId: tableId }
    });
    if (!table) return {};
    let tableData = [];
    let columns = [];
    try {
      tableData = table.data ? typeof table.data === "string" ? JSON.parse(table.data) : table.data : [];
      columns = table.columns ? typeof table.columns === "string" ? JSON.parse(table.columns) : table.columns : [];
    } catch (e) {
      console.warn("Erreur d\xE9codage donn\xE9es tableau:", e);
    }
    return {
      table_type: table.type,
      columns,
      data: tableData,
      metadata: {
        rows: Array.isArray(tableData) ? tableData.length : 0,
        has_formulas: Array.isArray(columns) ? columns.some((col) => col.formula) : false
      }
    };
  }
  /**
   * üè∑Ô∏è LECTURE DES DONN√âES DE CHAMP
   */
  async readFieldData(fieldId) {
    const field = await this.prisma.treeBranchLeafNode.findUnique({
      where: { id: fieldId },
      include: {
        other_TreeBranchLeafNode: {
          select: {
            id: true,
            label: true,
            tbl_code: true,
            value: true,
            type: true
          }
        }
      }
    });
    if (!field) return {};
    return {
      field_type: field.type,
      tbl_code: field.tbl_code,
      value: this.parseValue(field.value),
      options: field.other_TreeBranchLeafNode?.map((child) => ({
        id: child.id,
        label: child.label,
        tbl_code: child.tbl_code,
        value: this.parseValue(child.value),
        type: child.type
      })) || []
    };
  }
  /**
   * üßÆ MOTEUR DE CALCUL POUR FORMULES
   * Ex√©cute les calculs math√©matiques avec support des variables TBL
   */
  async calculateFormula(formulaId, contextData = {}) {
    console.log(`\u{1F9EE} [TBL Intelligence] Calcul formule ${formulaId}`);
    const steps = [];
    try {
      const formulaData = await this.readAndDecodeElementData(formulaId, "formula");
      if (!formulaData.sequence || !Array.isArray(formulaData.sequence)) {
        throw new Error("S\xE9quence de formule invalide");
      }
      steps.push(`\u{1F4D6} Formule charg\xE9e: ${formulaData.formula_content}`);
      steps.push(`\u{1F522} Variables disponibles: ${Object.keys(formulaData.variables).join(", ")}`);
      const allVariables = { ...formulaData.variables, ...contextData };
      steps.push(`\u{1F517} Variables totales: ${Object.keys(allVariables).length}`);
      const result = await this.evaluateFormulaSequence(formulaData.sequence, allVariables, steps);
      steps.push(`\u2705 R\xE9sultat final: ${result}`);
      return {
        result,
        success: true,
        steps
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Erreur inconnue";
      steps.push(`\u274C Erreur: ${errorMessage}`);
      return {
        result: null,
        success: false,
        error: errorMessage,
        steps
      };
    }
  }
  /**
   * üß© √âVALUATEUR DE S√âQUENCE DE FORMULE
   */
  async evaluateFormulaSequence(sequence, variables, steps) {
    const stack = [];
    for (let i = 0; i < sequence.length; i++) {
      const token = sequence[i];
      steps.push(`\u{1F504} Token ${i}: ${JSON.stringify(token)}`);
      if (typeof token === "number") {
        stack.push(token);
        steps.push(`\u{1F4CA} Nombre ajout\xE9: ${token}`);
      } else if (typeof token === "string") {
        if (token.startsWith("TBL_") && variables[token] !== void 0) {
          const value = this.convertToNumber(variables[token]);
          stack.push(value);
          steps.push(`\u{1F3F7}\uFE0F Variable ${token} = ${value}`);
        } else if (["+", "-", "*", "/", "^", ">", "<", ">=", "<=", "==", "!=", "AND", "OR"].includes(token)) {
          const result = this.executeOperation(token, stack, steps);
          if (result !== null) {
            stack.push(result);
          }
        } else if (token.includes("(")) {
          const result = await this.executeFunction(token, stack, variables, steps);
          if (result !== null) {
            stack.push(result);
          }
        } else {
          stack.push(token);
          steps.push(`\u{1F4DD} String ajout\xE9e: "${token}"`);
        }
      }
    }
    if (stack.length === 1) {
      return stack[0];
    } else if (stack.length === 0) {
      throw new Error("\xC9valuation vide");
    } else {
      throw new Error(`\xC9valuation ambigu\xEB: ${stack.length} r\xE9sultats`);
    }
  }
  /**
   * ‚öôÔ∏è EX√âCUTEUR D'OP√âRATIONS
   */
  executeOperation(operator, stack, steps) {
    if (stack.length < 2) {
      steps.push(`\u274C Pas assez d'op\xE9randes pour ${operator}`);
      return null;
    }
    const b = stack.pop();
    const a = stack.pop();
    const numA = this.convertToNumber(a);
    const numB = this.convertToNumber(b);
    let result;
    switch (operator) {
      case "+":
        result = numA + numB;
        break;
      case "-":
        result = numA - numB;
        break;
      case "*":
        result = numA * numB;
        break;
      case "/":
        if (numB === 0) {
          steps.push(`\u274C Division par z\xE9ro`);
          return null;
        }
        result = numA / numB;
        break;
      case "^":
        result = Math.pow(numA, numB);
        break;
      case ">":
        result = numA > numB;
        break;
      case "<":
        result = numA < numB;
        break;
      case ">=":
        result = numA >= numB;
        break;
      case "<=":
        result = numA <= numB;
        break;
      case "==":
        result = a === b;
        break;
      case "!=":
        result = a !== b;
        break;
      case "AND":
        result = Boolean(a) && Boolean(b);
        break;
      case "OR":
        result = Boolean(a) || Boolean(b);
        break;
      default:
        steps.push(`\u274C Op\xE9rateur inconnu: ${operator}`);
        return null;
    }
    steps.push(`\u{1F522} ${a} ${operator} ${b} = ${result}`);
    return result;
  }
  /**
   * üîß EX√âCUTEUR DE FONCTIONS
   */
  async executeFunction(functionCall, stack, variables, steps) {
    const match = functionCall.match(/^(\w+)\((.*)\)$/);
    if (!match) {
      steps.push(`\u274C Format de fonction invalide: ${functionCall}`);
      return null;
    }
    const funcName = match[1];
    const argsStr = match[2];
    const args = [];
    if (argsStr.trim()) {
      const argTokens = argsStr.split(",").map((s) => s.trim());
      for (const argToken of argTokens) {
        if (argToken.startsWith("TBL_") && variables[argToken] !== void 0) {
          args.push(this.convertToNumber(variables[argToken]));
        } else if (!isNaN(Number(argToken))) {
          args.push(Number(argToken));
        } else {
          args.push(argToken.replace(/['"]/g, ""));
        }
      }
    }
    const requiredArgs = this.getFunctionArity(funcName);
    while (args.length < requiredArgs && stack.length > 0) {
      args.unshift(stack.pop());
    }
    let result = null;
    switch (funcName.toUpperCase()) {
      case "SUM":
        result = args.reduce((sum, val) => sum + this.convertToNumber(val), 0);
        break;
      case "AVG":
        result = args.length > 0 ? args.reduce((sum, val) => sum + this.convertToNumber(val), 0) / args.length : 0;
        break;
      case "MIN":
        result = Math.min(...args.map((val) => this.convertToNumber(val)));
        break;
      case "MAX":
        result = Math.max(...args.map((val) => this.convertToNumber(val)));
        break;
      case "ROUND":
        const num = this.convertToNumber(args[0]);
        const decimals = args[1] ? this.convertToNumber(args[1]) : 0;
        result = Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
        break;
      case "IF":
        const condition = Boolean(args[0]);
        result = condition ? args[1] : args[2];
        break;
      case "CONCAT":
        result = args.map((val) => String(val)).join("");
        break;
      case "LEN":
        result = String(args[0]).length;
        break;
      default:
        steps.push(`\u274C Fonction inconnue: ${funcName}`);
        return null;
    }
    steps.push(`\u{1F527} ${funcName}(${args.join(", ")}) = ${result}`);
    return result;
  }
  /**
   * üìä CONVERTISSEUR NUM√âRIQUE INTELLIGENT
   */
  convertToNumber(value) {
    if (typeof value === "number") return value;
    if (typeof value === "boolean") return value ? 1 : 0;
    if (typeof value === "string") {
      const num = parseFloat(value);
      return isNaN(num) ? 0 : num;
    }
    return 0;
  }
  /**
   * ‚öñÔ∏è MOTEUR D'√âVALUATION DES CONDITIONS
   * √âvalue les conditions logiques avec support des options et comparaisons
   */
  async evaluateCondition(conditionId, contextData = {}) {
    console.log(`\u2696\uFE0F [TBL Intelligence] \xC9valuation condition ${conditionId}`);
    const details = [];
    try {
      const conditionData = await this.readAndDecodeElementData(conditionId, "condition");
      if (!conditionData.rules || !Array.isArray(conditionData.rules)) {
        throw new Error("R\xE8gles de condition invalides");
      }
      details.push(`\u{1F4D6} Condition charg\xE9e: ${conditionData.condition_type}`);
      details.push(`\u{1F4CB} Nombre de r\xE8gles: ${conditionData.rules.length}`);
      details.push(`\u{1F517} Logique: ${conditionData.logic || "AND"}`);
      const ruleResults = [];
      for (let i = 0; i < conditionData.rules.length; i++) {
        const rule = conditionData.rules[i];
        const ruleResult = await this.evaluateConditionRule(rule, contextData, details, i);
        ruleResults.push(ruleResult);
      }
      const finalResult = this.applyLogicToResults(ruleResults, conditionData.logic || "AND", details);
      details.push(`\u2705 R\xE9sultat final: ${finalResult}`);
      return {
        result: finalResult,
        success: true,
        details
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Erreur inconnue";
      details.push(`\u274C Erreur: ${errorMessage}`);
      return {
        result: false,
        success: false,
        error: errorMessage,
        details
      };
    }
  }
  /**
   * üìè √âVALUATEUR DE R√àGLE INDIVIDUELLE
   */
  async evaluateConditionRule(rule, contextData, details, ruleIndex) {
    details.push(`\u{1F50D} R\xE8gle ${ruleIndex + 1}: ${rule.operator}`);
    let sourceValue;
    if (rule.source_node_id) {
      const sourceElement = await this.prisma.treeBranchLeafNode.findUnique({
        where: { id: rule.source_node_id },
        select: {
          value: true,
          tbl_code: true,
          label: true,
          other_TreeBranchLeafNode: {
            select: {
              id: true,
              value: true,
              tbl_code: true,
              label: true
            }
          }
        }
      });
      if (sourceElement) {
        sourceValue = this.parseValue(sourceElement.value);
        details.push(`\u{1F4CA} Source ${sourceElement.tbl_code}: ${sourceValue}`);
        if (sourceElement.other_TreeBranchLeafNode && sourceElement.other_TreeBranchLeafNode.length > 0) {
          const selectedOption = sourceElement.other_TreeBranchLeafNode.find(
            (child) => child.value === sourceValue || child.tbl_code === sourceValue
          );
          if (selectedOption) {
            sourceValue = selectedOption.value || selectedOption.tbl_code;
            details.push(`\u{1F3AF} Option s\xE9lectionn\xE9e: ${selectedOption.label} (${sourceValue})`);
          }
        }
      } else {
        details.push(`\u274C Source non trouv\xE9e: ${rule.source_node_id}`);
        sourceValue = null;
      }
    } else if (contextData) {
      sourceValue = contextData.sourceValue || null;
      details.push(`\u{1F517} Valeur du contexte: ${sourceValue}`);
    }
    const compareValue = rule.value;
    details.push(`\u2696\uFE0F Comparaison: ${sourceValue} ${rule.operator} ${compareValue}`);
    const result = this.compareValues(sourceValue, rule.operator, compareValue);
    details.push(`\u{1F4CA} R\xE9sultat r\xE8gle ${ruleIndex + 1}: ${result}`);
    return result;
  }
  /**
   * üîç COMPARATEUR DE VALEURS UNIVERSEL
   */
  compareValues(sourceValue, operator, compareValue) {
    const source = this.normalizeValueForComparison(sourceValue);
    const compare = this.normalizeValueForComparison(compareValue);
    switch (operator) {
      case "==":
      case "equals":
        return source === compare;
      case "!=":
      case "not_equals":
        return source !== compare;
      case ">":
      case "greater_than":
        return Number(source) > Number(compare);
      case ">=":
      case "greater_than_or_equal":
        return Number(source) >= Number(compare);
      case "<":
      case "less_than":
        return Number(source) < Number(compare);
      case "<=":
      case "less_than_or_equal":
        return Number(source) <= Number(compare);
      case "contains":
        return String(source).toLowerCase().includes(String(compare).toLowerCase());
      case "starts_with":
        return String(source).toLowerCase().startsWith(String(compare).toLowerCase());
      case "ends_with":
        return String(source).toLowerCase().endsWith(String(compare).toLowerCase());
      case "is_empty":
        return !source || source === "" || source === null || source === void 0;
      case "is_not_empty":
        return !(!source || source === "" || source === null || source === void 0);
      case "in":
        if (Array.isArray(compare)) {
          return compare.includes(source);
        }
        return String(compare).split(",").map((s) => s.trim()).includes(String(source));
      case "not_in":
        if (Array.isArray(compare)) {
          return !compare.includes(source);
        }
        return !String(compare).split(",").map((s) => s.trim()).includes(String(source));
      default:
        console.warn(`Op\xE9rateur de comparaison non support\xE9: ${operator}`);
        return false;
    }
  }
  /**
   * üîß NORMALISATEUR DE VALEURS POUR COMPARAISON
   */
  normalizeValueForComparison(value) {
    if (value === null || value === void 0) return null;
    if (typeof value === "boolean") return value;
    if (typeof value === "number") return value;
    if (typeof value === "string") {
      const num = parseFloat(value.trim());
      if (!isNaN(num) && isFinite(num)) {
        return num;
      }
      const lower = value.toLowerCase().trim();
      if (lower === "true" || lower === "1") return true;
      if (lower === "false" || lower === "0") return false;
      return value.trim();
    }
    return String(value);
  }
  /**
   * üßÆ APPLICATEUR DE LOGIQUE GLOBALE
   */
  applyLogicToResults(results, logic, details) {
    details.push(`\u{1F9EE} Application logique ${logic} sur ${results.length} r\xE9sultats: [${results.join(", ")}]`);
    switch (logic.toUpperCase()) {
      case "AND":
        const andResult = results.every((r) => r);
        details.push(`\u{1F517} AND: tous vrais = ${andResult}`);
        return andResult;
      case "OR":
        const orResult = results.some((r) => r);
        details.push(`\u{1F517} OR: au moins un vrai = ${orResult}`);
        return orResult;
      case "XOR":
        const trueCount = results.filter((r) => r).length;
        const xorResult = trueCount === 1;
        details.push(`\u{1F517} XOR: exactement un vrai = ${xorResult}`);
        return xorResult;
      case "NAND":
        const nandResult = !results.every((r) => r);
        details.push(`\u{1F517} NAND: pas tous vrais = ${nandResult}`);
        return nandResult;
      case "NOR":
        const norResult = !results.some((r) => r);
        details.push(`\u{1F517} NOR: aucun vrai = ${norResult}`);
        return norResult;
      default:
        details.push(`\u26A0\uFE0F Logique inconnue ${logic}, utilisation de AND par d\xE9faut`);
        return results.every((r) => r);
    }
  }
  /**
   * üìä MOTEUR D'ANALYSE ET TRAITEMENT DES TABLEAUX
   * Analyse les structures de tableaux avec donn√©es dynamiques et formules
   */
  async processTable(tableId, contextData = {}) {
    console.log(`\u{1F4CA} [TBL Intelligence] Traitement tableau ${tableId}`);
    const processing = [];
    try {
      const tableData = await this.readAndDecodeElementData(tableId, "table");
      if (!tableData.columns || !Array.isArray(tableData.columns)) {
        throw new Error("Structure de tableau invalide");
      }
      processing.push(`\u{1F4D6} Tableau charg\xE9: ${tableData.table_type}`);
      processing.push(`\u{1F4CB} Colonnes: ${tableData.columns.length}`);
      processing.push(`\u{1F4CA} Lignes de donn\xE9es: ${tableData.data.length}`);
      const formulaColumns = tableData.columns.filter((col) => col.formula);
      processing.push(`\u{1F9EE} Colonnes avec formules: ${formulaColumns.length}`);
      const processedData = [];
      let calculatedCells = 0;
      for (let rowIndex = 0; rowIndex < tableData.data.length; rowIndex++) {
        const row = tableData.data[rowIndex];
        const processedRow = [];
        processing.push(`\u{1F504} Traitement ligne ${rowIndex + 1}`);
        for (let colIndex = 0; colIndex < tableData.columns.length; colIndex++) {
          const column = tableData.columns[colIndex];
          let cellValue = row[colIndex] || null;
          if (column.formula) {
            processing.push(`\u{1F9EE} Calcul formule colonne ${column.name}: ${column.formula}`);
            try {
              const cellContext = {
                ...contextData,
                rowIndex,
                colIndex,
                rowData: row,
                currentValue: cellValue
              };
              const formulaResult = await this.calculateTableFormula(
                column.formula,
                cellContext,
                tableData.data,
                rowIndex,
                colIndex
              );
              if (formulaResult.success) {
                cellValue = formulaResult.result;
                calculatedCells++;
                processing.push(`\u2705 Formule calcul\xE9e: ${formulaResult.result}`);
              } else {
                processing.push(`\u274C Erreur formule: ${formulaResult.error}`);
              }
            } catch (error) {
              const errorMsg = error instanceof Error ? error.message : "Erreur calcul";
              processing.push(`\u274C Erreur calcul cellule [${rowIndex}, ${colIndex}]: ${errorMsg}`);
            }
          }
          processedRow.push(cellValue);
        }
        processedData.push(processedRow);
      }
      const metadata = {
        rows: processedData.length,
        columns: tableData.columns.length,
        hasFormulas: formulaColumns.length > 0,
        calculatedCells
      };
      processing.push(`\u2705 Tableau trait\xE9: ${metadata.rows}x${metadata.columns}, ${calculatedCells} cellules calcul\xE9es`);
      return {
        processedData,
        metadata,
        success: true,
        processing
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Erreur inconnue";
      processing.push(`\u274C Erreur: ${errorMessage}`);
      return {
        processedData: [],
        metadata: { rows: 0, columns: 0, hasFormulas: false, calculatedCells: 0 },
        success: false,
        error: errorMessage,
        processing
      };
    }
  }
  /**
   * üßÆ CALCULATEUR DE FORMULES DE TABLEAU
   */
  async calculateTableFormula(formula, cellContext, tableData, rowIndex, colIndex) {
    try {
      const tableVariables = {
        // Variables de position
        ROW_INDEX: rowIndex,
        COL_INDEX: colIndex,
        ROW_NUMBER: rowIndex + 1,
        COL_NUMBER: colIndex + 1,
        // Variables de donn√©es
        CURRENT_VALUE: cellContext.currentValue,
        ROW_DATA: cellContext.rowData,
        // Fonctions de tableau
        TABLE_ROWS: tableData.length,
        TABLE_COLS: tableData[0]?.length || 0
      };
      for (let r = 0; r < tableData.length; r++) {
        for (let c = 0; c < (tableData[r]?.length || 0); c++) {
          if (r !== rowIndex || c !== colIndex) {
            tableVariables[`CELL_${r}_${c}`] = tableData[r][c];
            tableVariables[`R${r}C${c}`] = tableData[r][c];
          }
        }
      }
      const result = await this.evaluateTableFormula(formula, tableVariables, cellContext);
      return {
        result,
        success: true
      };
    } catch (error) {
      return {
        result: null,
        success: false,
        error: error instanceof Error ? error.message : "Erreur calcul formule"
      };
    }
  }
  /**
   * üî¢ √âVALUATEUR DE FORMULES DE TABLEAU
   */
  async evaluateTableFormula(formula, variables, context) {
    let processedFormula = formula;
    processedFormula = processedFormula.replace(/R(\d+)C(\d+)/g, (match, row, col) => {
      const value = variables[`R${row}C${col}`];
      return typeof value === "number" ? value.toString() : `"${value}"`;
    });
    for (const [varName, varValue] of Object.entries(variables)) {
      if (processedFormula.includes(varName)) {
        const replacement = typeof varValue === "number" ? varValue.toString() : `"${varValue}"`;
        processedFormula = processedFormula.replace(new RegExp(varName, "g"), replacement);
      }
    }
    processedFormula = await this.replaceTableFunctions(processedFormula, variables, context);
    try {
      return this.safeEvaluateExpression(processedFormula);
    } catch (error) {
      console.warn("Formule non \xE9valuable comme JS, tentative d'\xE9valuation simple:", processedFormula);
      return processedFormula;
    }
  }
  /**
   * üîß REMPLACEUR DE FONCTIONS DE TABLEAU
   */
  async replaceTableFunctions(formula, variables, context) {
    let result = formula;
    result = result.replace(/SUM_ROW\(\)/g, () => {
      const rowData = context.rowData;
      if (Array.isArray(rowData)) {
        const sum = rowData.reduce((acc, val) => acc + (Number(val) || 0), 0);
        return sum.toString();
      }
      return "0";
    });
    result = result.replace(/SUM_COL\((\d+)\)/g, (match, colIndex) => {
      const col = Number(colIndex);
      const tableRows = variables.TABLE_ROWS;
      let sum = 0;
      for (let r = 0; r < tableRows; r++) {
        const cellValue = variables[`R${r}C${col}`];
        sum += Number(cellValue) || 0;
      }
      return sum.toString();
    });
    result = result.replace(/AVG_ROW\(\)/g, () => {
      const rowData = context.rowData;
      if (Array.isArray(rowData) && rowData.length > 0) {
        const sum = rowData.reduce((acc, val) => acc + (Number(val) || 0), 0);
        return (sum / rowData.length).toString();
      }
      return "0";
    });
    result = result.replace(/COUNT_NON_EMPTY_ROW\(\)/g, () => {
      const rowData = context.rowData;
      if (Array.isArray(rowData)) {
        const count = rowData.filter((val) => val !== null && val !== void 0 && val !== "").length;
        return count.toString();
      }
      return "0";
    });
    return result;
  }
  /**
   * üîí √âVALUATEUR D'EXPRESSIONS S√âCURIS√â
   */
  safeEvaluateExpression(expression) {
    const allowedPattern = /^[\d\s+\-*/().,"'>=<!&|]+$/;
    if (!allowedPattern.test(expression)) {
      throw new Error("Expression contient des caract\xE8res non autoris\xE9s");
    }
    try {
      const func = new Function(`"use strict"; return (${expression});`);
      return func();
    } catch (error) {
      throw new Error(`Erreur \xE9valuation: ${error instanceof Error ? error.message : "Inconnue"}`);
    }
  }
  /**
   * üî¢ ARIT√â DES FONCTIONS (compl√©t√©e)
   */
  getFunctionArity(funcName) {
    switch (funcName.toUpperCase()) {
      case "SUM":
      case "AVG":
      case "MIN":
      case "MAX":
        return 0;
      // Variable
      case "ROUND":
        return 1;
      case "IF":
        return 3;
      case "CONCAT":
        return 0;
      // Variable
      case "LEN":
        return 1;
      case "SUM_ROW":
      case "AVG_ROW":
      case "COUNT_NON_EMPTY_ROW":
        return 0;
      case "SUM_COL":
        return 1;
      default:
        return 0;
    }
  }
  /**
   * üîç ANALYSE COMPL√àTE D'UN √âL√âMENT
   * Analyse un √©l√©ment par son CODE TBL ou son UUID
   */
  async analyzeElement(elementIdentifier) {
    console.log(`\u{1F9E0} [TBL Intelligence] Analyse compl\xE8te de ${elementIdentifier}`);
    console.log(`\u{1F50D} Recherche TBL Bridge sur code: ${elementIdentifier}`);
    const element = await this.prisma.treeBranchLeafNode.findFirst({
      where: { tbl_code: elementIdentifier },
      // UNIQUEMENT code TBL !
      include: {
        TreeBranchLeafNodeFormula: true,
        TreeBranchLeafNodeCondition: true,
        TreeBranchLeafNodeTable: true,
        other_TreeBranchLeafNode: {
          select: {
            id: true,
            label: true,
            tbl_code: true,
            tbl_type: true,
            tbl_capacity: true,
            type: true
          }
        },
        TreeBranchLeafNode: {
          select: {
            id: true,
            label: true,
            tbl_code: true,
            tbl_type: true,
            type: true
          }
        }
      }
    });
    if (!element) {
      throw new Error(`\u274C \xC9l\xE9ment TBL Bridge avec code "${elementIdentifier}" non trouv\xE9 dans la base de donn\xE9es`);
    }
    console.log(`\u2705 \xC9l\xE9ment TBL Bridge trouv\xE9: ${element.label} (${element.type})`);
    console.log(`   \u{1F3AF} TBL Code: ${element.tbl_code}`);
    console.log(`   \u{1F3D7}\uFE0F Type TBL: ${element.tbl_type} | \u{1F527} Capacit\xE9 TBL: ${element.tbl_capacity}`);
    const typeDescription = this.getTBLTypeDescription(element.tbl_type);
    const capacityDescription = this.getTBLCapacityDescription(element.tbl_capacity);
    console.log(`   \u{1F4CB} TBL Intelligence: ${typeDescription} avec ${capacityDescription}`);
    const tblElement = {
      id: element.id,
      label: element.label,
      tbl_code: element.tbl_code || "",
      tbl_type: element.tbl_type || 0,
      tbl_capacity: element.tbl_capacity || 0,
      type: element.type,
      parent_id: element.parent_id || void 0
    };
    console.log(`\u{1F9E0} [TBL Intelligence V2.0] Analyse des capacit\xE9s via colonnes Prisma...`);
    const formulas = element.tbl_capacity === 2 ? await this.analyzeFormulas(element.TreeBranchLeafNodeFormula || []) : [];
    const conditions = element.tbl_capacity === 3 ? await this.analyzeConditions(element.TreeBranchLeafNodeCondition || []) : [];
    const tables = element.tbl_capacity === 4 ? await this.analyzeTables(element.TreeBranchLeafNodeTable || []) : [];
    console.log(`\u{1F4CA} [TBL V2.0] R\xE9sultats: ${formulas.length} formules, ${conditions.length} conditions, ${tables.length} tableaux`);
    const dependencies = await this.buildDependencyGraph(tblElement, formulas, conditions, tables);
    console.log(`\u2705 [TBL Intelligence] Analyse termin\xE9e pour ${element.label} (${element.tbl_code})`);
    console.log(`   \u{1F4CA} ${formulas.length} formules, ${conditions.length} conditions, ${tables.length} tableaux`);
    console.log(`   \u{1F517} ${dependencies.length} d\xE9pendances d\xE9tect\xE9es`);
    return {
      element: tblElement,
      formulas,
      conditions,
      tables,
      dependencies
    };
  }
  /**
   * üßÆ ANALYSE DES FORMULES
   * Extrait les codes TBL r√©f√©renc√©s dans les formules
   */
  async analyzeFormulas(formulas) {
    const tblFormulas = [];
    for (const formula of formulas) {
      console.log(`\u{1F9EE} [TBL Intelligence] Analyse formule ${formula.id}`);
      const referencedFields = [];
      const dependencies = [];
      const tokens2 = Array.isArray(formula.tokens) ? formula.tokens : [];
      for (const token of tokens2) {
        if (token.type === "variable" && token.reference_id) {
          const referencedElement = await this.prisma.treeBranchLeafNode.findUnique({
            where: { id: token.reference_id },
            select: { tbl_code: true, label: true }
          });
          if (referencedElement?.tbl_code) {
            referencedFields.push(referencedElement.tbl_code);
            dependencies.push({
              source_code: referencedElement.tbl_code,
              target_code: "",
              // Sera rempli par l'√©l√©ment parent
              dependency_type: "formula",
              relationship: "depends_on"
            });
            console.log(`   \u{1F517} R\xE9f\xE9rence d\xE9tect\xE9e: ${referencedElement.label} (${referencedElement.tbl_code})`);
          }
        }
      }
      tblFormulas.push({
        id: formula.id,
        formula_content: formula.sequence || "[]",
        referenced_fields: referencedFields,
        dependencies
      });
    }
    return tblFormulas;
  }
  /**
   * ‚öñÔ∏è ANALYSE DES CONDITIONS
   * Identifie les relations options + champs conditionnels
   */
  async analyzeConditions(conditions) {
    const tblConditions = [];
    for (const condition of conditions) {
      console.log(`\u2696\uFE0F [TBL Intelligence] Analyse condition ${condition.id}`);
      const triggerElements = [];
      const targetElements = [];
      const optionMappings = [];
      for (const rule of condition.TreeBranchLeafNodeConditionRule || []) {
        if (rule.source_node_id) {
          const sourceElement = await this.prisma.treeBranchLeafNode.findUnique({
            where: { id: rule.source_node_id },
            select: {
              tbl_code: true,
              label: true,
              type: true,
              other_TreeBranchLeafNode: {
                select: {
                  id: true,
                  tbl_code: true,
                  label: true,
                  type: true
                }
              }
            }
          });
          if (sourceElement?.tbl_code) {
            triggerElements.push(sourceElement.tbl_code);
            if (sourceElement.type === "leaf_option" || sourceElement.type === "leaf_option_field") {
              for (const child of sourceElement.other_TreeBranchLeafNode) {
                if (child.tbl_code && child.type === "leaf_field") {
                  optionMappings.push({
                    option_code: sourceElement.tbl_code,
                    field_code: child.tbl_code,
                    show_when_selected: rule.condition_value === "true" || rule.condition_value === sourceElement.label
                  });
                  console.log(`   \u{1F3AF} Option + Champ d\xE9tect\xE9: ${sourceElement.label} (${sourceElement.tbl_code}) \u2192 ${child.label} (${child.tbl_code})`);
                }
              }
            }
          }
        }
        if (rule.target_node_id) {
          const targetElement = await this.prisma.treeBranchLeafNode.findUnique({
            where: { id: rule.target_node_id },
            select: { tbl_code: true, label: true }
          });
          if (targetElement?.tbl_code) {
            targetElements.push(targetElement.tbl_code);
          }
        }
      }
      tblConditions.push({
        id: condition.id,
        condition_logic: condition.logic || "and",
        trigger_elements: triggerElements,
        target_elements: targetElements,
        option_mappings: optionMappings
      });
    }
    return tblConditions;
  }
  /**
   * üìä ANALYSE DES TABLEAUX
   * Identifie les sources de donn√©es et relations
   */
  async analyzeTables(tables) {
    const tblTables = [];
    for (const table of tables) {
      console.log(`\u{1F4CA} [TBL Intelligence] Analyse tableau ${table.id}`);
      const dataSources = [];
      const computedColumns = [];
      const relationships = [];
      for (const column of table.TreeBranchLeafNodeTableColumn || []) {
        if (column.source_node_id) {
          const sourceElement = await this.prisma.treeBranchLeafNode.findUnique({
            where: { id: column.source_node_id },
            select: { tbl_code: true, label: true, tbl_capacity: true }
          });
          if (sourceElement?.tbl_code) {
            if (sourceElement.tbl_capacity === 2) {
              computedColumns.push(sourceElement.tbl_code);
            } else {
              dataSources.push(sourceElement.tbl_code);
            }
            console.log(`   \u{1F4CB} Source donn\xE9es: ${sourceElement.label} (${sourceElement.tbl_code})`);
          }
        }
      }
      tblTables.push({
        id: table.id,
        data_sources: dataSources,
        computed_columns: computedColumns,
        relationships
      });
    }
    return tblTables;
  }
  /**
   * üîó CONSTRUCTION DU GRAPHE DE D√âPENDANCES
   * Cr√©e le r√©seau complet des relations entre √©l√©ments
   */
  async buildDependencyGraph(element, formulas, conditions, tables) {
    const dependencies = [];
    for (const formula of formulas) {
      for (const dep of formula.dependencies) {
        dependencies.push({
          ...dep,
          target_code: element.tbl_code
        });
      }
    }
    for (const condition of conditions) {
      for (const triggerCode of condition.trigger_elements) {
        for (const targetCode of condition.target_elements) {
          dependencies.push({
            source_code: triggerCode,
            target_code: targetCode,
            dependency_type: "condition",
            relationship: "triggers"
          });
        }
      }
      for (const mapping of condition.option_mappings) {
        dependencies.push({
          source_code: mapping.option_code,
          target_code: mapping.field_code,
          dependency_type: "condition",
          relationship: "triggers"
        });
      }
    }
    for (const table of tables) {
      for (const sourceCode of table.data_sources) {
        dependencies.push({
          source_code: sourceCode,
          target_code: element.tbl_code,
          dependency_type: "data_flow",
          relationship: "affects"
        });
      }
    }
    return dependencies;
  }
  /**
   * üéØ R√âSOLUTION INTELLIGENTE
   * R√©sout une valeur en tenant compte de toutes les d√©pendances TBL
   */
  async resolveValue(elementCode, context = {}) {
    console.log(`\u{1F3AF} [TBL Intelligence] R\xE9solution intelligente de ${elementCode}`);
    const element = await this.prisma.treeBranchLeafNode.findFirst({
      where: { tbl_code: elementCode }
    });
    if (!element) {
      throw new Error(`\xC9l\xE9ment avec code TBL ${elementCode} non trouv\xE9`);
    }
    const analysis = await this.analyzeElement(element.id);
    switch (analysis.element.tbl_capacity) {
      case 2:
        return await this.resolveFormula(analysis, context);
      case 3:
        return await this.resolveCondition(analysis, context);
      case 4:
        return await this.resolveTable(analysis, context);
      default:
        return await this.resolveSimpleValue(analysis, context);
    }
  }
  async resolveFormula(analysis, context) {
    console.log(`\u{1F9EE} R\xE9solution formule avec ${analysis.formulas.length} formules`);
    return {
      value: 0,
      // Calcul√© selon la formule
      dependencies_resolved: analysis.formulas.flatMap((f) => f.referenced_fields),
      conditions_evaluated: [],
      formulas_calculated: analysis.formulas.map((f) => f.id)
    };
  }
  async resolveCondition(analysis, context) {
    console.log(`\u2696\uFE0F R\xE9solution condition avec ${analysis.conditions.length} conditions`);
    return {
      value: true,
      // √âvalu√© selon les conditions
      dependencies_resolved: [],
      conditions_evaluated: analysis.conditions.map((c) => c.id),
      formulas_calculated: []
    };
  }
  async resolveTable(analysis, context) {
    console.log(`\u{1F4CA} R\xE9solution tableau avec ${analysis.tables.length} tableaux`);
    return {
      value: [],
      // Donn√©es du tableau
      dependencies_resolved: analysis.tables.flatMap((t) => t.data_sources),
      conditions_evaluated: [],
      formulas_calculated: []
    };
  }
  async resolveSimpleValue(analysis, context) {
    const value = context[analysis.element.tbl_code] || null;
    console.log(`\u{1F4DD} R\xE9solution valeur simple: ${analysis.element.label} = ${value}`);
    return {
      value,
      dependencies_resolved: [],
      conditions_evaluated: [],
      formulas_calculated: []
    };
  }
  // üöÄ TBL BRIDGE V2.0 - M√©thodes de description des types et capacit√©s
  /**
   * Retourne la description du type TBL selon le README
   */
  getTBLTypeDescription(tbl_type) {
    const typeMap = {
      1: "Branche (Onglet TBL)",
      2: "Sous-Branche (Liste d\xE9roulante TBL)",
      3: "Champ (Input utilisateur)",
      4: "Option (Choix dans liste)",
      5: "Option + champ (Option qui ouvre un champ)",
      6: "Champ donn\xE9es (Affichage donn\xE9es calcul\xE9es)",
      7: "Section (Container pour champs donn\xE9es)"
    };
    return typeMap[tbl_type] || `Type inconnu (${tbl_type})`;
  }
  /**
   * Retourne la description de la capacit√© TBL selon le README
   */
  getTBLCapacityDescription(tbl_capacity) {
    const capacityMap = {
      1: "Neutre (Pas de traitement sp\xE9cial)",
      2: "Formule (Calcul math\xE9matique)",
      3: "Condition (Logique if/then/else)",
      4: "Tableau (Donn\xE9es tabulaires)"
    };
    return capacityMap[tbl_capacity] || `Capacit\xE9 inconnue (${tbl_capacity})`;
  }
};
var TBLIntelligence_default = TBLIntelligence;

// src/components/TreeBranchLeaf/tbl-bridge/intelligence/TBLEvaluationEngine.ts
var TBLEvaluationEngine = class {
  intelligence;
  evaluationCache = /* @__PURE__ */ new Map();
  CACHE_TTL = 5e3;
  // 5 secondes
  constructor() {
    this.intelligence = new TBLIntelligence_default();
  }
  /**
   * üéØ √âVALUATION PRINCIPALE
   * Point d'entr√©e unique pour toutes les √©valuations TBL
   */
  async evaluate(request) {
    const startTime = Date.now();
    console.log(`\u{1F680} [TBL Evaluation] D\xE9but \xE9valuation ${request.element_code}`);
    console.log(`   Mode: ${request.evaluation_mode}, Deep: ${request.deep_resolution}`);
    const result = {
      success: false,
      element_code: request.element_code,
      final_value: null,
      evaluation_path: [],
      dependencies_used: [],
      options_triggered: [],
      formulas_calculated: [],
      conditions_evaluated: [],
      performance: {
        total_time_ms: 0,
        elements_analyzed: 0,
        cache_hits: 0
      },
      errors: [],
      warnings: []
    };
    try {
      const cacheKey = this.getCacheKey(request);
      const cached = this.getCachedResult(cacheKey);
      if (cached) {
        console.log(`\u{1F4BE} [TBL Evaluation] Cache HIT pour ${request.element_code}`);
        result.performance.cache_hits = 1;
        result.final_value = cached;
        result.success = true;
        return result;
      }
      const analysis = await this.intelligence.analyzeElement(request.element_code);
      result.performance.elements_analyzed++;
      result.evaluation_path.push(request.element_code);
      switch (request.evaluation_mode) {
        case "formula":
          await this.evaluateFormulas(analysis, request, result);
          break;
        case "condition":
          await this.evaluateConditions(analysis, request, result);
          break;
        case "table":
          await this.evaluateTables(analysis, request, result);
          break;
        case "auto":
        default:
          await this.evaluateAuto(analysis, request, result);
          break;
      }
      if (request.deep_resolution) {
        await this.resolveDeepDependencies(analysis, request, result);
      }
      this.setCachedResult(cacheKey, result.final_value);
      result.success = true;
      console.log(`\u2705 [TBL Evaluation] \xC9valuation r\xE9ussie: ${request.element_code} = ${result.final_value}`);
    } catch (error) {
      console.error(`\u274C [TBL Evaluation] Erreur:`, error);
      result.errors.push(error instanceof Error ? error.message : "Erreur inconnue");
    }
    result.performance.total_time_ms = Date.now() - startTime;
    return result;
  }
  /**
   * üßÆ √âVALUATION DES FORMULES
   */
  async evaluateFormulas(analysis, request, result) {
    console.log(`\u{1F9EE} [TBL Evaluation] \xC9valuation de ${analysis.formulas.length} formules`);
    for (const formula of analysis.formulas) {
      try {
        const fieldValues = {};
        for (const fieldCode of formula.referenced_fields) {
          if (fieldCode in request.context_values) {
            const value = request.context_values[fieldCode];
            fieldValues[fieldCode] = typeof value === "number" ? value : parseFloat(String(value)) || 0;
            result.dependencies_used.push(fieldCode);
          } else {
            result.warnings.push(`Champ manquant pour formule: ${fieldCode}`);
          }
        }
        const formulaResult = this.calculateFormula(formula.formula_content, fieldValues);
        result.formulas_calculated.push({
          formula_id: formula.id,
          referenced_codes: formula.referenced_fields,
          result: formulaResult
        });
        result.final_value = formulaResult;
        console.log(`   \u2705 Formule ${formula.id}: ${formulaResult}`);
      } catch (error) {
        console.error(`   \u274C Erreur formule ${formula.id}:`, error);
        result.errors.push(`Formule ${formula.id}: ${error instanceof Error ? error.message : "Erreur"}`);
      }
    }
  }
  /**
   * ‚öñÔ∏è √âVALUATION DES CONDITIONS
   */
  async evaluateConditions(analysis, request, result) {
    console.log(`\u2696\uFE0F [TBL Evaluation] \xC9valuation de ${analysis.conditions.length} conditions`);
    for (const condition of analysis.conditions) {
      try {
        let conditionResult = true;
        const usedTriggers = [];
        for (const triggerCode of condition.trigger_elements) {
          if (triggerCode in request.context_values) {
            const triggerValue = request.context_values[triggerCode];
            const triggerResult = Boolean(triggerValue);
            conditionResult = conditionResult && triggerResult;
            usedTriggers.push(triggerCode);
            result.dependencies_used.push(triggerCode);
          }
        }
        for (const mapping of condition.option_mappings) {
          const optionValue = request.context_values[mapping.option_code];
          const shouldShowField = Boolean(optionValue) && mapping.show_when_selected;
          result.options_triggered.push({
            option_code: mapping.option_code,
            field_code: mapping.field_code,
            show_field: shouldShowField
          });
          console.log(`   \u{1F3AF} Option ${mapping.option_code} \u2192 Champ ${mapping.field_code}: ${shouldShowField ? "AFFICH\xC9" : "MASQU\xC9"}`);
        }
        result.conditions_evaluated.push({
          condition_id: condition.id,
          trigger_codes: usedTriggers,
          result: conditionResult
        });
        result.final_value = conditionResult;
        console.log(`   \u2705 Condition ${condition.id}: ${conditionResult}`);
      } catch (error) {
        console.error(`   \u274C Erreur condition ${condition.id}:`, error);
        result.errors.push(`Condition ${condition.id}: ${error instanceof Error ? error.message : "Erreur"}`);
      }
    }
  }
  /**
   * üìä √âVALUATION DES TABLEAUX
   */
  async evaluateTables(analysis, request, result) {
    console.log(`\u{1F4CA} [TBL Evaluation] \xC9valuation de ${analysis.tables.length} tableaux`);
    for (const table of analysis.tables) {
      try {
        const tableData = [];
        for (const sourceCode of table.data_sources) {
          if (sourceCode in request.context_values) {
            const sourceValue = request.context_values[sourceCode];
            tableData.push({ [sourceCode]: sourceValue });
            result.dependencies_used.push(sourceCode);
          }
        }
        for (const computedCode of table.computed_columns) {
          console.log(`   \u{1F9EE} Colonne calcul\xE9e: ${computedCode}`);
        }
        result.final_value = tableData;
        console.log(`   \u2705 Tableau ${table.id}: ${tableData.length} lignes`);
      } catch (error) {
        console.error(`   \u274C Erreur tableau ${table.id}:`, error);
        result.errors.push(`Tableau ${table.id}: ${error instanceof Error ? error.message : "Erreur"}`);
      }
    }
  }
  /**
   * ü§ñ √âVALUATION AUTOMATIQUE
   * D√©tecte automatiquement le type d'√©valuation selon la capacit√© TBL
   */
  async evaluateAuto(analysis, request, result) {
    const capacity = analysis.element.tbl_capacity;
    console.log(`\u{1F916} [TBL Evaluation] Mode auto - capacit\xE9 d\xE9tect\xE9e: ${capacity}`);
    switch (capacity) {
      case 2:
        await this.evaluateFormulas(analysis, request, result);
        break;
      case 3:
        await this.evaluateConditions(analysis, request, result);
        break;
      case 4:
        await this.evaluateTables(analysis, request, result);
        break;
      default:
        result.final_value = request.context_values[request.element_code] || null;
        break;
    }
  }
  /**
   * üîÑ R√âSOLUTION R√âCURSIVE DES D√âPENDANCES
   */
  async resolveDeepDependencies(analysis, request, result) {
    console.log(`\u{1F504} [TBL Evaluation] R\xE9solution profonde des d\xE9pendances`);
    for (const dependency of analysis.dependencies) {
      if (!result.evaluation_path.includes(dependency.source_code)) {
        const subRequest = {
          ...request,
          element_code: dependency.source_code,
          deep_resolution: false
          // √âviter la r√©cursion infinie
        };
        const subResult = await this.evaluate(subRequest);
        if (subResult.success) {
          result.evaluation_path.push(...subResult.evaluation_path);
          result.dependencies_used.push(...subResult.dependencies_used);
          result.performance.elements_analyzed += subResult.performance.elements_analyzed;
        }
      }
    }
  }
  /**
   * üßÆ CALCUL R√âEL DE FORMULE
   */
  calculateFormula(formulaContent, fieldValues) {
    try {
      const sequence = JSON.parse(formulaContent);
      let result = 0;
      for (const token of sequence) {
        if (token.type === "number") {
          result += parseFloat(token.value) || 0;
        } else if (token.type === "variable" && token.reference_code) {
          result += fieldValues[token.reference_code] || 0;
        }
      }
      return result;
    } catch {
      return 0;
    }
  }
  /**
   * üíæ GESTION DU CACHE
   */
  getCacheKey(request) {
    const contextHash = JSON.stringify(request.context_values);
    return `${request.element_code}:${request.evaluation_mode}:${contextHash}`;
  }
  getCachedResult(key2) {
    const cached = this.evaluationCache.get(key2);
    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      return cached.result;
    }
    return null;
  }
  setCachedResult(key2, result) {
    this.evaluationCache.set(key2, {
      result,
      timestamp: Date.now()
    });
  }
};
var TBLEvaluationEngine_default = TBLEvaluationEngine;

// src/components/TreeBranchLeaf/tbl-bridge/routes/tbl-intelligence-routes.ts
init_operation_interpreter();
init_database();
var router58 = import_express59.default.Router();
console.log("\u{1F9E0} [TBL INTELLIGENCE] Initialisation du routeur tbl-intelligence-routes (avec operation-interpreter)");
var evaluationEngine = new TBLEvaluationEngine_default();
function logRouteHit(route) {
  console.log(`\u{1F6F0}\uFE0F  [TBL INTELLIGENCE] Hit ${route} @ ${(/* @__PURE__ */ new Date()).toISOString()}`);
}
router58.post("/evaluate", async (req2, res) => {
  logRouteHit("POST /api/tbl/evaluate");
  const prisma51 = db;
  try {
    const { elementId, elementIds, contextData = {}, evalType } = req2.body || {};
    if (Array.isArray(elementIds) && elementIds.length > 0) {
      const startedAt = Date.now();
      const results = {};
      const traces = {};
      for (const id of elementIds) {
        if (!id || typeof id !== "string") {
          results[id || ""] = { success: false, error: "elementId invalide" };
          continue;
        }
        try {
          const single = await resolveSingleEvaluation(prisma51, id, contextData);
          results[id] = single.payload;
          traces[id] = single.trace;
        } catch (e) {
          results[id] = { success: false, error: "Erreur interne (batch item)", details: e instanceof Error ? e.message : "unknown" };
        }
      }
      return res.json({
        success: true,
        mode: "batch",
        evalType: evalType || "batch",
        count: elementIds.length,
        durationMs: Date.now() - startedAt,
        results,
        traces
      });
    }
    if (!elementId || typeof elementId !== "string") {
      return res.status(400).json({ success: false, error: "Param\xE8tre elementId manquant ou invalide (ni elementIds[] fourni)." });
    }
    const trace = [];
    let resolvedNodeId = null;
    let variable = null;
    const byKey = await prisma51.treeBranchLeafNodeVariable.findUnique({ where: { exposedKey: elementId }, select: { nodeId: true, exposedKey: true, displayName: true, sourceRef: true } });
    if (byKey) {
      resolvedNodeId = byKey.nodeId;
      variable = { exposedKey: byKey.exposedKey, displayName: byKey.displayName, sourceRef: byKey.sourceRef };
      trace.push({ step: "variable_exposedKey", info: "R\xE9solu via variable.exposedKey", success: true });
    } else {
      trace.push({ step: "variable_exposedKey", info: "Aucune variable avec cet exposedKey", success: false });
    }
    if (!resolvedNodeId) {
      const node = await prisma51.treeBranchLeafNode.findUnique({ where: { id: elementId }, select: { id: true } });
      if (node) {
        resolvedNodeId = node.id;
        trace.push({ step: "node_direct", info: "Correspondance trouv\xE9e dans TreeBranchLeafNode", success: true });
      } else {
        trace.push({ step: "node_direct", info: "Pas de node avec cet id", success: false });
      }
    }
    if (!resolvedNodeId) {
      const formula = await prisma51.treeBranchLeafNodeFormula.findUnique({
        where: { id: elementId },
        select: { id: true, nodeId: true, name: true, tokens: true }
      });
      if (formula) {
        resolvedNodeId = formula.nodeId;
        trace.push({ step: "formula_id", info: `Formule trouv\xE9e: ${formula.name}`, success: true });
        try {
          const prismaInstance = db;
          const submissionId = contextData.submissionId || "temp-evaluation";
          const valueMap = /* @__PURE__ */ new Map();
          for (const [key2, value] of Object.entries(contextData)) {
            valueMap.set(key2, value);
            if (!key2.startsWith("@")) {
              valueMap.set(`@value.${key2}`, value);
            }
          }
          console.log(`\u{1F9EE} [TBL EVALUATE] \xC9valuation directe formule: ${formula.name} (${formula.id})`);
          const valuesCache = /* @__PURE__ */ new Map();
          const labelMap = /* @__PURE__ */ new Map();
          const result = await interpretFormula(
            formula.id,
            submissionId,
            prismaInstance,
            valuesCache,
            0,
            valueMap,
            labelMap
          );
          trace.push({ step: "formula_direct_eval", info: `R\xE9sultat: ${result.result}`, success: true });
          return res.json({
            success: true,
            type: "formula",
            capacity: "2",
            value: result.result,
            humanText: result.humanText,
            details: result.details,
            trace
          });
        } catch (evalError) {
          console.error(`\u274C [TBL EVALUATE] Erreur \xE9valuation directe formule:`, evalError);
          trace.push({ step: "formula_direct_eval", info: `Erreur: ${evalError instanceof Error ? evalError.message : "unknown"}`, success: false });
        }
      } else {
        trace.push({ step: "formula_id", info: "Aucune formule avec cet id", success: false });
      }
    }
    if (!resolvedNodeId) {
      const viaSourceFormula = await prisma51.treeBranchLeafNodeVariable.findFirst({ where: { sourceRef: `formula:${elementId}` }, select: { nodeId: true, exposedKey: true, displayName: true, sourceRef: true } });
      if (viaSourceFormula) {
        resolvedNodeId = viaSourceFormula.nodeId;
        variable = { exposedKey: viaSourceFormula.exposedKey, displayName: viaSourceFormula.displayName, sourceRef: viaSourceFormula.sourceRef };
        trace.push({ step: "variable_sourceRef_formula", info: "R\xE9solu via variable.sourceRef=formula:<id>", success: true });
      } else {
        trace.push({ step: "variable_sourceRef_formula", info: "Aucune variable.sourceRef=formula:<id>", success: false });
      }
    }
    if (!resolvedNodeId) {
      const viaSourceRaw = await prisma51.treeBranchLeafNodeVariable.findFirst({ where: { sourceRef: elementId }, select: { nodeId: true, exposedKey: true, displayName: true, sourceRef: true } });
      if (viaSourceRaw) {
        resolvedNodeId = viaSourceRaw.nodeId;
        variable = { exposedKey: viaSourceRaw.exposedKey, displayName: viaSourceRaw.displayName, sourceRef: viaSourceRaw.sourceRef };
        trace.push({ step: "variable_sourceRef_raw", info: "R\xE9solu via variable.sourceRef = id", success: true });
      } else {
        trace.push({ step: "variable_sourceRef_raw", info: "Aucune variable.sourceRef = id", success: false });
      }
    }
    if (!resolvedNodeId) {
      return res.status(422).json({
        success: false,
        error: "Impossible de r\xE9soudre elementId",
        code: "ELEMENT_UNRESOLVED",
        hint: "V\xE9rifier que la variable ou formule est cr\xE9\xE9e avant l'\xE9valuation",
        trace
      });
    }
    if (!variable) {
      const v = await prisma51.treeBranchLeafNodeVariable.findFirst({ where: { nodeId: resolvedNodeId }, select: { exposedKey: true, displayName: true, sourceRef: true } });
      if (v) {
        variable = { exposedKey: v.exposedKey, displayName: v.displayName, sourceRef: v.sourceRef };
        trace.push({ step: "variable_from_node", info: "Variable trouv\xE9e via nodeId", success: true });
      }
    }
    if (!variable || !variable.exposedKey) {
      return res.status(422).json({ success: false, error: "Variable associ\xE9e introuvable ou sans exposedKey", trace });
    }
    const sr = variable.sourceRef || "";
    let capacity = "1";
    if (sr.startsWith("formula:")) capacity = "2";
    else if (sr.startsWith("condition:")) capacity = "3";
    else if (sr.startsWith("table:")) capacity = "4";
    trace.push({ step: "capacity_detect", info: `Capacit\xE9 d\xE9tect\xE9e=${capacity}`, success: true });
    if (capacity === "2") {
      const result = await evaluationEngine.evaluate({
        element_code: variable.exposedKey,
        context_values: contextData,
        evaluation_mode: "auto",
        deep_resolution: true
      });
      if (result.success) {
        return res.json({ success: true, type: "formula", capacity, value: result.final_value, dependencies: result.dependencies_used, performance: result.performance, trace });
      }
      return res.status(422).json({ success: false, type: "formula", capacity, error: "\xC9chec moteur", details: result.errors, trace });
    }
    if (capacity === "3") {
      return res.json({ success: true, type: "condition", capacity, status: "not_implemented", value: null, trace });
    }
    if (capacity === "4") {
      return res.json({ success: true, type: "table", capacity, status: "not_implemented", value: null, trace });
    }
    return res.json({ success: true, type: "neutral", capacity, value: null, trace });
  } catch (e) {
    console.error("\u{1F4A5} [TBL INTELLIGENCE] Erreur /evaluate:", e);
    return res.status(500).json({ success: false, error: "Erreur interne /evaluate", details: e instanceof Error ? e.message : "unknown" });
  }
});
async function resolveSingleEvaluation(prisma51, elementId, contextData) {
  const evaluationEngine2 = new TBLEvaluationEngine_default();
  const trace = [];
  let resolvedNodeId = null;
  let variable = null;
  const byKey = await prisma51.treeBranchLeafNodeVariable.findUnique({ where: { exposedKey: elementId }, select: { nodeId: true, exposedKey: true, displayName: true, sourceRef: true } });
  if (byKey) {
    resolvedNodeId = byKey.nodeId;
    variable = { exposedKey: byKey.exposedKey, displayName: byKey.displayName, sourceRef: byKey.sourceRef };
    trace.push({ step: "variable_exposedKey", info: "R\xE9solu via variable.exposedKey", success: true });
  } else {
    trace.push({ step: "variable_exposedKey", info: "Aucune variable avec cet exposedKey", success: false });
  }
  if (!resolvedNodeId) {
    const node = await prisma51.treeBranchLeafNode.findUnique({ where: { id: elementId }, select: { id: true } });
    if (node) {
      resolvedNodeId = node.id;
      trace.push({ step: "node_direct", info: "Correspondance trouv\xE9e dans TreeBranchLeafNode", success: true });
    } else {
      trace.push({ step: "node_direct", info: "Pas de node avec cet id", success: false });
    }
  }
  if (!resolvedNodeId) {
    const formula = await prisma51.treeBranchLeafNodeFormula.findUnique({
      where: { id: elementId },
      select: { id: true, nodeId: true, name: true, tokens: true }
    });
    if (formula) {
      resolvedNodeId = formula.nodeId;
      trace.push({ step: "formula_id", info: `Formule trouv\xE9e: ${formula.name}`, success: true });
      try {
        const prismaInstance = db;
        const submissionId = contextData.submissionId || "temp-evaluation";
        const valueMap = /* @__PURE__ */ new Map();
        for (const [key2, value] of Object.entries(contextData)) {
          valueMap.set(key2, value);
          if (!key2.startsWith("@")) {
            valueMap.set(`@value.${key2}`, value);
          }
        }
        console.log(`\u{1F9EE} [TBL EVALUATE BATCH] \xC9valuation directe formule: ${formula.name} (${formula.id})`);
        const valuesCache = /* @__PURE__ */ new Map();
        const labelMap = /* @__PURE__ */ new Map();
        const result = await interpretFormula(
          formula.id,
          submissionId,
          prismaInstance,
          valuesCache,
          0,
          valueMap,
          labelMap
        );
        trace.push({ step: "formula_direct_eval", info: `R\xE9sultat: ${result.result}`, success: true });
        return {
          payload: {
            success: true,
            type: "formula",
            capacity: "2",
            value: result.result,
            humanText: result.humanText,
            details: result.details
          },
          trace
        };
      } catch (evalError) {
        console.error(`\u274C [TBL EVALUATE BATCH] Erreur \xE9valuation directe formule:`, evalError);
        trace.push({ step: "formula_direct_eval", info: `Erreur: ${evalError instanceof Error ? evalError.message : "unknown"}`, success: false });
      }
    } else {
      trace.push({ step: "formula_id", info: "Aucune formule avec cet id", success: false });
    }
  }
  if (!resolvedNodeId) {
    const viaSourceFormula = await prisma51.treeBranchLeafNodeVariable.findFirst({ where: { sourceRef: `formula:${elementId}` }, select: { nodeId: true, exposedKey: true, displayName: true, sourceRef: true } });
    if (viaSourceFormula) {
      resolvedNodeId = viaSourceFormula.nodeId;
      variable = { exposedKey: viaSourceFormula.exposedKey, displayName: viaSourceFormula.displayName, sourceRef: viaSourceFormula.sourceRef };
      trace.push({ step: "variable_sourceRef_formula", info: "R\xE9solu via variable.sourceRef=formula:<id>", success: true });
    } else {
      trace.push({ step: "variable_sourceRef_formula", info: "Aucune variable.sourceRef=formula:<id>", success: false });
    }
  }
  if (!resolvedNodeId) {
    const viaSourceRaw = await prisma51.treeBranchLeafNodeVariable.findFirst({ where: { sourceRef: elementId }, select: { nodeId: true, exposedKey: true, displayName: true, sourceRef: true } });
    if (viaSourceRaw) {
      resolvedNodeId = viaSourceRaw.nodeId;
      variable = { exposedKey: viaSourceRaw.exposedKey, displayName: viaSourceRaw.displayName, sourceRef: viaSourceRaw.sourceRef };
      trace.push({ step: "variable_sourceRef_raw", info: "R\xE9solu via variable.sourceRef = id", success: true });
    } else {
      trace.push({ step: "variable_sourceRef_raw", info: "Aucune variable.sourceRef = id", success: false });
    }
  }
  if (!resolvedNodeId) {
    return { payload: { success: false, error: "Impossible de r\xE9soudre elementId", trace }, trace };
  }
  if (!variable) {
    const v = await prisma51.treeBranchLeafNodeVariable.findFirst({ where: { nodeId: resolvedNodeId }, select: { exposedKey: true, displayName: true, sourceRef: true } });
    if (v) {
      variable = { exposedKey: v.exposedKey, displayName: v.displayName, sourceRef: v.sourceRef };
      trace.push({ step: "variable_from_node", info: "Variable trouv\xE9e via nodeId", success: true });
    }
  }
  if (!variable || !variable.exposedKey) {
    return { payload: { success: false, error: "Variable associ\xE9e introuvable ou sans exposedKey", trace }, trace };
  }
  const sr = variable.sourceRef || "";
  let capacity = "1";
  if (sr.startsWith("formula:")) capacity = "2";
  else if (sr.startsWith("condition:")) capacity = "3";
  else if (sr.startsWith("table:")) capacity = "4";
  trace.push({ step: "capacity_detect", info: `Capacit\xE9 d\xE9tect\xE9e=${capacity}`, success: true });
  if (capacity === "2") {
    try {
      const prismaInstance = db;
      const formulaId = sr.replace(/^(formula:|node-formula:)/, "");
      const submissionId = contextData.submissionId || "temp-evaluation";
      const allNodes = await prismaInstance.treeBranchLeafNode.findMany({
        select: { id: true, label: true }
      });
      const labelToNodeId = /* @__PURE__ */ new Map();
      for (const node of allNodes) {
        labelToNodeId.set(node.label.toLowerCase(), node.id);
      }
      const valueMap = /* @__PURE__ */ new Map();
      for (const [key2, value] of Object.entries(contextData)) {
        valueMap.set(key2, value);
        if (!key2.startsWith("@")) {
          valueMap.set(`@value.${key2}`, value);
        }
        const nodeId = labelToNodeId.get(key2.toLowerCase());
        if (nodeId) {
          valueMap.set(nodeId, value);
          valueMap.set(`@value.${nodeId}`, value);
        }
      }
      console.log(`\u{1F9EE} [TBL EVALUATE] Utilisation de operation-interpreter pour formule: ${formulaId}`);
      console.log(`   \u{1F4CA} ValueMap: ${valueMap.size} entr\xE9es`);
      const valuesCache = /* @__PURE__ */ new Map();
      const labelMap = /* @__PURE__ */ new Map();
      const result = await interpretFormula(
        formulaId,
        submissionId,
        prismaInstance,
        valuesCache,
        0,
        // depth
        valueMap,
        labelMap
      );
      trace.push({ step: "formula_interpret", info: `R\xE9sultat: ${result.result}`, success: true });
      return {
        payload: {
          success: true,
          type: "formula",
          capacity,
          value: result.result,
          humanText: result.humanText,
          details: result.details
        },
        trace
      };
    } catch (error) {
      console.error(`\u274C [TBL EVALUATE] Erreur interpretFormula:`, error);
      trace.push({ step: "formula_interpret", info: `Erreur: ${error instanceof Error ? error.message : "unknown"}`, success: false });
      const result = await evaluationEngine2.evaluate({
        element_code: variable.exposedKey,
        context_values: contextData,
        evaluation_mode: "auto",
        deep_resolution: true
      });
      if (result.success) {
        return { payload: { success: true, type: "formula", capacity, value: result.final_value, dependencies: result.dependencies_used, performance: result.performance }, trace };
      }
      return { payload: { success: false, type: "formula", capacity, error: "\xC9chec moteur", details: result.errors }, trace };
    }
  }
  if (capacity === "3") {
    try {
      const prismaInstance = db;
      const conditionId = sr.replace(/^condition:/, "");
      const submissionId = contextData.submissionId || "temp-evaluation";
      const allNodes = await prismaInstance.treeBranchLeafNode.findMany({
        select: { id: true, label: true }
      });
      const labelToNodeId = /* @__PURE__ */ new Map();
      const nodeIdToLabel = /* @__PURE__ */ new Map();
      for (const node of allNodes) {
        labelToNodeId.set(node.label.toLowerCase(), node.id);
        nodeIdToLabel.set(node.id, node.label);
      }
      const valueMap = /* @__PURE__ */ new Map();
      for (const [key2, value] of Object.entries(contextData)) {
        valueMap.set(key2, value);
        if (!key2.startsWith("@")) {
          valueMap.set(`@value.${key2}`, value);
        }
        const nodeId = labelToNodeId.get(key2.toLowerCase());
        if (nodeId) {
          valueMap.set(nodeId, value);
          valueMap.set(`@value.${nodeId}`, value);
          console.log(`   \u{1F517} Mapping label "${key2}" \u2192 nodeId "${nodeId}" = ${value}`);
        }
      }
      console.log(`\u2696\uFE0F [TBL EVALUATE] Utilisation de operation-interpreter pour condition: ${conditionId}`);
      console.log(`   \u{1F4CA} ValueMap: ${valueMap.size} entr\xE9es`);
      const valuesCache = /* @__PURE__ */ new Map();
      const labelMap = /* @__PURE__ */ new Map();
      const result = await interpretCondition(
        conditionId,
        submissionId,
        prismaInstance,
        valuesCache,
        0,
        // depth
        valueMap,
        labelMap
      );
      trace.push({ step: "condition_interpret", info: `R\xE9sultat: ${result.result}`, success: true });
      return {
        payload: {
          success: true,
          type: "condition",
          capacity,
          value: result.result,
          humanText: result.humanText,
          details: result.details
        },
        trace
      };
    } catch (error) {
      console.error(`\u274C [TBL EVALUATE] Erreur interpretCondition:`, error);
      trace.push({ step: "condition_interpret", info: `Erreur: ${error instanceof Error ? error.message : "unknown"}`, success: false });
      return { payload: { success: false, type: "condition", capacity, error: "\xC9chec \xE9valuation condition", details: error instanceof Error ? error.message : "unknown" }, trace };
    }
  }
  if (capacity === "4") {
    return { payload: { success: true, type: "table", capacity, status: "not_implemented", value: null }, trace };
  }
  return { payload: { success: true, type: "neutral", capacity, value: null }, trace };
}
router58.get("/_debug_list", (req2, res) => {
  logRouteHit("GET /api/tbl/_debug_list");
  return res.json({
    routes: [
      "POST /api/tbl/evaluate (minimal)",
      "POST /api/tbl/evaluate/formula/:tblCode (disabled)",
      "POST /api/tbl/condition (\u2705 ACTIVE avec CapacityCalculator)",
      "POST /api/tbl/evaluate/condition/:tblCode (\u2705 ACTIVE avec CapacityCalculator)",
      "POST /api/tbl/evaluate/table/:tblCode (disabled)",
      "GET /api/tbl/analyze/:tblCode (disabled)",
      "GET /api/tbl/status (disabled)"
    ],
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  });
});
router58.post("/evaluate/formula/:tblCode", async (req2, res) => {
  return res.status(503).json({ success: false, error: "Route d\xE9sactiv\xE9e pour d\xE9bogage." });
});
router58.post("/condition", async (req2, res) => {
  logRouteHit("POST /api/tbl/condition");
  try {
    const { elementId, contextData = {}, submissionId = "df833cac-0b44-4b2b-bb1c-de3878f00182" } = req2.body || {};
    if (!elementId) {
      return res.status(400).json({
        success: false,
        error: "elementId requis"
      });
    }
    console.log("\u{1F527} [TBL CONDITION] \xC9valuation avec CapacityCalculator:", elementId);
    const calculator = new CapacityCalculator();
    const context = {
      submissionId,
      organizationId: "test-org",
      userId: "test-user"
    };
    const result = await calculator.evaluateCondition(elementId, context);
    console.log("\u2705 [TBL CONDITION] R\xE9sultat CapacityCalculator:", result);
    return res.json({
      success: true,
      evaluation: result,
      elementId,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("\u274C [TBL CONDITION] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur interne",
      details: error instanceof Error ? error.message : "unknown"
    });
  }
});
router58.post("/evaluate/condition/:tblCode", async (req2, res) => {
  logRouteHit("POST /api/tbl/evaluate/condition/:tblCode");
  const { tblCode } = req2.params;
  const { submissionId = "df833cac-0b44-4b2b-bb1c-de3878f00182" } = req2.body || {};
  if (!tblCode) {
    return res.status(400).json({
      success: false,
      error: "tblCode requis"
    });
  }
  console.log("\u{1F527} [TBL EVALUATE CONDITION] \xC9valuation avec operation-interpreter:", tblCode);
  const prisma51 = db;
  try {
    const conditionRecord = await prisma51.treeBranchLeafNodeCondition.findUnique({
      where: { id: tblCode },
      select: { nodeId: true }
    });
    if (!conditionRecord?.nodeId) {
      return res.status(404).json({
        success: false,
        error: `Condition ${tblCode} introuvable`
      });
    }
    const result = await evaluateVariableOperation(
      conditionRecord.nodeId,
      submissionId || tblCode,
      prisma51
    );
    console.log("\u2705 [TBL EVALUATE CONDITION] R\xE9sultat operation-interpreter:", result);
    return res.json({
      success: true,
      evaluation: result,
      operationResult: result.operationResult,
      operationDetail: result.operationDetail,
      operationSource: result.operationSource,
      tblCode,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("\u274C [TBL EVALUATE CONDITION] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur interne",
      details: error instanceof Error ? error.message : "unknown"
    });
  }
});
router58.post("/evaluate/table/:tblCode", async (req2, res) => {
  return res.status(503).json({ success: false, error: "Route d\xE9sactiv\xE9e pour d\xE9bogage." });
});
router58.get("/analyze/:tblCode", async (req2, res) => {
  return res.status(503).json({ success: false, error: "Route d\xE9sactiv\xE9e pour d\xE9bogage." });
});
router58.get("/status", async (req2, res) => {
  return res.status(503).json({ success: false, error: "Route d\xE9sactiv\xE9e pour d\xE9bogage." });
});
router58.post("/update-database-results", async (req2, res) => {
  logRouteHit("POST /api/tbl/update-database-results");
  try {
    const { submissionId = "df833cac-0b44-4b2b-bb1c-de3878f00182" } = req2.body || {};
    console.log("\u{1F504} [TBL UPDATE] D\xE9but mise \xE0 jour base de donn\xE9es avec CapacityCalculator");
    const prisma51 = db;
    const submissionData = await prisma51.treeBranchLeafSubmissionData.findMany({
      where: {
        submissionId,
        operationSource: "condition"
        // Seulement les conditions (en minuscules)
      }
    });
    console.log(`\u{1F504} [TBL UPDATE] Trouv\xE9 ${submissionData.length} donn\xE9es de conditions \xE0 mettre \xE0 jour`);
    const calculator = new CapacityCalculator();
    const context = {
      submissionId,
      organizationId: "test-org",
      userId: "test-user"
    };
    let updated = 0;
    const errors = [];
    for (const data of submissionData) {
      try {
        const conditionId = data.sourceRef;
        if (!conditionId) {
          console.log(`\u26A0\uFE0F [TBL UPDATE] Pas de sourceRef pour ${data.id}, ignor\xE9`);
          continue;
        }
        const result = await calculator.evaluateCondition(conditionId, context);
        const newOperationResult = result.success ? {
          success: true,
          conditionId,
          result: result.result,
          evaluated: true,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          method: "CapacityCalculator"
        } : {
          success: false,
          conditionId,
          error: result.error,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          method: "CapacityCalculator"
        };
        await prisma51.treeBranchLeafSubmissionData.update({
          where: { id: data.id },
          data: {
            operationResult: newOperationResult
          }
        });
        updated++;
        console.log(`\u2705 [TBL UPDATE] Condition ${conditionId} mise \xE0 jour:`, newOperationResult);
      } catch (error) {
        errors.push({
          dataId: data.id,
          sourceRef: data.sourceRef,
          error: error instanceof Error ? error.message : "unknown"
        });
        console.error(`\u274C [TBL UPDATE] Erreur data ${data.id}:`, error);
      }
    }
    return res.json({
      success: true,
      updated,
      total: submissionData.length,
      errors,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("\u274C [TBL UPDATE] Erreur globale:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur interne",
      details: error instanceof Error ? error.message : "unknown"
    });
  }
});
router58.post("/check-submission-data", async (req2, res) => {
  logRouteHit("POST /api/tbl/check-submission-data");
  try {
    const { submissionId = "df833cac-0b44-4b2b-bb1c-de3878f00182" } = req2.body || {};
    const prisma51 = db;
    const allData = await prisma51.treeBranchLeafSubmissionData.findMany({
      where: { submissionId }
    });
    const grouped = allData.reduce((acc, item) => {
      const source = item.operationSource || "null";
      if (!acc[source]) acc[source] = [];
      acc[source].push({
        id: item.id,
        sourceRef: item.sourceRef,
        operationResult: item.operationResult
      });
      return acc;
    }, {});
    return res.json({
      success: true,
      submissionId,
      total: allData.length,
      bySource: grouped,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("\u274C [TBL CHECK] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur interne",
      details: error instanceof Error ? error.message : "unknown"
    });
  }
});
router58.post("/update-database-with-intelligent-translations", async (req2, res) => {
  logRouteHit("POST /api/tbl/update-database-with-intelligent-translations");
  try {
    const { submissionId = "df833cac-0b44-4b2b-bb1c-de3878f00182" } = req2.body || {};
    console.log("\u{1F9E0} [TBL INTELLIGENT UPDATE] D\xE9but mise \xE0 jour avec traductions intelligentes");
    const prisma51 = db;
    let TBLIntelligentTranslator;
    try {
      const translatorModule = await import("../../../../../../tbl-intelligent-translator.cjs");
      TBLIntelligentTranslator = translatorModule.default;
    } catch (error) {
      console.error("\u274C [TBL INTELLIGENT] Impossible de charger TBLIntelligentTranslator:", error);
      return res.status(500).json({
        success: false,
        error: "TBLIntelligentTranslator non disponible"
      });
    }
    const translator = new TBLIntelligentTranslator(prisma51);
    const submissionData = await prisma51.treeBranchLeafSubmissionData.findMany({
      where: {
        submissionId,
        operationSource: {
          in: ["condition", "formula", "table"]
        },
        operationDetail: {
          not: null
        }
      },
      include: {
        TreeBranchLeafNode: true
      }
    });
    console.log(`\u{1F9E0} [TBL INTELLIGENT UPDATE] Trouv\xE9 ${submissionData.length} donn\xE9es \xE0 traduire`);
    let updated = 0;
    const errors = [];
    for (const data of submissionData) {
      try {
        console.log(`\u{1F527} [TBL INTELLIGENT] Traduction: ${data.TreeBranchLeafNode?.label || "Sans nom"} (${data.operationSource})`);
        const intelligentResult = await translator.translateCapacity(
          data.operationSource,
          data.operationDetail,
          data.sourceRef || data.nodeId,
          data.submissionId
        );
        console.log(`\u2705 [TBL INTELLIGENT] Traduction g\xE9n\xE9r\xE9e: ${intelligentResult.substring(0, 100)}...`);
        await prisma51.treeBranchLeafSubmissionData.update({
          where: { id: data.id },
          data: {
            operationResult: intelligentResult,
            lastResolved: /* @__PURE__ */ new Date()
          }
        });
        updated++;
        console.log(`\u2705 [TBL INTELLIGENT] Mis \xE0 jour: ${data.id}`);
      } catch (error) {
        errors.push({
          dataId: data.id,
          nodeLabel: data.TreeBranchLeafNode?.label,
          error: error instanceof Error ? error.message : "unknown"
        });
        console.error(`\u274C [TBL INTELLIGENT] Erreur data ${data.id}:`, error);
      }
    }
    return res.json({
      success: true,
      message: "Traductions intelligentes appliqu\xE9es",
      updated,
      total: submissionData.length,
      errors,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("\u274C [TBL INTELLIGENT UPDATE] Erreur globale:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur interne",
      details: error instanceof Error ? error.message : "unknown"
    });
  }
});
router58.get("/check-intelligent-translations", async (req2, res) => {
  logRouteHit("GET /api/tbl/check-intelligent-translations");
  try {
    const { submissionId = "df833cac-0b44-4b2b-bb1c-de3878f00182" } = req2.query;
    const prisma51 = db;
    const recentData = await prisma51.treeBranchLeafSubmissionData.findMany({
      where: {
        submissionId,
        operationSource: {
          in: ["condition", "formula", "table"]
        },
        operationResult: {
          not: null
        }
      },
      include: {
        TreeBranchLeafNode: true
      },
      orderBy: {
        lastResolved: "desc"
      },
      take: 10
    });
    const translations = recentData.map((data) => ({
      id: data.id,
      nodeLabel: data.TreeBranchLeafNode?.label,
      operationSource: data.operationSource,
      operationResult: data.operationResult,
      lastResolved: data.lastResolved,
      isIntelligent: typeof data.operationResult === "string" && !data.operationResult.includes("\xC9valu\xE9 dynamiquement par TBL Prisma") && (data.operationResult.includes("Si ") || data.operationResult.includes("(/)") || data.operationResult.includes("Tableau"))
    }));
    return res.json({
      success: true,
      submissionId,
      total: recentData.length,
      translations,
      stats: {
        intelligent: translations.filter((t) => t.isIntelligent).length,
        old: translations.filter((t) => !t.isIntelligent).length
      },
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("\u274C [TBL CHECK INTELLIGENT] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur interne",
      details: error instanceof Error ? error.message : "unknown"
    });
  }
});
router58.get("/nodes/:nodeId", async (req2, res) => {
  logRouteHit("GET /api/tbl/nodes/:nodeId");
  try {
    const { nodeId } = req2.params;
    console.log("\u{1F504} [TBL NODES] R\xE9cup\xE9ration node via TBL:", nodeId);
    const prisma51 = db;
    const node = await prisma51.treeBranchLeafNode.findUnique({
      where: { id: nodeId }
    });
    if (!node) {
      return res.status(404).json({ success: false, error: "Node non trouv\xE9" });
    }
    return res.json(node);
  } catch (error) {
    console.error("\u274C [TBL NODES] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur interne",
      details: error instanceof Error ? error.message : "unknown"
    });
  }
});
router58.get("/reusables/conditions", async (req2, res) => {
  logRouteHit("GET /api/tbl/reusables/conditions");
  try {
    console.log("\u{1F504} [TBL CONDITIONS] R\xE9cup\xE9ration conditions via TBL");
    const prisma51 = db;
    const conditions = await prisma51.treeBranchLeafNodeCondition.findMany({
      include: {
        node: true
      }
    });
    return res.json({
      success: true,
      conditions,
      count: conditions.length
    });
  } catch (error) {
    console.error("\u274C [TBL CONDITIONS] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur interne",
      details: error instanceof Error ? error.message : "unknown"
    });
  }
});
router58.get("/reusables/formulas", async (req2, res) => {
  logRouteHit("GET /api/tbl/reusables/formulas");
  try {
    console.log("\u{1F504} [TBL FORMULAS] R\xE9cup\xE9ration formules via TBL");
    const prisma51 = db;
    const formulas = await prisma51.treeBranchLeafNodeFormula.findMany({
      include: {
        node: true
      }
    });
    return res.json({
      success: true,
      formulas,
      count: formulas.length
    });
  } catch (error) {
    console.error("\u274C [TBL FORMULAS] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur interne",
      details: error instanceof Error ? error.message : "unknown"
    });
  }
});
var tbl_intelligence_routes_default = router58;

// src/routes/tbl-capabilities.ts
var import_express60 = __toESM(require("express"), 1);
init_database();
var prisma33 = db;
var router59 = import_express60.default.Router();
function extractFormulaDependencies(tokens2) {
  const deps = [];
  for (const t of tokens2 || []) {
    if (!t) continue;
    if (typeof t === "object" && "type" in t && t.type === "ref" && typeof t.value === "string") {
      deps.push(t.value);
    } else if (typeof t === "string") {
      const m = t.match(/@value\.[0-9a-fA-F-]{36}/g);
      if (m) m.forEach((ref) => deps.push(ref.replace("@value.", "")));
    }
  }
  return Array.from(new Set(deps));
}
function extractConditionDependencies(conditionSet) {
  if (!conditionSet || typeof conditionSet !== "object") return [];
  const deps = /* @__PURE__ */ new Set();
  const scan = (obj) => {
    if (!obj || typeof obj !== "object") return;
    if (Array.isArray(obj)) {
      obj.forEach(scan);
      return;
    }
    const rec = obj;
    if (typeof rec.ref === "string") {
      const cleaned = rec.ref.startsWith("@value.") ? rec.ref.substring(7) : rec.ref;
      deps.add(cleaned);
    }
    for (const k of Object.keys(rec)) scan(rec[k]);
  };
  scan(conditionSet);
  return Array.from(deps);
}
async function resolveCapabilities(treeId, opts = {}) {
  const [variables, formulas, conditions, tables] = await Promise.all([
    prisma33.treeBranchLeafNodeVariable.findMany({
      where: { TreeBranchLeafNode: { treeId } },
      select: {
        id: true,
        nodeId: true,
        sourceRef: true,
        sourceType: true,
        exposedKey: true,
        displayName: true,
        fixedValue: true,
        selectedNodeId: true
      }
    }),
    prisma33.treeBranchLeafNodeFormula.findMany({
      where: { TreeBranchLeafNode: { treeId } },
      select: { id: true, nodeId: true, tokens: true, name: true }
    }),
    prisma33.treeBranchLeafNodeCondition.findMany({
      where: { TreeBranchLeafNode: { treeId } },
      select: { id: true, nodeId: true, conditionSet: true, name: true }
    }),
    prisma33.treeBranchLeafNodeTable.findMany({
      where: { TreeBranchLeafNode: { treeId } },
      select: { id: true, nodeId: true, type: true, name: true, meta: true }
    })
  ]);
  const formulaByNode = /* @__PURE__ */ new Map();
  formulas.forEach((f) => formulaByNode.set(f.nodeId, f));
  const conditionByNode = /* @__PURE__ */ new Map();
  conditions.forEach((c) => conditionByNode.set(c.nodeId, c));
  const tableByNode = /* @__PURE__ */ new Map();
  tables.forEach((t) => tableByNode.set(t.nodeId, t));
  const capabilities = [];
  for (const v of variables) {
    let capacity = "unknown";
    let deps = [];
    if (v.sourceRef) {
      if (v.sourceRef.startsWith("formula:") || v.sourceRef.startsWith("node-formula:")) capacity = "formula";
      else if (v.sourceRef.startsWith("condition:")) capacity = "condition";
      else if (v.sourceRef.startsWith("table:")) capacity = "table";
      else if (v.sourceType === "fixed" || v.fixedValue) capacity = "fixed";
      else capacity = "data";
    } else if (v.fixedValue) {
      capacity = "fixed";
    } else {
      if (formulaByNode.has(v.nodeId)) capacity = "formula";
      else if (conditionByNode.has(v.nodeId)) capacity = "condition";
      else if (tableByNode.has(v.nodeId)) capacity = "table";
      else capacity = "data";
    }
    const formula = formulaByNode.get(v.nodeId);
    const condition = conditionByNode.get(v.nodeId);
    const table = tableByNode.get(v.nodeId);
    if (opts.extractDependencies) {
      if (formula?.tokens) deps = extractFormulaDependencies(formula.tokens);
      else if (condition?.conditionSet) deps = extractConditionDependencies(condition.conditionSet);
    }
    const cap = {
      nodeId: v.nodeId,
      variableId: v.id,
      sourceRef: v.sourceRef,
      sourceType: v.sourceType,
      exposedKey: v.exposedKey,
      displayName: v.displayName,
      fixedValue: v.fixedValue,
      capacity,
      hasFormula: !!formula,
      hasCondition: !!condition,
      hasTable: !!table,
      dependencies: deps.length ? deps : void 0,
      raw: opts.includeRaw ? { variable: v, formula, condition, table } : void 0
    };
    capabilities.push(cap);
  }
  return capabilities;
}
router59.get("/capabilities", authenticateToken, async (req2, res) => {
  try {
    const treeId = String(req2.query.treeId || "");
    if (!treeId) {
      return res.status(400).json({ error: "treeId requis" });
    }
    const includeRaw = req2.query.raw === "1" || req2.query.raw === "true";
    const extractDeps = req2.query.deps === "1" || req2.query.deps === "true";
    const data = await resolveCapabilities(treeId, { includeRaw, extractDependencies: extractDeps });
    res.json({
      treeId,
      count: data.length,
      capabilities: data,
      meta: {
        extractedAt: (/* @__PURE__ */ new Date()).toISOString(),
        raw: includeRaw,
        deps: extractDeps,
        version: "v1"
      }
    });
  } catch (error) {
    const err = error;
    console.error("\u274C [TBL Capabilities] Erreur:", err);
    res.status(500).json({ error: "Erreur serveur capabilities", details: err.message });
  }
});
var tbl_capabilities_default = router59;

// src/routes/leadGeneration.ts
var import_express61 = require("express");
init_database();
var import_express_rate_limit6 = __toESM(require("express-rate-limit"), 1);
var router60 = (0, import_express61.Router)();
var prisma34 = db;
var leadGenRateLimit = (0, import_express_rate_limit6.default)({
  windowMs: 60 * 1e3,
  // 1 minute
  max: 50,
  // 50 requ√™tes par minute
  message: { success: false, message: "Trop de requ\xEAtes lead generation" }
});
router60.use(authMiddleware);
router60.use(leadGenRateLimit);
var getQueryString = (value) => {
  if (typeof value === "string") return value;
  if (Array.isArray(value)) {
    const firstString = value.find((item) => typeof item === "string");
    if (firstString) return firstString;
  }
  return void 0;
};
var buildOriginFilter = (origin) => {
  if (origin !== "d1m") return void 0;
  return {
    OR: [
      { NOT: { sourceId: null } },
      { source: { in: ["public-form", "d1m", "devis1minute", "landing"] } }
    ]
  };
};
router60.get("/campaigns", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({ success: false, message: "Organization ID manquant" });
    }
    const sources = await prisma34.leadSource.findMany({
      where: { organizationId },
      include: {
        _count: { select: { Lead: true } }
      },
      orderBy: { createdAt: "desc" }
    });
    const campaigns = await Promise.all(
      sources.map(async (s) => {
        const completedLeads = await prisma34.lead.count({
          where: { organizationId, sourceId: s.id, status: "completed" }
        });
        const leadsGenerated = s._count?.Lead ?? 0;
        const conversionRate = leadsGenerated > 0 ? Math.round(completedLeads / leadsGenerated * 100) : 0;
        return {
          id: s.id,
          name: s.name,
          description: s.description ?? "",
          category: "source",
          targetPostalCodes: [],
          budget: 0,
          spentBudget: 0,
          costPerLead: 0,
          status: s.isActive ? "active" : "paused",
          utmSource: "",
          utmMedium: "",
          utmCampaign: "",
          leadsGenerated,
          leadsPublished: 0,
          conversionRate,
          qualityScore: 0,
          createdAt: s.createdAt instanceof Date ? s.createdAt.toISOString() : (/* @__PURE__ */ new Date()).toISOString(),
          startDate: void 0,
          endDate: void 0,
          isAutomatic: false,
          targetAudience: [],
          landingPageUrl: void 0
        };
      })
    );
    res.json({ success: true, data: campaigns });
  } catch (error) {
    console.error("\u274C [LEAD-GEN] Erreur r\xE9cup\xE9ration campagnes (LeadSource):", error);
    res.status(500).json({ success: false, message: "Erreur lors de la r\xE9cup\xE9ration des campagnes" });
  }
});
router60.post("/campaigns", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const { name, description, isActive = true } = req2.body;
    if (!name) return res.status(400).json({ success: false, message: "Nom de campagne requis" });
    const created = await prisma34.leadSource.create({
      data: { organizationId, name, description, isActive: Boolean(isActive) }
    });
    res.json({ success: true, data: created, message: "Campagne cr\xE9\xE9e avec succ\xE8s" });
  } catch (error) {
    console.error("\u274C [LEAD-GEN] Erreur cr\xE9ation campagne (LeadSource):", error);
    res.status(500).json({ success: false, message: "Erreur lors de la cr\xE9ation de la campagne" });
  }
});
router60.get("/stats", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const monthStart = /* @__PURE__ */ new Date();
    monthStart.setDate(1);
    monthStart.setHours(0, 0, 0, 0);
    const originParam = getQueryString(req2.query.origin) ?? "d1m";
    const originWhere = buildOriginFilter(originParam);
    const [totalCampaigns, activeCampaigns, totalLeads, thisMonthLeads] = await Promise.all([
      prisma34.leadSource.count({ where: { organizationId } }),
      prisma34.leadSource.count({ where: { organizationId, isActive: true } }),
      prisma34.lead.count({ where: { organizationId, ...originWhere ?? {} } }),
      prisma34.lead.count({ where: { organizationId, createdAt: { gte: monthStart }, ...originWhere ?? {} } })
    ]);
    res.json({ success: true, data: { totalCampaigns, activeCampaigns, totalLeads, thisMonthLeads } });
  } catch (error) {
    console.error("\u274C [LEAD-GEN] Erreur stats (LeadSource/Lead):", error);
    res.status(500).json({ success: false, message: "Erreur lors de la r\xE9cup\xE9ration des statistiques" });
  }
});
router60.put("/campaigns/:id", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const existing = await prisma34.leadSource.findFirst({ where: { id, organizationId } });
    if (!existing) return res.status(404).json({ success: false, message: "Campagne non trouv\xE9e" });
    const { name, description, isActive } = req2.body;
    const updated = await prisma34.leadSource.update({ where: { id }, data: { name, description, isActive } });
    res.json({ success: true, data: updated, message: "Campagne modifi\xE9e avec succ\xE8s" });
  } catch (error) {
    console.error("\u274C [LEAD-GEN] Erreur modification campagne (LeadSource):", error);
    res.status(500).json({ success: false, message: "Erreur lors de la modification de la campagne" });
  }
});
router60.delete("/campaigns/:id", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const deleted = await prisma34.leadSource.deleteMany({ where: { id, organizationId } });
    if (deleted.count === 0) return res.status(404).json({ success: false, message: "Campagne non trouv\xE9e" });
    res.json({ success: true, message: "Campagne supprim\xE9e avec succ\xE8s" });
  } catch (error) {
    console.error("\u274C [LEAD-GEN] Erreur suppression campagne (LeadSource):", error);
    res.status(500).json({ success: false, message: "Erreur lors de la suppression de la campagne" });
  }
});
router60.patch("/campaigns/:id/status", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const { status } = req2.body;
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    if (!status) return res.status(400).json({ success: false, message: "Statut requis" });
    const target = await prisma34.leadSource.findFirst({ where: { id, organizationId } });
    if (!target) return res.status(404).json({ success: false, message: "Campagne non trouv\xE9e" });
    const updated = await prisma34.leadSource.update({ where: { id }, data: { isActive: status === "active" } });
    res.json({ success: true, data: updated, message: "Statut mis \xE0 jour" });
  } catch (error) {
    console.error("\u274C [LEAD-GEN] Erreur MAJ statut (LeadSource):", error);
    res.status(500).json({ success: false, message: "Erreur lors de la mise \xE0 jour du statut" });
  }
});
router60.post("/campaigns/:id/duplicate", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const source = await prisma34.leadSource.findFirst({ where: { id, organizationId } });
    if (!source) return res.status(404).json({ success: false, message: "Campagne non trouv\xE9e" });
    const copy = await prisma34.leadSource.create({
      data: {
        organizationId,
        name: `${source.name} (Copie)`,
        description: source.description,
        color: source.color,
        icon: source.icon,
        isActive: false
      }
    });
    res.json({ success: true, data: copy, message: "Campagne dupliqu\xE9e avec succ\xE8s" });
  } catch (error) {
    console.error("\u274C [LEAD-GEN] Erreur duplication campagne (LeadSource):", error);
    res.status(500).json({ success: false, message: "Erreur lors de la duplication de la campagne" });
  }
});
router60.get("/stats/timeseries", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const daysParam = getQueryString(req2.query.days);
    const requestedDays = Number.parseInt(daysParam ?? "30", 10);
    const days = Math.min(365, Math.max(1, Number.isNaN(requestedDays) ? 30 : requestedDays));
    const start = /* @__PURE__ */ new Date();
    start.setDate(start.getDate() - (days - 1));
    start.setHours(0, 0, 0, 0);
    const originParam = getQueryString(req2.query.origin) ?? "d1m";
    const originWhere = buildOriginFilter(originParam);
    const leads = await prisma34.lead.findMany({
      where: { organizationId, createdAt: { gte: start }, ...originWhere ?? {} },
      select: { createdAt: true, status: true }
    });
    const byDay = /* @__PURE__ */ new Map();
    for (let i = 0; i < days; i++) {
      const d = new Date(start.getTime());
      d.setDate(start.getDate() + i);
      const key2 = d.toISOString().slice(0, 10);
      byDay.set(key2, { created: 0, completed: 0 });
    }
    for (const lead of leads) {
      const key2 = lead.createdAt instanceof Date ? lead.createdAt.toISOString().slice(0, 10) : new Date(lead.createdAt).toISOString().slice(0, 10);
      const rec = byDay.get(key2);
      if (rec) {
        rec.created++;
        if (lead.status === "completed") rec.completed++;
      }
    }
    const series = Array.from(byDay.entries()).map(([date, v]) => ({ date, created: v.created, completed: v.completed }));
    res.json({ success: true, data: { start: start.toISOString(), days, series } });
  } catch (error) {
    console.error("\u274C [LEAD-GEN] Erreur timeseries:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la r\xE9cup\xE9ration des s\xE9ries temporelles" });
  }
});
var leadGeneration_default = router60;

// src/routes/marketplace-fixed.ts
var import_express62 = require("express");
init_prisma();
var import_express_rate_limit7 = __toESM(require("express-rate-limit"), 1);
var router61 = (0, import_express62.Router)();
var marketplaceRateLimit = (0, import_express_rate_limit7.default)({
  windowMs: 60 * 1e3,
  // 1 minute
  max: 100,
  // 100 requ√™tes par minute
  message: { success: false, message: "Trop de requ\xEAtes marketplace" }
});
router61.use(authMiddleware);
router61.use(marketplaceRateLimit);
router61.get("/leads", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "Organization ID manquant"
      });
    }
    const {
      status = "AVAILABLE",
      minPrice,
      maxPrice,
      targetSectors,
      targetRegions,
      limit = 50,
      offset = 0,
      availableOnly
    } = req2.query;
    const where = {};
    if (availableOnly === "true" || status) {
      where.status = status;
    }
    if (minPrice) {
      where.price = { ...where.price, gte: parseFloat(minPrice) };
    }
    if (maxPrice) {
      where.price = { ...where.price, lte: parseFloat(maxPrice) };
    }
    if (targetSectors) {
      where.targetSectors = { hasSome: [targetSectors] };
    }
    if (targetRegions) {
      where.targetRegions = { hasSome: [targetRegions] };
    }
    console.log("\u{1F50D} [MARKETPLACE] Requ\xEAte leads avec filtres:", where);
    const leads = await db.leadMarketplace.findMany({
      where,
      include: {
        Lead: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            phone: true,
            company: true,
            aiScore: true,
            createdAt: true,
            organizationId: true,
            data: true
          }
        },
        LeadPurchase: {
          select: {
            id: true,
            price: true,
            purchasedAt: true,
            partnerOrganizationId: true
          }
        }
      },
      orderBy: {
        publishedAt: "desc"
      },
      take: parseInt(limit),
      skip: parseInt(offset)
    });
    const total = await db.leadMarketplace.count({ where });
    const transformedLeads = leads.map((marketplace) => ({
      id: marketplace.id,
      leadId: marketplace.leadId,
      price: marketplace.price,
      exclusivePrice: marketplace.exclusivePrice,
      maxPartners: marketplace.maxPartners,
      currentPartners: marketplace.currentPartners,
      status: marketplace.status,
      targetSectors: marketplace.targetSectors,
      targetRegions: marketplace.targetRegions,
      minRating: marketplace.minRating,
      publishedAt: marketplace.publishedAt?.toISOString(),
      expiresAt: marketplace.expiresAt?.toISOString(),
      aiScore: marketplace.aiScore || 0,
      urgencyScore: marketplace.urgencyScore,
      qualityScore: marketplace.qualityScore,
      aiAnalysis: marketplace.aiAnalysis,
      createdAt: marketplace.createdAt.toISOString(),
      updatedAt: marketplace.updatedAt.toISOString(),
      lead: {
        id: marketplace.Lead.id,
        firstName: marketplace.Lead.firstName || "",
        lastName: marketplace.Lead.lastName || "",
        email: marketplace.Lead.email || "",
        phone: marketplace.Lead.phone || "",
        company: marketplace.Lead.company || ""
      },
      purchases: marketplace.LeadPurchase || []
    }));
    console.log(`\u2705 [MARKETPLACE] ${transformedLeads.length} leads trouv\xE9s`);
    res.json({
      success: true,
      data: {
        leads: transformedLeads,
        pagination: {
          total,
          limit: parseInt(limit),
          offset: parseInt(offset),
          hasMore: parseInt(offset) + parseInt(limit) < total
        }
      }
    });
  } catch (error) {
    console.error("\u274C [MARKETPLACE] Erreur r\xE9cup\xE9ration leads:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration des leads marketplace",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router61.get("/stats", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "Organization ID manquant"
      });
    }
    const [
      availableLeads,
      soldLeads,
      totalPurchases,
      myPublishedLeads
    ] = await Promise.all([
      db.leadMarketplace.count({
        where: { status: "AVAILABLE" }
      }),
      db.leadMarketplace.count({
        where: { status: "PURCHASED" }
      }),
      db.leadPurchase.count().catch(() => 0),
      // En cas d'erreur
      db.leadMarketplace.count({
        where: {
          Lead: {
            organizationId
          }
        }
      })
    ]);
    res.json({
      success: true,
      data: {
        totalLeads: availableLeads + soldLeads,
        availableLeads,
        avgPrice: 0,
        // TODO: calculer la moyenne des prix
        newToday: 0,
        // TODO: compter les leads d'aujourd'hui
        marketplace: {
          availableLeads,
          soldLeads
        },
        organization: {
          totalPurchases,
          myPublishedLeads,
          currentCredits: 0
          // TODO: syst√®me de cr√©dits si n√©cessaire
        }
      }
    });
  } catch (error) {
    console.error("\u274C [MARKETPLACE] Erreur stats:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration des statistiques",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router61.get("/saved-searches", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "Organization ID manquant"
      });
    }
    res.json({
      success: true,
      data: []
    });
  } catch (error) {
    console.error("\u274C [MARKETPLACE] Erreur recherches sauvegard\xE9es:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration des recherches sauvegard\xE9es",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router61.post("/purchase/:leadId", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { leadId } = req2.params;
    const organizationId = req2.user?.organizationId;
    const userId = req2.user?.userId || req2.user?.id;
    if (!organizationId || !userId) {
      return res.status(400).json({
        success: false,
        message: "Organization ID ou User ID manquant"
      });
    }
    const leadMarketplace = await db.leadMarketplace.findUnique({
      where: { leadId },
      include: { Lead: true }
    });
    if (!leadMarketplace || leadMarketplace.status !== "AVAILABLE") {
      return res.status(404).json({
        success: false,
        message: "Lead non disponible"
      });
    }
    res.json({
      success: true,
      message: "Fonctionnalit\xE9 d'achat en cours d'impl\xE9mentation",
      data: {
        leadId,
        price: leadMarketplace.price,
        status: "simulation"
      }
    });
  } catch (error) {
    console.error("\u274C [MARKETPLACE] Erreur achat lead:", error);
    res.status(500).json({
      success: false,
      message: error instanceof Error ? error.message : "Erreur lors de l'achat du lead",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
var marketplace_fixed_default = router61;

// src/routes/partner.ts
var import_express63 = require("express");
init_database();
var import_express_rate_limit8 = __toESM(require("express-rate-limit"), 1);
var router62 = (0, import_express63.Router)();
var prisma35 = db;
var partnerRateLimit = (0, import_express_rate_limit8.default)({
  windowMs: 60 * 1e3,
  // 1 minute
  max: 30,
  // 30 requ√™tes par minute
  message: { success: false, message: "Trop de requ\xEAtes partner portal" }
});
router62.use(authMiddleware);
router62.use(partnerRateLimit);
router62.get("/dashboard", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "Organization ID manquant"
      });
    }
    const partnerOrg = await prisma35.partnerOrganization.findUnique({
      where: { organizationId },
      include: {
        organization: {
          select: {
            name: true,
            credits: true
          }
        }
      }
    });
    if (!partnerOrg) {
      return res.status(403).json({
        success: false,
        message: "Acc\xE8s partenaire non autoris\xE9"
      });
    }
    const startOfMonth = new Date((/* @__PURE__ */ new Date()).getFullYear(), (/* @__PURE__ */ new Date()).getMonth(), 1);
    const [
      totalLeadsGenerated,
      monthlyLeadsGenerated,
      totalRevenue,
      monthlyRevenue,
      activeCampaigns
    ] = await Promise.all([
      prisma35.lead.count({
        where: { organizationId }
      }),
      prisma35.lead.count({
        where: {
          organizationId,
          createdAt: { gte: startOfMonth }
        }
      }),
      prisma35.creditTransaction.aggregate({
        where: {
          organizationId,
          type: "SALE"
        },
        _sum: { amount: true }
      }),
      prisma35.creditTransaction.aggregate({
        where: {
          organizationId,
          type: "SALE",
          createdAt: { gte: startOfMonth }
        },
        _sum: { amount: true }
      }),
      prisma35.campaign.count({
        where: {
          organizationId,
          status: "ACTIVE"
        }
      })
    ]);
    res.json({
      success: true,
      data: {
        partner: partnerOrg,
        stats: {
          totalLeadsGenerated,
          monthlyLeadsGenerated,
          totalRevenue: totalRevenue._sum.amount || 0,
          monthlyRevenue: monthlyRevenue._sum.amount || 0,
          activeCampaigns,
          currentCredits: partnerOrg.organization.credits || 0
        }
      }
    });
  } catch (error) {
    console.error("\u274C [PARTNER] Erreur dashboard:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration du dashboard partenaire"
    });
  }
});
router62.get("/earnings", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "Organization ID manquant"
      });
    }
    const { period = "30", offset = 0, limit = 50 } = req2.query;
    const startDate = /* @__PURE__ */ new Date();
    startDate.setDate(startDate.getDate() - parseInt(period));
    const earnings = await prisma35.creditTransaction.findMany({
      where: {
        organizationId,
        type: "SALE",
        createdAt: { gte: startDate }
      },
      include: {
        relatedLead: {
          select: {
            firstName: true,
            lastName: true,
            company: true,
            marketplacePrice: true
          }
        }
      },
      orderBy: {
        createdAt: "desc"
      },
      take: parseInt(limit),
      skip: parseInt(offset)
    });
    const totalEarnings = await prisma35.creditTransaction.aggregate({
      where: {
        organizationId,
        type: "SALE",
        createdAt: { gte: startDate }
      },
      _sum: { amount: true },
      _count: true
    });
    res.json({
      success: true,
      data: {
        earnings,
        summary: {
          totalAmount: totalEarnings._sum.amount || 0,
          totalTransactions: totalEarnings._count,
          period: parseInt(period)
        }
      }
    });
  } catch (error) {
    console.error("\u274C [PARTNER] Erreur earnings:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration des revenus"
    });
  }
});
router62.get("/leads", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "Organization ID manquant"
      });
    }
    const {
      status,
      marketplaceOnly = false,
      offset = 0,
      limit = 50
    } = req2.query;
    const where = { organizationId };
    if (status) {
      where.status = status;
    }
    if (marketplaceOnly === "true") {
      where.LeadMarketplace = {
        isNot: null
      };
    }
    const leads = await prisma35.lead.findMany({
      where,
      include: {
        campaign: {
          select: {
            name: true,
            type: true
          }
        },
        LeadMarketplace: {
          select: {
            marketplacePrice: true,
            marketplaceVisible: true,
            status: true,
            soldAt: true
          }
        },
        aiRecommendations: {
          select: {
            score: true,
            recommendation: true
          },
          orderBy: {
            createdAt: "desc"
          },
          take: 1
        }
      },
      orderBy: {
        createdAt: "desc"
      },
      take: parseInt(limit),
      skip: parseInt(offset)
    });
    const total = await prisma35.lead.count({ where });
    res.json({
      success: true,
      data: {
        leads,
        pagination: {
          total,
          limit: parseInt(limit),
          offset: parseInt(offset),
          hasMore: parseInt(offset) + parseInt(limit) < total
        }
      }
    });
  } catch (error) {
    console.error("\u274C [PARTNER] Erreur r\xE9cup\xE9ration leads:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration des leads partenaire"
    });
  }
});
router62.post("/register", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "Organization ID manquant"
      });
    }
    const {
      contactPerson,
      contactEmail,
      contactPhone,
      website,
      description,
      specialties = [],
      commissionRate = 10
    } = req2.body;
    if (!contactPerson || !contactEmail) {
      return res.status(400).json({
        success: false,
        message: "Personne de contact et email requis"
      });
    }
    const existingPartner = await prisma35.partnerOrganization.findUnique({
      where: { organizationId }
    });
    if (existingPartner) {
      return res.status(400).json({
        success: false,
        message: "Organisation d\xE9j\xE0 enregistr\xE9e comme partenaire"
      });
    }
    const partnerOrg = await prisma35.partnerOrganization.create({
      data: {
        organizationId,
        partnerType: "LEAD_GENERATOR",
        status: "PENDING",
        contactPerson,
        contactEmail,
        contactPhone,
        website,
        description,
        specialties,
        commissionRate: parseFloat(commissionRate.toString())
      },
      include: {
        organization: {
          select: {
            name: true
          }
        }
      }
    });
    res.json({
      success: true,
      data: partnerOrg,
      message: "Demande de partenariat enregistr\xE9e avec succ\xE8s"
    });
  } catch (error) {
    console.error("\u274C [PARTNER] Erreur enregistrement:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de l'enregistrement du partenariat"
    });
  }
});
var partner_default = router62;

// src/routes/publicForms.ts
var import_express64 = require("express");
var import_express_rate_limit9 = __toESM(require("express-rate-limit"), 1);
var import_zod8 = require("zod");
init_prisma();
console.log("[PUBLIC-FORMS-DEBUG] prisma import\xE9:", typeof db, db ? "\u2705 OK" : "\u274C UNDEFINED");
var router63 = (0, import_express64.Router)();
var submissionRateLimit = (0, import_express_rate_limit9.default)({
  windowMs: 5 * 60 * 1e3,
  max: 10,
  message: { success: false, message: "Trop de soumissions de formulaires" }
});
var adminRateLimit = (0, import_express_rate_limit9.default)({
  windowMs: 60 * 1e3,
  max: 100,
  message: { success: false, message: "Trop de requetes formulaires" }
});
var rawBaseUrl = process.env.PUBLIC_FORMS_BASE_URL || process.env.PUBLIC_SITE_URL || process.env.FRONTEND_BASE_URL || "https://devis1minute.be";
var PUBLIC_FORMS_BASE_URL = rawBaseUrl.replace(/\/$/, "");
var DEFAULT_EMBED_HEIGHT = Number.parseInt(process.env.PUBLIC_FORM_EMBED_HEIGHT ?? "", 10) || 520;
var slugify = (value) => value.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-zA-Z0-9\s-]/g, "").trim().replace(/\s+/g, "-").replace(/-+/g, "-").toLowerCase();
var generateFallbackSlug = () => `form-${Math.random().toString(36).slice(2, 8)}`;
var ensureUniqueSlug = async (organizationId, base, excludeFormId) => {
  const sanitized2 = base || generateFallbackSlug();
  let slug = sanitized2;
  let counter = 1;
  const maxAttempts = 100;
  while (counter <= maxAttempts) {
    const allWithSlug = await db.publicForm.findMany({
      where: {
        organizationId,
        slug,
        id: excludeFormId ? { not: excludeFormId } : void 0
      },
      select: { id: true, deletedAt: true }
    });
    if (allWithSlug.length === 0) {
      console.log("[ensureUniqueSlug] \u2705 Slug disponible:", slug);
      return slug;
    }
    const activeOnes = allWithSlug.filter((f) => f.deletedAt === null);
    const deletedOnes = allWithSlug.filter((f) => f.deletedAt !== null);
    if (activeOnes.length === 0 && deletedOnes.length > 0) {
      console.log(`[ensureUniqueSlug] \u{1F5D1}\uFE0F Suppression d\xE9finitive de ${deletedOnes.length} formulaire(s) supprim\xE9(s) avec le slug "${slug}"`);
      await db.publicForm.deleteMany({
        where: {
          id: { in: deletedOnes.map((f) => f.id) }
        }
      });
      console.log("[ensureUniqueSlug] \u2705 Slug lib\xE9r\xE9:", slug);
      return slug;
    }
    if (activeOnes.length > 0) {
      console.log("[ensureUniqueSlug] \u26A0\uFE0F Slug d\xE9j\xE0 utilis\xE9 par un formulaire actif:", slug);
      slug = `${sanitized2}-${counter++}`;
    }
  }
  const timestamp = Date.now();
  const timestampedSlug = `${sanitized2}-${timestamp}`;
  console.log("[ensureUniqueSlug] \u{1F504} Utilisation du slug avec timestamp:", timestampedSlug);
  return timestampedSlug;
};
var toPublicUrl = (slug) => `${PUBLIC_FORMS_BASE_URL}/forms/${slug}`;
var buildEmbedCode = (slug) => {
  const url = toPublicUrl(slug);
  return `<iframe src="${url}" title="Formulaire ${slug}" style="width:100%;max-width:600px;height:${DEFAULT_EMBED_HEIGHT}px;border:0;border-radius:12px;" loading="lazy" referrerpolicy="no-referrer-when-downgrade"></iframe>`;
};
var mapFormToResponse = (form) => {
  const rawFields = Array.isArray(form.fields) ? form.fields : [];
  return {
    id: form.id,
    name: form.name,
    description: form.description ?? void 0,
    category: form.category ?? "contact",
    slug: form.slug,
    publicUrl: toPublicUrl(form.slug),
    embedCode: buildEmbedCode(form.slug),
    isActive: form.isActive && form.deletedAt === null,
    collectsRgpdConsent: form.collectsRgpdConsent,
    autoPublishLeads: form.autoPublishLeads,
    requiresCommercialTracking: form.requiresCommercialTracking ?? false,
    maxSubmissionsPerDay: form.maxSubmissionsPerDay ?? void 0,
    customCss: form.customCss ?? void 0,
    thankYouMessage: form.thankYouMessage,
    redirectUrl: form.redirectUrl ?? void 0,
    submissionCount: form.submissionCount ?? 0,
    conversionRate: Number(form.conversionRate ?? 0),
    lastSubmission: form.lastSubmissionAt ? form.lastSubmissionAt.toISOString() : void 0,
    createdAt: form.createdAt.toISOString(),
    updatedAt: form.updatedAt.toISOString(),
    fields: rawFields,
    campaigns: form.campaigns ?? []
  };
};
var mapSubmissionToResponse = (submission) => ({
  id: submission.id,
  formId: submission.formId,
  submittedAt: submission.createdAt.toISOString(),
  ipAddress: submission.ipAddress ?? "",
  userAgent: submission.userAgent ?? "",
  leadId: submission.leadId ?? void 0,
  data: submission.data ?? {},
  status: submission.status ?? "new"
});
var optionalPositiveInt = import_zod8.z.preprocess((value) => {
  if (value === null || value === void 0 || value === "") {
    return void 0;
  }
  if (typeof value === "string") {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : value;
  }
  return value;
}, import_zod8.z.number().int().positive().optional());
var formFieldSchema = import_zod8.z.object({
  id: import_zod8.z.union([import_zod8.z.string(), import_zod8.z.number()]).optional(),
  name: import_zod8.z.string().optional(),
  label: import_zod8.z.string().optional(),
  type: import_zod8.z.string().optional(),
  required: import_zod8.z.boolean().optional(),
  placeholder: import_zod8.z.string().optional(),
  options: import_zod8.z.array(import_zod8.z.string()).optional(),
  order: import_zod8.z.number().int().optional()
}).passthrough();
var baseFormSchema = import_zod8.z.object({
  name: import_zod8.z.string().min(1, "Nom requis"),
  description: import_zod8.z.string().max(1e3).optional(),
  category: import_zod8.z.string().max(120).optional(),
  slug: import_zod8.z.string().max(160).optional(),
  fields: import_zod8.z.array(formFieldSchema).default([]),
  thankYouMessage: import_zod8.z.string().min(1).max(1e3).optional(),
  redirectUrl: import_zod8.z.string().max(500).optional(),
  collectsRgpdConsent: import_zod8.z.boolean().optional(),
  autoPublishLeads: import_zod8.z.boolean().optional(),
  requiresCommercialTracking: import_zod8.z.boolean().optional(),
  maxSubmissionsPerDay: optionalPositiveInt,
  customCss: import_zod8.z.string().optional(),
  campaigns: import_zod8.z.array(import_zod8.z.string().min(1)).optional(),
  isActive: import_zod8.z.boolean().optional(),
  isPublic: import_zod8.z.boolean().optional()
});
var createFormSchema = baseFormSchema;
var updateFormSchema = baseFormSchema.partial();
var toggleSchema = import_zod8.z.object({ isActive: import_zod8.z.boolean() });
var generateUserSlug = async (firstName, lastName, organizationId) => {
  const slugify2 = (text) => {
    return text.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
  };
  const baseSlug = `${slugify2(firstName)}-${slugify2(lastName)}`;
  const existingUsers = await db.user.findMany({
    where: {
      organizationId,
      OR: [
        { firstName, lastName },
        // Chercher aussi les variantes avec suffixe
        {
          firstName: { startsWith: firstName },
          lastName: { startsWith: lastName }
        }
      ]
    }
  });
  if (existingUsers.length === 0 || existingUsers.length === 1) {
    return baseSlug;
  }
  let counter = 2;
  let slug = `${baseSlug}-${counter}`;
  while (counter < 100) {
    const exists = existingUsers.some((u) => {
      const userSlug = `${slugify2(u.firstName)}-${slugify2(u.lastName)}`;
      return userSlug === slug;
    });
    if (!exists) break;
    counter++;
    slug = `${baseSlug}-${counter}`;
  }
  return slug;
};
var submissionSchema = import_zod8.z.object({
  formId: import_zod8.z.string().min(1),
  privacyConsent: import_zod8.z.boolean(),
  marketingConsent: import_zod8.z.boolean().optional()
}).passthrough();
var normalizeFormPayload = (payload) => {
  if (!payload || typeof payload !== "object") {
    return {};
  }
  const data = { ...payload };
  if (!data.name && typeof data.title === "string") {
    data.name = data.title;
  }
  if (!data.thankYouMessage && typeof data.submissionMessage === "string") {
    data.thankYouMessage = data.submissionMessage;
  }
  if (!data.fields && Array.isArray(data.formFields)) {
    data.fields = data.formFields;
  }
  if (data.maxSubmissionsPerDay === "") {
    data.maxSubmissionsPerDay = void 0;
  }
  return data;
};
var resolveOrganizationId = (req2, res) => {
  const organizationId = req2.user?.organizationId;
  if (!organizationId) {
    res.status(400).json({ success: false, message: "Organization ID manquant" });
    return null;
  }
  return organizationId;
};
var listFormsHandler = async (req2, res) => {
  const organizationId = resolveOrganizationId(req2, res);
  if (!organizationId) {
    return;
  }
  try {
    const forms = await db.publicForm.findMany({
      where: { organizationId, deletedAt: null },
      orderBy: { createdAt: "desc" }
    });
    res.json(forms.map(mapFormToResponse));
  } catch (error) {
    console.error("[PUBLIC-FORMS] Liste impossible:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la recuperation des formulaires" });
  }
};
var statsHandler = async (req2, res) => {
  const organizationId = resolveOrganizationId(req2, res);
  if (!organizationId) {
    return;
  }
  try {
    const startOfDay = /* @__PURE__ */ new Date();
    startOfDay.setHours(0, 0, 0, 0);
    const [forms, totalSubmissions, todaySubmissions] = await db.$transaction([
      db.publicForm.findMany({
        where: { organizationId, deletedAt: null },
        select: { id: true, name: true, submissionCount: true, conversionRate: true, isActive: true }
      }),
      db.publicFormSubmission.count({ where: { organizationId } }),
      db.publicFormSubmission.count({
        where: { organizationId, createdAt: { gte: startOfDay } }
      })
    ]);
    const totalForms = forms.length;
    const activeForms = forms.filter((form) => form.isActive).length;
    const conversionRate = totalForms > 0 ? Number(
      (forms.reduce((sum, form) => sum + Number(form.conversionRate ?? 0), 0) / totalForms).toFixed(2)
    ) : 0;
    const topForm = forms.reduce((best, current) => {
      if (!best || current.submissionCount > best.submissionCount) {
        return current;
      }
      return best;
    }, null);
    res.json({
      totalForms,
      activeForms,
      totalSubmissions,
      todaySubmissions,
      conversionRate,
      topPerformingForm: topForm?.name ?? ""
    });
  } catch (error) {
    console.error("[PUBLIC-FORMS] Statistiques impossibles:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la recuperation des statistiques" });
  }
};
var submissionsHandler = async (req2, res) => {
  const organizationId = resolveOrganizationId(req2, res);
  if (!organizationId) {
    return;
  }
  const { formId } = req2.params;
  try {
    const form = await db.publicForm.findFirst({
      where: { id: formId, organizationId, deletedAt: null }
    });
    if (!form) {
      res.status(404).json({ success: false, message: "Formulaire introuvable" });
      return;
    }
    const submissions = await db.publicFormSubmission.findMany({
      where: { formId: form.id, organizationId },
      orderBy: { createdAt: "desc" },
      take: 100
    });
    res.json(submissions.map(mapSubmissionToResponse));
  } catch (error) {
    console.error("[PUBLIC-FORMS] Soumissions impossibles:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la recuperation des soumissions" });
  }
};
var createFormHandler = async (req2, res) => {
  const organizationId = resolveOrganizationId(req2, res);
  if (!organizationId) {
    return;
  }
  const normalized = normalizeFormPayload(req2.body);
  const parsed = createFormSchema.safeParse(normalized);
  if (!parsed.success) {
    res.status(400).json({ success: false, message: "Donnees invalides", issues: parsed.error.flatten() });
    return;
  }
  try {
    const payload = parsed.data;
    const baseSlug = slugify(payload.slug ?? payload.name);
    const slug = await ensureUniqueSlug(organizationId, baseSlug);
    const created = await db.publicForm.create({
      data: {
        organizationId,
        name: payload.name.trim(),
        description: payload.description?.trim() || null,
        category: (payload.category ?? "contact").toLowerCase(),
        slug,
        fields: payload.fields,
        thankYouMessage: payload.thankYouMessage ?? "Merci pour votre soumission !",
        redirectUrl: payload.redirectUrl?.trim() || null,
        collectsRgpdConsent: payload.collectsRgpdConsent ?? true,
        autoPublishLeads: payload.autoPublishLeads ?? false,
        requiresCommercialTracking: payload.requiresCommercialTracking ?? false,
        maxSubmissionsPerDay: payload.maxSubmissionsPerDay ?? null,
        customCss: payload.customCss ?? null,
        campaigns: payload.campaigns ?? [],
        isActive: payload.isActive ?? true,
        isPublic: payload.isPublic ?? true,
        submissionCount: 0,
        conversionRate: 0
      }
    });
    res.status(201).json(mapFormToResponse(created));
  } catch (error) {
    console.error("[PUBLIC-FORMS] Creation impossible:", error);
    if (error instanceof Error && "code" in error && error.code === "P2002") {
      res.status(409).json({
        success: false,
        message: "Un formulaire avec ce nom existe d\xE9j\xE0. Veuillez choisir un autre nom."
      });
      return;
    }
    res.status(500).json({ success: false, message: "Erreur lors de la cr\xE9ation du formulaire" });
  }
};
var updateFormHandler = async (req2, res) => {
  const organizationId = resolveOrganizationId(req2, res);
  if (!organizationId) {
    return;
  }
  const { formId } = req2.params;
  const normalized = normalizeFormPayload(req2.body);
  const parsed = updateFormSchema.safeParse(normalized);
  if (!parsed.success) {
    res.status(400).json({ success: false, message: "Donnees invalides", issues: parsed.error.flatten() });
    return;
  }
  try {
    const form = await db.publicForm.findFirst({
      where: { id: formId, organizationId, deletedAt: null }
    });
    if (!form) {
      res.status(404).json({ success: false, message: "Formulaire introuvable" });
      return;
    }
    const payload = parsed.data;
    let nextSlug = form.slug;
    if (payload.slug || payload.name) {
      const baseSlug = slugify(payload.slug ?? payload.name ?? form.name);
      nextSlug = await ensureUniqueSlug(organizationId, baseSlug, form.id);
    }
    const data = {};
    if (payload.name !== void 0) data.name = payload.name.trim();
    if (payload.description !== void 0) data.description = payload.description?.trim() || null;
    if (payload.category !== void 0) data.category = payload.category;
    if (payload.fields !== void 0) data.fields = payload.fields;
    if (payload.thankYouMessage !== void 0) data.thankYouMessage = payload.thankYouMessage;
    if (payload.redirectUrl !== void 0) data.redirectUrl = payload.redirectUrl?.trim() || null;
    if (payload.collectsRgpdConsent !== void 0) data.collectsRgpdConsent = payload.collectsRgpdConsent;
    if (payload.autoPublishLeads !== void 0) data.autoPublishLeads = payload.autoPublishLeads;
    if (payload.requiresCommercialTracking !== void 0) data.requiresCommercialTracking = payload.requiresCommercialTracking;
    if (payload.maxSubmissionsPerDay !== void 0) data.maxSubmissionsPerDay = payload.maxSubmissionsPerDay ?? null;
    if (payload.customCss !== void 0) data.customCss = payload.customCss ?? null;
    if (payload.campaigns !== void 0) data.campaigns = payload.campaigns;
    if (payload.isActive !== void 0) data.isActive = payload.isActive;
    if (nextSlug !== form.slug) data.slug = nextSlug;
    const updated = await db.publicForm.update({
      where: { id: form.id },
      data
    });
    res.json(mapFormToResponse(updated));
  } catch (error) {
    console.error("[PUBLIC-FORMS] Mise \xE0 jour impossible:", error);
    if (error instanceof Error && "code" in error && error.code === "P2002") {
      res.status(409).json({
        success: false,
        message: "Un formulaire avec ce nom existe d\xE9j\xE0. Veuillez choisir un autre nom."
      });
      return;
    }
    res.status(500).json({ success: false, message: "Erreur lors de la mise \xE0 jour du formulaire" });
  }
};
var toggleFormHandler = async (req2, res) => {
  const organizationId = resolveOrganizationId(req2, res);
  if (!organizationId) {
    return;
  }
  const { formId } = req2.params;
  const parsed = toggleSchema.safeParse(req2.body);
  if (!parsed.success) {
    res.status(400).json({ success: false, message: "Donnees invalides", issues: parsed.error.flatten() });
    return;
  }
  try {
    const form = await db.publicForm.findFirst({
      where: { id: formId, organizationId, deletedAt: null }
    });
    if (!form) {
      res.status(404).json({ success: false, message: "Formulaire introuvable" });
      return;
    }
    const updated = await db.publicForm.update({
      where: { id: form.id },
      data: { isActive: parsed.data.isActive }
    });
    res.json(mapFormToResponse(updated));
  } catch (error) {
    console.error("[PUBLIC-FORMS] Toggle impossible:", error);
    res.status(500).json({ success: false, message: "Erreur lors du changement de statut du formulaire" });
  }
};
var deleteFormHandler = async (req2, res) => {
  const organizationId = resolveOrganizationId(req2, res);
  if (!organizationId) {
    return;
  }
  const { formId } = req2.params;
  try {
    const form = await db.publicForm.findFirst({
      where: { id: formId, organizationId, deletedAt: null }
    });
    if (!form) {
      res.status(404).json({ success: false, message: "Formulaire introuvable" });
      return;
    }
    const deletedSlug = `${form.slug}-deleted-${Date.now()}`;
    await db.publicForm.update({
      where: { id: form.id },
      data: {
        deletedAt: /* @__PURE__ */ new Date(),
        isActive: false,
        slug: deletedSlug
        // Lib√®re le slug original pour r√©utilisation
      }
    });
    res.json({ success: true });
  } catch (error) {
    console.error("[PUBLIC-FORMS] Suppression impossible:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la suppression du formulaire" });
  }
};
router63.get(
  "/",
  authMiddleware,
  requireRole2(["admin", "super_admin"]),
  adminRateLimit,
  listFormsHandler
);
router63.get(
  "/stats",
  authMiddleware,
  requireRole2(["admin", "super_admin"]),
  adminRateLimit,
  statsHandler
);
router63.get(
  "/:formId/submissions",
  authMiddleware,
  requireRole2(["admin", "super_admin"]),
  adminRateLimit,
  submissionsHandler
);
router63.get(
  "/:formId",
  authMiddleware,
  requireRole2(["admin", "super_admin"]),
  adminRateLimit,
  async (req2, res) => {
    try {
      const { formId } = req2.params;
      const user = req2.user;
      const form = await db.publicForm.findFirst({
        where: {
          id: formId,
          deletedAt: null,
          ...user.isSuperAdmin ? {} : { organizationId: user.organizationId }
        }
      });
      if (!form) {
        return res.status(404).json({ success: false, message: "Formulaire introuvable" });
      }
      res.json(form);
    } catch (error) {
      console.error("[PUBLIC-FORMS] Erreur r\xE9cup\xE9ration formulaire:", error);
      res.status(500).json({ success: false, message: "Erreur lors de la r\xE9cup\xE9ration du formulaire" });
    }
  }
);
router63.post(
  "/",
  authMiddleware,
  requireRole2(["admin", "super_admin"]),
  adminRateLimit,
  createFormHandler
);
router63.put(
  "/:formId",
  authMiddleware,
  requireRole2(["admin", "super_admin"]),
  adminRateLimit,
  updateFormHandler
);
router63.patch(
  "/:formId/toggle",
  authMiddleware,
  requireRole2(["admin", "super_admin"]),
  adminRateLimit,
  toggleFormHandler
);
router63.delete(
  "/:formId",
  authMiddleware,
  requireRole2(["admin", "super_admin"]),
  adminRateLimit,
  deleteFormHandler
);
var adminRouter = (0, import_express64.Router)();
adminRouter.get("/list", listFormsHandler);
adminRouter.get("/stats", statsHandler);
adminRouter.get("/:formId/submissions", submissionsHandler);
adminRouter.post("/create", createFormHandler);
adminRouter.put("/:formId", updateFormHandler);
adminRouter.patch("/:formId/toggle", toggleFormHandler);
adminRouter.post("/:formId/toggle", toggleFormHandler);
adminRouter.delete("/:formId", deleteFormHandler);
router63.use(
  "/admin",
  authMiddleware,
  requireRole2(["admin", "super_admin"]),
  adminRateLimit,
  adminRouter
);
router63.get("/my-commercial-links", authMiddleware, async (req2, res) => {
  const userId = req2.user?.id;
  const organizationId = req2.user?.organizationId;
  if (!userId || !organizationId) {
    res.status(401).json({ success: false, message: "Non authentifi\xE9" });
    return;
  }
  try {
    const user = await db.user.findUnique({
      where: { id: userId },
      select: { firstName: true, lastName: true }
    });
    if (!user) {
      res.status(404).json({ success: false, message: "Utilisateur introuvable" });
      return;
    }
    const userSlug = await generateUserSlug(user.firstName, user.lastName, organizationId);
    const forms = await db.publicForm.findMany({
      where: {
        organizationId,
        requiresCommercialTracking: true,
        deletedAt: null
      },
      select: {
        id: true,
        name: true,
        description: true,
        slug: true,
        isActive: true,
        submissionCount: true
      },
      orderBy: { createdAt: "desc" }
    });
    res.json({
      success: true,
      userSlug,
      forms
    });
  } catch (error) {
    console.error("[PUBLIC-FORMS] Erreur r\xE9cup\xE9ration liens commerciaux:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la r\xE9cup\xE9ration" });
  }
});
router63.get("/public/:identifier/config", async (req2, res) => {
  try {
    const { identifier } = req2.params;
    const form = await db.publicForm.findFirst({
      where: {
        deletedAt: null,
        isActive: true,
        isPublic: true,
        OR: [{ id: identifier }, { slug: identifier }]
      }
    });
    if (!form) {
      res.status(404).json({ success: false, message: "Formulaire introuvable" });
      return;
    }
    const fields = Array.isArray(form.fields) ? form.fields : [];
    res.json({
      success: true,
      data: {
        id: form.id,
        title: form.name,
        name: form.name,
        description: form.description,
        fields,
        styling: {
          submitLabel: "Envoyer",
          customCss: form.customCss ?? void 0,
          redirectUrl: form.redirectUrl ?? void 0
        },
        submissionMessage: form.thankYouMessage
      }
    });
  } catch (error) {
    console.error("[PUBLIC-FORMS] Config publique impossible:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la recuperation de la configuration du formulaire" });
  }
});
router63.post("/submit", submissionRateLimit, async (req2, res) => {
  const parsed = submissionSchema.safeParse(req2.body);
  if (!parsed.success) {
    res.status(400).json({ success: false, message: "Donnees de soumission invalides", issues: parsed.error.flatten() });
    return;
  }
  const { formId, privacyConsent, marketingConsent = false, ref, ...payload } = parsed.data;
  if (!privacyConsent) {
    res.status(400).json({ success: false, message: "Consentement de confidentialite requis" });
    return;
  }
  try {
    const form = await db.publicForm.findFirst({
      where: {
        deletedAt: null,
        isActive: true,
        isPublic: true,
        OR: [{ id: formId }, { slug: formId }]
      }
    });
    if (!form) {
      res.status(404).json({ success: false, message: "Formulaire introuvable" });
      return;
    }
    if (form.maxSubmissionsPerDay) {
      const startOfDay = /* @__PURE__ */ new Date();
      startOfDay.setHours(0, 0, 0, 0);
      const submissionsToday = await db.publicFormSubmission.count({
        where: {
          formId: form.id,
          createdAt: { gte: startOfDay }
        }
      });
      if (submissionsToday >= form.maxSubmissionsPerDay) {
        res.status(429).json({ success: false, message: "Limite de soumissions atteinte pour aujourd'hui" });
        return;
      }
    }
    const ipAddress = req2.headers["x-forwarded-for"]?.split(",")[0]?.trim() || req2.socket.remoteAddress || "unknown";
    const userAgent = req2.headers["user-agent"] ?? "unknown";
    const referredBy = ref || null;
    const submission = await db.publicFormSubmission.create({
      data: {
        formId: form.id,
        organizationId: form.organizationId,
        data: payload,
        status: "new",
        ipAddress,
        userAgent,
        privacyConsent,
        marketingConsent,
        referredBy
      }
    });
    await db.publicForm.update({
      where: { id: form.id },
      data: {
        submissionCount: { increment: 1 },
        lastSubmissionAt: /* @__PURE__ */ new Date()
      }
    });
    if (form.autoPublishLeads) {
      try {
        const leadData = {
          organizationId: form.organizationId,
          source: "public-form",
          status: "nouveau",
          notes: `Lead cr\xE9\xE9 automatiquement depuis le formulaire "${form.name}"`,
          data: payload
        };
        if (payload.firstName) leadData.firstName = payload.firstName;
        if (payload.lastName) leadData.lastName = payload.lastName;
        if (payload.email) leadData.email = payload.email;
        if (payload.phone) leadData.phone = payload.phone;
        if (payload.company) leadData.company = payload.company;
        if (referredBy) {
          const slugParts = referredBy.split("-");
          const users = await db.user.findMany({
            where: {
              organizationId: form.organizationId
            }
          });
          let referrer = null;
          for (const u of users) {
            const userSlug = await generateUserSlug(u.firstName, u.lastName, form.organizationId);
            if (userSlug === referredBy) {
              referrer = u;
              break;
            }
          }
          if (referrer) {
            leadData.assignedUserId = referrer.id;
            leadData.notes = `Lead cr\xE9\xE9 depuis le formulaire "${form.name}" via le lien de ${referrer.firstName} ${referrer.lastName}`;
            console.log(`\u2705 [PUBLIC-FORMS] Lead attribu\xE9 automatiquement \xE0 ${referrer.firstName} ${referrer.lastName}`);
          } else {
            console.warn(`\u26A0\uFE0F [PUBLIC-FORMS] Utilisateur r\xE9f\xE9rent introuvable pour le slug: ${referredBy}`);
          }
        }
        const lead = await db.lead.create({ data: leadData });
        await db.publicFormSubmission.update({
          where: { id: submission.id },
          data: { leadId: lead.id }
        });
        console.log(`\u2705 [PUBLIC-FORMS] Lead cr\xE9\xE9 automatiquement: ${lead.id}`);
      } catch (leadError) {
        console.error("[PUBLIC-FORMS] Erreur lors de la cr\xE9ation du lead:", leadError);
      }
    }
    res.json({
      success: true,
      message: form.thankYouMessage,
      data: {
        submissionId: submission.id,
        submittedAt: submission.createdAt.toISOString()
      }
    });
  } catch (error) {
    console.error("[PUBLIC-FORMS] Soumission impossible:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la soumission du formulaire" });
  }
});
var publicForms_default = router63;

// src/routes/landingPages.ts
var import_express65 = require("express");
var import_express_rate_limit10 = __toESM(require("express-rate-limit"), 1);
init_prisma();
var router64 = (0, import_express65.Router)();
var publicLandingRateLimit = (0, import_express_rate_limit10.default)({
  windowMs: 60 * 1e3,
  // 1 minute
  max: 100,
  // 100 vues par minute par IP
  message: { success: false, message: "Trop de requ\xEAtes landing pages" }
});
var adminLandingRateLimit = (0, import_express_rate_limit10.default)({
  windowMs: 60 * 1e3,
  // 1 minute
  max: 50,
  // 50 requ√™tes par minute
  message: { success: false, message: "Trop de requ\xEAtes landing admin" }
});
var isJsonObject2 = (value) => typeof value === "object" && value !== null && !Array.isArray(value);
var toJsonObject = (value) => isJsonObject2(value) ? value : {};
var toStringOrNull = (value) => typeof value === "string" ? value : null;
var toStringArray = (value) => Array.isArray(value) ? value.filter((item) => typeof item === "string") : [];
var toSnapshots = (value) => {
  if (!Array.isArray(value)) return [];
  return value.filter((item) => isJsonObject2(item)).map((item) => {
    const id = toStringOrNull(item.id);
    const label = toStringOrNull(item.label) ?? `Snapshot ${(/* @__PURE__ */ new Date()).toLocaleString()}`;
    const createdAt = toStringOrNull(item.createdAt) ?? (/* @__PURE__ */ new Date()).toISOString();
    const content = toJsonObject(item.content ?? {});
    const settings = toJsonObject(item.settings ?? {});
    if (!id) {
      return null;
    }
    const snapshot = {
      id,
      label,
      createdAt,
      content,
      settings
    };
    return snapshot;
  }).filter((snapshot) => snapshot !== null);
};
router64.get("/public/:slug", publicLandingRateLimit, async (req2, res) => {
  try {
    const { slug } = req2.params;
    const landingPage = await db.treeBranchLeafTree.findFirst({
      where: {
        category: "landing",
        isPublic: true,
        OR: [
          { id: slug },
          { name: slug }
        ]
      },
      include: { Organization: { select: { name: true } } }
    });
    if (!landingPage) {
      return res.status(404).json({
        success: false,
        message: "Landing page non trouv\xE9e"
      });
    }
    await db.treeBranchLeafSubmission.create({
      data: {
        treeId: landingPage.id,
        status: "view",
        summary: {},
        exportData: {}
      }
    });
    const content = toJsonObject(landingPage.metadata);
    const styling = toJsonObject(landingPage.settings);
    const seo = toJsonObject(content.seo ?? null);
    const tracking = toJsonObject(styling.tracking ?? null);
    const title = toStringOrNull(content.title) ?? landingPage.name;
    const subtitle = toStringOrNull(content.subtitle);
    const ctaButton = toStringOrNull(content.ctaButton);
    const ctaUrl = toStringOrNull(content.ctaUrl);
    const seoTitle = toStringOrNull(seo.title) ?? landingPage.name;
    const seoDescription = toStringOrNull(seo.description);
    const keywords = toStringArray(seo.keywords);
    res.json({
      success: true,
      data: {
        id: landingPage.id,
        title,
        subtitle,
        content,
        seo: {
          title: seoTitle,
          description: seoDescription,
          keywords
        },
        styling,
        tracking,
        // { googleTagId?: string; metaPixelId?: string; enable?: boolean }
        ctaButton,
        ctaUrl,
        campaign: { name: landingPage.Organization?.name }
      }
    });
  } catch (error) {
    console.error("\u274C [LANDING-PAGES] Erreur affichage public:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de l'affichage de la landing page"
    });
  }
});
router64.post("/public/:slug/track", publicLandingRateLimit, async (req2, res) => {
  try {
    const { slug } = req2.params;
    const { event, data = {} } = req2.body;
    if (!event) {
      return res.status(400).json({
        success: false,
        message: "Type d'\xE9v\xE9nement requis"
      });
    }
    const landingPage = await db.treeBranchLeafTree.findFirst({
      where: {
        category: "landing",
        OR: [{ id: slug }, { name: slug }]
      },
      select: { id: true, organizationId: true }
    });
    if (!landingPage) {
      return res.status(404).json({
        success: false,
        message: "Landing page non trouv\xE9e"
      });
    }
    await db.treeBranchLeafSubmission.create({
      data: {
        treeId: landingPage.id,
        status: event,
        summary: data || {},
        exportData: {
          userAgent: req2.get("User-Agent"),
          ip: req2.ip,
          referer: req2.get("Referer")
        }
      }
    });
    res.json({
      success: true,
      message: "\xC9v\xE9nement track\u0117 avec succ\xE8s"
    });
  } catch (error) {
    console.error("\u274C [LANDING-PAGES] Erreur tracking:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors du tracking"
    });
  }
});
router64.use("/admin", authMiddleware);
router64.use("/admin", adminLandingRateLimit);
router64.get("/admin/list", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "Organization ID manquant"
      });
    }
    const trees = await db.treeBranchLeafTree.findMany({
      where: { organizationId, category: "landing" },
      orderBy: { createdAt: "desc" }
    });
    const data = await Promise.all(
      trees.map(async (t) => {
        const [views, conversions] = await Promise.all([
          db.treeBranchLeafSubmission.count({ where: { treeId: t.id, status: "view" } }),
          db.treeBranchLeafSubmission.count({ where: { treeId: t.id, status: "form_submit" } })
        ]);
        const conversionRate = views > 0 ? Math.round(conversions / views * 100) : 0;
        const content = toJsonObject(t.metadata);
        const status = (t.status ?? "draft").toUpperCase();
        return {
          id: t.id,
          title: t.name,
          slug: t.id,
          description: t.description ?? "",
          content,
          status,
          metaTitle: t.name,
          metaDescription: "",
          keywords: [],
          customCSS: "",
          customJS: "",
          trackingPixels: [],
          publishedAt: t.status === "published" ? t.updatedAt : null,
          views,
          conversions,
          conversionRate,
          createdAt: t.createdAt,
          updatedAt: t.updatedAt
        };
      })
    );
    res.json({ success: true, data });
  } catch (error) {
    console.error("\u274C [LANDING-ADMIN] Erreur liste:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la r\xE9cup\xE9ration des landing pages" });
  }
});
router64.get("/", authMiddleware, adminLandingRateLimit, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const trees = await db.treeBranchLeafTree.findMany({ where: { organizationId, category: "landing" }, orderBy: { createdAt: "desc" } });
    const data = await Promise.all(
      trees.map(async (t) => {
        const [views, conversions] = await Promise.all([
          db.treeBranchLeafSubmission.count({ where: { treeId: t.id, status: "view" } }),
          db.treeBranchLeafSubmission.count({ where: { treeId: t.id, status: "form_submit" } })
        ]);
        const conversionRate = views > 0 ? Math.round(conversions / views * 100) : 0;
        const content = toJsonObject(t.metadata);
        const status = (t.status ?? "draft").toUpperCase();
        return {
          id: t.id,
          title: t.name,
          slug: t.id,
          description: t.description ?? "",
          content,
          status,
          metaTitle: t.name,
          metaDescription: "",
          keywords: [],
          customCSS: "",
          customJS: "",
          trackingPixels: [],
          publishedAt: t.status === "published" ? t.updatedAt : null,
          views,
          conversions,
          conversionRate,
          createdAt: t.createdAt,
          updatedAt: t.updatedAt
        };
      })
    );
    res.json({ success: true, data });
  } catch (error) {
    console.error("\u274C [LANDING] Erreur / (list):", error);
    res.status(500).json({ success: false, message: "Erreur lors de la r\xE9cup\xE9ration des landing pages" });
  }
});
router64.get("/stats", authMiddleware, adminLandingRateLimit, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const totalPages = await db.treeBranchLeafTree.count({ where: { organizationId, category: "landing" } });
    const publishedPages = await db.treeBranchLeafTree.count({ where: { organizationId, category: "landing", status: "published" } });
    const draftPages = totalPages - publishedPages;
    const [totalViews, totalConversions] = await Promise.all([
      db.treeBranchLeafSubmission.count({ where: { status: "view", TreeBranchLeafTree: { organizationId, category: "landing" } } }),
      db.treeBranchLeafSubmission.count({ where: { status: "form_submit", TreeBranchLeafTree: { organizationId, category: "landing" } } })
    ]);
    const avgConversionRate = totalViews > 0 ? Math.round(totalConversions / totalViews * 100) : 0;
    res.json({ success: true, data: { totalPages, publishedPages, draftPages, totalViews, totalConversions, avgConversionRate } });
  } catch (error) {
    console.error("\u274C [LANDING] Erreur /stats:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la r\xE9cup\xE9ration des statistiques" });
  }
});
router64.get("/stats/timeseries", authMiddleware, adminLandingRateLimit, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const daysParam = Array.isArray(req2.query.days) ? req2.query.days[0] : req2.query.days;
    const requestedDays = Number.parseInt(daysParam ?? "30", 10);
    const safeDays = Number.isNaN(requestedDays) ? 30 : requestedDays;
    const days = Math.min(365, Math.max(1, safeDays));
    const start = /* @__PURE__ */ new Date();
    start.setDate(start.getDate() - (days - 1));
    start.setHours(0, 0, 0, 0);
    const submissions = await db.treeBranchLeafSubmission.findMany({
      where: { createdAt: { gte: start }, TreeBranchLeafTree: { organizationId, category: "landing" } },
      select: { createdAt: true, status: true }
    });
    const byDay = /* @__PURE__ */ new Map();
    for (let i = 0; i < days; i++) {
      const d = new Date(start.getTime());
      d.setDate(start.getDate() + i);
      byDay.set(d.toISOString().slice(0, 10), { views: 0, conversions: 0 });
    }
    for (const s of submissions) {
      const key2 = new Date(s.createdAt).toISOString().slice(0, 10);
      const rec = byDay.get(key2);
      if (!rec) continue;
      if (s.status === "view") rec.views++;
      if (s.status === "form_submit") rec.conversions++;
    }
    const series = Array.from(byDay.entries()).map(([date, v]) => ({ date, views: v.views, conversions: v.conversions }));
    res.json({ success: true, data: { start: start.toISOString(), days, series } });
  } catch (error) {
    console.error("\u274C [LANDING] Erreur timeseries:", error);
    res.status(500).json({ success: false, message: "Erreur s\xE9ries temporelles landing" });
  }
});
router64.post("/", authMiddleware, adminLandingRateLimit, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const { title, description, content, status, settings } = req2.body;
    if (!title) return res.status(400).json({ success: false, message: "Titre requis" });
    const created = await db.treeBranchLeafTree.create({
      data: {
        organizationId,
        name: title,
        description: description || "",
        category: "landing",
        status: (status || "DRAFT").toLowerCase(),
        metadata: content || {},
        settings: settings || {}
      }
    });
    res.json({ success: true, data: { id: created.id } });
  } catch (error) {
    console.error("\u274C [LANDING] Erreur cr\xE9ation:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la cr\xE9ation" });
  }
});
router64.put("/:id", authMiddleware, adminLandingRateLimit, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const tree = await db.treeBranchLeafTree.findFirst({ where: { id, organizationId, category: "landing" } });
    if (!tree) return res.status(404).json({ success: false, message: "Landing page non trouv\xE9e" });
    const { title, description, content, status, settings } = req2.body;
    const updated = await db.treeBranchLeafTree.update({
      where: { id },
      data: {
        name: title ?? tree.name,
        description: description ?? tree.description,
        metadata: content ?? tree.metadata,
        settings: settings ?? tree.settings,
        status: status ? status.toLowerCase() : tree.status
      }
    });
    res.json({ success: true, data: { id: updated.id } });
  } catch (error) {
    console.error("\u274C [LANDING] Erreur mise \xE0 jour:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la mise \xE0 jour" });
  }
});
router64.delete("/:id", authMiddleware, adminLandingRateLimit, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const deleted = await db.treeBranchLeafTree.deleteMany({ where: { id, organizationId, category: "landing" } });
    if (deleted.count === 0) return res.status(404).json({ success: false, message: "Landing page non trouv\xE9e" });
    res.json({ success: true });
  } catch (error) {
    console.error("\u274C [LANDING] Erreur suppression:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la suppression" });
  }
});
router64.patch("/:id/publish", authMiddleware, adminLandingRateLimit, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const { publish } = req2.body;
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    if (publish === void 0) return res.status(400).json({ success: false, message: "Param\xE8tre publish manquant" });
    const tree = await db.treeBranchLeafTree.findFirst({ where: { id, organizationId, category: "landing" } });
    if (!tree) return res.status(404).json({ success: false, message: "Landing page non trouv\xE9e" });
    const updated = await db.treeBranchLeafTree.update({ where: { id }, data: { status: publish ? "published" : "draft", isPublic: !!publish } });
    res.json({ success: true, data: { id: updated.id, status: updated.status } });
  } catch (error) {
    console.error("\u274C [LANDING] Erreur publish:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la publication" });
  }
});
router64.get("/admin/:id", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const tree = await db.treeBranchLeafTree.findFirst({ where: { id, organizationId, category: "landing" } });
    if (!tree) return res.status(404).json({ success: false, message: "Landing page non trouv\xE9e" });
    const content = toJsonObject(tree.metadata);
    const styling = toJsonObject(tree.settings);
    const seo = toJsonObject(content.seo ?? null);
    const tracking = toJsonObject(styling.tracking ?? null);
    const status = (tree.status ?? "draft").toUpperCase();
    const seoTitle = toStringOrNull(seo.title) ?? tree.name;
    const seoDescription = toStringOrNull(seo.description) ?? "";
    const keywords = toStringArray(seo.keywords);
    res.json({
      success: true,
      data: {
        id: tree.id,
        title: tree.name,
        description: tree.description ?? "",
        status,
        content,
        seo: {
          title: seoTitle,
          description: seoDescription,
          keywords
        },
        styling,
        tracking,
        isPublic: !!tree.isPublic,
        createdAt: tree.createdAt,
        updatedAt: tree.updatedAt
      }
    });
  } catch (error) {
    console.error("\u274C [LANDING-ADMIN] Erreur d\xE9tail:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la r\xE9cup\xE9ration du d\xE9tail" });
  }
});
router64.post("/:id/duplicate", authMiddleware, adminLandingRateLimit, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const tree = await db.treeBranchLeafTree.findFirst({ where: { id, organizationId, category: "landing" } });
    if (!tree) return res.status(404).json({ success: false, message: "Landing page non trouv\xE9e" });
    const suffix = Math.random().toString(36).slice(2, 6);
    const copy = await db.treeBranchLeafTree.create({
      data: {
        organizationId,
        name: `${tree.name} (copie ${suffix})`,
        description: tree.description || "",
        category: "landing",
        status: "draft",
        isPublic: false,
        metadata: toJsonObject(tree.metadata),
        settings: toJsonObject(tree.settings)
      }
    });
    res.json({ success: true, data: { id: copy.id } });
  } catch (error) {
    console.error("\u274C [LANDING] Erreur duplication:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la duplication" });
  }
});
router64.post("/:id/snapshot", authMiddleware, adminLandingRateLimit, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const { label } = req2.body;
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const tree = await db.treeBranchLeafTree.findFirst({ where: { id, organizationId, category: "landing" } });
    if (!tree) return res.status(404).json({ success: false, message: "Landing page non trouv\xE9e" });
    const settings = toJsonObject(tree.settings);
    const versions = toSnapshots(settings._versions);
    const snapshotId = `${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
    const snapshot = {
      id: snapshotId,
      label: label || `Snapshot ${(/* @__PURE__ */ new Date()).toLocaleString()}`,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      content: toJsonObject(tree.metadata),
      settings: toJsonObject(tree.settings)
    };
    const updatedSettings = {
      ...settings,
      _versions: [snapshot, ...versions]
    };
    const updated = await db.treeBranchLeafTree.update({ where: { id }, data: { settings: updatedSettings } });
    res.json({ success: true, data: { id: updated.id, snapshotId } });
  } catch (error) {
    console.error("\u274C [LANDING] Erreur snapshot:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la cr\xE9ation du snapshot" });
  }
});
router64.get("/:id/versions", authMiddleware, adminLandingRateLimit, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const tree = await db.treeBranchLeafTree.findFirst({ where: { id, organizationId, category: "landing" } });
    if (!tree) return res.status(404).json({ success: false, message: "Landing page non trouv\xE9e" });
    const settings = toJsonObject(tree.settings);
    const versions = toSnapshots(settings._versions);
    res.json({
      success: true,
      data: versions.map((version) => ({
        id: version.id,
        label: version.label,
        createdAt: version.createdAt
      }))
    });
  } catch (error) {
    console.error("\u274C [LANDING] Erreur versions:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la r\xE9cup\xE9ration des versions" });
  }
});
router64.post("/:id/restore", authMiddleware, adminLandingRateLimit, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const { snapshotId } = req2.body;
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    if (!snapshotId) return res.status(400).json({ success: false, message: "snapshotId requis" });
    const tree = await db.treeBranchLeafTree.findFirst({ where: { id, organizationId, category: "landing" } });
    if (!tree) return res.status(404).json({ success: false, message: "Landing page non trouv\xE9e" });
    const settings = toJsonObject(tree.settings);
    const versions = toSnapshots(settings._versions);
    const snap = versions.find((version) => version.id === snapshotId);
    if (!snap) return res.status(404).json({ success: false, message: "Snapshot non trouv\xE9" });
    const updated = await db.treeBranchLeafTree.update({
      where: { id },
      data: {
        metadata: snap.content,
        settings: { ...snap.settings, _versions: versions }
      }
    });
    res.json({ success: true, data: { id: updated.id } });
  } catch (error) {
    console.error("\u274C [LANDING] Erreur restore:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la restauration" });
  }
});
var landingPages_default = router64;

// src/routes/campaignAnalytics.ts
var import_express66 = require("express");
init_database();
var import_express_rate_limit11 = __toESM(require("express-rate-limit"), 1);
var router65 = (0, import_express66.Router)();
var prisma36 = db;
var campaignAnalyticsRateLimit = (0, import_express_rate_limit11.default)({
  windowMs: 60 * 1e3,
  // 1 minute
  max: 50,
  // 50 requ√™tes par minute
  message: { success: false, message: "Trop de requ\xEAtes campaign analytics" }
});
router65.use(authMiddleware);
router65.use(campaignAnalyticsRateLimit);
router65.get("/dashboard", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "Organization ID manquant"
      });
    }
    const { period = "30" } = req2.query;
    const startDate = /* @__PURE__ */ new Date();
    startDate.setDate(startDate.getDate() - parseInt(period));
    const [
      totalLeads,
      periodLeads,
      activeCampaigns,
      totalRevenue,
      averageAiScore,
      conversionFunnel
    ] = await Promise.all([
      // Total des leads
      prisma36.lead.count({
        where: { organizationId }
      }),
      // Leads de la p√©riode
      prisma36.lead.count({
        where: {
          organizationId,
          createdAt: { gte: startDate }
        }
      }),
      // Campagnes actives
      prisma36.campaign.count({
        where: {
          organizationId,
          status: "ACTIVE"
        }
      }),
      // Revenus totaux
      prisma36.creditTransaction.aggregate({
        where: {
          organizationId,
          type: "SALE"
        },
        _sum: { amount: true }
      }),
      // Score IA moyen
      prisma36.lead.aggregate({
        where: {
          organizationId,
          aiScore: { not: null }
        },
        _avg: { aiScore: true }
      }),
      // Funnel de conversion
      prisma36.lead.groupBy({
        by: ["status"],
        where: { organizationId },
        _count: true
      })
    ]);
    const dailyLeads = await prisma36.$queryRaw`
      SELECT 
        DATE(created_at) as date,
        COUNT(*) as count
      FROM "Lead" 
      WHERE organization_id = ${organizationId}
        AND created_at >= ${startDate}
      GROUP BY DATE(created_at)
      ORDER BY date ASC
    `;
    const topCampaigns = await prisma36.campaign.findMany({
      where: { organizationId },
      select: {
        id: true,
        name: true,
        type: true,
        _count: {
          select: { leads: true }
        }
      },
      orderBy: {
        leads: { _count: "desc" }
      },
      take: 5
    });
    const leadsSources = await prisma36.lead.groupBy({
      by: ["source"],
      where: {
        organizationId,
        createdAt: { gte: startDate }
      },
      _count: true
    });
    res.json({
      success: true,
      data: {
        period: parseInt(period),
        metrics: {
          totalLeads,
          periodLeads,
          activeCampaigns,
          totalRevenue: totalRevenue._sum.amount || 0,
          averageAiScore: Math.round((averageAiScore._avg.aiScore || 0) * 100) / 100
        },
        conversionFunnel: conversionFunnel.map((item) => ({
          status: item.status,
          count: item._count
        })),
        dailyLeads,
        topCampaigns: topCampaigns.map((campaign) => ({
          ...campaign,
          leadsCount: campaign._count.leads
        })),
        leadsSources: leadsSources.map((source) => ({
          source: source.source,
          count: source._count
        }))
      }
    });
  } catch (error) {
    console.error("\u274C [CAMPAIGN-ANALYTICS] Erreur dashboard:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration du dashboard analytics"
    });
  }
});
router65.get("/campaign/:id", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "Organization ID manquant"
      });
    }
    const { period = "30" } = req2.query;
    const startDate = /* @__PURE__ */ new Date();
    startDate.setDate(startDate.getDate() - parseInt(period));
    const campaign = await prisma36.campaign.findFirst({
      where: {
        id,
        organizationId
      },
      include: {
        _count: {
          select: {
            leads: true,
            publicForms: true,
            landingPages: true
          }
        }
      }
    });
    if (!campaign) {
      return res.status(404).json({
        success: false,
        message: "Campagne non trouv\xE9e"
      });
    }
    const [
      periodLeads,
      leadsRevenue,
      averageAiScore,
      statusBreakdown,
      sourceBreakdown,
      regionBreakdown
    ] = await Promise.all([
      // Leads de la p√©riode
      prisma36.lead.count({
        where: {
          campaignId: id,
          createdAt: { gte: startDate }
        }
      }),
      // Revenus g√©n√©r√©s par les leads de cette campagne
      prisma36.leadMarketplace.aggregate({
        where: {
          campaignId: id,
          status: "SOLD"
        },
        _sum: { marketplacePrice: true }
      }),
      // Score IA moyen
      prisma36.lead.aggregate({
        where: {
          campaignId: id,
          aiScore: { not: null }
        },
        _avg: { aiScore: true }
      }),
      // R√©partition par statut
      prisma36.lead.groupBy({
        by: ["status"],
        where: { campaignId: id },
        _count: true
      }),
      // R√©partition par source
      prisma36.lead.groupBy({
        by: ["source"],
        where: { campaignId: id },
        _count: true
      }),
      // R√©partition par r√©gion
      prisma36.lead.groupBy({
        by: ["region"],
        where: {
          campaignId: id,
          region: { not: null }
        },
        _count: true
      })
    ]);
    const dailyLeadsEvolution = await prisma36.$queryRaw`
      SELECT 
        DATE(created_at) as date,
        COUNT(*) as count,
        AVG(ai_score) as avg_score
      FROM "Lead" 
      WHERE campaign_id = ${id}
        AND created_at >= ${startDate}
      GROUP BY DATE(created_at)
      ORDER BY date ASC
    `;
    const formsPerformance = await prisma36.publicForm.findMany({
      where: { campaignId: id },
      select: {
        id: true,
        title: true,
        submissionsCount: true,
        isActive: true,
        _count: {
          select: { leads: true }
        }
      }
    });
    const landingPagesPerformance = await prisma36.landingPage.findMany({
      where: { campaignId: id },
      select: {
        id: true,
        title: true,
        slug: true,
        viewsCount: true,
        clicksCount: true,
        conversionsCount: true,
        isPublished: true
      }
    });
    res.json({
      success: true,
      data: {
        campaign: {
          ...campaign,
          totalLeads: campaign._count.leads,
          totalForms: campaign._count.publicForms,
          totalLandingPages: campaign._count.landingPages
        },
        period: parseInt(period),
        metrics: {
          periodLeads,
          leadsRevenue: leadsRevenue._sum.marketplacePrice || 0,
          averageAiScore: Math.round((averageAiScore._avg.aiScore || 0) * 100) / 100,
          costPerLead: campaign.budget && campaign._count.leads > 0 ? Math.round(campaign.budget / campaign._count.leads * 100) / 100 : 0
        },
        breakdowns: {
          status: statusBreakdown.map((item) => ({
            status: item.status,
            count: item._count
          })),
          source: sourceBreakdown.map((item) => ({
            source: item.source,
            count: item._count
          })),
          region: regionBreakdown.map((item) => ({
            region: item.region,
            count: item._count
          }))
        },
        dailyEvolution: dailyLeadsEvolution,
        formsPerformance: formsPerformance.map((form) => ({
          ...form,
          conversionRate: form.submissionsCount > 0 ? Math.round(form._count.leads / form.submissionsCount * 100 * 100) / 100 : 0
        })),
        landingPagesPerformance: landingPagesPerformance.map((page) => ({
          ...page,
          conversionRate: page.viewsCount > 0 ? Math.round(page.conversionsCount / page.viewsCount * 100 * 100) / 100 : 0,
          clickThroughRate: page.viewsCount > 0 ? Math.round(page.clicksCount / page.viewsCount * 100 * 100) / 100 : 0
        }))
      }
    });
  } catch (error) {
    console.error("\u274C [CAMPAIGN-ANALYTICS] Erreur campagne:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration des analytics de campagne"
    });
  }
});
router65.get("/ai-insights", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "Organization ID manquant"
      });
    }
    const aiRecommendations = await prisma36.aiRecommendation.findMany({
      where: {
        lead: {
          organizationId
        }
      },
      include: {
        lead: {
          select: {
            firstName: true,
            lastName: true,
            company: true,
            aiScore: true
          }
        }
      },
      orderBy: {
        createdAt: "desc"
      },
      take: 20
    });
    const scoreDistribution = await prisma36.$queryRaw`
      SELECT 
        CASE 
          WHEN ai_score >= 90 THEN 'Excellent (90-100)'
          WHEN ai_score >= 80 THEN 'Tr√®s bon (80-89)'
          WHEN ai_score >= 70 THEN 'Bon (70-79)'
          WHEN ai_score >= 60 THEN 'Moyen (60-69)'
          ELSE 'Faible (0-59)'
        END as score_range,
        COUNT(*) as count
      FROM "Lead" 
      WHERE organization_id = ${organizationId}
        AND ai_score IS NOT NULL
      GROUP BY score_range
      ORDER BY MIN(ai_score) DESC
    `;
    const campaignScores = await prisma36.campaign.findMany({
      where: { organizationId },
      select: {
        id: true,
        name: true,
        leads: {
          select: {
            aiScore: true
          },
          where: {
            aiScore: { not: null }
          }
        }
      }
    });
    const campaignScoresAnalysis = campaignScores.map((campaign) => {
      const scores = campaign.leads.map((lead) => lead.aiScore).filter(Boolean);
      return {
        campaignId: campaign.id,
        campaignName: campaign.name,
        averageScore: scores.length > 0 ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length * 100) / 100 : 0,
        leadsCount: scores.length,
        scoreRange: {
          min: Math.min(...scores),
          max: Math.max(...scores)
        }
      };
    }).filter((campaign) => campaign.leadsCount > 0);
    res.json({
      success: true,
      data: {
        aiRecommendations,
        scoreDistribution,
        campaignScoresAnalysis,
        insights: [
          // G√©n√©ration d'insights automatiques bas√©s sur les donn√©es
          ...aiRecommendations.length > 0 ? [{
            type: "recommendation",
            title: "Nouvelles recommandations IA",
            description: `${aiRecommendations.length} nouvelles recommandations disponibles`,
            actionable: true
          }] : [],
          ...campaignScoresAnalysis.length > 0 ? [{
            type: "performance",
            title: "Meilleure campagne par score IA",
            description: `La campagne "${campaignScoresAnalysis.sort((a, b) => b.averageScore - a.averageScore)[0].campaignName}" a le meilleur score moyen (${campaignScoresAnalysis[0].averageScore})`,
            actionable: false
          }] : []
        ]
      }
    });
  } catch (error) {
    console.error("\u274C [CAMPAIGN-ANALYTICS] Erreur AI insights:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de la r\xE9cup\xE9ration des insights IA"
    });
  }
});
router65.get("/export", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        message: "Organization ID manquant"
      });
    }
    const {
      format = "json",
      campaignId,
      startDate,
      endDate
    } = req2.query;
    const where = { organizationId };
    if (campaignId) {
      where.campaignId = campaignId;
    }
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }
    const leads = await prisma36.lead.findMany({
      where,
      include: {
        campaign: {
          select: {
            name: true,
            type: true
          }
        },
        LeadMarketplace: {
          select: {
            marketplacePrice: true,
            marketplaceVisible: true,
            status: true
          }
        },
        aiRecommendations: {
          select: {
            score: true,
            recommendation: true,
            createdAt: true
          },
          orderBy: {
            createdAt: "desc"
          },
          take: 1
        }
      },
      orderBy: {
        createdAt: "desc"
      }
    });
    if (format === "csv") {
      res.setHeader("Content-Type", "text/csv");
      res.setHeader("Content-Disposition", 'attachment; filename="leads-export.csv"');
      res.send("CSV export \xE0 impl\xE9menter");
    } else {
      res.json({
        success: true,
        data: {
          exportDate: (/* @__PURE__ */ new Date()).toISOString(),
          filters: { campaignId, startDate, endDate },
          totalRecords: leads.length,
          leads
        }
      });
    }
  } catch (error) {
    console.error("\u274C [CAMPAIGN-ANALYTICS] Erreur export:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de l'export des donn\xE9es"
    });
  }
});
var campaignAnalytics_default = router65;

// src/routes/dispatch.ts
var import_express67 = require("express");
var import_express_rate_limit12 = __toESM(require("express-rate-limit"), 1);
init_database();
var router66 = (0, import_express67.Router)();
var prisma37 = db;
var dispatchRateLimit = (0, import_express_rate_limit12.default)({
  windowMs: 60 * 1e3,
  max: 60,
  message: { success: false, message: "Trop de requ\xEAtes dispatch" }
});
router66.use(authMiddleware);
router66.use(dispatchRateLimit);
router66.get("/rules", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const rules = await prisma37.automationRule.findMany({
      where: { organizationId },
      orderBy: { createdAt: "desc" }
    });
    res.json({ success: true, data: rules });
  } catch (error) {
    console.error("\u274C [DISPATCH] Erreur liste:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la r\xE9cup\xE9ration des r\xE8gles" });
  }
});
router66.post("/rules", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const { event, action: action2, params, active = true } = req2.body;
    if (!event || !action2) return res.status(400).json({ success: false, message: "event et action sont requis" });
    const created = await prisma37.automationRule.create({ data: { organizationId, event, action: action2, params: params ?? {}, active: !!active } });
    res.json({ success: true, data: created, message: "R\xE8gle cr\xE9\xE9e" });
  } catch (error) {
    console.error("\u274C [DISPATCH] Erreur cr\xE9ation:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la cr\xE9ation de la r\xE8gle" });
  }
});
router66.put("/rules/:id", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const existing = await prisma37.automationRule.findFirst({ where: { id, organizationId } });
    if (!existing) return res.status(404).json({ success: false, message: "R\xE8gle non trouv\xE9e" });
    const { event, action: action2, params, active } = req2.body;
    const updated = await prisma37.automationRule.update({ where: { id }, data: { event, action: action2, params, active } });
    res.json({ success: true, data: updated, message: "R\xE8gle mise \xE0 jour" });
  } catch (error) {
    console.error("\u274C [DISPATCH] Erreur mise \xE0 jour:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la mise \xE0 jour de la r\xE8gle" });
  }
});
router66.delete("/rules/:id", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const deleted = await prisma37.automationRule.deleteMany({ where: { id, organizationId } });
    if (!deleted.count) return res.status(404).json({ success: false, message: "R\xE8gle non trouv\xE9e" });
    res.json({ success: true, message: "R\xE8gle supprim\xE9e" });
  } catch (error) {
    console.error("\u274C [DISPATCH] Erreur suppression:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la suppression de la r\xE8gle" });
  }
});
router66.post("/simulate", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const { lead } = req2.body;
    if (!lead) return res.status(400).json({ success: false, message: "lead requis" });
    const rules = await prisma37.automationRule.findMany({ where: { organizationId, active: true }, orderBy: { createdAt: "asc" } });
    const matches = [];
    for (const r of rules) {
      const params = r.params || {};
      const conds = params.conditions && typeof params.conditions === "object" ? params.conditions : {};
      let score = 0;
      let total = 0;
      for (const [k, v] of Object.entries(conds)) {
        total++;
        if (lead[k] === v) score++;
      }
      const ratio = total > 0 ? score / total : 0;
      if (total === 0 || ratio >= 0.75) {
        matches.push({ ruleId: r.id, action: r.action, score: Math.round(ratio * 100) });
      }
    }
    res.json({ success: true, data: { matches } });
  } catch (error) {
    console.error("\u274C [DISPATCH] Erreur simulate:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la simulation" });
  }
});
var dispatch_default = router66;

// src/routes/integrationsStatus.ts
var import_express68 = require("express");
var import_crypto20 = require("crypto");
var import_express_rate_limit13 = __toESM(require("express-rate-limit"), 1);
init_database();
var router67 = (0, import_express68.Router)();
var prisma38 = db;
var rl = (0, import_express_rate_limit13.default)({ windowMs: 60 * 1e3, max: 60 });
router67.use(authMiddleware);
router67.use(rl);
router67.get("/status", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const [google11, telnyx, adPlatforms] = await Promise.all([
      prisma38.googleWorkspaceConfig.findUnique({ where: { organizationId } }),
      prisma38.telnyxConnection.findMany({ where: { organizationId } }),
      prisma38.adPlatformIntegration.findMany({ where: { organizationId } })
    ]);
    const status = {
      google: {
        enabled: !!google11?.enabled || !!google11?.isActive,
        gmail: !!google11?.gmailEnabled,
        calendar: !!google11?.calendarEnabled,
        drive: !!google11?.driveEnabled,
        meet: !!google11?.meetEnabled,
        sheets: !!google11?.sheetsEnabled,
        voice: !!google11?.voiceEnabled,
        lastSync: google11?.updatedAt ?? null
      },
      telnyx: {
        connections: telnyx.map((t) => ({ id: t.id, name: t.name, status: t.status, type: t.type })),
        active: telnyx.some((t) => t.status === "active")
      },
      adPlatforms: adPlatforms.map((p) => ({ id: p.id, platform: p.platform, name: p.name, status: p.status, lastSync: p.lastSync }))
    };
    res.json({ success: true, data: status });
  } catch (error) {
    console.error("\u274C [INTEGRATIONS] Erreur status:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la r\xE9cup\xE9ration du statut des int\xE9grations" });
  }
});
router67.post("/ad-platform/connect", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const { platform, name, credentials, config } = req2.body;
    if (!platform) return res.status(400).json({ success: false, message: "Param\xE8tre platform requis" });
    const existing = await prisma38.adPlatformIntegration.findFirst({ where: { organizationId, platform } });
    let rec;
    if (existing) {
      rec = await prisma38.adPlatformIntegration.update({
        where: { id: existing.id },
        data: {
          name: name ?? existing.name,
          credentials: credentials ?? existing.credentials ?? import_client.Prisma.JsonNull,
          config: config ?? existing.config ?? import_client.Prisma.JsonNull,
          status: "connected",
          active: true,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    } else {
      rec = await prisma38.adPlatformIntegration.create({
        data: {
          id: (0, import_crypto20.randomUUID)(),
          organizationId,
          platform,
          name: name || platform,
          credentials: credentials ?? import_client.Prisma.JsonNull,
          config: config ?? import_client.Prisma.JsonNull,
          status: "connected",
          active: true,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    }
    res.json({ success: true, data: { id: rec.id } });
  } catch (error) {
    console.error("\u274C [INTEGRATIONS] Erreur connect:", error);
    res.status(500).json({ success: false, message: "Erreur connexion plateforme" });
  }
});
router67.post("/ad-platform/disconnect", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const { platform } = req2.body;
    if (!platform) return res.status(400).json({ success: false, message: "Param\xE8tre platform requis" });
    const existing = await prisma38.adPlatformIntegration.findFirst({ where: { organizationId, platform } });
    if (!existing) return res.status(404).json({ success: false, message: "Int\xE9gration non trouv\xE9e" });
    await prisma38.adPlatformIntegration.update({
      where: { id: existing.id },
      data: { status: "disconnected", active: false, updatedAt: /* @__PURE__ */ new Date() }
    });
    res.json({ success: true });
  } catch (error) {
    console.error("\u274C [INTEGRATIONS] Erreur disconnect:", error);
    res.status(500).json({ success: false, message: "Erreur d\xE9connexion plateforme" });
  }
});
router67.post("/ad-platform/sync", requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    if (!organizationId) return res.status(400).json({ success: false, message: "Organization ID manquant" });
    const { platform } = req2.body;
    if (!platform) return res.status(400).json({ success: false, message: "Param\xE8tre platform requis" });
    const existing = await prisma38.adPlatformIntegration.findFirst({ where: { organizationId, platform } });
    if (!existing) return res.status(404).json({ success: false, message: "Int\xE9gration non trouv\xE9e" });
    const rec = await prisma38.adPlatformIntegration.update({ where: { id: existing.id }, data: { lastSync: /* @__PURE__ */ new Date(), updatedAt: /* @__PURE__ */ new Date() } });
    res.json({ success: true, data: { id: rec.id, lastSync: rec.lastSync } });
  } catch (error) {
    console.error("\u274C [INTEGRATIONS] Erreur sync:", error);
    res.status(500).json({ success: false, message: "Erreur lors de la synchronisation" });
  }
});
var integrationsStatus_default = router67;

// src/routes/integrations.ts
var import_express69 = require("express");
init_database();
var import_axios3 = __toESM(require("axios"), 1);
var import_googleapis9 = require("googleapis");
var import_crypto21 = require("crypto");

// src/services/adPlatformService.ts
init_prisma();
var import_meta2 = {};
var AD_PLATFORMS = {
  google_ads: {
    id: "google_ads",
    name: "google_ads",
    displayName: "Google Ads",
    icon: "GoogleOutlined",
    // URL de callback dynamique (√©vite le hardcode localhost dans le bundle)
    authUrl: (() => {
      const env = globalThis?.process?.env || {};
      const explicit = env.GOOGLE_ADS_REDIRECT || env.GOOGLE_REDIRECT_URI;
      if (explicit) return explicit;
      const viteEnv = import_meta2?.env || {};
      const frontendBase = viteEnv.VITE_API_BASE_URL || viteEnv.API_URL || "";
      if (frontendBase) return `${frontendBase.replace(/\/$/, "")}/api/google-auth/callback`;
      if (typeof window !== "undefined") return `${window.location.origin}/api/google-auth/callback`;
      return "/api/google-auth/callback";
    })(),
    scopes: [
      "https://www.googleapis.com/auth/adwords"
    ],
    fields: [
      {
        key: "account_id",
        label: "ID du compte Google Ads",
        type: "text",
        required: true
      },
      {
        key: "customer_id",
        label: "ID client",
        type: "text",
        required: true
      }
    ]
  },
  meta_ads: {
    id: "meta_ads",
    name: "meta_ads",
    displayName: "Meta Ads (Facebook/Instagram)",
    icon: "FacebookOutlined",
    authUrl: "https://www.facebook.com/v18.0/dialog/oauth",
    scopes: [
      "read_insights",
      "pages_show_list",
      "instagram_basic"
    ],
    fields: [
      {
        key: "app_id",
        label: "App ID Facebook",
        type: "text",
        required: true
      },
      {
        key: "business_account_id",
        label: "ID du compte Business Manager",
        type: "text",
        required: true
      }
    ]
  },
  linkedin_ads: {
    id: "linkedin_ads",
    name: "linkedin_ads",
    displayName: "LinkedIn Ads",
    icon: "LinkedinOutlined",
    authUrl: "https://www.linkedin.com/oauth/v2/authorization",
    scopes: [
      "r_ads",
      "rw_ads",
      "r_organization_social"
    ],
    fields: [
      {
        key: "organization_id",
        label: "ID de l'organisation LinkedIn",
        type: "text",
        required: true
      }
    ]
  },
  tiktok_ads: {
    id: "tiktok_ads",
    name: "tiktok_ads",
    displayName: "TikTok Ads",
    icon: "TikTokOutlined",
    authUrl: "https://ads.tiktok.com/marketing_api/auth",
    scopes: [
      "advertiser_read",
      "campaign_read",
      "campaign_write"
    ],
    fields: [
      {
        key: "advertiser_id",
        label: "ID de l'annonceur TikTok",
        type: "text",
        required: true
      }
    ]
  }
};
var AdPlatformService = class {
  /**
   * R√©cup√®re toutes les int√©grations publicitaires d'une organisation
   */
  static async getIntegrations(organizationId) {
    return db.adPlatformIntegration.findMany({
      where: {
        organizationId,
        active: true
      },
      include: {
        AdCampaign: {
          include: {
            AdMetrics: {
              orderBy: {
                date: "desc"
              },
              take: 30
              // 30 derniers jours
            }
          }
        }
      }
    });
  }
  /**
   * Cr√©e une nouvelle int√©gration publicitaire
   */
  static async createIntegration(organizationId, platform, name, config, credentials) {
    return db.adPlatformIntegration.create({
      data: {
        organizationId,
        platform,
        name,
        config,
        credentials,
        status: "connected"
      }
    });
  }
  /**
   * Met √† jour le statut d'une int√©gration
   */
  static async updateIntegrationStatus(integrationId, status) {
    return db.adPlatformIntegration.update({
      where: { id: integrationId },
      data: {
        status,
        lastSync: /* @__PURE__ */ new Date()
      }
    });
  }
  /**
   * Cr√©e une nouvelle campagne publicitaire
   */
  static async createCampaign(organizationId, platformIntegrationId, campaignData) {
    return db.adCampaign.create({
      data: {
        organizationId,
        platformIntegrationId,
        ...campaignData
      }
    });
  }
  /**
   * Met √† jour les m√©triques d'une campagne
   */
  static async updateCampaignMetrics(campaignId, date, metrics) {
    return db.adMetrics.upsert({
      where: {
        campaignId_date: {
          campaignId,
          date
        }
      },
      create: {
        campaignId,
        date,
        ...metrics
      },
      update: {
        ...metrics
      }
    });
  }
  /**
   * R√©cup√®re les m√©triques d'une campagne sur une p√©riode
   */
  static async getCampaignMetrics(campaignId, startDate, endDate) {
    return db.adMetrics.findMany({
      where: {
        campaignId,
        date: {
          gte: startDate,
          lte: endDate
        }
      },
      orderBy: {
        date: "asc"
      }
    });
  }
  /**
   * Calcule le ROI global d'une organisation
   */
  static async calculateOrganizationROI(organizationId) {
    const campaigns = await db.adCampaign.findMany({
      where: {
        organizationId
      },
      include: {
        AdMetrics: true
      }
    });
    let totalSpent = 0;
    let totalRevenue = 0;
    let totalLeads = 0;
    for (const campaign of campaigns) {
      for (const metric of campaign.AdMetrics) {
        totalSpent += Number(metric.spend);
        totalLeads += metric.conversions;
      }
    }
    const avgLeadValue = 500;
    totalRevenue = totalLeads * avgLeadValue;
    const roi = totalSpent > 0 ? (totalRevenue - totalSpent) / totalSpent * 100 : 0;
    return {
      totalSpent,
      totalRevenue,
      totalLeads,
      roi,
      avgCostPerLead: totalLeads > 0 ? totalSpent / totalLeads : 0
    };
  }
  /**
   * Synchronise les donn√©es depuis les APIs externes
   */
  static async syncPlatformData(integrationId) {
    const integration = await db.adPlatformIntegration.findUnique({
      where: { id: integrationId },
      include: {
        AdCampaign: true
      }
    });
    if (!integration) {
      throw new Error("Int\xE9gration non trouv\xE9e");
    }
    try {
      switch (integration.platform) {
        case "google_ads":
          await this.syncGoogleAds(integration);
          break;
        case "meta_ads":
          await this.syncMetaAds(integration);
          break;
        case "linkedin_ads":
          await this.syncLinkedInAds(integration);
          break;
        case "tiktok_ads":
          await this.syncTikTokAds(integration);
          break;
      }
      await db.analyticsEvent.create({
        data: {
          organizationId: integration.organizationId,
          eventType: "platform_sync_completed",
          source: "advertising",
          sourceId: integrationId,
          data: {
            platform: integration.platform,
            campaignCount: integration.AdCampaign.length
          }
        }
      });
      await this.updateIntegrationStatus(integrationId, "connected");
    } catch (error) {
      await this.updateIntegrationStatus(integrationId, "error");
      throw error;
    }
  }
  /**
   * Synchronisation Google Ads (√† impl√©menter)
   */
  static async syncGoogleAds(integration) {
    console.log("Synchronisation Google Ads pour:", integration.name);
  }
  /**
   * Synchronisation Meta Ads (√† impl√©menter)
   */
  static async syncMetaAds(integration) {
    console.log("Synchronisation Meta Ads pour:", integration.name);
  }
  /**
   * Synchronisation LinkedIn Ads (√† impl√©menter)
   */
  static async syncLinkedInAds(integration) {
    console.log("Synchronisation LinkedIn Ads pour:", integration.name);
  }
  /**
   * Synchronisation TikTok Ads (√† impl√©menter)
   */
  static async syncTikTokAds(integration) {
    console.log("Synchronisation TikTok Ads pour:", integration.name);
  }
};

// src/services/ecommerceService.ts
init_prisma();
var ECOMMERCE_PLATFORMS = {
  shopify: {
    id: "shopify",
    name: "shopify",
    displayName: "Shopify",
    icon: "ShopOutlined",
    webhookSupport: true,
    fields: [
      {
        key: "shop_domain",
        label: "Domaine de la boutique",
        type: "url",
        required: true,
        placeholder: "https://votre-boutique.myshopify.com"
      },
      {
        key: "access_token",
        label: "Token d'acc\xE8s priv\xE9",
        type: "password",
        required: true
      },
      {
        key: "webhook_secret",
        label: "Secret webhook",
        type: "password",
        required: false
      }
    ]
  },
  woocommerce: {
    id: "woocommerce",
    name: "woocommerce",
    displayName: "WooCommerce",
    icon: "ShoppingCartOutlined",
    webhookSupport: true,
    fields: [
      {
        key: "site_url",
        label: "URL du site WordPress",
        type: "url",
        required: true,
        placeholder: "https://votre-site.com"
      },
      {
        key: "consumer_key",
        label: "Cl\xE9 consommateur",
        type: "text",
        required: true
      },
      {
        key: "consumer_secret",
        label: "Secret consommateur",
        type: "password",
        required: true
      }
    ]
  },
  prestashop: {
    id: "prestashop",
    name: "prestashop",
    displayName: "PrestaShop",
    icon: "ShopOutlined",
    webhookSupport: false,
    fields: [
      {
        key: "shop_url",
        label: "URL de la boutique",
        type: "url",
        required: true,
        placeholder: "https://votre-boutique.com"
      },
      {
        key: "webservice_key",
        label: "Cl\xE9 webservice",
        type: "password",
        required: true
      }
    ]
  },
  magento: {
    id: "magento",
    name: "magento",
    displayName: "Magento",
    icon: "ShoppingOutlined",
    webhookSupport: true,
    fields: [
      {
        key: "store_url",
        label: "URL du magasin",
        type: "url",
        required: true,
        placeholder: "https://votre-magasin.com"
      },
      {
        key: "access_token",
        label: "Token d'acc\xE8s admin",
        type: "password",
        required: true
      }
    ]
  },
  custom: {
    id: "custom",
    name: "custom",
    displayName: "API personnalis\xE9e",
    icon: "ApiOutlined",
    webhookSupport: true,
    fields: [
      {
        key: "api_url",
        label: "URL de l'API",
        type: "url",
        required: true,
        placeholder: "https://api.votre-boutique.com"
      },
      {
        key: "api_key",
        label: "Cl\xE9 API",
        type: "password",
        required: true
      },
      {
        key: "auth_type",
        label: "Type d'authentification",
        type: "select",
        required: true,
        options: [
          { value: "bearer", label: "Bearer Token" },
          { value: "basic", label: "Basic Auth" },
          { value: "api_key", label: "API Key" }
        ]
      }
    ]
  }
};
var EcommerceService = class {
  /**
   * R√©cup√®re toutes les int√©grations e-commerce d'une organisation
   */
  static async getIntegrations(organizationId) {
    return db.ecommerceIntegration.findMany({
      where: {
        organizationId,
        active: true
      },
      include: {
        Product: {
          where: {
            status: "active"
          }
        },
        Order: {
          orderBy: {
            orderDate: "desc"
          },
          take: 10
          // 10 derni√®res commandes
        }
      }
    });
  }
  /**
   * Cr√©e une nouvelle int√©gration e-commerce
   */
  static async createIntegration(organizationId, platform, name, url, config, credentials) {
    return db.ecommerceIntegration.create({
      data: {
        organizationId,
        platform,
        name,
        url,
        config,
        credentials,
        status: "connected"
      }
    });
  }
  /**
   * Test de connexion √† une int√©gration
   */
  static async testConnection(integrationId) {
    const integration = await db.ecommerceIntegration.findUnique({
      where: { id: integrationId }
    });
    if (!integration) {
      throw new Error("Int\xE9gration non trouv\xE9e");
    }
    try {
      let isConnected = false;
      switch (integration.platform) {
        case "shopify":
          isConnected = await this.testShopifyConnection(integration);
          break;
        case "woocommerce":
          isConnected = await this.testWooCommerceConnection(integration);
          break;
        case "prestashop":
          isConnected = await this.testPrestaShopConnection(integration);
          break;
        case "magento":
          isConnected = await this.testMagentoConnection(integration);
          break;
        case "custom":
          isConnected = await this.testCustomConnection(integration);
          break;
      }
      const status = isConnected ? "connected" : "error";
      await db.ecommerceIntegration.update({
        where: { id: integrationId },
        data: {
          status,
          lastSync: /* @__PURE__ */ new Date()
        }
      });
      return { connected: isConnected, status };
    } catch (error) {
      await db.ecommerceIntegration.update({
        where: { id: integrationId },
        data: {
          status: "error",
          lastSync: /* @__PURE__ */ new Date()
        }
      });
      throw error;
    }
  }
  /**
   * Synchronise les produits depuis la plateforme e-commerce
   */
  static async syncProducts(integrationId) {
    const integration = await db.ecommerceIntegration.findUnique({
      where: { id: integrationId }
    });
    if (!integration) {
      throw new Error("Int\xE9gration non trouv\xE9e");
    }
    let products = [];
    switch (integration.platform) {
      case "shopify":
        products = await this.fetchShopifyProducts(integration);
        break;
      case "woocommerce":
        products = await this.fetchWooCommerceProducts(integration);
        break;
      case "prestashop":
        products = await this.fetchPrestaShopProducts(integration);
        break;
      case "magento":
        products = await this.fetchMagentoProducts(integration);
        break;
      case "custom":
        products = await this.fetchCustomProducts(integration);
        break;
    }
    for (const productData of products) {
      await db.product.upsert({
        where: {
          organizationId_externalId: {
            organizationId: integration.organizationId,
            externalId: productData.externalId || ""
          }
        },
        create: {
          organizationId: integration.organizationId,
          ecommerceIntegrationId: integrationId,
          ...productData,
          images: JSON.stringify(productData.images || []),
          metadata: JSON.stringify(productData.metadata || {})
        },
        update: {
          ...productData,
          images: JSON.stringify(productData.images || []),
          metadata: JSON.stringify(productData.metadata || {})
        }
      });
    }
    await db.analyticsEvent.create({
      data: {
        organizationId: integration.organizationId,
        eventType: "products_synced",
        source: "ecommerce",
        sourceId: integrationId,
        data: {
          platform: integration.platform,
          productCount: products.length
        }
      }
    });
    return products.length;
  }
  /**
   * Synchronise les commandes depuis la plateforme e-commerce
   */
  static async syncOrders(integrationId, fromDate) {
    const integration = await db.ecommerceIntegration.findUnique({
      where: { id: integrationId }
    });
    if (!integration) {
      throw new Error("Int\xE9gration non trouv\xE9e");
    }
    let orders = [];
    switch (integration.platform) {
      case "shopify":
        orders = await this.fetchShopifyOrders(integration, fromDate);
        break;
      case "woocommerce":
        orders = await this.fetchWooCommerceOrders(integration, fromDate);
        break;
      case "prestashop":
        orders = await this.fetchPrestaShopOrders(integration, fromDate);
        break;
      case "magento":
        orders = await this.fetchMagentoOrders(integration, fromDate);
        break;
      case "custom":
        orders = await this.fetchCustomOrders(integration, fromDate);
        break;
    }
    for (const orderData of orders) {
      await db.order.upsert({
        where: {
          organizationId_externalId: {
            organizationId: integration.organizationId,
            externalId: orderData.externalId || ""
          }
        },
        create: {
          organizationId: integration.organizationId,
          ecommerceIntegrationId: integrationId,
          ...orderData,
          billingAddress: JSON.stringify(orderData.billingAddress || {}),
          shippingAddress: JSON.stringify(orderData.shippingAddress || {}),
          items: JSON.stringify(orderData.items || []),
          metadata: JSON.stringify(orderData.metadata || {})
        },
        update: {
          ...orderData,
          billingAddress: JSON.stringify(orderData.billingAddress || {}),
          shippingAddress: JSON.stringify(orderData.shippingAddress || {}),
          items: JSON.stringify(orderData.items || []),
          metadata: JSON.stringify(orderData.metadata || {})
        }
      });
      await db.analyticsEvent.create({
        data: {
          organizationId: integration.organizationId,
          eventType: "order_placed",
          source: "ecommerce",
          sourceId: orderData.externalId || "",
          data: {
            platform: integration.platform,
            orderNumber: orderData.orderNumber,
            customerEmail: orderData.customerEmail
          },
          value: orderData.totalAmount
        }
      });
    }
    return orders.length;
  }
  // Tests de connexion (√† impl√©menter)
  static async testShopifyConnection(integration) {
    console.log("Test connexion Shopify:", integration.url);
    return true;
  }
  static async testWooCommerceConnection(integration) {
    console.log("Test connexion WooCommerce:", integration.url);
    return true;
  }
  static async testPrestaShopConnection(integration) {
    console.log("Test connexion PrestaShop:", integration.url);
    return true;
  }
  static async testMagentoConnection(integration) {
    console.log("Test connexion Magento:", integration.url);
    return true;
  }
  static async testCustomConnection(integration) {
    console.log("Test connexion API personnalis\xE9e:", integration.url);
    return true;
  }
  // R√©cup√©ration des produits (√† impl√©menter)
  static async fetchShopifyProducts(integration) {
    console.warn("\u{1F6CD}\uFE0F [Ecommerce] fetchShopifyProducts non impl\xE9ment\xE9", {
      integrationId: integration?.id ?? integration?.url ?? "unknown"
    });
    return [];
  }
  static async fetchWooCommerceProducts(integration) {
    console.warn("\u{1F6CD}\uFE0F [Ecommerce] fetchWooCommerceProducts non impl\xE9ment\xE9", {
      integrationId: integration?.id ?? integration?.url ?? "unknown"
    });
    return [];
  }
  static async fetchPrestaShopProducts(integration) {
    console.warn("\u{1F6CD}\uFE0F [Ecommerce] fetchPrestaShopProducts non impl\xE9ment\xE9", {
      integrationId: integration?.id ?? integration?.url ?? "unknown"
    });
    return [];
  }
  static async fetchMagentoProducts(integration) {
    console.warn("\u{1F6CD}\uFE0F [Ecommerce] fetchMagentoProducts non impl\xE9ment\xE9", {
      integrationId: integration?.id ?? integration?.url ?? "unknown"
    });
    return [];
  }
  static async fetchCustomProducts(integration) {
    console.warn("\u{1F6CD}\uFE0F [Ecommerce] fetchCustomProducts non impl\xE9ment\xE9", {
      integrationId: integration?.id ?? integration?.url ?? "unknown"
    });
    return [];
  }
  // R√©cup√©ration des commandes (√† impl√©menter)
  static async fetchShopifyOrders(integration, fromDate) {
    console.warn("\u{1F6D2} [Ecommerce] fetchShopifyOrders non impl\xE9ment\xE9", {
      integrationId: integration?.id ?? integration?.url ?? "unknown",
      fromDate: fromDate?.toISOString() ?? null
    });
    return [];
  }
  static async fetchWooCommerceOrders(integration, fromDate) {
    console.warn("\u{1F6D2} [Ecommerce] fetchWooCommerceOrders non impl\xE9ment\xE9", {
      integrationId: integration?.id ?? integration?.url ?? "unknown",
      fromDate: fromDate?.toISOString() ?? null
    });
    return [];
  }
  static async fetchPrestaShopOrders(integration, fromDate) {
    console.warn("\u{1F6D2} [Ecommerce] fetchPrestaShopOrders non impl\xE9ment\xE9", {
      integrationId: integration?.id ?? integration?.url ?? "unknown",
      fromDate: fromDate?.toISOString() ?? null
    });
    return [];
  }
  static async fetchMagentoOrders(integration, fromDate) {
    console.warn("\u{1F6D2} [Ecommerce] fetchMagentoOrders non impl\xE9ment\xE9", {
      integrationId: integration?.id ?? integration?.url ?? "unknown",
      fromDate: fromDate?.toISOString() ?? null
    });
    return [];
  }
  static async fetchCustomOrders(integration, fromDate) {
    console.warn("\u{1F6D2} [Ecommerce] fetchCustomOrders non impl\xE9ment\xE9", {
      integrationId: integration?.id ?? integration?.url ?? "unknown",
      fromDate: fromDate?.toISOString() ?? null
    });
    return [];
  }
};

// src/routes/integrations.ts
var prisma39 = db;
var router68 = (0, import_express69.Router)();
var memCache = /* @__PURE__ */ new Map();
function cacheGet(key2) {
  const it = memCache.get(key2);
  if (!it) return void 0;
  if (Date.now() > it.expiresAt) {
    memCache.delete(key2);
    return void 0;
  }
  return it.payload;
}
function cacheSet(key2, payload, ttlMs) {
  memCache.set(key2, { expiresAt: Date.now() + ttlMs, payload });
}
var DEFAULT_ADS_REDIRECT = (() => {
  const explicit = process.env.GOOGLE_ADS_REDIRECT_URI || googleOAuthConfig.redirectUri;
  if (explicit && explicit.trim().length > 0) return explicit.trim();
  return googleOAuthConfig.redirectUri;
})();
function sanitizeRedirectUri(raw) {
  if (!raw) return { uri: DEFAULT_ADS_REDIRECT, sanitized: false };
  const original = raw;
  let val = raw.trim();
  val = val.replace(/^['"]/g, "").replace(/['"]$/g, "");
  const match = val.match(/https?:\/\/[^\s"']+/);
  if (match) {
    val = match[0];
  }
  try {
    const u = new URL(val);
    if (!/^https?:$/.test(u.protocol)) throw new Error("Unsupported protocol");
    return { uri: u.toString(), raw: original, sanitized: val !== original, warning: val !== original ? "Redirect URI corrig\xE9 depuis la variable d'environnement (guillemets/texte parasite retir\xE9s)" : void 0 };
  } catch {
    return { uri: DEFAULT_ADS_REDIRECT, raw: original, sanitized: true, warning: "Redirect URI invalide d\xE9tect\xE9 dans GOOGLE_ADS_REDIRECT_URI \u2014 fallback appliqu\xE9" };
  }
}
function sanitizeClientValue(raw) {
  if (!raw) return { value: void 0, sanitized: false };
  const original = raw;
  let v = raw.trim();
  const looksQuoted = /^['"].*['"]$/.test(v);
  if (looksQuoted) {
    v = v.replace(/^['"]/, "").replace(/['"]$/, "");
  }
  const sanitized2 = v !== original;
  const warning = sanitized2 ? "Credential nettoy\xE9 (espaces/guillemets retir\xE9s) \u2014 v\xE9rifiez votre .env" : void 0;
  return { value: v, sanitized: sanitized2, warning, looksQuoted };
}
function fingerprintSecret(secret) {
  if (!secret) return null;
  try {
    const hex = (0, import_crypto21.createHash)("sha256").update(secret).digest("hex");
    return hex.slice(0, 12);
  } catch {
    return null;
  }
}
function maskValue(value, prefix = 4, suffix = 4) {
  if (!value) return null;
  const len = value.length;
  if (len <= prefix + suffix + 1) return value;
  return `${value.slice(0, prefix)}\u2026${value.slice(len - suffix)}`;
}
function normalizeGoogleAdsCustomerId(raw) {
  if (!raw) return void 0;
  const digitsOnly = String(raw).replace(/[^0-9]/g, "");
  if (digitsOnly.length !== 10) return void 0;
  return digitsOnly;
}
function formatGoogleAdsCustomerId(raw) {
  const normalized = normalizeGoogleAdsCustomerId(raw);
  if (!normalized) return void 0;
  return `${normalized.slice(0, 3)}-${normalized.slice(3, 6)}-${normalized.slice(6)}`;
}
router68.get("/", async (req2, res) => {
  const { code, state } = req2.query;
  if (code && state) {
    try {
      let parsed;
      try {
        parsed = JSON.parse(decodeURIComponent(state));
      } catch {
        const raw = Buffer.from(String(state), "base64url").toString("utf8");
        parsed = JSON.parse(raw);
      }
      if (parsed.platform === "meta_ads") {
        const redirectUrl = `/api/integrations/advertising/oauth/meta_ads/callback?code=${encodeURIComponent(code)}&state=${encodeURIComponent(state)}`;
        return res.redirect(redirectUrl);
      }
    } catch (e) {
      console.error("Erreur parsing state Facebook:", e);
    }
  }
  res.send("CRM API Server - Facebook OAuth Callback Handler");
});
router68.get("/callback", async (req2, res) => {
  const { code, state } = req2.query;
  if (code && state) {
    try {
      let parsed;
      try {
        parsed = JSON.parse(decodeURIComponent(state));
      } catch {
        const raw = Buffer.from(String(state), "base64url").toString("utf8");
        parsed = JSON.parse(raw);
      }
      if (parsed.platform === "meta_ads") {
        const redirectUrl = `/api/integrations/advertising/oauth/meta_ads/callback?code=${encodeURIComponent(code)}&state=${encodeURIComponent(state)}`;
        return res.redirect(redirectUrl);
      }
    } catch (e) {
      console.error("Erreur parsing state:", e);
    }
  }
  res.status(400).send("Callback invalide");
});
router68.get("/advertising/oauth/:platform/callback", async (req2, res) => {
  res.setHeader("ngrok-skip-browser-warning", "true");
  res.setHeader("User-Agent", "CRM-OAuth-Handler");
  try {
    const platform = req2.params.platform;
    const { code, state, error } = req2.query;
    if (error) {
      console.warn("OAuth error from provider:", error);
    }
    if (!code || !state) {
      res.status(400).send("Missing code/state");
      return;
    }
    let parsed;
    try {
      parsed = JSON.parse(decodeURIComponent(state));
    } catch {
      try {
        const raw = Buffer.from(String(state), "base64url").toString("utf8");
        parsed = JSON.parse(raw);
      } catch {
        res.status(400).send("Invalid state");
        return;
      }
    }
    const organizationId = parsed.organizationId;
    const userId = parsed.userId;
    const upsertIntegration = async (data) => {
      const existing = await prisma39.adPlatformIntegration.findFirst({ where: { organizationId, platform } });
      if (existing) {
        await prisma39.adPlatformIntegration.update({ where: { id: existing.id }, data: { ...data, status: "connected", active: true, updatedAt: /* @__PURE__ */ new Date() } });
        return existing.id;
      }
      const created = await prisma39.adPlatformIntegration.create({
        data: {
          id: (0, import_crypto21.randomUUID)(),
          organizationId,
          platform,
          name: data.name || platform,
          credentials: data.credentials ?? {},
          config: data.config ?? {},
          status: "connected",
          active: true,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
      return created.id;
    };
    if (platform === "google_ads") {
      const idSan = sanitizeClientValue(process.env.GOOGLE_ADS_CLIENT_ID);
      const secretSan = sanitizeClientValue(process.env.GOOGLE_ADS_CLIENT_SECRET);
      const clientId = idSan.value;
      const clientSecret = secretSan.value;
      const { uri: redirectUri } = sanitizeRedirectUri(process.env.GOOGLE_ADS_REDIRECT_URI);
      if (!clientId || !clientSecret) {
        await upsertIntegration({ name: "Google Ads (OAuth pending)", credentials: { authCode: code, error: "missing_client_creds", userId } });
      } else {
        try {
          const oauth2 = new import_googleapis9.google.auth.OAuth2(clientId, clientSecret, redirectUri);
          const { tokens: tokens2 } = await oauth2.getToken(code);
          console.log("\u2705 Google Ads OAuth tokens received successfully");
          await upsertIntegration({ name: "Google Ads OAuth", credentials: { tokens: tokens2, userId } });
        } catch (e) {
          const idSanMasked = clientId ? clientId.length > 8 ? clientId.slice(0, 4) + "..." + clientId.slice(-4) : "defined" : "MISSING";
          const secretFp = fingerprintSecret(clientSecret);
          console.error(`Google Ads token exchange failed (clientId=${idSanMasked}, secretFp=${secretFp ?? "null"}):`, e);
          const errorMsg = e.message || e.code || "unknown_error";
          let userFriendlyError = "Erreur d'authentification";
          if (errorMsg.includes("invalid_client")) {
            userFriendlyError = "Client OAuth non autoris\xE9 pour Google Ads API";
          } else if (errorMsg.includes("invalid_scope")) {
            userFriendlyError = "Scope Google Ads non activ\xE9";
          }
          await upsertIntegration({
            name: `Google Ads (${userFriendlyError})`,
            credentials: { authCode: code, error: errorMsg, userError: userFriendlyError, userId }
          });
        }
      }
    } else if (platform === "meta_ads") {
      const appId = process.env.META_APP_ID;
      const appSecret = process.env.META_APP_SECRET;
      const redirectUri = process.env.META_REDIRECT_URI || "https://localhost:3000/";
      if (!appId || !appSecret) {
        await upsertIntegration({ name: "Meta Ads (OAuth pending)", credentials: { authCode: code, error: "missing_app_creds", userId } });
      } else {
        try {
          const tokenRes = await import_axios3.default.get("https://graph.facebook.com/v18.0/oauth/access_token", {
            params: { client_id: appId, redirect_uri: redirectUri, client_secret: appSecret, code }
          });
          const accessToken = tokenRes.data?.access_token;
          let longLived = accessToken;
          try {
            const ll = await import_axios3.default.get("https://graph.facebook.com/v18.0/oauth/access_token", {
              params: { grant_type: "fb_exchange_token", client_id: appId, client_secret: appSecret, fb_exchange_token: accessToken }
            });
            longLived = ll.data?.access_token || accessToken;
          } catch {
          }
          await upsertIntegration({ name: "Meta Ads OAuth", credentials: { accessToken: longLived, userId } });
        } catch (e) {
          console.error("Meta token exchange failed:", e);
          await upsertIntegration({ name: "Meta Ads (OAuth error)", credentials: { authCode: code, error: "token_exchange_failed", userId } });
        }
      }
    } else {
      res.status(400).send("Unsupported platform");
      return;
    }
    res.setHeader("Content-Type", "text/html; charset=utf-8");
    res.send(`<!doctype html><html><body style="font-family:sans-serif; padding:16px">      <p>Authentification ${platform} termin\xE9e. Vous pouvez fermer cette fen\xEAtre.</p>      <script src="/api/integrations/advertising/oauth/callback-close.js?platform=${encodeURIComponent(platform)}"></script>    </body></html>`);
  } catch (error) {
    console.error("Erreur oauth callback:", error);
    res.status(500).send("OAuth callback error");
  }
});
router68.get("/advertising/oauth/callback-close.js", (req2, res) => {
  const platform = req2.query.platform || "google_ads";
  const js = `(() => {
  const payload = { type: 'ads_oauth_done', platform: ${JSON.stringify(platform)}, ts: Date.now() };
  const notify = () => { try { window.opener && window.opener.postMessage(payload, '*'); } catch (e) {} };
  // Notifier plusieurs fois
  notify();
  let n = 0;
  const t1 = setInterval(() => { n++; notify(); if (n > 10) clearInterval(t1); }, 250);
  // Fermer \xE0 r\xE9p\xE9tition
  let c = 0;
  const t2 = setInterval(() => {
    c++;
    try { window.close(); } catch (e) {}
    try { window.open('', '_self'); window.close(); } catch (e) {}
    if (c > 20 || window.closed) clearInterval(t2);
  }, 300);
  // S\xE9curit\xE9: arr\xEAt des timers
  setTimeout(() => { try { clearInterval(t1); clearInterval(t2); } catch (e) {} }, 8000);
})();`;
  res.setHeader("Content-Type", "application/javascript; charset=utf-8");
  res.send(js);
});
router68.use(authMiddleware, impersonationMiddleware);
var getEffectiveOrgId = (req2) => {
  const headerOrgId = req2.headers["x-organization-id"];
  if (typeof headerOrgId === "string" && headerOrgId !== "all") return headerOrgId;
  const qOrg = req2.query.organizationId || req2.query.orgId;
  if (qOrg && qOrg !== "all") return qOrg;
  const user = req2.user;
  return user?.organizationId;
};
router68.get("/", async (req2, res) => {
  const user = req2.user;
  const organizationId = getEffectiveOrgId(req2);
  if (!user) {
    res.status(401).json({ success: false, message: "Unauthorized" });
    return;
  }
  if (!organizationId) {
    res.json({ success: true, data: [] });
    return;
  }
  try {
    const integrationsSettings = await prisma39.integrationsSettings.findMany({
      where: { organizationId },
      include: {
        user: { select: { id: true, email: true, firstName: true, lastName: true } }
      }
    });
    res.json({ success: true, data: integrationsSettings });
  } catch (error) {
    console.error("Failed to get integrations:", error);
    res.status(500).json({ success: false, message: "Failed to get integrations" });
  }
});
router68.post("/", async (req2, res) => {
  const user = req2.user;
  const organizationId = getEffectiveOrgId(req2);
  const { type, config, enabled } = req2.body;
  if (!user) {
    res.status(401).json({ success: false, message: "Unauthorized" });
    return;
  }
  if (!organizationId) {
    res.status(400).json({ success: false, message: "Organization ID is required to create or update an integration." });
    return;
  }
  if (!type) {
    res.status(400).json({ success: false, message: "Integration type is required." });
    return;
  }
  try {
    const upsertedIntegration = await prisma39.integrationsSettings.upsert({
      where: {
        organizationId_type: {
          organizationId,
          type
        }
      },
      update: {
        config,
        enabled,
        userId: user.id
      },
      create: {
        type,
        config,
        enabled,
        organizationId,
        userId: user.id
      }
    });
    res.status(201).json({ success: true, data: upsertedIntegration });
  } catch (error) {
    console.error("Failed to upsert integration:", error);
    res.status(500).json({ success: false, message: "Failed to upsert integration" });
  }
});
router68.delete("/:type", async (req2, res) => {
  const user = req2.user;
  const organizationId = getEffectiveOrgId(req2);
  const { type } = req2.params;
  if (!user) {
    res.status(401).json({ success: false, message: "Unauthorized" });
    return;
  }
  if (!organizationId) {
    res.status(400).json({ success: false, message: "Organization context is missing." });
    return;
  }
  try {
    await prisma39.integrationsSettings.delete({
      where: {
        organizationId_type: {
          organizationId,
          type
        }
      }
    });
    res.status(200).json({ success: true, message: "Integration deleted successfully." });
  } catch (error) {
    if (error.code === "P2025") {
      res.status(404).json({ success: false, message: "Integration not found" });
      return;
    }
    console.error("Failed to delete integration:", error);
    res.status(500).json({ success: false, message: "Failed to delete integration" });
  }
});
router68.get("/advertising/platforms", (req2, res) => {
  res.json({
    success: true,
    platforms: Object.values(AD_PLATFORMS)
  });
});
router68.get("/advertising/env-check", (_req, res) => {
  const backendUrl = process.env.BACKEND_URL;
  const googleClientId = sanitizeClientValue(process.env.GOOGLE_ADS_CLIENT_ID);
  const googleClientSecret = sanitizeClientValue(process.env.GOOGLE_ADS_CLIENT_SECRET);
  const googleDeveloperToken = sanitizeClientValue(process.env.GOOGLE_ADS_DEVELOPER_TOKEN);
  const googleApiVersionRaw = (process.env.GOOGLE_ADS_API_VERSION || "v18").trim();
  const googleRedirect = sanitizeRedirectUri(process.env.GOOGLE_ADS_REDIRECT_URI);
  const googleManagerCustomer = normalizeGoogleAdsCustomerId(process.env.GOOGLE_ADS_MANAGER_CUSTOMER_ID);
  const googleLoginCustomer = normalizeGoogleAdsCustomerId(process.env.GOOGLE_ADS_LOGIN_CUSTOMER_ID);
  const googleWarnings = [];
  if (googleClientId.sanitized || googleClientId.looksQuoted) {
    googleWarnings.push("GOOGLE_ADS_CLIENT_ID semblait contenir des guillemets/espaces \u2014 valeur nettoy\xE9e.");
  }
  if (googleClientSecret.sanitized || googleClientSecret.looksQuoted) {
    googleWarnings.push("GOOGLE_ADS_CLIENT_SECRET semblait contenir des guillemets/espaces \u2014 valeur nettoy\xE9e.");
  }
  if (googleDeveloperToken.sanitized || googleDeveloperToken.looksQuoted) {
    googleWarnings.push("GOOGLE_ADS_DEVELOPER_TOKEN semblait contenir des guillemets/espaces \u2014 valeur nettoy\xE9e.");
  }
  if (googleRedirect.warning) {
    googleWarnings.push(googleRedirect.warning);
  }
  const metaAppId = sanitizeClientValue(process.env.META_APP_ID);
  const metaAppSecret = sanitizeClientValue(process.env.META_APP_SECRET);
  const metaRedirect = sanitizeRedirectUri(process.env.META_REDIRECT_URI);
  const metaWarnings = [];
  if (metaAppId.sanitized || metaAppId.looksQuoted) {
    metaWarnings.push("META_APP_ID semblait contenir des guillemets/espaces \u2014 valeur nettoy\xE9e.");
  }
  if (metaAppSecret.sanitized || metaAppSecret.looksQuoted) {
    metaWarnings.push("META_APP_SECRET semblait contenir des guillemets/espaces \u2014 valeur nettoy\xE9e.");
  }
  if (metaRedirect.warning) {
    metaWarnings.push(metaRedirect.warning);
  }
  const vars = {
    BACKEND_URL: !!backendUrl,
    GOOGLE_ADS_CLIENT_ID: !!googleClientId.value,
    GOOGLE_ADS_CLIENT_SECRET: !!googleClientSecret.value,
    GOOGLE_ADS_DEVELOPER_TOKEN: !!googleDeveloperToken.value,
    META_APP_ID: !!metaAppId.value,
    META_APP_SECRET: !!metaAppSecret.value
  };
  const missing = Object.entries(vars).filter(([, ok]) => !ok).map(([k]) => k);
  const maskOrNull = (value) => maskValue(value ?? void 0);
  const details = {
    backend: {
      backendUrlDefined: !!backendUrl
    },
    google: {
      clientId: {
        defined: !!googleClientId.value,
        sanitized: googleClientId.sanitized,
        looksQuoted: googleClientId.looksQuoted,
        length: googleClientId.value?.length ?? 0,
        masked: maskOrNull(googleClientId.value)
      },
      clientSecret: {
        defined: !!googleClientSecret.value,
        sanitized: googleClientSecret.sanitized,
        looksQuoted: googleClientSecret.looksQuoted,
        length: googleClientSecret.value?.length ?? 0,
        fingerprint: fingerprintSecret(googleClientSecret.value)
      },
      developerToken: {
        defined: !!googleDeveloperToken.value,
        sanitized: googleDeveloperToken.sanitized,
        looksQuoted: googleDeveloperToken.looksQuoted,
        length: googleDeveloperToken.value?.length ?? 0,
        fingerprint: fingerprintSecret(googleDeveloperToken.value),
        masked: maskOrNull(googleDeveloperToken.value)
      },
      managerCustomerId: {
        raw: process.env.GOOGLE_ADS_MANAGER_CUSTOMER_ID ?? null,
        normalized: googleManagerCustomer ?? null,
        formatted: formatGoogleAdsCustomerId(googleManagerCustomer) ?? null
      },
      loginCustomerId: {
        raw: process.env.GOOGLE_ADS_LOGIN_CUSTOMER_ID ?? null,
        normalized: googleLoginCustomer ?? null,
        formatted: formatGoogleAdsCustomerId(googleLoginCustomer) ?? null
      },
      apiVersion: {
        value: googleApiVersionRaw,
        defaultApplied: !process.env.GOOGLE_ADS_API_VERSION
      },
      redirectUri: {
        value: googleRedirect.uri,
        sanitized: googleRedirect.sanitized,
        warning: googleRedirect.warning ?? null
      }
    },
    meta: {
      appId: {
        defined: !!metaAppId.value,
        sanitized: metaAppId.sanitized,
        looksQuoted: metaAppId.looksQuoted,
        length: metaAppId.value?.length ?? 0,
        masked: maskOrNull(metaAppId.value)
      },
      appSecret: {
        defined: !!metaAppSecret.value,
        sanitized: metaAppSecret.sanitized,
        looksQuoted: metaAppSecret.looksQuoted,
        length: metaAppSecret.value?.length ?? 0,
        fingerprint: fingerprintSecret(metaAppSecret.value)
      },
      redirectUri: {
        value: metaRedirect.uri,
        sanitized: metaRedirect.sanitized,
        warning: metaRedirect.warning ?? null
      }
    }
  };
  res.json({
    success: true,
    vars,
    missing,
    ready: missing.length === 0,
    warnings: [...googleWarnings, ...metaWarnings],
    details
  });
});
router68.get("/advertising", async (req2, res) => {
  try {
    const organizationId = getEffectiveOrgId(req2);
    if (!organizationId) {
      return res.status(400).json({ error: "Organisation requise" });
    }
    const integrations = await AdPlatformService.getIntegrations(organizationId);
    res.json({
      success: true,
      integrations
    });
  } catch (error) {
    console.error("Erreur r\xE9cup\xE9ration int\xE9grations publicitaires:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router68.get("/advertising/oauth/:platform/url", async (req2, res) => {
  try {
    const platform = req2.params.platform;
    const user = req2.user;
    const organizationId = getEffectiveOrgId(req2);
    if (!user || !organizationId) {
      return res.status(401).json({ success: false, message: "Auth requise" });
    }
    const stateObj = {
      platform,
      organizationId,
      userId: user.userId,
      ts: Date.now()
    };
    const stateRaw = JSON.stringify(stateObj);
    const stateEncoded = Buffer.from(stateRaw, "utf8").toString("base64url");
    if (platform === "google_ads") {
      const idSan = sanitizeClientValue(process.env.GOOGLE_ADS_CLIENT_ID);
      const secretSan = sanitizeClientValue(process.env.GOOGLE_ADS_CLIENT_SECRET || "");
      const clientId = idSan.value;
      const clientSecret = secretSan.value || "";
      const { uri: redirectUri, warning } = sanitizeRedirectUri(process.env.GOOGLE_ADS_REDIRECT_URI);
      if (!clientId) {
        const missing = ["GOOGLE_ADS_CLIENT_ID"];
        const backend = (process.env.BACKEND_URL || process.env.API_URL || "").trim() || "http://localhost:4000";
        const demoUrl = `${backend}/api/integrations/advertising/oauth/google_ads/demo?missing=${encodeURIComponent(missing.join(","))}`;
        return res.json({ success: true, platform, demo: true, requiredEnv: missing, authUrl: demoUrl, message: "Mode d\xE9mo: variables d'environnement manquantes" });
      }
      try {
        const oauth2 = new import_googleapis9.google.auth.OAuth2(clientId, clientSecret, redirectUri);
        const authUrl = oauth2.generateAuthUrl({
          access_type: "offline",
          prompt: "consent",
          scope: ["https://www.googleapis.com/auth/adwords"],
          state: stateEncoded
        });
        const masked = clientId.length > 8 ? clientId.slice(0, 4) + "..." + clientId.slice(-4) : "defined";
        const warns = [];
        if (warning) warns.push(warning);
        if (idSan.sanitized || idSan.looksQuoted) warns.push("GOOGLE_ADS_CLIENT_ID semblait contenir des guillemets/espaces \u2014 valeur nettoy\xE9e");
        if (secretSan.sanitized || secretSan.looksQuoted) warns.push("GOOGLE_ADS_CLIENT_SECRET semblait contenir des guillemets/espaces \u2014 valeur nettoy\xE9e");
        console.log(`[ADS OAUTH] G\xE9n\xE9ration URL Google Ads OAuth | clientId=${masked} | redirectUri=${redirectUri}`);
        return res.json({ success: true, platform, authUrl, warnings: warns });
      } catch (err) {
        console.error("Erreur g\xE9n\xE9ration URL OAuth Google Ads:", err);
        return res.status(500).json({ success: false, message: "Erreur g\xE9n\xE9ration URL OAuth (Google Ads)" });
      }
    }
    if (platform === "meta_ads") {
      const appId = process.env.META_APP_ID;
      const redirectUri = process.env.META_REDIRECT_URI || "https://localhost:3000/";
      if (!appId) {
        const missing = ["META_APP_ID"];
        const backend = (process.env.BACKEND_URL || process.env.API_URL || "").trim() || "http://localhost:4000";
        const demoUrl = `${backend}/api/integrations/advertising/oauth/meta_ads/demo?missing=${encodeURIComponent(missing.join(","))}`;
        return res.json({ success: true, platform, demo: true, requiredEnv: missing, authUrl: demoUrl, message: "Mode d\xE9mo: variables d'environnement manquantes" });
      }
      const basicScope = "public_profile";
      const scope = encodeURIComponent(basicScope);
      if (redirectUri === "https://www.facebook.com/connect/login_success.html") {
        const authUrl = `https://www.facebook.com/v18.0/dialog/oauth?client_id=${appId}&redirect_uri=${encodeURIComponent(redirectUri)}&response_type=code&scope=${scope}&state=${encodeURIComponent(stateRaw)}&display=popup`;
        return res.json({
          success: true,
          platform,
          authUrl,
          usePopup: true,
          message: "Utilisation de l'URI Facebook universelle avec popup"
        });
      } else {
        const authUrl = `https://www.facebook.com/v18.0/dialog/oauth?client_id=${appId}&redirect_uri=${encodeURIComponent(redirectUri)}&response_type=code&scope=${scope}&state=${encodeURIComponent(stateRaw)}`;
        return res.json({ success: true, platform, authUrl });
      }
    }
    return res.status(400).json({ success: false, message: "Plateforme non support\xE9e" });
  } catch (error) {
    console.error("Erreur oauth url:", error);
    res.status(500).json({ success: false, message: "Erreur g\xE9n\xE9ration URL OAuth" });
  }
});
router68.get("/advertising/oauth/google_ads/debug", async (req2, res) => {
  try {
    const user = req2.user;
    const organizationId = getEffectiveOrgId(req2);
    if (!user || !organizationId) {
      return res.status(401).json({ success: false, message: "Auth requise" });
    }
    const idSan = sanitizeClientValue(process.env.GOOGLE_ADS_CLIENT_ID || "");
    const secretSan = sanitizeClientValue(process.env.GOOGLE_ADS_CLIENT_SECRET || "");
    const clientId = idSan.value || "";
    const clientSecret = secretSan.value || "";
    const { uri: redirectUri, warning: redirectWarning } = sanitizeRedirectUri(process.env.GOOGLE_ADS_REDIRECT_URI);
    const masked = clientId ? clientId.length > 8 ? clientId.slice(0, 4) + "..." + clientId.slice(-4) : "defined" : "MISSING";
    const warnings = [];
    if (!clientId) warnings.push("GOOGLE_ADS_CLIENT_ID manquant");
    if (!redirectUri) warnings.push("Redirect URI manquant");
    if (redirectWarning) warnings.push(redirectWarning);
    if (idSan.sanitized || idSan.looksQuoted) warnings.push("GOOGLE_ADS_CLIENT_ID semblait contenir des guillemets/espaces \u2014 valeur nettoy\xE9e");
    if (secretSan.sanitized || secretSan.looksQuoted) warnings.push("GOOGLE_ADS_CLIENT_SECRET semblait contenir des guillemets/espaces \u2014 valeur nettoy\xE9e");
    const defaultScopes = ["https://www.googleapis.com/auth/adwords"];
    const testScopes = ["openid", "email", "profile"];
    let authUrl = null;
    let testAuthUrl = null;
    try {
      if (clientId) {
        const stateRaw = JSON.stringify({ platform: "google_ads", organizationId, userId: user.userId, ts: Date.now() });
        const oauth2 = new import_googleapis9.google.auth.OAuth2(clientId, clientSecret, redirectUri);
        authUrl = oauth2.generateAuthUrl({ access_type: "offline", prompt: "consent", scope: defaultScopes, state: stateRaw });
        testAuthUrl = oauth2.generateAuthUrl({ access_type: "offline", prompt: "consent", scope: testScopes, state: stateRaw });
      }
    } catch (e) {
      warnings.push("Erreur lors de la g\xE9n\xE9ration de l'URL OAuth: " + e.message);
    }
    return res.json({
      success: true,
      platform: "google_ads",
      clientIdMasked: masked,
      clientSecretFingerprint: fingerprintSecret(clientSecret),
      clientSecretLength: clientSecret ? clientSecret.length : 0,
      clientSecretStartsWithGOCSPX: clientSecret ? clientSecret.startsWith("GOCSPX-") : false,
      redirectUri,
      scope: defaultScopes,
      testScopes,
      organizationId,
      userId: user.userId,
      authUrl,
      testAuthUrl,
      warnings
    });
  } catch (error) {
    console.error("Erreur debug OAuth Google Ads:", error);
    res.status(500).json({ success: false, message: "Erreur serveur (debug OAuth)" });
  }
});
router68.get("/advertising/oauth/:platform/demo", (req2, res) => {
  const platform = req2.params.platform;
  const missing = String(req2.query.missing || "").split(",").filter(Boolean);
  const platformLabel = platform === "google_ads" ? "Google Ads" : platform === "meta_ads" ? "Meta Ads" : platform;
  res.setHeader("Content-Type", "text/html; charset=utf-8");
  res.send(`<!doctype html>
  <html lang="fr">
    <head>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>Mode d\xE9mo \u2014 OAuth non configur\xE9</title>
      <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; padding: 24px; color: #0f172a; }
        .card { max-width: 720px; margin: 0 auto; border: 1px solid #e2e8f0; border-radius: 12px; padding: 20px; box-shadow: 0 10px 18px rgba(2,6,23,0.06); }
        h1 { font-size: 20px; margin: 0 0 8px; }
        .muted { color: #475569; }
        code { background: #f1f5f9; padding: 2px 6px; border-radius: 6px; }
        ul { margin: 8px 0 16px 22px; }
        .actions { display: flex; gap: 8px; }
        button { padding: 8px 12px; border-radius: 8px; border: 1px solid #cbd5e1; background: white; cursor: pointer; }
        button.primary { background: #2563eb; color: white; border-color: #2563eb; }
      </style>
    </head>
    <body>
      <div class="card">
        <h1>Mode d\xE9mo \u2014 ${platformLabel} OAuth non configur\xE9</h1>
  <p class="muted">Pour activer l'authentification ${platformLabel}, d\xE9finissez les variables d'environnement suivantes c\xF4t\xE9 serveur :</p>
        ${missing.length ? `<ul>${missing.map((v) => `<li><code>${v}</code></li>`).join("")}</ul>` : ""}
        <p class="muted">Apr\xE8s configuration, relancez l'API puis r\xE9essayez. Cette fen\xEAtre se fermera automatiquement.</p>
        <div class="actions">
          <button class="primary" id="close">Fermer maintenant</button>
        </div>
      </div>
      <script>
        const notify = () => { try { window.opener && window.opener.postMessage({ type: 'ads_oauth_done', platform: '${platform}', demo: true }, '*'); } catch (e) {} };
        document.getElementById('close').addEventListener('click', () => { notify(); window.close(); });
        setTimeout(() => { notify(); window.close(); }, 1600);
      </script>
    </body>
  </html>`);
});
router68.get("/advertising/:platform/accounts", async (req2, res) => {
  try {
    const platform = req2.params.platform;
    const organizationId = getEffectiveOrgId(req2);
    if (!organizationId) return res.status(400).json({ success: false, message: "Organisation requise" });
    let integration = await prisma39.adPlatformIntegration.findFirst({ where: { organizationId, platform } });
    if (!integration) {
      return res.json({ success: true, platform, integration: null, accounts: [], note: "Aucune int\xE9gration configur\xE9e" });
    }
    if (platform === "google_ads") {
      const devTokenSan = sanitizeClientValue(process.env.GOOGLE_ADS_DEVELOPER_TOKEN || "");
      const devToken = devTokenSan.value || "";
      const idSan = sanitizeClientValue(process.env.GOOGLE_ADS_CLIENT_ID || "");
      const secretSan = sanitizeClientValue(process.env.GOOGLE_ADS_CLIENT_SECRET || "");
      const clientId = idSan.value || "";
      const clientSecret = secretSan.value || "";
      const { uri: redirectUri } = sanitizeRedirectUri(process.env.GOOGLE_ADS_REDIRECT_URI);
      const creds = integration.credentials;
      const cfg = integration.config;
      const loginCustomerIdSelected = normalizeGoogleAdsCustomerId(cfg?.selectedAccount?.id);
      const loginCustomerIdSelectedFormatted = formatGoogleAdsCustomerId(loginCustomerIdSelected);
      const envLoginCandidatesRaw = [
        process.env.GOOGLE_ADS_MANAGER_CUSTOMER_ID,
        process.env.GOOGLE_ADS_LOGIN_CUSTOMER_ID,
        process.env.GOOGLE_ADS_MANAGER_ID
      ];
      const envLoginCandidates = envLoginCandidatesRaw.map((value) => normalizeGoogleAdsCustomerId(value)).filter((value) => Boolean(value));
      const loginCustomerCandidates = Array.from(
        new Set([loginCustomerIdSelected, ...envLoginCandidates].filter((value) => Boolean(value)))
      );
      const sendLoginOnListEnv = (() => {
        const v = String(process.env.GOOGLE_ADS_LIST_SEND_LOGIN_CUSTOMER || "").trim().toLowerCase();
        return v === "1" || v === "true" || v === "yes";
      })();
      const loginRequirementKey = `ads.accounts.force-login:${organizationId}`;
      const forcedLoginFromCache = cacheGet(loginRequirementKey) === true;
      const primaryCandidate = loginCustomerCandidates[0];
      const shouldSendLoginHeaderFirst = Boolean(primaryCandidate) && (sendLoginOnListEnv || forcedLoginFromCache || Boolean(loginCustomerIdSelected));
      const primaryLoginCustomerId = shouldSendLoginHeaderFirst ? primaryCandidate : void 0;
      const cloneIntegrationCredentials = () => {
        const raw = integration?.credentials;
        if (!raw || typeof raw !== "object" || Array.isArray(raw)) {
          return raw && typeof raw === "object" ? { ...raw } : null;
        }
        return { ...raw };
      };
      const credentialsForSuccess = () => {
        const clone = cloneIntegrationCredentials();
        if (!clone) return void 0;
        let mutated = false;
        if (Object.prototype.hasOwnProperty.call(clone, "userError")) {
          delete clone.userError;
          mutated = true;
        }
        if (Object.prototype.hasOwnProperty.call(clone, "error")) {
          delete clone.error;
          mutated = true;
        }
        return mutated ? clone : void 0;
      };
      const credentialsForError = (userError) => {
        const clone = cloneIntegrationCredentials() ?? {};
        let mutated = false;
        if (userError && clone.userError !== userError) {
          clone.userError = userError;
          mutated = true;
        }
        return mutated ? clone : void 0;
      };
      const markIntegrationStatus = async (status, userError) => {
        if (!integration) return;
        const data = {
          status,
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (status === "connected") {
          data.lastSync = /* @__PURE__ */ new Date();
          const sanitized2 = credentialsForSuccess();
          if (sanitized2) data.credentials = sanitized2;
        } else if (status === "error") {
          const credsWithError = credentialsForError(userError);
          if (credsWithError) data.credentials = credsWithError;
        }
        const updated = await prisma39.adPlatformIntegration.update({
          where: { id: integration.id },
          data
        });
        integration = updated;
      };
      const tokensRaw = creds && typeof creds === "object" && "tokens" in creds ? creds["tokens"] : void 0;
      const storedTokens = tokensRaw && typeof tokensRaw === "object" ? tokensRaw : {};
      const warnings = [];
      if (!devToken) warnings.push("GOOGLE_ADS_DEVELOPER_TOKEN manquant \u2014 requ\xEAtes Google Ads refus\xE9es");
      if (devTokenSan.sanitized || devTokenSan.looksQuoted) warnings.push("GOOGLE_ADS_DEVELOPER_TOKEN semblait contenir des guillemets/espaces \u2014 valeur nettoy\xE9e");
      if (!clientId || !clientSecret) warnings.push("Client OAuth Google Ads incomplet \u2014 rafra\xEEchissement du token impossible");
      let accessToken = storedTokens.access_token;
      const refreshToken = storedTokens.refresh_token;
      try {
        if ((!accessToken || storedTokens.expiry_date) && clientId && clientSecret && (refreshToken || storedTokens.expiry_date)) {
          const oauth2 = new import_googleapis9.google.auth.OAuth2(clientId, clientSecret, redirectUri);
          oauth2.setCredentials({
            access_token: storedTokens.access_token,
            refresh_token: storedTokens.refresh_token,
            expiry_date: storedTokens.expiry_date,
            token_type: storedTokens.token_type,
            scope: storedTokens.scope
          });
          const tk = await oauth2.getAccessToken();
          accessToken = tk?.token || oauth2.credentials.access_token || accessToken;
        }
      } catch {
        warnings.push("\xC9chec du rafra\xEEchissement de l\u2019access token \u2014 tentative avec le token stock\xE9");
      }
      if (!accessToken) {
        return res.json({ success: true, platform, integration, accounts: [], warnings, disabledReason: "missing_access_token", message: "Access token indisponible", connectionState: "disconnected" });
      }
      if (!devToken) {
        return res.json({ success: true, platform, integration, accounts: [], warnings, disabledReason: "missing_developer_token", message: "Developer token manquant", connectionState: "disconnected" });
      }
      const candidateApiVersions = (() => {
        const envValue = (process.env.GOOGLE_ADS_API_VERSION || "").trim();
        const defaults = ["v19", "v18", "v17"];
        const ordered = envValue ? [envValue, ...defaults] : defaults;
        return Array.from(new Set(ordered)).filter(Boolean);
      })();
      const unsupportedVersions = [];
      const extractGoogleAdsError = (err) => {
        const ax = err;
        const data = ax?.response?.data;
        const apiError = data?.error;
        const apiMsg = apiError?.message || "Erreur Google Ads API";
        const apiStatus = apiError?.status || "UNKNOWN";
        const detailMsgs = [];
        const errorCodeKeys = [];
        try {
          const detailsArr = Array.isArray(apiError?.details) ? apiError.details : [];
          for (const d of detailsArr) {
            const dA = d;
            const dB = d;
            const errorsContainer = Array.isArray(dA?.errors) ? dA.errors : Array.isArray(dB?.data?.errors) ? dB.data?.errors : [];
            for (const e of errorsContainer) {
              if (e?.message) detailMsgs.push(String(e.message));
              const ec = e?.errorCode;
              if (ec && typeof ec === "object") {
                for (const k of Object.keys(ec)) {
                  const val = ec[k];
                  if (val) errorCodeKeys.push(`${k}:${String(val)}`);
                }
              }
            }
          }
        } catch {
        }
        const apiErrorSummary = `${apiStatus}: ${apiMsg}${detailMsgs.length ? " \u2014 " + detailMsgs[0] : ""}`;
        return { data, apiErrorSummary, apiStatus, errorCodeKeys };
      };
      const buildCacheKeyBase = (apiVersion, loginCustomerId, headerFormat) => {
        const loginKey = loginCustomerId ?? "none";
        const formatKey = headerFormat ?? "none";
        return `ads.accounts:${organizationId}:${apiVersion}:${loginKey}:${formatKey}:${fingerprintSecret(devToken) || "no-dev"}`;
      };
      const runWithApiVersion = async (apiVersion) => {
        const cacheTtlSuccessMs = 3e4;
        const cacheTtlErrorMs = 2e4;
        const attemptList = async (loginCustomerId, allowCacheRead = true, options) => {
          const headerFormat = options?.headerFormat ?? "digits";
          const sanitizedLoginForKey = normalizeGoogleAdsCustomerId(loginCustomerId);
          const cacheKeyBase = buildCacheKeyBase(apiVersion, sanitizedLoginForKey ?? loginCustomerId, headerFormat);
          const cacheKeyOk = cacheKeyBase;
          const cacheKeyErr = `${cacheKeyBase}:error`;
          if (allowCacheRead) {
            const cachedOk = cacheGet(cacheKeyOk);
            if (cachedOk) {
              const headerFmtDiag = cachedOk?.diagnostics?.loginCustomerHeaderFormatUsed;
              const headerFormatFromCache = headerFmtDiag === "formatted" || headerFmtDiag === "raw" || headerFmtDiag === "digits" ? headerFmtDiag : "none";
              return {
                type: "success",
                payload: { ...cachedOk, cached: true },
                loginCustomerId: sanitizedLoginForKey ?? loginCustomerId,
                headerFormatUsed: headerFormatFromCache,
                fromCache: true,
                cacheKeyBase,
                cacheKeyUsed: cacheKeyOk,
                apiVersion
              };
            }
            const cachedErr = cacheGet(cacheKeyErr);
            if (cachedErr) {
              const cachedStatus = typeof cachedErr.apiStatus === "string" ? cachedErr.apiStatus : "UNKNOWN";
              const headerFmtDiag = cachedErr?.diagnostics?.loginCustomerHeaderFormatUsed;
              const headerFormatFromCache = headerFmtDiag === "formatted" || headerFmtDiag === "raw" || headerFmtDiag === "digits" ? headerFmtDiag : "none";
              return {
                type: "error",
                payload: { ...cachedErr, cached: true },
                apiStatus: cachedStatus,
                loginCustomerId: sanitizedLoginForKey ?? loginCustomerId,
                headerFormatUsed: headerFormatFromCache,
                fromCache: true,
                cacheKeyBase,
                cacheKeyUsed: cacheKeyErr,
                apiVersion
              };
            }
          }
          const url = `https://googleads.googleapis.com/${apiVersion}/customers:listAccessibleCustomers`;
          const headers = {
            Authorization: `Bearer ${accessToken}`,
            "developer-token": devToken,
            Accept: "application/json"
          };
          const sanitizedLoginHeader = sanitizedLoginForKey;
          const formattedLoginHeader = sanitizedLoginHeader ? formatGoogleAdsCustomerId(sanitizedLoginHeader) : void 0;
          const rawLoginHeader = typeof loginCustomerId === "string" ? loginCustomerId.trim() : void 0;
          const loginHeaderValue = (() => {
            if (headerFormat === "formatted") return formattedLoginHeader;
            if (headerFormat === "raw") return rawLoginHeader;
            return sanitizedLoginHeader;
          })();
          const loginHeaderSent = Boolean(loginHeaderValue);
          if (loginHeaderSent && loginHeaderValue) {
            headers["login-customer-id"] = loginHeaderValue;
          }
          try {
            const resp = await import_axios3.default.get(url, { headers });
            const names = resp.data?.resourceNames || resp.data?.resource_names || [];
            const accounts = names.map((rn) => {
              const m = String(rn).match(/customers\/(\d+)/);
              return { id: m ? m[1] : rn };
            });
            const payload = {
              success: true,
              platform,
              integration,
              accounts,
              warnings: [...warnings],
              diagnostics: {
                loginCustomerIdSelected,
                loginCustomerIdSelectedFormatted,
                loginCustomerHeaderSent: loginHeaderSent,
                loginCustomerAttempted: sanitizedLoginHeader ?? null,
                loginCustomerAttemptFormatted: sanitizedLoginHeader ? formatGoogleAdsCustomerId(sanitizedLoginHeader) : null,
                loginCustomerAttemptRaw: rawLoginHeader ?? null,
                loginCustomerHeaderValue: loginHeaderValue ?? null,
                loginCustomerHeaderFormatUsed: loginHeaderSent ? headerFormat : "none",
                loginHeaderSource: sanitizedLoginHeader ? sanitizedLoginHeader === loginCustomerIdSelected ? "selected_account" : envLoginCandidates.includes(sanitizedLoginHeader) ? "environment" : "manual" : null,
                apiVersion,
                availableLoginCustomerCandidates: loginCustomerCandidates,
                forcedLoginHeader: forcedLoginFromCache,
                fallbackTriggered: false
              },
              cached: false,
              cacheTtlMs: cacheTtlSuccessMs,
              connectionState: "connected"
            };
            cacheSet(cacheKeyOk, payload, cacheTtlSuccessMs);
            return { type: "success", payload, loginCustomerId: sanitizedLoginHeader ?? loginCustomerId, headerFormatUsed: loginHeaderSent ? headerFormat : "none", fromCache: false, cacheKeyBase, cacheKeyUsed: cacheKeyOk, apiVersion };
          } catch (error) {
            const { data, apiErrorSummary, apiStatus, errorCodeKeys } = extractGoogleAdsError(error);
            console.error("Erreur Google Ads listAccessibleCustomers:", data || error);
            console.error("Google Ads diagnostics (listAccessibleCustomers):", {
              organizationId,
              apiStatus,
              loginHeader: {
                sent: loginHeaderSent,
                valueLength: loginHeaderValue ? loginHeaderValue.length : 0,
                normalized: sanitizedLoginHeader ?? null,
                formatted: sanitizedLoginHeader ? formatGoogleAdsCustomerId(sanitizedLoginHeader) : null,
                formatUsed: loginHeaderSent ? headerFormat : "none",
                source: sanitizedLoginHeader ? sanitizedLoginHeader === loginCustomerIdSelected ? "selected_account" : envLoginCandidates.includes(sanitizedLoginHeader) ? "environment" : "manual" : null
              },
              developerToken: {
                defined: Boolean(devToken),
                fingerprint: fingerprintSecret(devToken),
                length: devToken ? devToken.length : 0
              },
              clientId: {
                defined: Boolean(clientId),
                masked: clientId ? clientId.length > 8 ? `${clientId.slice(0, 4)}...${clientId.slice(-4)}` : "defined" : "MISSING"
              },
              redirectUri,
              errorCodeKeys,
              apiVersion
            });
            const warningsForPayload = [...warnings];
            let humanHint;
            if (apiStatus === "INVALID_ARGUMENT") {
              humanHint = "INVALID_ARGUMENT re\xE7u. V\xE9rifiez GOOGLE_ADS_DEVELOPER_TOKEN (sans guillemets/espaces), l\u2019approbation API et red\xE9marrez l\u2019API apr\xE8s modification du .env.";
              if (devTokenSan.sanitized || devTokenSan.looksQuoted) {
                humanHint += " Le token a \xE9t\xE9 nettoy\xE9 automatiquement c\xF4t\xE9 serveur (indice: guillemets/espaces d\xE9tect\xE9s).";
              }
              if (!loginHeaderSent && loginCustomerCandidates.length === 0) {
                warningsForPayload.push("INVALID_ARGUMENT sans login-customer-id et aucun identifiant de repli disponible. D\xE9finissez GOOGLE_ADS_MANAGER_CUSTOMER_ID ou s\xE9lectionnez un compte Google Ads.");
              }
            }
            const payload = {
              success: true,
              platform,
              integration,
              accounts: [],
              warnings: warningsForPayload,
              apiError: data,
              apiErrorSummary,
              apiStatus,
              disabledReason: "ads_api_error",
              diagnostics: {
                apiVersion,
                devTokenFingerprint: fingerprintSecret(devToken),
                devTokenLength: devToken ? devToken.length : 0,
                clientIdMasked: idSan.value ? idSan.value.length > 8 ? idSan.value.slice(0, 4) + "..." + idSan.value.slice(-4) : "defined" : "MISSING",
                redirectUri,
                loginCustomerIdSelected,
                loginCustomerIdSelectedFormatted,
                loginCustomerHeaderSent: loginHeaderSent,
                loginCustomerAttempted: sanitizedLoginHeader ?? null,
                loginCustomerAttemptFormatted: sanitizedLoginHeader ? formatGoogleAdsCustomerId(sanitizedLoginHeader) : null,
                loginCustomerAttemptRaw: rawLoginHeader ?? null,
                loginCustomerHeaderValue: loginHeaderValue ?? null,
                loginCustomerHeaderFormatUsed: loginHeaderSent ? headerFormat : "none",
                loginHeaderSource: sanitizedLoginHeader ? sanitizedLoginHeader === loginCustomerIdSelected ? "selected_account" : envLoginCandidates.includes(sanitizedLoginHeader) ? "environment" : "manual" : null,
                availableLoginCustomerCandidates: loginCustomerCandidates,
                primaryErrorCode: errorCodeKeys[0] || null,
                errorCodeKeys,
                humanHint,
                forcedLoginHeader: forcedLoginFromCache,
                fallbackTriggered: false
              },
              cached: false,
              cacheTtlMs: cacheTtlErrorMs,
              connectionState: "error"
            };
            cacheSet(cacheKeyErr, payload, cacheTtlErrorMs);
            return { type: "error", payload, apiStatus, loginCustomerId: sanitizedLoginHeader ?? loginCustomerId, headerFormatUsed: loginHeaderSent ? headerFormat : "none", fromCache: false, cacheKeyBase, cacheKeyUsed: cacheKeyErr, apiVersion };
          }
        };
        const applyFormattedFallback = async (current, loginCustomerId, context) => {
          if (!loginCustomerId) return current;
          if (current.type === "success") return current;
          if (current.apiStatus !== "INVALID_ARGUMENT") return current;
          if (current.headerFormatUsed === "formatted") return current;
          const formattedAttempt = await attemptList(loginCustomerId, false, { headerFormat: "formatted" });
          const warningNoteSuccess = "La requ\xEAte Google Ads a abouti apr\xE8s r\xE9\xE9mission du login-customer-id au format 123-456-7890.";
          const warningNoteFailure = `Tentative suppl\xE9mentaire avec login-customer-id format\xE9 (tirets) \xE9galement en \xE9chec (${formattedAttempt.apiStatus}).`;
          const diagAugmentation = {
            formatFallbackTriggered: true,
            formatFallbackContext: context
          };
          if (formattedAttempt.type === "success") {
            formattedAttempt.payload.warnings = [...formattedAttempt.payload.warnings, warningNoteSuccess];
            formattedAttempt.payload.diagnostics = {
              ...formattedAttempt.payload.diagnostics,
              ...diagAugmentation
            };
          } else {
            formattedAttempt.payload.warnings = [...formattedAttempt.payload.warnings, warningNoteFailure];
            formattedAttempt.payload.diagnostics = {
              ...formattedAttempt.payload.diagnostics,
              ...diagAugmentation
            };
          }
          return formattedAttempt;
        };
        let initialAttempt = await attemptList(primaryLoginCustomerId, true);
        initialAttempt = await applyFormattedFallback(initialAttempt, primaryLoginCustomerId, "initial");
        if (initialAttempt.type === "success") {
          if (!initialAttempt.fromCache) {
            await markIntegrationStatus("connected");
            initialAttempt.payload.integration = integration;
            cacheSet(initialAttempt.cacheKeyUsed, initialAttempt.payload, initialAttempt.payload.cacheTtlMs);
          } else {
            initialAttempt.payload.integration = integration;
          }
          initialAttempt.payload.diagnostics = {
            ...initialAttempt.payload.diagnostics,
            apiVersion
          };
          return initialAttempt;
        }
        const shouldRetryWithLoginHeader = initialAttempt.apiStatus === "INVALID_ARGUMENT" && !primaryLoginCustomerId && loginCustomerCandidates.length > 0;
        if (shouldRetryWithLoginHeader) {
          const fallbackLoginCustomerId = loginCustomerCandidates[0];
          const fallbackLabel = formatGoogleAdsCustomerId(fallbackLoginCustomerId) ?? fallbackLoginCustomerId;
          cacheSet(loginRequirementKey, true, 10 * 60 * 1e3);
          let fallbackAttempt = await attemptList(fallbackLoginCustomerId, false);
          fallbackAttempt = await applyFormattedFallback(fallbackAttempt, fallbackLoginCustomerId, "secondary");
          if (fallbackAttempt.type === "success") {
            fallbackAttempt.payload.warnings = [
              ...fallbackAttempt.payload.warnings,
              `La requ\xEAte initiale sans login-customer-id a retourn\xE9 INVALID_ARGUMENT. Relance r\xE9ussie avec l'identifiant ${fallbackLabel}.`
            ];
            fallbackAttempt.payload.diagnostics = {
              ...fallbackAttempt.payload.diagnostics,
              fallbackTriggered: true,
              fallbackLoginCustomerId,
              fallbackLoginCustomerFormatted: fallbackLabel,
              fallbackReason: "INVALID_ARGUMENT_without_login_header",
              apiVersion
            };
            await markIntegrationStatus("connected");
            fallbackAttempt.payload.integration = integration;
            cacheSet(fallbackAttempt.cacheKeyUsed, fallbackAttempt.payload, fallbackAttempt.payload.cacheTtlMs);
            return fallbackAttempt;
          }
          fallbackAttempt.payload.warnings = [
            ...fallbackAttempt.payload.warnings,
            `La requ\xEAte initiale sans login-customer-id a retourn\xE9 INVALID_ARGUMENT. La relance avec ${fallbackLabel} a \xE9galement \xE9chou\xE9 (${fallbackAttempt.apiStatus}).`
          ];
          fallbackAttempt.payload.diagnostics = {
            ...fallbackAttempt.payload.diagnostics,
            fallbackTriggered: true,
            fallbackLoginCustomerId,
            fallbackLoginCustomerFormatted: fallbackLabel,
            fallbackReason: "INVALID_ARGUMENT_without_login_header",
            apiVersion
          };
          const fallbackErrorSummary = fallbackAttempt.payload.apiErrorSummary || fallbackAttempt.apiStatus;
          await markIntegrationStatus("error", fallbackErrorSummary);
          fallbackAttempt.payload.integration = integration;
          cacheSet(fallbackAttempt.cacheKeyUsed, fallbackAttempt.payload, fallbackAttempt.payload.cacheTtlMs);
          return fallbackAttempt;
        }
        const initialErrorSummary = initialAttempt.payload.apiErrorSummary || initialAttempt.apiStatus;
        if (!initialAttempt.fromCache) {
          await markIntegrationStatus("error", initialErrorSummary);
          initialAttempt.payload.integration = integration;
          cacheSet(initialAttempt.cacheKeyUsed, initialAttempt.payload, initialAttempt.payload.cacheTtlMs);
        } else {
          initialAttempt.payload.integration = integration;
        }
        initialAttempt.payload.diagnostics = {
          ...initialAttempt.payload.diagnostics,
          apiVersion
        };
        return initialAttempt;
      };
      let finalResult;
      for (const apiVersion of candidateApiVersions) {
        const result = await runWithApiVersion(apiVersion);
        if (result.type === "success") {
          finalResult = result;
          break;
        }
        const primaryError = result.payload?.diagnostics?.primaryErrorCode;
        if (result.apiStatus === "INVALID_ARGUMENT" && primaryError === "requestError:UNSUPPORTED_VERSION") {
          unsupportedVersions.push(apiVersion);
          continue;
        }
        finalResult = result;
        break;
      }
      if (!finalResult) {
        finalResult = await runWithApiVersion(candidateApiVersions[candidateApiVersions.length - 1] || "v18");
      }
      if (unsupportedVersions.length) {
        const diag = finalResult.payload?.diagnostics ?? {};
        finalResult.payload.diagnostics = {
          ...diag,
          unsupportedApiVersions: unsupportedVersions
        };
        finalResult.payload.warnings = [
          ...finalResult.payload.warnings || [],
          `Versions Google Ads non support\xE9es d\xE9tect\xE9es: ${unsupportedVersions.join(", ")}`
        ];
      }
      console.log("[Google Ads] R\xE9sultat listAccessibleCustomers", {
        organizationId,
        type: finalResult.type,
        apiVersion: finalResult.apiVersion,
        unsupportedVersions,
        fromCache: finalResult.fromCache
      });
      if (finalResult.type === "success") {
        if (!finalResult.fromCache) {
          await markIntegrationStatus("connected");
          finalResult.payload.integration = integration;
          cacheSet(finalResult.cacheKeyUsed, finalResult.payload, finalResult.payload.cacheTtlMs);
        } else {
          finalResult.payload.integration = integration;
        }
        return res.json(finalResult.payload);
      }
      const finalErrorSummary = finalResult.payload.apiErrorSummary || finalResult.apiStatus;
      if (!finalResult.fromCache) {
        await markIntegrationStatus("error", finalErrorSummary);
        finalResult.payload.integration = integration;
        cacheSet(finalResult.cacheKeyUsed, finalResult.payload, finalResult.payload.cacheTtlMs);
      } else {
        finalResult.payload.integration = integration;
      }
      return res.json(finalResult.payload);
    }
    if (platform === "meta_ads") {
      const appIdSan = sanitizeClientValue(process.env.META_APP_ID || "");
      const appSecretSan = sanitizeClientValue(process.env.META_APP_SECRET || "");
      const warnings = [];
      if (!appIdSan.value) warnings.push("META_APP_ID manquant \u2014 authentification Meta impossible");
      if (!appSecretSan.value) warnings.push("META_APP_SECRET manquant \u2014 \xE9changes de tokens impossibles");
      if (appIdSan.sanitized || appIdSan.looksQuoted) warnings.push("META_APP_ID semblait contenir des guillemets/espaces \u2014 valeur nettoy\xE9e");
      if (appSecretSan.sanitized || appSecretSan.looksQuoted) warnings.push("META_APP_SECRET semblait contenir des guillemets/espaces \u2014 valeur nettoy\xE9e");
      const rawCreds = integration.credentials;
      const rawAccessToken = rawCreds && typeof rawCreds === "object" ? rawCreds.accessToken : void 0;
      const trimmedAccessToken = typeof rawAccessToken === "string" ? rawAccessToken.trim() : void 0;
      const accessToken = trimmedAccessToken;
      const cloneIntegrationCredentials = () => {
        const raw = integration?.credentials;
        if (!raw || typeof raw !== "object" || Array.isArray(raw)) {
          return raw && typeof raw === "object" ? { ...raw } : null;
        }
        return { ...raw };
      };
      const credentialsForSuccess = () => {
        const clone = cloneIntegrationCredentials();
        if (!clone) return void 0;
        let mutated = false;
        if (accessToken && clone.accessToken !== accessToken) {
          clone.accessToken = accessToken;
          mutated = true;
        }
        if (Object.prototype.hasOwnProperty.call(clone, "userError")) {
          delete clone.userError;
          mutated = true;
        }
        if (Object.prototype.hasOwnProperty.call(clone, "error")) {
          delete clone.error;
          mutated = true;
        }
        return mutated ? clone : void 0;
      };
      const credentialsForError = (userError, errorCode) => {
        const clone = cloneIntegrationCredentials() ?? {};
        let mutated = false;
        if (userError && clone.userError !== userError) {
          clone.userError = userError;
          mutated = true;
        }
        if (errorCode && clone.error !== errorCode) {
          clone.error = errorCode;
          mutated = true;
        }
        return mutated ? clone : void 0;
      };
      const markIntegrationStatus = async (status, userError, errorCode) => {
        if (!integration) return;
        const data = {
          status,
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (status === "connected") {
          data.lastSync = /* @__PURE__ */ new Date();
          const sanitized2 = credentialsForSuccess();
          if (sanitized2) data.credentials = sanitized2;
        } else if (status === "error") {
          const credsWithError = credentialsForError(userError, errorCode);
          if (credsWithError) data.credentials = credsWithError;
        }
        const updated = await prisma39.adPlatformIntegration.update({
          where: { id: integration.id },
          data
        });
        integration = updated;
      };
      if (!accessToken) {
        return res.json({
          success: true,
          platform,
          integration,
          accounts: [],
          warnings,
          disabledReason: "missing_access_token",
          message: "Access token Meta Ads indisponible",
          connectionState: "disconnected"
        });
      }
      const cacheKeyBase = `meta.accounts:${organizationId}:${fingerprintSecret(accessToken) || "anon"}`;
      const cacheKeyOk = `${cacheKeyBase}:ok`;
      const cacheKeyError = `${cacheKeyBase}:error`;
      const cacheTtlSuccessMs = 3e4;
      const cacheTtlErrorMs = 2e4;
      const cachedOk = cacheGet(cacheKeyOk);
      if (cachedOk) {
        const diagnostics = cachedOk?.diagnostics && typeof cachedOk.diagnostics === "object" && !Array.isArray(cachedOk.diagnostics) ? { ...cachedOk.diagnostics, cached: true } : { cached: true };
        return res.json({ ...cachedOk, diagnostics });
      }
      const cachedErr = cacheGet(cacheKeyError);
      if (cachedErr) {
        const diagnostics = cachedErr?.diagnostics && typeof cachedErr.diagnostics === "object" && !Array.isArray(cachedErr.diagnostics) ? { ...cachedErr.diagnostics, cached: true } : { cached: true };
        return res.json({ ...cachedErr, diagnostics });
      }
      try {
        const accountsResp = await import_axios3.default.get("https://graph.facebook.com/v18.0/me/adaccounts", {
          params: {
            fields: "id,account_id,name,account_status,currency,timezone_id,business_name",
            access_token: accessToken
          }
        });
        const rawAccounts = Array.isArray(accountsResp.data?.data) ? accountsResp.data.data : [];
        const accounts = rawAccounts.map((acc) => {
          const accountId = typeof acc.account_id === "string" ? acc.account_id : void 0;
          const actId = typeof acc.id === "string" ? acc.id : accountId;
          return {
            id: actId || accountId || "unknown",
            accountId: accountId || null,
            name: typeof acc.name === "string" ? acc.name : "Compte Meta",
            status: typeof acc.account_status === "number" ? acc.account_status : acc.account_status ?? null,
            currency: typeof acc.currency === "string" ? acc.currency : null,
            timezoneId: typeof acc.timezone_id === "string" ? acc.timezone_id : null,
            businessName: typeof acc.business_name === "string" ? acc.business_name : null
          };
        });
        await markIntegrationStatus("connected");
        const payload = {
          success: true,
          platform,
          integration,
          accounts,
          warnings,
          diagnostics: {
            tokenFingerprint: fingerprintSecret(accessToken),
            accountCount: accounts.length,
            cached: false
          },
          connectionState: "connected"
        };
        cacheSet(cacheKeyOk, payload, cacheTtlSuccessMs);
        return res.json(payload);
      } catch (error) {
        const ax = error;
        const fbError = ax?.response?.data?.error;
        const fbType = fbError?.type || "MetaApiError";
        const fbMessage = fbError?.message || "Erreur Meta Ads API";
        const fbCode = typeof fbError?.code === "number" ? fbError?.code : null;
        const fbSubcode = typeof fbError?.error_subcode === "number" ? fbError?.error_subcode : null;
        const fbTraceId = fbError?.fbtrace_id || null;
        let userFriendly = fbMessage;
        if (fbCode === 190) {
          userFriendly = "Session Meta expir\xE9e \u2014 reconnectez-vous \xE0 Meta Ads.";
        } else if (fbCode === 102) {
          userFriendly = "Jeton Meta invalide \u2014 relancez l\u2019authentification.";
        }
        await markIntegrationStatus("error", userFriendly, fbType);
        const payload = {
          success: true,
          platform,
          integration,
          accounts: [],
          warnings,
          apiError: fbError,
          apiErrorSummary: `${fbType}${fbCode ? ` (${fbCode}${fbSubcode ? `/${fbSubcode}` : ""})` : ""}: ${fbMessage}`,
          disabledReason: "ads_api_error",
          connectionState: "error",
          diagnostics: {
            tokenFingerprint: fingerprintSecret(accessToken),
            appIdPresent: !!appIdSan.value,
            errorCode: fbCode,
            errorSubcode: fbSubcode,
            errorType: fbType,
            fbTraceId,
            cached: false
          }
        };
        cacheSet(cacheKeyError, payload, cacheTtlErrorMs);
        return res.json(payload);
      }
    }
    return res.json({ success: true, platform, integration, accounts: [], note: "Int\xE9gration configur\xE9e", connectionState: "unknown" });
  } catch (error) {
    console.error("Erreur listing comptes:", error);
    res.status(500).json({ success: false, message: "Erreur listing comptes" });
  }
});
router68.get("/advertising/google_ads/test/customers-get", async (req2, res) => {
  try {
    const organizationId = getEffectiveOrgId(req2);
    if (!organizationId) return res.status(400).json({ success: false, message: "Organisation requise" });
    const integ = await prisma39.adPlatformIntegration.findFirst({ where: { organizationId, platform: "google_ads" } });
    if (!integ) return res.status(404).json({ success: false, message: "Int\xE9gration Google Ads manquante" });
    const devTokenSan = sanitizeClientValue(process.env.GOOGLE_ADS_DEVELOPER_TOKEN || "");
    const devToken = devTokenSan.value || "";
    const idSan = sanitizeClientValue(process.env.GOOGLE_ADS_CLIENT_ID || "");
    const secretSan = sanitizeClientValue(process.env.GOOGLE_ADS_CLIENT_SECRET || "");
    const clientId = idSan.value || "";
    const clientSecret = secretSan.value || "";
    const { uri: redirectUri } = sanitizeRedirectUri(process.env.GOOGLE_ADS_REDIRECT_URI);
    const qCustomerId = String(req2.query.customerId || "").trim();
    const normalizedCustomerId = qCustomerId.replace(/[^0-9]/g, "");
    const apiVersion = String(req2.query.apiVersion || process.env.GOOGLE_ADS_API_VERSION || "v18").trim();
    const withLoginHeader = String(req2.query.withLoginHeader || "").toLowerCase();
    const sendLoginHeader = withLoginHeader === "1" || withLoginHeader === "true" || withLoginHeader === "yes";
    const warnings = [];
    if (!normalizedCustomerId || normalizedCustomerId.length < 8) return res.status(400).json({ success: false, message: "Param\xE8tre customerId invalide" });
    if (!devToken) warnings.push("GOOGLE_ADS_DEVELOPER_TOKEN manquant \u2014 requ\xEAtes Google Ads refus\xE9es");
    if (devTokenSan.sanitized || devTokenSan.looksQuoted) warnings.push("GOOGLE_ADS_DEVELOPER_TOKEN semblait contenir des guillemets/espaces \u2014 valeur nettoy\xE9e");
    if (!clientId || !clientSecret) warnings.push("Client OAuth Google Ads incomplet \u2014 rafra\xEEchissement du token impossible");
    const creds = integ.credentials;
    const tokensRaw = creds && typeof creds === "object" && "tokens" in creds ? creds["tokens"] : void 0;
    const storedTokens = tokensRaw && typeof tokensRaw === "object" ? tokensRaw : {};
    let accessToken = storedTokens.access_token;
    const refreshToken = storedTokens.refresh_token;
    try {
      if ((!accessToken || storedTokens.expiry_date) && clientId && clientSecret && (refreshToken || storedTokens.expiry_date)) {
        const oauth2 = new import_googleapis9.google.auth.OAuth2(clientId, clientSecret, redirectUri);
        oauth2.setCredentials({
          access_token: storedTokens.access_token,
          refresh_token: storedTokens.refresh_token,
          expiry_date: storedTokens.expiry_date,
          token_type: storedTokens.token_type,
          scope: storedTokens.scope
        });
        const tk = await oauth2.getAccessToken();
        accessToken = tk?.token || oauth2.credentials.access_token || accessToken;
      }
    } catch {
      warnings.push("\xC9chec du rafra\xEEchissement de l\u2019access token \u2014 tentative avec le token stock\xE9");
    }
    if (!accessToken) {
      return res.json({ success: true, test: "customers.get", customerId: normalizedCustomerId, warnings, disabledReason: "missing_access_token" });
    }
    if (!devToken) {
      return res.json({ success: true, test: "customers.get", customerId: normalizedCustomerId, warnings, disabledReason: "missing_developer_token" });
    }
    const url = `https://googleads.googleapis.com/${apiVersion}/customers/${normalizedCustomerId}`;
    const headers = {
      Authorization: `Bearer ${accessToken}`,
      "developer-token": devToken,
      Accept: "application/json"
    };
    const loginHeaderSent = !!(sendLoginHeader && normalizedCustomerId);
    if (loginHeaderSent) headers["login-customer-id"] = normalizedCustomerId;
    try {
      const resp = await import_axios3.default.get(url, { headers });
      return res.json({
        success: true,
        test: "customers.get",
        customerId: normalizedCustomerId,
        apiVersion,
        loginCustomerHeaderSent: loginHeaderSent,
        warnings,
        data: resp.data
      });
    } catch (error) {
      const ax = error;
      const data = ax?.response?.data;
      const apiError = data?.error;
      const apiMsg = apiError?.message || "Erreur Google Ads API";
      const apiStatus = apiError?.status || "UNKNOWN";
      const detailMsgs = [];
      const errorCodeKeys = [];
      try {
        const detailsArr = Array.isArray(apiError?.details) ? apiError.details : [];
        for (const d of detailsArr) {
          const dA = d;
          const dB = d;
          const errorsContainer = Array.isArray(dA?.errors) ? dA.errors : Array.isArray(dB?.data?.errors) ? dB.data?.errors : [];
          for (const e of errorsContainer) {
            if (e?.message) detailMsgs.push(String(e.message));
            const ec = e?.errorCode;
            if (ec && typeof ec === "object") {
              for (const k of Object.keys(ec)) {
                const val = ec[k];
                if (val) errorCodeKeys.push(`${k}:${String(val)}`);
              }
            }
          }
        }
      } catch {
      }
      const apiErrorSummary = `${apiStatus}: ${apiMsg}${detailMsgs.length ? " \u2014 " + detailMsgs[0] : ""}`;
      return res.json({
        success: true,
        test: "customers.get",
        customerId: normalizedCustomerId,
        apiVersion,
        loginCustomerHeaderSent: loginHeaderSent,
        warnings,
        apiError: data,
        apiErrorSummary,
        diagnostics: {
          devTokenFingerprint: fingerprintSecret(devToken),
          devTokenLength: devToken ? devToken.length : 0,
          clientIdMasked: idSan.value ? idSan.value.length > 8 ? idSan.value.slice(0, 4) + "..." + idSan.value.slice(-4) : "defined" : "MISSING",
          redirectUri,
          primaryErrorCode: errorCodeKeys[0] || null,
          errorCodeKeys
        }
      });
    }
  } catch (error) {
    console.error("Erreur test customers.get:", error);
    res.status(500).json({ success: false, message: "Erreur test customers.get" });
  }
});
router68.delete("/advertising/:platform", async (req2, res) => {
  const user = req2.user;
  const organizationId = getEffectiveOrgId(req2);
  const platform = req2.params.platform;
  if (!user) {
    res.status(401).json({ success: false, message: "Unauthorized" });
    return;
  }
  if (!organizationId) {
    res.status(400).json({ success: false, message: "Organization context is missing." });
    return;
  }
  try {
    const deleted = await prisma39.adPlatformIntegration.deleteMany({
      where: {
        organizationId,
        platform
      }
    });
    if (deleted.count === 0) {
      res.status(404).json({ success: false, message: "Integration not found" });
      return;
    }
    res.status(200).json({ success: true, message: `Int\xE9gration ${platform} supprim\xE9e avec succ\xE8s` });
  } catch (error) {
    console.error("Failed to delete platform integration:", error);
    res.status(500).json({ success: false, message: "Failed to delete integration" });
  }
});
router68.post("/advertising/:platform/select-account", async (req2, res) => {
  try {
    const platform = req2.params.platform;
    const organizationId = getEffectiveOrgId(req2);
    if (!organizationId) return res.status(400).json({ success: false, message: "Organisation requise" });
    const { account } = req2.body;
    if (!account || !account.id) {
      return res.status(400).json({ success: false, message: "Compte invalide" });
    }
    const integ = await prisma39.adPlatformIntegration.findFirst({ where: { organizationId, platform } });
    if (!integ) return res.status(404).json({ success: false, message: "Int\xE9gration non trouv\xE9e" });
    const currentConfig = integ.config;
    const newConfig = { ...currentConfig || {}, selectedAccount: { id: account.id, name: account.name, currency: account.currency } };
    let newName = integ.name;
    const genericNames = /* @__PURE__ */ new Set(["google_ads", "meta_ads", "Google Ads OAuth", "Meta Ads OAuth"]);
    if (!newName || genericNames.has(newName)) {
      newName = `${platform} - ${account.name || account.id}`;
    }
    await prisma39.adPlatformIntegration.update({
      where: { id: integ.id },
      data: { config: newConfig, name: newName, updatedAt: /* @__PURE__ */ new Date() }
    });
    return res.json({ success: true, platform, selectedAccount: { id: account.id, name: account.name, currency: account.currency } });
  } catch (error) {
    console.error("Erreur select account:", error);
    res.status(500).json({ success: false, message: "Erreur s\xE9lection compte" });
  }
});
router68.post("/advertising", async (req2, res) => {
  try {
    const organizationId = getEffectiveOrgId(req2);
    if (!organizationId) {
      return res.status(400).json({ error: "Organisation requise" });
    }
    const { platform, name, config, credentials } = req2.body;
    if (!platform || !name || !config || !credentials) {
      return res.status(400).json({
        error: "Plateforme, nom, configuration et identifiants requis"
      });
    }
    if (!AD_PLATFORMS[platform]) {
      return res.status(400).json({
        error: "Plateforme publicitaire non support\xE9e"
      });
    }
    const integration = await AdPlatformService.createIntegration(
      organizationId,
      platform,
      name,
      config,
      credentials
    );
    res.status(201).json({
      success: true,
      integration
    });
  } catch (error) {
    console.error("Erreur cr\xE9ation int\xE9gration publicitaire:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router68.get("/ecommerce/platforms", (req2, res) => {
  res.json({
    success: true,
    platforms: Object.values(ECOMMERCE_PLATFORMS)
  });
});
router68.get("/ecommerce", async (req2, res) => {
  try {
    const organizationId = getEffectiveOrgId(req2);
    if (!organizationId) {
      return res.status(400).json({ error: "Organisation requise" });
    }
    const integrations = await EcommerceService.getIntegrations(organizationId);
    res.json({
      success: true,
      integrations
    });
  } catch (error) {
    console.error("Erreur r\xE9cup\xE9ration int\xE9grations e-commerce:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router68.post("/ecommerce", async (req2, res) => {
  try {
    const organizationId = getEffectiveOrgId(req2);
    if (!organizationId) {
      return res.status(400).json({ error: "Organisation requise" });
    }
    const { platform, name, url, config, credentials } = req2.body;
    if (!platform || !name || !url || !config || !credentials) {
      return res.status(400).json({
        error: "Plateforme, nom, URL, configuration et identifiants requis"
      });
    }
    if (!ECOMMERCE_PLATFORMS[platform]) {
      return res.status(400).json({
        error: "Plateforme e-commerce non support\xE9e"
      });
    }
    const integration = await EcommerceService.createIntegration(
      organizationId,
      platform,
      name,
      url,
      config,
      credentials
    );
    res.status(201).json({
      success: true,
      integration
    });
  } catch (error) {
    console.error("Erreur cr\xE9ation int\xE9gration e-commerce:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
var integrations_default = router68;

// src/routes/publicLeads.ts
var import_express70 = require("express");
var import_express_rate_limit14 = require("express-rate-limit");
var import_express_validator = require("express-validator");
init_database();
var router69 = (0, import_express70.Router)();
var prisma40 = db;
var geminiService2 = getGeminiService();
var publicRateLimit = (0, import_express_rate_limit14.rateLimit)({
  windowMs: 15 * 60 * 1e3,
  // 15 minutes
  max: 10,
  // Max 10 requ√™tes par IP par fen√™tre
  message: {
    error: "Trop de requ\xEAtes. Veuillez patienter avant de r\xE9essayer.",
    retryAfter: "15 minutes"
  },
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req2, res) => {
    console.log(`[RATE-LIMIT] IP bloqu\xE9e: ${req2.ip}`);
    res.status(429).json({
      error: "Trop de requ\xEAtes. Veuillez patienter avant de r\xE9essayer.",
      retryAfter: "15 minutes"
    });
  }
});
var leadCreationLimit = (0, import_express_rate_limit14.rateLimit)({
  windowMs: 5 * 60 * 1e3,
  // 5 minutes
  max: 3,
  // Max 3 leads par IP par 5 minutes
  message: {
    error: "Limite de cr\xE9ation de demandes atteinte. Veuillez patienter.",
    retryAfter: "5 minutes"
  },
  standardHeaders: true,
  legacyHeaders: false
});
var validateLead = [
  (0, import_express_validator.body)("projectType").isIn(["website", "ecommerce", "app", "branding", "marketing", "consulting", "other"]).withMessage("Type de projet invalide"),
  (0, import_express_validator.body)("projectDescription").isLength({ min: 10, max: 1e3 }).withMessage("Description du projet entre 10 et 1000 caract\xE8res"),
  (0, import_express_validator.body)("budget").isInt({ min: 500, max: 1e5 }).withMessage("Budget entre 500\u20AC et 100,000\u20AC"),
  (0, import_express_validator.body)("timeline").isIn(["urgent", "1-3 mois", "3-6 mois", "6+ mois"]).withMessage("Timeline invalide"),
  (0, import_express_validator.body)("businessType").isIn(["startup", "PME", "grande-entreprise", "association", "particulier"]).withMessage("Type d'entreprise invalide"),
  (0, import_express_validator.body)("firstName").isLength({ min: 2, max: 50 }).matches(/^[a-zA-Z√Ä-√ø\s-']+$/).withMessage("Pr\xE9nom invalide"),
  (0, import_express_validator.body)("lastName").isLength({ min: 2, max: 50 }).matches(/^[a-zA-Z√Ä-√ø\s-']+$/).withMessage("Nom de famille invalide"),
  (0, import_express_validator.body)("email").isEmail().normalizeEmail().withMessage("Adresse email invalide"),
  (0, import_express_validator.body)("phone").matches(/^(\+32|0)[1-9][0-9]{7,8}$/).withMessage("Num\xE9ro de t\xE9l\xE9phone belge invalide"),
  (0, import_express_validator.body)("company").optional().isLength({ max: 100 }).withMessage("Nom d'entreprise trop long"),
  (0, import_express_validator.body)("city").isLength({ min: 2, max: 50 }).withMessage("Ville invalide"),
  (0, import_express_validator.body)("acceptsMarketing").isBoolean().withMessage("Consentement marketing requis"),
  (0, import_express_validator.body)("rgpdConsent").equals("true").withMessage("Le consentement RGPD est obligatoire")
];
async function calculateLeadScore(leadData) {
  try {
    const prompt = `
    \xC9value cette demande de devis et donne un score de qualit\xE9 entre 1 et 100:

    Type de projet: ${leadData.projectType}
    Description: ${leadData.projectDescription}
    Budget: ${leadData.budget}\u20AC
    Timeline: ${leadData.timeline}
    Type d'entreprise: ${leadData.businessType}
    Ville: ${leadData.city}

    Crit\xE8res d'\xE9valuation:
    - Coh\xE9rence budget/projet (30%)
    - Clart\xE9 de la description (25%)
    - Urgence du timeline (20%)
    - Type d'entreprise (15%)
    - Localisation Belgique (10%)

    R\xE9ponds uniquement par un nombre entre 1 et 100.
    `;
    const response = await geminiService2.generateText(prompt);
    const score = parseInt(response.trim());
    return isNaN(score) ? 50 : Math.max(1, Math.min(100, score));
  } catch (error) {
    console.error("[GEMINI-SCORE] Erreur calcul score:", error);
    return 50;
  }
}
router69.get("/health", (req2, res) => {
  res.json({
    status: "healthy",
    service: "Devis1Minute Public API",
    version: "1.0.0",
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    endpoints: {
      leads: "/api/public/leads",
      stats: "/api/public/stats",
      categories: "/api/public/categories"
    }
  });
});
router69.get("/stats", publicRateLimit, async (req2, res) => {
  try {
    const stats = await prisma40.$transaction(async (tx) => {
      const totalLeads = await tx.lead.count();
      const recentLeads = await tx.lead.count({
        where: {
          createdAt: {
            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3)
            // 30 jours
          }
        }
      });
      return {
        totalLeads: totalLeads || 1247,
        // Valeur par d√©faut pour l'effet
        successRate: 92,
        // Pourcentage fixe optimiste
        averageResponseTime: "2h",
        // D√©lai de r√©ponse moyen
        clientsServed: Math.floor(totalLeads * 0.8) || 998,
        monthlyGrowth: recentLeads > 0 ? 15 : 12
        // Croissance mensuelle
      };
    });
    res.json(stats);
  } catch (error) {
    console.error("[PUBLIC-STATS] Erreur:", error);
    res.json({
      totalLeads: 1247,
      successRate: 92,
      averageResponseTime: "2h",
      clientsServed: 998,
      monthlyGrowth: 15
    });
  }
});
router69.get("/categories", publicRateLimit, (req2, res) => {
  const categories = [
    {
      id: "website",
      name: "Site Web",
      description: "Sites vitrine, corporate et institutionnels",
      icon: "GlobalOutlined",
      estimatedPrice: "1,500 - 8,000\u20AC",
      deliveryTime: "2-6 semaines"
    },
    {
      id: "ecommerce",
      name: "E-commerce",
      description: "Boutiques en ligne et places de march\xE9",
      icon: "ShoppingCartOutlined",
      estimatedPrice: "3,000 - 15,000\u20AC",
      deliveryTime: "4-10 semaines"
    },
    {
      id: "app",
      name: "Application Mobile",
      description: "Apps iOS et Android natives et hybrides",
      icon: "MobileOutlined",
      estimatedPrice: "5,000 - 25,000\u20AC",
      deliveryTime: "8-16 semaines"
    },
    {
      id: "branding",
      name: "Identit\xE9 Visuelle",
      description: "Logo, charte graphique, supports print",
      icon: "BgColorsOutlined",
      estimatedPrice: "800 - 3,500\u20AC",
      deliveryTime: "1-4 semaines"
    },
    {
      id: "marketing",
      name: "Marketing Digital",
      description: "SEO, SEM, r\xE9seaux sociaux, email marketing",
      icon: "TrophyOutlined",
      estimatedPrice: "500 - 2,500\u20AC/mois",
      deliveryTime: "Continu"
    },
    {
      id: "consulting",
      name: "Conseil Digital",
      description: "Strat\xE9gie, audit, accompagnement",
      icon: "BulbOutlined",
      estimatedPrice: "150 - 800\u20AC/jour",
      deliveryTime: "Sur mesure"
    }
  ];
  res.json(categories);
});
router69.post("/leads", leadCreationLimit, validateLead, async (req2, res) => {
  try {
    const errors = (0, import_express_validator.validationResult)(req2);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        error: "Donn\xE9es invalides",
        details: errors.array()
      });
    }
    const leadData = req2.body;
    const clientIp = req2.ip || req2.connection.remoteAddress;
    console.log(`[PUBLIC-LEAD] Nouvelle demande depuis ${clientIp}`);
    console.log(`[PUBLIC-LEAD] Projet: ${leadData.projectType} - Budget: ${leadData.budget}\u20AC`);
    const existingLead = await prisma40.lead.findFirst({
      where: {
        email: leadData.email,
        createdAt: {
          gte: new Date(Date.now() - 24 * 60 * 60 * 1e3)
        }
      }
    });
    if (existingLead) {
      return res.status(400).json({
        success: false,
        error: "Une demande avec cet email a d\xE9j\xE0 \xE9t\xE9 soumise aujourd'hui",
        message: "Nous vous recontacterons bient\xF4t."
      });
    }
    const qualityScore = await calculateLeadScore(leadData);
    const lead = await prisma40.lead.create({
      data: {
        // Informations projet
        projectType: leadData.projectType,
        projectDescription: leadData.projectDescription,
        budget: leadData.budget,
        timeline: leadData.timeline,
        businessType: leadData.businessType,
        // Informations contact
        firstName: leadData.firstName,
        lastName: leadData.lastName,
        email: leadData.email,
        phone: leadData.phone,
        company: leadData.company,
        city: leadData.city,
        // M√©tadonn√©es
        source: "public-form",
        status: qualityScore >= 70 ? "qualified" : qualityScore >= 40 ? "potential" : "cold",
        qualityScore,
        acceptsMarketing: leadData.acceptsMarketing,
        rgpdConsent: true,
        ipAddress: clientIp,
        // Donn√©es optionnelles
        targetAudience: leadData.targetAudience,
        goals: leadData.goals || [],
        additionalServices: leadData.additionalServices || [],
        // Timestamps
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log(`[PUBLIC-LEAD] Lead cr\xE9\xE9: ${lead.id} - Score: ${qualityScore}/100`);
    const response = {
      success: true,
      message: "Votre demande a \xE9t\xE9 envoy\xE9e avec succ\xE8s !",
      leadId: lead.id,
      score: qualityScore,
      estimatedResponseTime: qualityScore >= 70 ? "2-4 heures" : "24-48 heures",
      nextSteps: [
        "Analyse de votre demande par notre \xE9quipe",
        "Appel de qualification sous 24h",
        "Pr\xE9sentation d'un devis personnalis\xE9",
        "Planification du projet"
      ]
    };
    res.status(201).json(response);
  } catch (error) {
    console.error("[PUBLIC-LEAD] Erreur cr\xE9ation:", error);
    res.status(500).json({
      success: false,
      error: "Erreur lors de l'envoi de votre demande",
      message: "Veuillez r\xE9essayer ou nous contacter directement."
    });
  }
});
router69.get("/lead-status/:id", publicRateLimit, async (req2, res) => {
  try {
    const { id } = req2.params;
    if (!id || typeof id !== "string") {
      return res.status(400).json({
        error: "ID de demande invalide"
      });
    }
    const lead = await prisma40.lead.findUnique({
      where: { id },
      select: {
        id: true,
        status: true,
        createdAt: true,
        projectType: true,
        firstName: true,
        qualityScore: true
      }
    });
    if (!lead) {
      return res.status(404).json({
        error: "Demande non trouv\xE9e"
      });
    }
    const statusMessages = {
      "new": "Votre demande a \xE9t\xE9 re\xE7ue et est en cours d'analyse",
      "contacted": "Notre \xE9quipe vous a contact\xE9",
      "qualified": "Votre demande a \xE9t\xE9 qualifi\xE9e et est prioritaire",
      "proposal": "Un devis personnalis\xE9 a \xE9t\xE9 pr\xE9par\xE9",
      "won": "F\xE9licitations ! Votre projet a \xE9t\xE9 accept\xE9",
      "lost": "Votre demande n'a pas abouti cette fois",
      "cold": "Votre demande est en attente d'informations compl\xE9mentaires"
    };
    res.json({
      id: lead.id,
      status: lead.status,
      message: statusMessages[lead.status] || "Statut en cours d'analyse",
      submittedAt: lead.createdAt,
      projectType: lead.projectType,
      qualityScore: lead.qualityScore
    });
  } catch (error) {
    console.error("[LEAD-STATUS] Erreur:", error);
    res.status(500).json({
      error: "Erreur lors de la v\xE9rification du statut"
    });
  }
});
var publicLeads_default = router69;

// src/routes/documents.ts
var import_express71 = require("express");
init_database();
var import_nanoid2 = require("nanoid");

// src/services/documentPdfRenderer.ts
var import_pdfkit2 = __toESM(require("pdfkit"), 1);
var import_stream = require("stream");
var path7 = __toESM(require("path"), 1);
var fs8 = __toESM(require("fs"), 1);

// src/services/textAlignmentUtils.ts
function calculateVerticalCenterOffset(actualHeight, textHeight) {
  if (!Number.isFinite(actualHeight) || !Number.isFinite(textHeight)) {
    return 0;
  }
  return Math.max(0, (actualHeight - textHeight) / 2);
}

// src/services/documentPdfRenderer.ts
var DEFAULT_THEME = {
  primaryColor: "#1890ff",
  secondaryColor: "#52c41a",
  accentColor: "#faad14",
  textColor: "#333333",
  backgroundColor: "#ffffff",
  fontFamily: "Helvetica",
  fontSize: 11
};
var PAGE_BUILDER_WIDTH = 794;
var PAGE_BUILDER_HEIGHT = 1123;
var A4_DIMENSION_TOLERANCE = 0.5;
var TYPE_LABELS = {
  QUOTE: "Devis",
  INVOICE: "Facture",
  ORDER: "Bon de commande",
  CONTRACT: "Contrat",
  PRESENTATION: "Pr\xE9sentation"
};
var DocumentPdfRenderer = class {
  doc;
  ctx;
  theme;
  pageWidth = 595.28;
  // A4
  pageHeight = 841.89;
  // A4
  margin = 50;
  contentWidth;
  currentY;
  imageCache = /* @__PURE__ */ new Map();
  // Cache pour les images pr√©-charg√©es
  scaleX = 1;
  scaleY = 1;
  scaleFactor = 1;
  isFirstModularPage = true;
  // üî• Flag pour g√©rer la pagination multi-pages
  constructor(context) {
    this.ctx = context;
    this.theme = { ...DEFAULT_THEME, ...context.template.theme };
    this.contentWidth = this.pageWidth - this.margin * 2;
    this.currentY = this.margin;
    this.doc = new import_pdfkit2.default({
      size: "A4",
      margins: {
        top: this.margin,
        bottom: this.margin,
        left: this.margin,
        right: this.margin
      },
      autoFirstPage: true,
      // NE PAS utiliser bufferPages - √ßa complique la gestion des pages
      info: {
        Title: `${TYPE_LABELS[context.template.type] || context.template.type} - ${context.documentNumber || context.template.name}`,
        Author: context.organization?.name || "2Thier CRM",
        Subject: TYPE_LABELS[context.template.type] || context.template.type,
        CreationDate: /* @__PURE__ */ new Date()
      }
    });
    this.ensureDocumentIsA4();
    this.scaleX = this.pageWidth / PAGE_BUILDER_WIDTH;
    this.scaleY = this.pageHeight / PAGE_BUILDER_HEIGHT;
    this.scaleFactor = Math.min(this.scaleX, this.scaleY);
  }
  /**
   * Rend un contenu par d√©faut quand aucune section n'est configur√©e
   * Affiche les donn√©es du lead et les donn√©es TBL disponibles
   */
  renderDefaultContent() {
    this.doc.fillColor(this.theme.primaryColor || "#1890ff").fontSize(this.scaleFontSize(24)).font("Helvetica-Bold").text(this.ctx.template.name || "Document", this.margin, this.currentY, {
      align: "center",
      width: this.contentWidth
    });
    this.currentY += 40;
    this.doc.fillColor(this.theme.textColor || "#333333").fontSize(this.scaleFontSize(14)).font("Helvetica").text(
      `${TYPE_LABELS[this.ctx.template.type] || this.ctx.template.type} ${this.ctx.documentNumber ? `N\xB0 ${this.ctx.documentNumber}` : ""}`,
      this.margin,
      this.currentY,
      { align: "center", width: this.contentWidth }
    );
    this.currentY += 40;
    this.doc.strokeColor(this.theme.primaryColor || "#1890ff").lineWidth(this.scaleFontSize(2)).moveTo(this.margin, this.currentY).lineTo(this.pageWidth - this.margin, this.currentY).stroke();
    this.currentY += 30;
    if (this.ctx.lead && (this.ctx.lead.firstName || this.ctx.lead.lastName || this.ctx.lead.company)) {
      this.doc.fillColor(this.theme.primaryColor || "#1890ff").fontSize(this.scaleFontSize(16)).font("Helvetica-Bold").text("\u{1F464} Client", this.margin, this.currentY);
      this.currentY += 25;
      this.doc.fillColor(this.theme.textColor || "#333333").fontSize(this.scaleFontSize(11)).font("Helvetica");
      const clientInfo = [];
      if (this.ctx.lead.company) clientInfo.push(`Soci\xE9t\xE9: ${this.ctx.lead.company}`);
      const fullName = [this.ctx.lead.firstName, this.ctx.lead.lastName].filter(Boolean).join(" ");
      if (fullName) clientInfo.push(`Nom: ${fullName}`);
      if (this.ctx.lead.email) clientInfo.push(`Email: ${this.ctx.lead.email}`);
      if (this.ctx.lead.phone) clientInfo.push(`T\xE9l: ${this.ctx.lead.phone}`);
      if (this.ctx.lead.address) clientInfo.push(`Adresse: ${this.ctx.lead.address}`);
      for (const info of clientInfo) {
        this.doc.text(info, this.margin, this.currentY, { width: this.contentWidth });
        this.currentY += 16;
      }
      this.currentY += 20;
    }
    console.log("\u{1F4C4} [PDF RENDERER] V\xE9rification tblData:", {
      hasTblData: !!this.ctx.tblData,
      tblDataKeys: Object.keys(this.ctx.tblData || {}),
      keysCount: Object.keys(this.ctx.tblData || {}).length
    });
    if (this.ctx.tblData && Object.keys(this.ctx.tblData).length > 0) {
      console.log("\u{1F4C4} [PDF RENDERER] \u2705 Rendu des donn\xE9es TBL...");
      this.doc.fillColor(this.theme.primaryColor || "#1890ff").fontSize(this.scaleFontSize(16)).font("Helvetica-Bold").text("\u{1F4CA} Donn\xE9es du formulaire", this.margin, this.currentY);
      this.currentY += 25;
      this.doc.fillColor(this.theme.textColor || "#333333").fontSize(this.scaleFontSize(10)).font("Helvetica");
      this.renderTblDataRecursive(this.ctx.tblData, 0);
    }
    this.currentY += 30;
    this.doc.fillColor("#888888").fontSize(this.scaleFontSize(10)).font("Helvetica-Oblique").text(
      "\u26A0\uFE0F Ce template n'a pas de sections configur\xE9es. Utilisez le Page Builder pour personnaliser la mise en page.",
      this.margin,
      this.currentY,
      { align: "center", width: this.contentWidth }
    );
  }
  /**
   * Affiche les donn√©es TBL de mani√®re r√©cursive
   */
  renderTblDataRecursive(data, indent) {
    const maxIndent = 3;
    if (indent > maxIndent) return;
    for (const [key2, value] of Object.entries(data)) {
      if (key2.startsWith("_") || key2 === "id" || key2 === "createdAt" || key2 === "updatedAt") continue;
      if (this.currentY > this.pageHeight - 100) {
        this.doc.addPage();
        this.currentY = this.margin;
      }
      const indentX = this.margin + indent * 15;
      if (value === null || value === void 0 || value === "") {
        continue;
      }
      if (typeof value === "object" && !Array.isArray(value)) {
        this.doc.font("Helvetica-Bold").text(`${key2}:`, indentX, this.currentY);
        this.currentY += 14;
        this.renderTblDataRecursive(value, indent + 1);
      } else if (Array.isArray(value)) {
        this.doc.font("Helvetica-Bold").text(`${key2}: [${value.length} \xE9l\xE9ments]`, indentX, this.currentY);
        this.currentY += 14;
      } else {
        const displayValue = String(value).substring(0, 100);
        this.doc.font("Helvetica").text(`${key2}: ${displayValue}`, indentX, this.currentY, { width: this.contentWidth - indent * 15 });
        this.currentY += 14;
      }
    }
  }
  /**
   * Collecte toutes les URLs d'images des sections pour les pr√©-charger
   */
  collectImageUrls() {
    const urls = [];
    for (const section of this.ctx.template.sections || []) {
      const config = section.config || {};
      if (section.type === "MODULAR_PAGE" && config.modules) {
        for (const mod of config.modules) {
          const modConfig = mod.config || {};
          if (mod.moduleType === "IMAGE") {
            const url = modConfig.image || modConfig.url || modConfig.src;
            if (url && url.startsWith("http")) urls.push(url);
          }
          if (mod.moduleType === "BACKGROUND" && modConfig.type === "image") {
            const url = modConfig.image || modConfig.url;
            if (url && url.startsWith("http")) urls.push(url);
          }
        }
      }
      if (config.image && config.image.startsWith("http")) urls.push(config.image);
      if (config.backgroundImage && config.backgroundImage.startsWith("http")) urls.push(config.backgroundImage);
      if (config.logoUrl && config.logoUrl.startsWith("http")) urls.push(config.logoUrl);
    }
    if (this.theme.logoUrl && this.theme.logoUrl.startsWith("http")) urls.push(this.theme.logoUrl);
    if (this.theme.headerImageUrl && this.theme.headerImageUrl.startsWith("http")) urls.push(this.theme.headerImageUrl);
    return [...new Set(urls)];
  }
  /**
   * Pr√©-charge les images externes en parall√®le
   */
  async preloadImages() {
    const urls = this.collectImageUrls();
    if (urls.length === 0) return;
    console.log(`\u{1F4C4} [PDF] Pr\xE9-chargement de ${urls.length} images externes...`);
    const fetchPromises = urls.map(async (url) => {
      try {
        const response = await fetch(url, {
          signal: AbortSignal.timeout(1e4)
          // Timeout 10s
        });
        if (!response.ok) {
          console.warn(`\u{1F4C4} [PDF] Image non accessible: ${url} (${response.status})`);
          return;
        }
        const arrayBuffer = await response.arrayBuffer();
        const buffer = Buffer.from(arrayBuffer);
        this.imageCache.set(url, buffer);
        console.log(`\u{1F4C4} [PDF] \u2705 Image charg\xE9e: ${url.substring(0, 60)}...`);
      } catch (error) {
        console.warn(`\u{1F4C4} [PDF] \xC9chec chargement image: ${url}`, error);
      }
    });
    await Promise.all(fetchPromises);
    console.log(`\u{1F4C4} [PDF] ${this.imageCache.size}/${urls.length} images pr\xE9-charg\xE9es`);
  }
  /**
   * G√©n√®re le PDF complet
   */
  async render() {
    await this.preloadImages();
    return new Promise((resolve, reject) => {
      const chunks = [];
      const stream = new import_stream.PassThrough();
      stream.on("data", (chunk) => chunks.push(chunk));
      stream.on("end", () => resolve(Buffer.concat(chunks)));
      stream.on("error", reject);
      this.doc.pipe(stream);
      try {
        console.log("\u{1F4C4} [PDF RENDERER] D\xE9but du rendu", {
          templateId: this.ctx.template.id,
          templateName: this.ctx.template.name,
          sectionsCount: this.ctx.template.sections?.length || 0,
          hasLead: !!this.ctx.lead,
          hasTblData: !!this.ctx.tblData && Object.keys(this.ctx.tblData).length > 0
        });
        const sortedSections = [...this.ctx.template.sections || []].sort((a, b) => a.order - b.order);
        console.log("\u{1F4C4} [PDF RENDERER] Sections \xE0 rendre:", sortedSections.map((s) => s.type));
        if (sortedSections.length === 0) {
          console.log("\u{1F4C4} [PDF RENDERER] \u26A0\uFE0F Aucune section configur\xE9e, rendu par d\xE9faut");
          this.renderDefaultContent();
        } else {
          for (const section of sortedSections) {
            console.log(`\u{1F4C4} [PDF RENDERER] Rendu section: ${section.type} (${section.id})`);
            this.renderSection(section);
          }
        }
        console.log("\u{1F4C4} [PDF RENDERER] \u2705 Rendu termin\xE9");
        this.renderFooter();
        this.doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }
  /**
   * Rend une section selon son type
   */
  renderSection(section) {
    const config = section.config || {};
    if (config.visible === false) return;
    if (config.conditionalDisplay && !this.evaluateCondition(config.conditionalDisplay)) {
      return;
    }
    console.log(`\u{1F4C4} [PDF] Rendering section: ${section.type}`);
    switch (section.type) {
      case "MODULAR_PAGE":
        this.renderModularPage(config);
        break;
      case "COVER_PAGE":
        this.renderCoverPage(config);
        break;
      case "COMPANY_PRESENTATION":
        this.renderCompanyPresentation(config);
        break;
      case "PROJECT_SUMMARY":
        this.renderProjectSummary(config);
        break;
      case "PRICING_TABLE":
        this.renderPricingTable(config);
        break;
      case "TEXT_BLOCK":
        this.renderTextBlock(config);
        break;
      case "TERMS_CONDITIONS":
        this.renderTermsConditions(config);
        break;
      case "SIGNATURE_BLOCK":
        this.renderSignatureBlock(config);
        break;
      case "CONTACT_INFO":
        this.renderContactInfo(config);
        break;
      case "TECHNICAL_SPECS":
        this.renderTechnicalSpecs(config);
        break;
      case "TIMELINE":
        this.renderTimeline(config);
        break;
      case "IMAGE":
        this.renderImage(config);
        break;
      case "PAGE_BREAK":
        this.doc.addPage();
        this.currentY = this.margin;
        break;
      case "CUSTOM_HTML":
        this.renderCustomContent(config);
        break;
      default:
        console.warn(`\u{1F4C4} [PDF] Unknown section type: ${section.type}`);
    }
  }
  convertPageBuilderRect(position) {
    const rawX = (position.x ?? 0) * this.scaleX;
    const rawY = (position.y ?? 0) * this.scaleY;
    const rawWidth = (position.width ?? 100) * this.scaleX;
    const rawHeight = (position.height ?? (position.blockHeight ?? 50)) * this.scaleY;
    const safeX = this.clamp(rawX, 0, this.pageWidth);
    const safeY = this.clamp(rawY, 0, this.pageHeight);
    const maxWidth = Math.max(1, this.pageWidth - safeX);
    const maxHeight = Math.max(1, this.pageHeight - safeY);
    const safeWidth = this.clamp(rawWidth, 1, maxWidth);
    const safeHeight = this.clamp(rawHeight, 1, maxHeight);
    return {
      x: safeX,
      y: safeY,
      width: safeWidth,
      height: safeHeight
    };
  }
  drawBackgroundImage(buffer, x, y, width, height) {
    if (!buffer || width <= 0 || height <= 0) return;
    const openImage = this.doc.openImage?.(buffer);
    if (openImage) {
      const imageWidth = openImage.width;
      const imageHeight = openImage.height;
      const coverScale = Math.max(width / imageWidth, height / imageHeight);
      const renderWidth = imageWidth * coverScale;
      const renderHeight = imageHeight * coverScale;
      const offsetX = x - Math.max(0, (renderWidth - width) / 2);
      const offsetY = y - Math.max(0, (renderHeight - height) / 2);
      this.doc.image(buffer, offsetX, offsetY, {
        width: renderWidth,
        height: renderHeight
      });
      return;
    }
    this.doc.image(buffer, x, y, {
      fit: [width, height],
      align: "center",
      valign: "center"
    });
  }
  clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }
  scaleFontSize(size) {
    const scaled = size * this.scaleFactor;
    return Math.max(6, scaled);
  }
  // ============================================================
  // üÜï RENDU DES PAGES MODULAIRES (PAGE BUILDER)
  // ============================================================
  /**
   * Rend une page modulaire compl√®te du Page Builder
   * Chaque MODULAR_PAGE cr√©e une nouvelle page dans le PDF (sauf la premi√®re)
   */
  renderModularPage(config) {
    console.log("\u{1F4C4} [PDF] ========================================");
    console.log("\u{1F4C4} [PDF] Rendu page modulaire:", config.name);
    console.log("\u{1F4C4} [PDF] Pages actuelles dans le doc:", this.doc.bufferedPageRange?.()?.count || "N/A");
    console.log("\u{1F4C4} [PDF] isFirstModularPage:", this.isFirstModularPage);
    if (!this.isFirstModularPage) {
      console.log("\u{1F4C4} [PDF] \u{1F4C3} Cr\xE9ation d'une nouvelle page PDF");
      this.doc.addPage();
      this.currentY = 0;
    }
    this.isFirstModularPage = false;
    const modules = config.modules || [];
    console.log("\u{1F4C4} [PDF] Nombre de modules:", modules.length);
    if (config.backgroundColor) {
      console.log("\u{1F4C4} [PDF] Fond de page:", config.backgroundColor);
      this.doc.rect(0, 0, this.pageWidth, this.pageHeight).fill(config.backgroundColor);
    }
    const sortedModules = [...modules].sort((a, b) => {
      const aType = a.moduleId || a.moduleType || a.type;
      const bType = b.moduleId || b.moduleType || b.type;
      if (aType === "BACKGROUND" && bType !== "BACKGROUND") return -1;
      if (bType === "BACKGROUND" && aType !== "BACKGROUND") return 1;
      const aY = a.position?.y ?? 0;
      const bY = b.position?.y ?? 0;
      const aX = a.position?.x ?? 0;
      const bX = b.position?.x ?? 0;
      if (Math.abs(aY - bY) > 5) return aY - bY;
      return aX - bX;
    });
    console.log(`\u{1F4C4} [PDF] Rendu de ${sortedModules.length} modules sur la page`);
    console.log(`\u{1F4C4} [PDF] Ordre des modules:`, sortedModules.map((m) => m.moduleId || m.moduleType || m.type));
    for (const moduleInstance of sortedModules) {
      this.renderModuleAbsolute(moduleInstance);
    }
    this.currentY = this.pageHeight;
  }
  /**
   * Rend un module √† sa position absolue (conversion pixel Page Builder -> points PDF)
   */
  renderModuleAbsolute(module2) {
    const moduleType = module2.moduleId || module2.moduleType || module2.type;
    const config = module2.config || {};
    const position = module2.position || {};
    const rect = this.convertPageBuilderRect(position);
    const conditionResult = this.evaluateModuleConditions(config);
    if (!conditionResult.shouldRender) {
      console.log(`\u{1F4C4} [PDF] Module ${moduleType}: SKIPPED (condition false)`);
      return;
    }
    const effectiveConfig = { ...config };
    if (conditionResult.content !== void 0) {
      console.log(`\u{1F4C4} [PDF] Module ${moduleType}: Using conditional content: "${conditionResult.content}"`);
      if (moduleType === "TITLE" || moduleType === "SUBTITLE" || moduleType === "TEXT_BLOCK") {
        effectiveConfig.text = conditionResult.content;
      }
    }
    console.log(`\u{1F4C4} [PDF] Module ${moduleType}: PageBuilder(${position.x ?? 0},${position.y ?? 0}) -> PDF(${rect.x.toFixed(1)},${rect.y.toFixed(1)}) size ${rect.width.toFixed(1)}x${rect.height.toFixed(1)}`);
    this.doc.save();
    try {
      switch (moduleType) {
        case "TITLE":
          this.renderModuleTitle(effectiveConfig, rect.x, rect.y, rect.width, rect.height);
          break;
        case "SUBTITLE":
          this.renderModuleSubtitle(effectiveConfig, rect.x, rect.y, rect.width, rect.height);
          break;
        case "TEXT_BLOCK":
          this.renderModuleTextBlock(effectiveConfig, rect.x, rect.y, rect.width, rect.height);
          break;
        case "IMAGE":
          this.renderModuleImage(effectiveConfig, rect.x, rect.y, rect.width, rect.height);
          break;
        case "BACKGROUND":
          this.renderModuleBackground(effectiveConfig, rect.x, rect.y, rect.width, rect.height);
          break;
        case "PRICING_TABLE":
          this.renderModulePricingTable(effectiveConfig, rect.x, rect.y, rect.width);
          break;
        case "TESTIMONIAL":
          this.renderModuleTestimonial(effectiveConfig, rect.x, rect.y, rect.width);
          break;
        case "COMPANY_PRESENTATION":
          this.renderModuleCompanyPresentation(effectiveConfig, rect.x, rect.y, rect.width);
          break;
        case "FAQ":
          this.renderModuleFaq(effectiveConfig, rect.x, rect.y, rect.width);
          break;
        case "DIVIDER":
          this.renderModuleDivider(effectiveConfig, rect.x, rect.y, rect.width);
          break;
        case "SPACER":
          break;
        default:
          console.warn(`\u{1F4C4} [PDF] Module type inconnu: ${moduleType}`);
      }
    } finally {
      this.doc.restore();
    }
  }
  // ============================================================
  // RENDERERS DE MODULES INDIVIDUELS
  // ============================================================
  renderModuleTitle(config, x, y, width, height) {
    const text = this.substituteVariables(config.text || "Titre");
    const level = config.level || "h1";
    const alignment = config.alignment || "center";
    const color = config.color || config.textColor || config.style?.color || "#FFFFFF";
    const actualHeight = height || 50;
    console.log(`\u{1F4C4} [PDF] TITLE: config.color=${config.color}, config.textColor=${config.textColor}, final color=${color}`);
    let fontSize = level === "h1" ? 20 : level === "h2" ? 16 : 14;
    this.doc.font("Helvetica-Bold");
    let scaledFontSize = this.scaleFontSize(fontSize);
    while (fontSize > 8) {
      this.doc.fontSize(scaledFontSize);
      const textHeight = this.doc.heightOfString(text, { width });
      if (textHeight <= actualHeight) break;
      fontSize -= 2;
      scaledFontSize = this.scaleFontSize(fontSize);
    }
    console.log(`\u{1F4C4} [PDF] TITLE: text="${text}", fontSize=${fontSize}, height=${Math.round(actualHeight)}, color=${color}`);
    const savedY = this.doc.y;
    this.doc.save();
    this.doc.fillColor(color);
    this.doc.fontSize(scaledFontSize);
    const titleTextHeight = this.doc.heightOfString(text, { width });
    const titleYOffset = calculateVerticalCenterOffset(actualHeight, titleTextHeight);
    this.doc.font("Helvetica-Bold");
    this.doc.text(text, x, y + titleYOffset, {
      width,
      height: actualHeight,
      align: alignment,
      lineBreak: true,
      continued: false
    });
    this.doc.restore();
    this.doc.y = Math.min(savedY, this.margin + 100);
  }
  renderModuleSubtitle(config, x, y, width, height) {
    const text = this.substituteVariables(config.text || "Sous-titre");
    const alignment = config.alignment || "center";
    const color = config.color || "#FFFFFF";
    const actualHeight = height || 30;
    let fontSize = config.fontSize || 14;
    this.doc.font("Helvetica");
    let scaledFontSize = this.scaleFontSize(fontSize);
    while (fontSize > 6) {
      this.doc.fontSize(scaledFontSize);
      const textHeight = this.doc.heightOfString(text, { width });
      if (textHeight <= actualHeight) break;
      fontSize -= 1;
      scaledFontSize = this.scaleFontSize(fontSize);
    }
    console.log(`\u{1F4C4} [PDF] SUBTITLE: text="${text}", fontSize=${fontSize}`);
    const savedY = this.doc.y;
    this.doc.fontSize(scaledFontSize);
    const subtitleTextHeight = this.doc.heightOfString(text, { width });
    const subtitleYOffset = calculateVerticalCenterOffset(actualHeight, subtitleTextHeight);
    this.doc.fillColor(color).fontSize(scaledFontSize).font("Helvetica").text(text, x, y + subtitleYOffset, {
      width,
      height: actualHeight,
      align: alignment,
      lineBreak: true,
      continued: false
    });
    this.doc.y = Math.min(savedY, this.margin + 100);
  }
  renderModuleTextBlock(config, x, y, width, height) {
    const text = this.substituteVariables(config.content || config.text || "");
    const alignment = config.alignment || "left";
    const color = config.color || "#FFFFFF";
    const actualHeight = height || 100;
    let fontSize = config.fontSize || 12;
    const maxFontSize = Math.floor(actualHeight / 4);
    fontSize = Math.min(fontSize, Math.max(maxFontSize, 8));
    const padding = config.backgroundColor ? 10 : 0;
    const innerWidth = Math.max(1, width - padding * 2);
    const innerHeight = Math.max(1, actualHeight - padding * 2);
    this.doc.font("Helvetica");
    let scaledFontSize = this.scaleFontSize(fontSize);
    while (fontSize > 6) {
      this.doc.fontSize(scaledFontSize);
      const textHeight = this.doc.heightOfString(text, { width: innerWidth });
      if (textHeight <= innerHeight) break;
      fontSize -= 1;
      scaledFontSize = this.scaleFontSize(fontSize);
    }
    if (config.backgroundColor) {
      this.doc.rect(x, y, width, actualHeight).fill(config.backgroundColor);
    }
    console.log(`\u{1F4C4} [PDF] TEXT_BLOCK: text="${text.substring(0, 30)}...", color=${color}, fontSize=${fontSize}`);
    const savedY = this.doc.y;
    const finalTextHeight = this.doc.heightOfString(text, { width: innerWidth });
    const textYOffset = calculateVerticalCenterOffset(innerHeight, finalTextHeight);
    const textX = x + padding;
    const textY = y + padding + textYOffset;
    this.doc.fillColor(color).fontSize(scaledFontSize).font("Helvetica").text(text, textX, textY, {
      width: innerWidth,
      height: actualHeight,
      align: alignment,
      lineBreak: true,
      continued: false
    });
    this.doc.y = Math.min(savedY, this.margin + 100);
  }
  renderModuleImage(config, x, y, width, height) {
    const imageUrl = config.image || config.url || config.src;
    console.log(`\u{1F4C4} [PDF] IMAGE: x=${Math.round(x)}, y=${Math.round(y)}, w=${Math.round(width)}, h=${Math.round(height)}`);
    console.log(`\u{1F4C4} [PDF] IMAGE: source=${imageUrl ? imageUrl.substring(0, 50) + "..." : "NONE"}`);
    if (!imageUrl) {
      console.log(`\u{1F4C4} [PDF] IMAGE: pas d'URL, affichage placeholder`);
      this.doc.rect(x, y, width, height).fill("#f0f0f0").stroke("#cccccc");
      this.doc.fontSize(12).fillColor("#999999").text("Image", x, y + height / 2 - 6, { width, align: "center", lineBreak: false });
      return;
    }
    const imageOptions = {
      fit: [width, height],
      align: "center",
      valign: "center"
    };
    try {
      if (imageUrl.startsWith("data:")) {
        console.log(`\u{1F4C4} [PDF] IMAGE: traitement data URL avec fit pour pr\xE9server proportions`);
        const base64Data = imageUrl.split(",")[1];
        if (base64Data) {
          const buffer = Buffer.from(base64Data, "base64");
          console.log(`\u{1F4C4} [PDF] IMAGE: buffer cr\xE9\xE9, taille=${buffer.length}`);
          this.doc.image(buffer, x, y, imageOptions);
          console.log(`\u{1F4C4} [PDF] IMAGE: \u2705 rendu r\xE9ussi \xE0 x=${Math.round(x)}, y=${Math.round(y)}`);
        } else {
          console.warn(`\u{1F4C4} [PDF] IMAGE: \u26A0\uFE0F pas de donn\xE9es base64 trouv\xE9es`);
          this.renderImagePlaceholder(x, y, width, height, "Base64 vide");
        }
      } else if (imageUrl.startsWith("/uploads/") || imageUrl.startsWith("uploads/")) {
        const localPath = path7.join(process.cwd(), "public", imageUrl);
        if (fs8.existsSync(localPath)) {
          this.doc.image(localPath, x, y, imageOptions);
        } else {
          console.warn(`\u{1F4C4} [PDF] Image locale non trouv\xE9e: ${localPath}`);
          this.renderImagePlaceholder(x, y, width, height, "Image non trouv\xE9e");
        }
      } else if (imageUrl.startsWith("http")) {
        const cachedBuffer = this.imageCache.get(imageUrl);
        if (cachedBuffer) {
          console.log(`\u{1F4C4} [PDF] \u2705 Utilisation image du cache: ${imageUrl.substring(0, 50)}...`);
          this.doc.image(cachedBuffer, x, y, imageOptions);
        } else {
          console.warn(`\u{1F4C4} [PDF] Image externe non en cache: ${imageUrl.substring(0, 50)}...`);
          this.renderImagePlaceholder(x, y, width, height, "Image non charg\xE9e");
        }
      } else {
        console.log(`\u{1F4C4} [PDF] URL non support\xE9e: ${imageUrl.substring(0, 50)}...`);
        this.renderImagePlaceholder(x, y, width, height, "URL non support\xE9e");
      }
    } catch (error) {
      console.error("\u{1F4C4} [PDF] Erreur chargement image:", error);
      this.renderImagePlaceholder(x, y, width, height, "Erreur");
    }
  }
  renderImagePlaceholder(x, y, width, height, text) {
    this.doc.rect(x, y, width, height).fill("#f5f5f5").stroke("#e0e0e0");
    this.doc.fontSize(10).fillColor("#999999").text(text, x, y + height / 2 - 5, { width, align: "center" });
  }
  renderModuleBackground(config, x, y, width, height) {
    const hasImage = !!config.image;
    const hasColor = !!config.color;
    const hasGradient = !!(config.gradientStart && config.gradientEnd);
    const declaredType = config.type;
    console.log(`\u{1F4C4} [PDF] BACKGROUND: declaredType=${declaredType}, hasImage=${hasImage}, hasColor=${hasColor}, hasGradient=${hasGradient}`);
    console.log(`\u{1F4C4} [PDF] BACKGROUND: position x=${x}, y=${y}, w=${width}, h=${height}`);
    if (hasImage) {
      console.log(`\u{1F4C4} [PDF] BACKGROUND: rendu image de fond`);
      try {
        const imageUrl = config.image;
        const backgroundColor = config.backgroundColor || config.color || this.theme.backgroundColor;
        if (backgroundColor) {
          this.doc.rect(x, y, width, height).fill(backgroundColor);
        }
        if (imageUrl.startsWith("data:")) {
          const base64Data = imageUrl.split(",")[1];
          if (base64Data) {
            const buffer = Buffer.from(base64Data, "base64");
            console.log(`\u{1F4C4} [PDF] BACKGROUND: buffer cr\xE9\xE9, taille=${buffer.length} octets`);
            this.drawBackgroundImage(buffer, x, y, width, height);
            console.log(`\u{1F4C4} [PDF] BACKGROUND: \u2705 image rendue avec succ\xE8s (ratio maintenu)`);
            return;
          }
          console.warn(`\u{1F4C4} [PDF] BACKGROUND: \u26A0\uFE0F pas de donn\xE9es base64`);
        } else if (imageUrl.startsWith("/uploads/") || imageUrl.startsWith("uploads/")) {
          const localPath = path7.join(process.cwd(), "public", imageUrl);
          if (fs8.existsSync(localPath)) {
            this.drawBackgroundImage(fs8.readFileSync(localPath), x, y, width, height);
            return;
          }
          console.warn(`\u{1F4C4} [PDF] Image locale non trouv\xE9e: ${localPath}`);
          this.renderImagePlaceholder(x, y, width, height, "Image non trouv\xE9e");
          return;
        } else if (imageUrl.startsWith("http")) {
          const cachedBuffer = this.imageCache.get(imageUrl);
          if (cachedBuffer) {
            this.drawBackgroundImage(cachedBuffer, x, y, width, height);
            return;
          }
          console.warn(`\u{1F4C4} [PDF] Image externe non en cache: ${imageUrl.substring(0, 50)}...`);
          this.renderImagePlaceholder(x, y, width, height, "Image non charg\xE9e");
          return;
        } else {
          console.log(`\u{1F4C4} [PDF] URL non support\xE9e: ${imageUrl.substring(0, 50)}...`);
          this.renderImagePlaceholder(x, y, width, height, "URL non support\xE9e");
          return;
        }
      } catch (error) {
        console.error(`\u{1F4C4} [PDF] BACKGROUND: \u274C erreur image:`, error);
      }
    }
    if (hasGradient) {
      console.log(`\u{1F4C4} [PDF] BACKGROUND: rendu gradient`);
      const steps = 20;
      const stepHeight = Math.max(1, height / steps);
      for (let i = 0; i < steps; i++) {
        const ratio = i / steps;
        const color = this.interpolateColor(config.gradientStart, config.gradientEnd, ratio);
        this.doc.rect(x, y + i * stepHeight, width, stepHeight + 1).fill(color);
      }
      return;
    }
    if (hasColor) {
      console.log(`\u{1F4C4} [PDF] BACKGROUND: rendu couleur solide ${config.color}`);
      this.doc.rect(x, y, width, height).fill(config.color);
      return;
    }
    console.log(`\u{1F4C4} [PDF] BACKGROUND: aucun rendu (pas d'image, pas de couleur, pas de gradient)`);
  }
  interpolateColor(color1, color2, ratio) {
    const hex = (c) => parseInt(c.replace("#", ""), 16);
    const r1 = hex(color1) >> 16 & 255;
    const g1 = hex(color1) >> 8 & 255;
    const b1 = hex(color1) & 255;
    const r2 = hex(color2) >> 16 & 255;
    const g2 = hex(color2) >> 8 & 255;
    const b2 = hex(color2) & 255;
    const r = Math.round(r1 + (r2 - r1) * ratio);
    const g = Math.round(g1 + (g2 - g1) * ratio);
    const b = Math.round(b1 + (b2 - b1) * ratio);
    return `#${(r << 16 | g << 8 | b).toString(16).padStart(6, "0")}`;
  }
  renderModulePricingTable(config, x, y, width) {
    const title = config.title || "Tarifs";
    const currency = config.currency || "\u20AC";
    const tvaRate = config.tvaRate || config.vatRate || 21;
    const showTotal = config.showTotal !== false;
    const showTVA = config.showTVA !== false;
    let items = [];
    if (config.pricingLines && config.pricingLines.length > 0) {
      console.log("\u{1F4C4} [PDF] PRICING_TABLE: Utilisation de pricingLines", config.pricingLines.length);
      items = this.processPricingLines(config.pricingLines, config);
      console.log("\u{1F4C4} [PDF] PRICING_TABLE: Items r\xE9solus:", items);
    } else if (config.items && config.items.length > 0) {
      items = config.items.map((item) => ({
        description: this.substituteVariables(item.name || item.label || ""),
        quantity: item.quantity || 1,
        unitPrice: parseFloat(item.price || item.amount || item.unitPrice || 0),
        total: parseFloat(item.price || item.amount || 0) * (item.quantity || 1)
      }));
    } else if (config.rows && config.rows.length > 0) {
      items = config.rows.map((row) => ({
        description: this.substituteVariables(row.designation || row.label || ""),
        quantity: row.quantity || 1,
        unitPrice: parseFloat(row.unitPrice || 0),
        total: (row.quantity || 1) * parseFloat(row.unitPrice || 0)
      }));
    }
    this.doc.fontSize(this.scaleFontSize(16)).font("Helvetica-Bold").fillColor(this.theme.primaryColor || "#1890ff").text(title, x, y, { width });
    let currentY = y + 25;
    const colWidths = [width * 0.5, width * 0.15, width * 0.15, width * 0.2];
    const headerHeight = 20;
    this.doc.rect(x, currentY, width, headerHeight).fill(this.theme.primaryColor || "#1890ff");
    this.doc.fontSize(this.scaleFontSize(10)).font("Helvetica-Bold").fillColor("#FFFFFF");
    this.doc.text("D\xE9signation", x + 5, currentY + 5, { width: colWidths[0] - 10 });
    this.doc.text("Qt\xE9", x + colWidths[0], currentY + 5, { width: colWidths[1], align: "center" });
    this.doc.text("P.U.", x + colWidths[0] + colWidths[1], currentY + 5, { width: colWidths[2], align: "right" });
    this.doc.text("Total", x + colWidths[0] + colWidths[1] + colWidths[2], currentY + 5, { width: colWidths[3], align: "right" });
    currentY += headerHeight;
    let totalHT = 0;
    if (items.length === 0) {
      this.doc.fontSize(this.scaleFontSize(10)).font("Helvetica-Oblique").fillColor("#999999").text("Aucune ligne configur\xE9e", x + 5, currentY + 5, { width: width - 10, align: "center" });
      currentY += 25;
    } else {
      for (const item of items) {
        const rowHeight = 18;
        const lineTotal = item.total || item.quantity * item.unitPrice;
        totalHT += lineTotal;
        this.doc.fontSize(this.scaleFontSize(10)).font("Helvetica").fillColor(this.theme.textColor || "#333333");
        this.doc.text(item.description || "-", x + 5, currentY + 4, { width: colWidths[0] - 10 });
        this.doc.text(String(item.quantity), x + colWidths[0], currentY + 4, { width: colWidths[1], align: "center" });
        this.doc.text(`${item.unitPrice.toFixed(2)} ${currency}`, x + colWidths[0] + colWidths[1], currentY + 4, { width: colWidths[2], align: "right" });
        this.doc.text(`${lineTotal.toFixed(2)} ${currency}`, x + colWidths[0] + colWidths[1] + colWidths[2], currentY + 4, { width: colWidths[3], align: "right" });
        this.doc.strokeColor("#e8e8e8").lineWidth(0.5).moveTo(x, currentY + rowHeight).lineTo(x + width, currentY + rowHeight).stroke();
        currentY += rowHeight;
      }
    }
    if (showTotal) {
      const tva = totalHT * (tvaRate / 100);
      const totalTTC = totalHT + tva;
      currentY += 5;
      this.doc.fontSize(this.scaleFontSize(10)).font("Helvetica-Bold").fillColor(this.theme.textColor || "#333333").text("Total HT", x + colWidths[0] + colWidths[1], currentY, { width: colWidths[2] + colWidths[3] * 0.5, align: "right" });
      this.doc.text(`${totalHT.toFixed(2)} ${currency}`, x + width - colWidths[3], currentY, { width: colWidths[3], align: "right" });
      currentY += 15;
      if (showTVA) {
        this.doc.font("Helvetica").text(`TVA (${tvaRate}%)`, x + colWidths[0] + colWidths[1], currentY, { width: colWidths[2] + colWidths[3] * 0.5, align: "right" });
        this.doc.text(`${tva.toFixed(2)} ${currency}`, x + width - colWidths[3], currentY, { width: colWidths[3], align: "right" });
        currentY += 15;
        this.doc.rect(x + width * 0.6, currentY - 2, width * 0.4, 20).fill(this.theme.primaryColor || "#1890ff");
        this.doc.fontSize(this.scaleFontSize(12)).font("Helvetica-Bold").fillColor("#FFFFFF").text("Total TTC", x + width * 0.6 + 5, currentY + 3, { width: width * 0.2 - 10 });
        this.doc.text(`${totalTTC.toFixed(2)} ${currency}`, x + width * 0.8, currentY + 3, { width: width * 0.2 - 5, align: "right" });
      }
    }
  }
  renderModuleTestimonial(config, x, y, width) {
    const quote = this.substituteVariables(config.quote || config.text || "");
    const author = config.author || "";
    const role = config.role || config.position || "";
    this.doc.fontSize(this.scaleFontSize(14)).font("Helvetica-Oblique").fillColor(this.theme.textColor || "#333333").text(`"${quote}"`, x, y, { width });
    const quoteHeight = this.doc.heightOfString(`"${quote}"`, { width });
    if (author) {
      this.doc.fontSize(this.scaleFontSize(12)).font("Helvetica-Bold").text(`\u2014 ${author}`, x, y + quoteHeight + 10, { width });
      if (role) {
        this.doc.fontSize(this.scaleFontSize(10)).font("Helvetica").fillColor("#666666").text(role, x, y + quoteHeight + 26, { width });
      }
    }
  }
  renderModuleCompanyPresentation(config, x, y, width) {
    const title = this.substituteVariables(config.title || "Notre entreprise");
    const description = this.substituteVariables(config.description || config.text || "");
    this.doc.fontSize(this.scaleFontSize(18)).font("Helvetica-Bold").fillColor(this.theme.primaryColor || "#1890ff").text(title, x, y, { width });
    if (description) {
      this.doc.fontSize(this.scaleFontSize(12)).font("Helvetica").fillColor(this.theme.textColor || "#333333").text(description, x, y + 30, { width });
    }
  }
  renderModuleFaq(config, x, y, width) {
    const title = config.title || "FAQ";
    const items = config.items || [];
    this.doc.fontSize(this.scaleFontSize(18)).font("Helvetica-Bold").fillColor(this.theme.primaryColor || "#1890ff").text(title, x, y, { width });
    let currentY = y + 30;
    for (const item of items) {
      const question = this.substituteVariables(item.question || "");
      const answer = this.substituteVariables(item.answer || "");
      this.doc.fontSize(this.scaleFontSize(12)).font("Helvetica-Bold").fillColor(this.theme.textColor || "#333333").text(`Q: ${question}`, x, currentY, { width });
      const qHeight = this.doc.heightOfString(`Q: ${question}`, { width });
      currentY += qHeight + 5;
      this.doc.fontSize(this.scaleFontSize(11)).font("Helvetica").fillColor("#666666").text(`R: ${answer}`, x, currentY, { width });
      const aHeight = this.doc.heightOfString(`R: ${answer}`, { width });
      currentY += aHeight + 15;
    }
  }
  // ============================================================
  /**
   * Page de couverture
   */
  renderCoverPage(config) {
    const primaryColor = this.theme.primaryColor || "#1890ff";
    this.doc.rect(0, 0, this.pageWidth, 200).fill(primaryColor);
    if (config.companyImage || this.theme.logoUrl) {
    }
    const title = this.substituteVariables(
      this.getTranslatedValue(config.title, "Devis")
    );
    this.doc.fillColor("#ffffff").fontSize(42).font("Helvetica-Bold").text(title, this.margin, 60, {
      width: this.contentWidth,
      align: "center"
    });
    if (config.subtitle) {
      const subtitle = this.substituteVariables(config.subtitle);
      this.doc.fontSize(18).font("Helvetica").text(subtitle, this.margin, 120, {
        width: this.contentWidth,
        align: "center"
      });
    }
    if (config.showDate !== false) {
      const dateStr = (/* @__PURE__ */ new Date()).toLocaleDateString("fr-FR", {
        day: "2-digit",
        month: "long",
        year: "numeric"
      });
      this.doc.fontSize(12).fillColor("#ffffff").text(dateStr, this.margin, 160, {
        width: this.contentWidth,
        align: "center"
      });
    }
    if (this.ctx.documentNumber) {
      this.doc.fontSize(14).fillColor(primaryColor).text(`N\xB0 ${this.ctx.documentNumber}`, this.margin, 220, {
        width: this.contentWidth,
        align: "right"
      });
    }
    this.currentY = 280;
    this.renderClientInfoBox();
    this.doc.addPage();
    this.currentY = this.margin;
  }
  /**
   * Box d'informations client
   */
  renderClientInfoBox() {
    const lead = this.ctx.lead;
    if (!lead.firstName && !lead.lastName && !lead.company) return;
    const boxX = this.pageWidth - this.margin - 250;
    const boxWidth = 250;
    let boxY = this.currentY;
    this.doc.rect(boxX, boxY, boxWidth, 120).stroke("#e8e8e8");
    this.doc.rect(boxX, boxY, boxWidth, 30).fill(this.theme.primaryColor || "#1890ff");
    this.doc.fillColor("#ffffff").fontSize(12).font("Helvetica-Bold").text("CLIENT", boxX + 10, boxY + 8);
    boxY += 40;
    const fullName = lead.fullName || `${lead.firstName || ""} ${lead.lastName || ""}`.trim();
    if (fullName) {
      this.doc.fillColor(this.theme.textColor || "#333333").fontSize(11).font("Helvetica-Bold").text(fullName, boxX + 10, boxY, { width: boxWidth - 20 });
      boxY += 16;
    }
    if (lead.company) {
      this.doc.font("Helvetica").fontSize(10).fillColor("#666666").text(lead.company, boxX + 10, boxY, { width: boxWidth - 20 });
      boxY += 14;
    }
    if (lead.email) {
      this.doc.fontSize(9).text(`\u{1F4E7} ${lead.email}`, boxX + 10, boxY, { width: boxWidth - 20 });
      boxY += 12;
    }
    if (lead.phone) {
      this.doc.text(`\u{1F4DE} ${lead.phone}`, boxX + 10, boxY, { width: boxWidth - 20 });
      boxY += 12;
    }
    if (lead.address) {
      this.doc.text(`\u{1F4CD} ${lead.address}`, boxX + 10, boxY, { width: boxWidth - 20 });
    }
  }
  /**
   * Pr√©sentation de l'entreprise
   */
  renderCompanyPresentation(config) {
    this.checkPageBreak(150);
    const title = this.substituteVariables(
      this.getTranslatedValue(config.title, "Notre Entreprise")
    );
    this.renderSectionTitle(title);
    if (config.description) {
      const desc = this.substituteVariables(this.getTranslatedValue(config.description, ""));
      this.doc.fontSize(this.theme.fontSize || 11).font("Helvetica").fillColor(this.theme.textColor || "#333333").text(desc, this.margin, this.currentY, {
        width: this.contentWidth,
        align: "justify",
        lineGap: 4
      });
      this.currentY = this.doc.y + 20;
    }
    if (config.highlights && Array.isArray(config.highlights)) {
      for (const highlight of config.highlights) {
        this.doc.fontSize(10).text(`\u2713 ${this.substituteVariables(highlight)}`, this.margin + 20, this.currentY);
        this.currentY += 16;
      }
      this.currentY += 10;
    }
  }
  /**
   * R√©sum√© du projet
   */
  renderProjectSummary(config) {
    this.checkPageBreak(200);
    const title = this.substituteVariables(
      this.getTranslatedValue(config.title, "R\xE9sum\xE9 du Projet")
    );
    this.renderSectionTitle(title);
    if (config.description) {
      const desc = this.substituteVariables(this.getTranslatedValue(config.description, ""));
      this.doc.fontSize(this.theme.fontSize || 11).font("Helvetica").fillColor(this.theme.textColor || "#333333").text(desc, this.margin, this.currentY, {
        width: this.contentWidth,
        align: "justify",
        lineGap: 4
      });
      this.currentY = this.doc.y + 15;
    }
    if (config.linkedFields && Array.isArray(config.linkedFields)) {
      this.renderLinkedFields(config.linkedFields);
    }
    if (config.showTblData !== false) {
      this.renderTblDataSummary();
    }
  }
  /**
   * Tableau des prix
   */
  renderPricingTable(config) {
    this.checkPageBreak(250);
    const title = this.substituteVariables(
      this.getTranslatedValue(config.title || config.tableTitle, "D\xE9tail de l'offre")
    );
    this.renderSectionTitle(title);
    const pricingLines = config.pricingLines || [];
    let items = [];
    if (pricingLines.length > 0) {
      items = this.processPricingLines(pricingLines, config);
    } else {
      items = config.items || this.extractPricingFromTbl();
    }
    if (items && items.length > 0) {
      this.renderPriceTable(items, config);
    } else {
      this.doc.fontSize(this.scaleFontSize(10)).fillColor("#666666").text("Aucun \xE9l\xE9ment de tarification configur\xE9", this.margin, this.currentY);
      this.currentY += 20;
    }
    if (config.showTotals !== false) {
      this.renderPriceTotals(config);
    }
  }
  /**
   * üÜï Traite les lignes de pricing configur√©es
   * - √âvalue les conditions d'affichage
   * - R√©sout les r√©f√©rences TBL (@value.xxx, @calculated.xxx, node-formula:xxx, etc.)
   * - G√©n√®re N lignes pour les repeaters
   */
  processPricingLines(pricingLines, _config) {
    const results = [];
    const tblData = this.ctx.tblData || {};
    for (const line of pricingLines) {
      if (line.condition && !this.evaluateCondition(line.condition)) {
        console.log(`\u{1F4C4} [PDF] Ligne "${line.label}" ignor\xE9e (condition non remplie)`);
        continue;
      }
      if (line.type === "repeater" && line.repeaterId) {
        const repeaterInstances = this.getRepeaterInstances(line.repeaterId, tblData);
        for (const instance of repeaterInstances) {
          const resolvedLine = this.resolveLineValues(line, instance);
          results.push(resolvedLine);
        }
      } else {
        const resolvedLine = this.resolveLineValues(line);
        results.push(resolvedLine);
      }
    }
    return results;
  }
  /**
   * R√©sout les valeurs d'une ligne (substitue les tokens TBL)
   */
  resolveLineValues(line, repeaterInstance) {
    console.log("\u{1F4C4} [PDF] resolveLineValues:", {
      label: line.label,
      labelSource: line.labelSource,
      quantity: line.quantity,
      quantitySource: line.quantitySource,
      unitPrice: line.unitPrice,
      unitPriceSource: line.unitPriceSource
    });
    const resolvedLine = {
      description: "",
      quantity: 1,
      unitPrice: 0,
      total: 0
    };
    if (line.labelSource) {
      const resolved = this.resolveVariable(line.labelSource);
      console.log(`\u{1F4C4} [PDF] Label r\xE9solu: "${resolved}" (source: ${line.labelSource})`);
      resolvedLine.description = resolved || line.label || "Non d\xE9fini";
    } else {
      resolvedLine.description = this.substituteVariables(line.label || "");
    }
    if (repeaterInstance && repeaterInstance.instanceLabel) {
      resolvedLine.description = `${resolvedLine.description} (${repeaterInstance.instanceLabel})`;
    }
    if (line.quantitySource) {
      const qty = this.resolveVariable(line.quantitySource);
      console.log(`\u{1F4C4} [PDF] Quantit\xE9 r\xE9solue: "${qty}" (source: ${line.quantitySource})`);
      resolvedLine.quantity = parseFloat(qty) || 1;
    } else if (typeof line.quantity === "string" && line.quantity.startsWith("@")) {
      const qty = this.resolveVariable(line.quantity);
      resolvedLine.quantity = parseFloat(qty) || 1;
    } else {
      resolvedLine.quantity = parseFloat(line.quantity) || 1;
    }
    if (line.unitPriceSource) {
      const price = this.resolveVariable(line.unitPriceSource);
      console.log(`\u{1F4C4} [PDF] Prix r\xE9solu: "${price}" (source: ${line.unitPriceSource})`);
      resolvedLine.unitPrice = parseFloat(price) || 0;
    } else if (typeof line.unitPrice === "string" && (line.unitPrice.startsWith("@") || line.unitPrice.startsWith("node-formula:") || line.unitPrice.startsWith("condition:"))) {
      const price = this.resolveVariable(line.unitPrice);
      resolvedLine.unitPrice = parseFloat(price) || 0;
    } else {
      resolvedLine.unitPrice = parseFloat(line.unitPrice) || 0;
    }
    console.log(`\u{1F4C4} [PDF] \u27A1\uFE0F Ligne r\xE9solue:`, resolvedLine);
    if (line.totalSource) {
      const tot = this.resolveVariable(line.totalSource);
      resolvedLine.total = parseFloat(tot) || 0;
    } else if (typeof line.total === "string" && line.total.startsWith("@")) {
      const tot = this.resolveVariable(line.total);
      resolvedLine.total = parseFloat(tot) || 0;
    } else if (line.total !== void 0) {
      resolvedLine.total = parseFloat(line.total) || 0;
    } else {
      resolvedLine.total = resolvedLine.quantity * resolvedLine.unitPrice;
    }
    return resolvedLine;
  }
  /**
   * R√©cup√®re les instances d'un repeater depuis les donn√©es TBL
   */
  getRepeaterInstances(repeaterId, tblData) {
    const instances = [];
    const repeaterPattern = new RegExp(`^${repeaterId}-\\d+$`);
    for (const key2 of Object.keys(tblData)) {
      if (repeaterPattern.test(key2) || key2.startsWith(`${repeaterId}-`)) {
        const instanceNumber = key2.split("-").pop();
        instances.push({
          id: key2,
          instanceLabel: `#${instanceNumber}`,
          data: tblData[key2]
        });
      }
    }
    if (instances.length === 0 && this.ctx.submission) {
      const submission = this.ctx.submission;
      const values = submission.values || {};
      for (const key2 of Object.keys(values)) {
        if (key2.includes(repeaterId) && key2.match(/-\d+$/)) {
          const instanceNumber = key2.split("-").pop();
          if (!instances.find((i) => i.instanceLabel === `#${instanceNumber}`)) {
            instances.push({
              id: key2,
              instanceLabel: `#${instanceNumber}`,
              data: values[key2]
            });
          }
        }
      }
    }
    console.log(`\u{1F4C4} [PDF] Repeater ${repeaterId}: ${instances.length} instance(s) trouv\xE9e(s)`);
    return instances;
  }
  /**
   * √âvalue une condition d'affichage
   */
  evaluateCondition(condition) {
    if (!condition || !condition.rules || condition.rules.length === 0) {
      return true;
    }
    const operator = condition.operator || "AND";
    const results = [];
    for (const rule of condition.rules) {
      const sourceValue = this.resolveVariable(rule.source);
      const targetValue = rule.value;
      let ruleResult = false;
      switch (rule.operator) {
        case "equals":
        case "==":
          ruleResult = String(sourceValue) === String(targetValue);
          break;
        case "notEquals":
        case "!=":
          ruleResult = String(sourceValue) !== String(targetValue);
          break;
        case "contains":
          ruleResult = String(sourceValue).includes(String(targetValue));
          break;
        case "notContains":
          ruleResult = !String(sourceValue).includes(String(targetValue));
          break;
        case "greaterThan":
        case ">":
          ruleResult = parseFloat(sourceValue) > parseFloat(targetValue);
          break;
        case "lessThan":
        case "<":
          ruleResult = parseFloat(sourceValue) < parseFloat(targetValue);
          break;
        case "greaterOrEqual":
        case ">=":
          ruleResult = parseFloat(sourceValue) >= parseFloat(targetValue);
          break;
        case "lessOrEqual":
        case "<=":
          ruleResult = parseFloat(sourceValue) <= parseFloat(targetValue);
          break;
        case "isEmpty":
          ruleResult = !sourceValue || sourceValue === "";
          break;
        case "isNotEmpty":
          ruleResult = !!sourceValue && sourceValue !== "";
          break;
        case "isTrue":
          ruleResult = sourceValue === true || sourceValue === "true" || sourceValue === 1;
          break;
        case "isFalse":
          ruleResult = sourceValue === false || sourceValue === "false" || sourceValue === 0;
          break;
        default:
          ruleResult = true;
      }
      results.push(ruleResult);
    }
    if (operator === "AND") {
      return results.every((r) => r);
    } else {
      return results.some((r) => r);
    }
  }
  /**
   * Rendu du tableau de prix
   */
  renderPriceTable(items, _config) {
    const colWidths = {
      description: this.contentWidth * 0.5,
      quantity: this.contentWidth * 0.1,
      unitPrice: this.contentWidth * 0.2,
      total: this.contentWidth * 0.2
    };
    const headerY = this.currentY;
    this.doc.rect(this.margin, headerY, this.contentWidth, 25).fill(this.theme.primaryColor || "#1890ff");
    this.doc.fillColor("#ffffff").fontSize(10).font("Helvetica-Bold");
    let xPos = this.margin + 5;
    this.doc.text("Description", xPos, headerY + 7, { width: colWidths.description - 10 });
    xPos += colWidths.description;
    this.doc.text("Qt\xE9", xPos, headerY + 7, { width: colWidths.quantity - 10, align: "center" });
    xPos += colWidths.quantity;
    this.doc.text("Prix unit.", xPos, headerY + 7, { width: colWidths.unitPrice - 10, align: "right" });
    xPos += colWidths.unitPrice;
    this.doc.text("Total", xPos, headerY + 7, { width: colWidths.total - 10, align: "right" });
    this.currentY = headerY + 30;
    this.doc.font("Helvetica").fillColor(this.theme.textColor || "#333333");
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const rowY = this.currentY;
      if (i % 2 === 1) {
        this.doc.rect(this.margin, rowY, this.contentWidth, 22).fill("#f9f9f9");
      }
      this.doc.fillColor(this.theme.textColor || "#333333").fontSize(9);
      xPos = this.margin + 5;
      const desc = this.substituteVariables(item.description || item.name || "");
      this.doc.text(desc, xPos, rowY + 5, { width: colWidths.description - 10 });
      xPos += colWidths.description;
      this.doc.text(String(item.quantity || 1), xPos, rowY + 5, { width: colWidths.quantity - 10, align: "center" });
      xPos += colWidths.quantity;
      const unitPrice = typeof item.unitPrice === "number" ? item.unitPrice.toFixed(2) + " \u20AC" : item.unitPrice || "-";
      this.doc.text(unitPrice, xPos, rowY + 5, { width: colWidths.unitPrice - 10, align: "right" });
      xPos += colWidths.unitPrice;
      const total = typeof item.total === "number" ? item.total.toFixed(2) + " \u20AC" : item.total || "-";
      this.doc.text(total, xPos, rowY + 5, { width: colWidths.total - 10, align: "right" });
      this.currentY += 22;
      this.checkPageBreak(25);
    }
    this.doc.moveTo(this.margin, this.currentY).lineTo(this.margin + this.contentWidth, this.currentY).stroke("#e8e8e8");
    this.currentY += 10;
  }
  /**
   * Totaux du tableau de prix
   */
  renderPriceTotals(config) {
    const quote = this.ctx.quote || {};
    const totalsX = this.pageWidth - this.margin - 200;
    if (quote.totalHT !== void 0 || config.totalHT !== void 0) {
      const ht = quote.totalHT ?? config.totalHT ?? 0;
      this.doc.fontSize(this.scaleFontSize(10)).font("Helvetica").fillColor("#666666").text("Total HT:", totalsX, this.currentY, { width: 100 });
      this.doc.font("Helvetica-Bold").fillColor(this.theme.textColor || "#333333").text(`${ht.toFixed(2)} \u20AC`, totalsX + 100, this.currentY, { width: 90, align: "right" });
      this.currentY += 18;
    }
    if (quote.totalTVA !== void 0 || config.totalTVA !== void 0) {
      const tva = quote.totalTVA ?? config.totalTVA ?? 0;
      this.doc.fontSize(this.scaleFontSize(10)).font("Helvetica").fillColor("#666666").text("TVA (21%):", totalsX, this.currentY, { width: 100 });
      this.doc.font("Helvetica-Bold").fillColor(this.theme.textColor || "#333333").text(`${tva.toFixed(2)} \u20AC`, totalsX + 100, this.currentY, { width: 90, align: "right" });
      this.currentY += 18;
    }
    if (quote.totalTTC !== void 0 || config.totalTTC !== void 0) {
      const ttc = quote.totalTTC ?? config.totalTTC ?? 0;
      this.doc.rect(totalsX - 10, this.currentY - 5, 210, 30).fill(this.theme.primaryColor || "#1890ff");
      this.doc.fontSize(this.scaleFontSize(12)).font("Helvetica-Bold").fillColor("#ffffff").text("TOTAL TTC:", totalsX, this.currentY + 3, { width: 100 });
      this.doc.text(`${ttc.toFixed(2)} \u20AC`, totalsX + 100, this.currentY + 3, { width: 90, align: "right" });
      this.currentY += 40;
    }
  }
  /**
   * Bloc de texte libre
   */
  renderTextBlock(config) {
    this.checkPageBreak(100);
    if (config.title) {
      const title = this.substituteVariables(this.getTranslatedValue(config.title, ""));
      if (title) {
        this.renderSectionTitle(title);
      }
    }
    if (config.content) {
      const content = this.substituteVariables(this.getTranslatedValue(config.content, ""));
      this.doc.fontSize(config.fontSize || this.theme.fontSize || 11).font("Helvetica").fillColor(this.theme.textColor || "#333333").text(content, this.margin, this.currentY, {
        width: this.contentWidth,
        align: config.align || "left",
        lineGap: 4
      });
      this.currentY = this.doc.y + 20;
    }
  }
  /**
   * Conditions g√©n√©rales
   */
  renderTermsConditions(config) {
    this.checkPageBreak(150);
    const title = this.substituteVariables(
      this.getTranslatedValue(config.title, "Conditions G\xE9n\xE9rales")
    );
    this.renderSectionTitle(title);
    const terms = this.getTranslatedValue(config.terms, config.content || "");
    if (terms) {
      this.doc.fontSize(9).font("Helvetica").fillColor("#666666").text(this.substituteVariables(terms), this.margin, this.currentY, {
        width: this.contentWidth,
        align: "justify",
        lineGap: 3
      });
      this.currentY = this.doc.y + 20;
    }
    if (config.items && Array.isArray(config.items)) {
      for (const item of config.items) {
        this.doc.fontSize(9).text(`\u2022 ${this.substituteVariables(item)}`, this.margin + 10, this.currentY);
        this.currentY += 14;
      }
      this.currentY += 10;
    }
  }
  /**
   * Bloc de signature
   */
  renderSignatureBlock(config) {
    this.checkPageBreak(150);
    const title = this.substituteVariables(
      this.getTranslatedValue(config.title, "Signature")
    );
    if (config.showTitle !== false) {
      this.renderSectionTitle(title);
    }
    if (config.acceptanceText) {
      const text = this.substituteVariables(this.getTranslatedValue(config.acceptanceText, ""));
      this.doc.fontSize(10).font("Helvetica").fillColor(this.theme.textColor || "#333333").text(text, this.margin, this.currentY, {
        width: this.contentWidth
      });
      this.currentY = this.doc.y + 20;
    }
    const colWidth = (this.contentWidth - 40) / 2;
    const leftX = this.margin;
    const rightX = this.margin + colWidth + 40;
    const signatureY = this.currentY;
    this.doc.fontSize(10).font("Helvetica-Bold").fillColor(this.theme.textColor || "#333333").text("Le Client", leftX, signatureY);
    this.doc.fontSize(9).font("Helvetica").fillColor("#666666").text("Date: ____/____/________", leftX, signatureY + 20).text("Signature pr\xE9c\xE9d\xE9e de la mention", leftX, signatureY + 40).text('"Lu et approuv\xE9":', leftX, signatureY + 52);
    this.doc.rect(leftX, signatureY + 70, colWidth, 60).stroke("#cccccc");
    this.doc.fontSize(10).font("Helvetica-Bold").fillColor(this.theme.textColor || "#333333").text("Pour l'entreprise", rightX, signatureY);
    this.doc.fontSize(9).font("Helvetica").fillColor("#666666").text("Date: ____/____/________", rightX, signatureY + 20).text(this.ctx.organization?.name || "", rightX, signatureY + 40);
    this.doc.rect(rightX, signatureY + 70, colWidth, 60).stroke("#cccccc");
    this.currentY = signatureY + 150;
  }
  /**
   * Informations de contact
   */
  renderContactInfo(config) {
    this.checkPageBreak(100);
    const title = this.substituteVariables(
      this.getTranslatedValue(config.title, "Contact")
    );
    this.renderSectionTitle(title);
    const org = this.ctx.organization || {};
    if (org.name) {
      this.doc.fontSize(11).font("Helvetica-Bold").fillColor(this.theme.textColor || "#333333").text(org.name, this.margin, this.currentY);
      this.currentY += 18;
    }
    this.doc.font("Helvetica").fontSize(10).fillColor("#666666");
    if (org.address) {
      this.doc.text(`\u{1F4CD} ${org.address}`, this.margin, this.currentY);
      this.currentY += 14;
    }
    if (org.phone) {
      this.doc.text(`\u{1F4DE} ${org.phone}`, this.margin, this.currentY);
      this.currentY += 14;
    }
    if (org.email) {
      this.doc.text(`\u{1F4E7} ${org.email}`, this.margin, this.currentY);
      this.currentY += 14;
    }
    if (org.website) {
      this.doc.text(`\u{1F310} ${org.website}`, this.margin, this.currentY);
      this.currentY += 14;
    }
    if (org.vatNumber) {
      this.doc.text(`TVA: ${org.vatNumber}`, this.margin, this.currentY);
      this.currentY += 14;
    }
    this.currentY += 10;
  }
  /**
   * Sp√©cifications techniques (donn√©es TBL)
   */
  renderTechnicalSpecs(config) {
    this.checkPageBreak(150);
    const title = this.substituteVariables(
      this.getTranslatedValue(config.title, "Sp\xE9cifications Techniques")
    );
    this.renderSectionTitle(title);
    this.renderTblDataSummary();
  }
  /**
   * Timeline / Calendrier
   */
  renderTimeline(config) {
    this.checkPageBreak(150);
    const title = this.substituteVariables(
      this.getTranslatedValue(config.title, "Calendrier")
    );
    this.renderSectionTitle(title);
    if (config.items && Array.isArray(config.items)) {
      for (const item of config.items) {
        this.doc.fontSize(10).font("Helvetica-Bold").fillColor(this.theme.primaryColor || "#1890ff").text(`\u{1F4C5} ${item.date || ""}`, this.margin, this.currentY);
        this.doc.font("Helvetica").fillColor(this.theme.textColor || "#333333").text(this.substituteVariables(item.description || ""), this.margin + 100, this.currentY);
        this.currentY += 20;
      }
    }
    this.currentY += 10;
  }
  /**
   * Image
   */
  renderImage(config) {
    if (config.url || config.src) {
      this.checkPageBreak(100);
      this.doc.fontSize(10).fillColor("#999999").text(`[Image: ${config.url || config.src}]`, this.margin, this.currentY);
      this.currentY += 20;
    }
  }
  /**
   * Contenu personnalis√©
   */
  renderCustomContent(config) {
    if (config.content) {
      const content = this.substituteVariables(config.content);
      this.doc.fontSize(this.theme.fontSize || 11).font("Helvetica").fillColor(this.theme.textColor || "#333333").text(content, this.margin, this.currentY, {
        width: this.contentWidth
      });
      this.currentY = this.doc.y + 15;
    }
  }
  // ============================================================
  // HELPERS
  // ============================================================
  /**
   * Rendu d'un titre de section
   */
  renderSectionTitle(title) {
    this.doc.fontSize(16).font("Helvetica-Bold").fillColor(this.theme.primaryColor || "#1890ff").text(title, this.margin, this.currentY);
    this.currentY = this.doc.y + 5;
    this.doc.moveTo(this.margin, this.currentY).lineTo(this.margin + 100, this.currentY).lineWidth(2).stroke(this.theme.primaryColor || "#1890ff");
    this.currentY += 15;
  }
  /**
   * Rendu des donn√©es TBL
   */
  renderTblDataSummary() {
    const tblData = this.ctx.tblData || {};
    const entries = Object.entries(tblData).filter(([_key, value]) => {
      if (value === null || value === void 0) return false;
      if (typeof value === "string" && value.startsWith("data:image")) return false;
      if (typeof value === "string" && value.length > 500) return false;
      return true;
    });
    if (entries.length === 0) {
      this.doc.fontSize(10).fillColor("#999999").text("Aucune donn\xE9e technique disponible", this.margin, this.currentY);
      this.currentY += 20;
      return;
    }
    for (const [key2, value] of entries) {
      this.checkPageBreak(20);
      const label = this.formatLabel(key2);
      const displayValue = this.formatValue(value);
      this.doc.fontSize(10).font("Helvetica-Bold").fillColor("#666666").text(`${label}:`, this.margin, this.currentY, { continued: true, width: 200 });
      this.doc.font("Helvetica").fillColor(this.theme.textColor || "#333333").text(` ${displayValue}`, { width: this.contentWidth - 210 });
      this.currentY = this.doc.y + 5;
    }
    this.currentY += 10;
  }
  /**
   * Rendu des champs li√©s
   */
  renderLinkedFields(linkedFields) {
    for (const fieldRef of linkedFields) {
      const value = this.resolveVariable(fieldRef);
      if (value) {
        this.doc.fontSize(10).font("Helvetica").fillColor(this.theme.textColor || "#333333").text(`\u2022 ${value}`, this.margin + 10, this.currentY);
        this.currentY += 16;
      }
    }
  }
  /**
   * Extraire les donn√©es de prix depuis TBL
   */
  extractPricingFromTbl() {
    return [];
  }
  /**
   * Substitue les variables dans un texte
   */
  substituteVariables(text) {
    if (!text || typeof text !== "string") return text || "";
    let result = text;
    result = result.replace(/@(value|select)\.([a-zA-Z0-9_.-]+)/g, (match, type, ref) => {
      return this.resolveVariable(`@${type}.${ref}`) || match;
    });
    result = result.replace(/\{\{([a-zA-Z0-9_.]+)\}\}/g, (match, ref) => {
      return this.resolveVariable(ref) || match;
    });
    result = result.replace(/\{(lead|quote|org)\.([a-zA-Z0-9_.]+)\}/g, (match, source, key2) => {
      const resolved = this.resolveVariable(`${source}.${key2}`);
      return resolved || match;
    });
    return result;
  }
  /**
   * R√©sout une r√©f√©rence de variable
   */
  resolveVariable(ref) {
    const lead = this.ctx.lead || {};
    const org = this.ctx.organization || {};
    const quote = this.ctx.quote || {};
    const tblData = this.ctx.tblData || {};
    console.log(`\u{1F4C4} [PDF] resolveVariable("${ref}")`, { tblDataKeys: Object.keys(tblData).slice(0, 10) });
    if (ref.startsWith("lead.")) {
      const key2 = ref.replace("lead.", "");
      return String(lead[key2] || "");
    }
    if (ref.startsWith("org.")) {
      const key2 = ref.replace("org.", "");
      return String(org[key2] || "");
    }
    if (ref.startsWith("quote.")) {
      const key2 = ref.replace("quote.", "");
      const value = quote[key2];
      if (typeof value === "number") return value.toFixed(2);
      return String(value || "");
    }
    if (ref.startsWith("@value.") || ref.startsWith("@select.")) {
      const nodeRef = ref.replace(/^@(value|select)\./, "");
      console.log(`\u{1F4C4} [PDF] Cherche TBL ref: "${nodeRef}"`);
      if (tblData[nodeRef] !== void 0) {
        console.log(`\u{1F4C4} [PDF] \u2705 Trouv\xE9 exact: ${tblData[nodeRef]}`);
        return this.formatValue(tblData[nodeRef]);
      }
      if (tblData.values && tblData.values[nodeRef] !== void 0) {
        console.log(`\u{1F4C4} [PDF] \u2705 Trouv\xE9 dans values: ${tblData.values[nodeRef]}`);
        return this.formatValue(tblData.values[nodeRef]);
      }
      for (const [key2, value] of Object.entries(tblData)) {
        if (key2.includes(nodeRef) || key2.endsWith(nodeRef)) {
          console.log(`\u{1F4C4} [PDF] \u2705 Trouv\xE9 partiel "${key2}": ${value}`);
          return this.formatValue(value);
        }
      }
      if (tblData.values) {
        for (const [key2, value] of Object.entries(tblData.values)) {
          if (key2.includes(nodeRef) || key2.endsWith(nodeRef)) {
            console.log(`\u{1F4C4} [PDF] \u2705 Trouv\xE9 partiel dans values "${key2}": ${value}`);
            return this.formatValue(value);
          }
        }
      }
    }
    if (ref.startsWith("calculatedValue:") || ref.startsWith("@calculated.")) {
      const calcRef = ref.replace(/^(calculatedValue:|@calculated\.)/, "");
      console.log(`\u{1F4C4} [PDF] Cherche calculatedValue: "${calcRef}"`);
      if (tblData.calculatedValues && tblData.calculatedValues[calcRef] !== void 0) {
        return this.formatValue(tblData.calculatedValues[calcRef]);
      }
      if (tblData[calcRef] !== void 0) {
        return this.formatValue(tblData[calcRef]);
      }
      for (const [key2, value] of Object.entries(tblData)) {
        if (key2.includes(calcRef) || key2.endsWith(calcRef)) {
          return this.formatValue(value);
        }
      }
    }
    if (ref.startsWith("node-formula:") || ref.startsWith("formula:")) {
      const formulaRef = ref.replace(/^(node-formula:|formula:)/, "");
      console.log(`\u{1F4C4} [PDF] Cherche formula: "${formulaRef}"`);
      if (tblData.formulas && tblData.formulas[formulaRef] !== void 0) {
        return this.formatValue(tblData.formulas[formulaRef]);
      }
      if (tblData[formulaRef] !== void 0) {
        return this.formatValue(tblData[formulaRef]);
      }
      for (const [key2, value] of Object.entries(tblData)) {
        if (key2.includes(formulaRef) || key2.endsWith(formulaRef)) {
          return this.formatValue(value);
        }
      }
    }
    if (ref.startsWith("condition:")) {
      const condRef = ref.replace("condition:", "");
      console.log(`\u{1F4C4} [PDF] Cherche condition: "${condRef}"`);
      if (tblData.conditions && tblData.conditions[condRef] !== void 0) {
        return this.formatValue(tblData.conditions[condRef]);
      }
      if (tblData[condRef] !== void 0) {
        return this.formatValue(tblData[condRef]);
      }
    }
    if (tblData[ref] !== void 0) {
      return this.formatValue(tblData[ref]);
    }
    for (const [key2, value] of Object.entries(tblData)) {
      if (key2.includes(ref) || ref.includes(key2)) {
        console.log(`\u{1F4C4} [PDF] \u2705 Trouv\xE9 par recherche globale "${key2}": ${value}`);
        return this.formatValue(value);
      }
    }
    console.log(`\u{1F4C4} [PDF] \u274C Variable non trouv\xE9e: "${ref}"`);
    return "";
  }
  /**
   * R√©cup√®re une valeur traduite
   */
  getTranslatedValue(value, fallback) {
    if (!value) return fallback;
    if (typeof value === "string") return value;
    if (typeof value === "object") {
      return value[this.ctx.language] || value["fr"] || value[Object.keys(value)[0]] || fallback;
    }
    return fallback;
  }
  /**
   * √âvalue une condition d'affichage (legacy - pour sections)
   */
  evaluateCondition(_condition) {
    return true;
  }
  /**
   * √âvalue une seule r√®gle de condition
   */
  evaluateSingleConditionRule(rule) {
    const fieldRef = rule.fieldRef;
    let fieldValue = null;
    const curlyMatch = fieldRef.match(/^\{(lead|quote|org)\.([a-zA-Z0-9_.]+)\}$/);
    if (curlyMatch) {
      const [, source, key2] = curlyMatch;
      let data = null;
      if (source === "lead") data = this.ctx.lead;
      else if (source === "quote") data = this.ctx.quote;
      else if (source === "org") data = this.ctx.organization;
      if (data) {
        const keys = key2.split(".");
        fieldValue = data;
        for (const k of keys) {
          fieldValue = fieldValue?.[k];
        }
      }
    }
    const tblMatch = fieldRef.match(/^@(value|select)\.([a-zA-Z0-9_.-]+)$/);
    if (tblMatch) {
      const [, , key2] = tblMatch;
      fieldValue = this.ctx.tblData?.[key2];
    }
    const compareValue = rule.compareValue;
    console.log(`\u{1F4CB} [PDF Condition] Rule: ${fieldRef} ${rule.operator} ${compareValue} | fieldValue=${fieldValue}`);
    switch (rule.operator) {
      case "IS_EMPTY":
        return fieldValue === null || fieldValue === void 0 || fieldValue === "";
      case "IS_NOT_EMPTY":
        return fieldValue !== null && fieldValue !== void 0 && fieldValue !== "";
      case "EQUALS":
        return String(fieldValue) === String(compareValue);
      case "NOT_EQUALS":
        return String(fieldValue) !== String(compareValue);
      case "CONTAINS":
        return String(fieldValue || "").toLowerCase().includes(String(compareValue).toLowerCase());
      case "NOT_CONTAINS":
        return !String(fieldValue || "").toLowerCase().includes(String(compareValue).toLowerCase());
      case "GREATER_THAN":
        return Number(fieldValue) > Number(compareValue);
      case "LESS_THAN":
        return Number(fieldValue) < Number(compareValue);
      case "GREATER_OR_EQUAL":
        return Number(fieldValue) >= Number(compareValue);
      case "LESS_OR_EQUAL":
        return Number(fieldValue) <= Number(compareValue);
      default:
        return true;
    }
  }
  /**
   * √âvalue les conditions d'un module et retourne le r√©sultat
   * @returns { shouldRender: boolean, content?: string }
   */
  evaluateModuleConditions(config) {
    const conditionalConfig = config._conditionalDisplay;
    if (!conditionalConfig || !conditionalConfig.enabled || conditionalConfig.rules.length === 0) {
      return { shouldRender: true };
    }
    console.log(`\u{1F4CB} [PDF] \xC9valuation conditions:`, JSON.stringify(conditionalConfig.rules));
    let result = this.evaluateSingleConditionRule(conditionalConfig.rules[0]);
    for (let i = 1; i < conditionalConfig.rules.length; i++) {
      const rule = conditionalConfig.rules[i];
      const ruleResult = this.evaluateSingleConditionRule(rule);
      if (rule.logicOperator === "AND") {
        result = result && ruleResult;
      } else if (rule.logicOperator === "OR") {
        result = result || ruleResult;
      }
    }
    const action2 = conditionalConfig.rules[0]?.action || "SHOW";
    console.log(`\u{1F4CB} [PDF] Condition result: ${result}, action: ${action2}`);
    if (action2 === "SHOW") {
      if (result && conditionalConfig.showContent) {
        return {
          shouldRender: true,
          content: this.substituteVariables(conditionalConfig.showContent)
        };
      } else if (!result && conditionalConfig.hideContent) {
        return {
          shouldRender: true,
          content: this.substituteVariables(conditionalConfig.hideContent)
        };
      } else if (!result) {
        return { shouldRender: false };
      }
      return { shouldRender: result };
    } else if (action2 === "HIDE") {
      if (!result && conditionalConfig.showContent) {
        return {
          shouldRender: true,
          content: this.substituteVariables(conditionalConfig.showContent)
        };
      } else if (result && conditionalConfig.hideContent) {
        return {
          shouldRender: true,
          content: this.substituteVariables(conditionalConfig.hideContent)
        };
      }
      return { shouldRender: !result };
    } else if (action2 === "ADD_CONTENT") {
      return {
        shouldRender: true,
        content: result ? this.substituteVariables(conditionalConfig.addContent || "") : this.substituteVariables(conditionalConfig.hideContent || "")
      };
    }
    return { shouldRender: true };
  }
  /**
   * Formate un label
   */
  formatLabel(key2) {
    if (/^[a-f0-9-]{36}$/i.test(key2)) return "Champ";
    return key2.replace(/([A-Z])/g, " $1").replace(/^./, (str) => str.toUpperCase()).replace(/_/g, " ").trim();
  }
  /**
   * Formate une valeur
   */
  formatValue(value) {
    if (value === null || value === void 0) return "-";
    if (typeof value === "boolean") return value ? "Oui" : "Non";
    if (Array.isArray(value)) return value.join(", ");
    if (typeof value === "number") return value.toLocaleString("fr-FR");
    if (typeof value === "object") return JSON.stringify(value);
    return String(value);
  }
  /**
   * V√©rifie si besoin d'une nouvelle page
   */
  checkPageBreak(neededSpace) {
    if (this.currentY + neededSpace > this.pageHeight - this.margin - 50) {
      this.doc.addPage();
      this.currentY = this.margin;
    }
  }
  /**
   * Pied de page - dessine sur la position absolue en bas de page
   */
  renderFooter() {
    const footerY = this.pageHeight - 40;
    const footerText = `Document g\xE9n\xE9r\xE9 le ${(/* @__PURE__ */ new Date()).toLocaleDateString("fr-FR")} | ${this.ctx.organization?.name || "2Thier CRM"}`;
    console.log(`\u{1F4C4} [PDF] FOOTER: y=${footerY}`);
    this.doc.fontSize(8).font("Helvetica").fillColor("#999999").text(footerText, this.margin, footerY, {
      width: this.contentWidth,
      align: "center",
      lineBreak: false,
      height: 20
      // Limiter strictement la hauteur
    });
  }
  ensureDocumentIsA4() {
    const page = this.doc.page;
    if (!page) return;
    const actualWidth = page.width ?? this.pageWidth;
    const actualHeight = page.height ?? this.pageHeight;
    const widthDiff = Math.abs(actualWidth - this.pageWidth);
    const heightDiff = Math.abs(actualHeight - this.pageHeight);
    if (widthDiff > A4_DIMENSION_TOLERANCE || heightDiff > A4_DIMENSION_TOLERANCE) {
      console.warn(`\u{1F4C4} [PDF] Taille A4 attendue: ${this.pageWidth.toFixed(2)}x${this.pageHeight.toFixed(2)}, taille r\xE9elle: ${actualWidth.toFixed(2)}x${actualHeight.toFixed(2)}`);
    }
    this.pageWidth = actualWidth;
    this.pageHeight = actualHeight;
    this.contentWidth = this.pageWidth - this.margin * 2;
  }
};
async function renderDocumentPdf(context) {
  const renderer = new DocumentPdfRenderer(context);
  return renderer.render();
}

// src/routes/documents.ts
var router70 = (0, import_express71.Router)();
var prisma41 = db;
function extractAddressComponents(lead) {
  const data = lead?.data || {};
  const result = {
    address: "",
    street: "",
    number: "",
    box: "",
    postalCode: "",
    city: "",
    country: ""
  };
  result.address = lead?.address || data?.address || "";
  result.street = lead?.street || data?.street || "";
  result.number = lead?.number || data?.number || "";
  result.box = lead?.box || data?.box || data?.boite || "";
  result.postalCode = lead?.postalCode || lead?.zipCode || data?.postalCode || data?.zipCode || data?.zip || "";
  result.city = lead?.city || lead?.ville || data?.city || data?.ville || "";
  result.country = lead?.country || lead?.pays || data?.country || data?.pays || "";
  if (result.address && (!result.street || !result.postalCode || !result.city)) {
    const parsed = parseAddress(result.address);
    if (!result.street && parsed.street) result.street = parsed.street;
    if (!result.number && parsed.number) result.number = parsed.number;
    if (!result.box && parsed.box) result.box = parsed.box;
    if (!result.postalCode && parsed.postalCode) result.postalCode = parsed.postalCode;
    if (!result.city && parsed.city) result.city = parsed.city;
  }
  if (!result.address && (result.street || result.city)) {
    const parts = [];
    if (result.street) {
      let streetPart = result.street;
      if (result.number) streetPart += " " + result.number;
      if (result.box) streetPart += " " + result.box;
      parts.push(streetPart);
    }
    if (result.postalCode || result.city) {
      parts.push([result.postalCode, result.city].filter(Boolean).join(" "));
    }
    result.address = parts.join(", ");
  }
  return result;
}
function parseAddress(address) {
  const result = { street: "", number: "", box: "", postalCode: "", city: "" };
  if (!address || typeof address !== "string") return result;
  const postalMatch = address.match(/(\d{4})\s*(.+?)$/i);
  if (postalMatch) {
    result.postalCode = postalMatch[1];
    result.city = postalMatch[2].replace(/^,\s*/, "").trim();
    const streetPart = address.substring(0, postalMatch.index).replace(/,\s*$/, "").trim();
    const streetNumMatch = streetPart.match(/^(.+?)\s+(\d+[a-zA-Z]?)(?:\s+(?:Bte|bo√Æte|box|b)?\.?\s*(\d+|[a-zA-Z]))?$/i);
    if (streetNumMatch) {
      result.street = streetNumMatch[1].trim();
      result.number = streetNumMatch[2];
      result.box = streetNumMatch[3] || "";
    } else {
      result.street = streetPart;
    }
  } else {
    result.street = address;
  }
  return result;
}
router70.get("/templates", async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"];
    const isSuperAdmin2 = req2.headers["x-is-super-admin"] === "true";
    const { treeId, isActive, type } = req2.query;
    if (!organizationId && !isSuperAdmin2) {
      return res.status(400).json({ error: "Organization ID requis" });
    }
    const where = isSuperAdmin2 ? {} : { organizationId };
    if (treeId) {
      where.OR = [
        { treeId },
        { treeId: null }
        // Templates g√©n√©riques disponibles pour tous les arbres
      ];
    }
    if (isActive === "true") {
      where.isActive = true;
    } else if (isActive === "false") {
      where.isActive = false;
    }
    if (type) {
      where.type = type;
    }
    const templates = await prisma41.documentTemplate.findMany({
      where,
      include: {
        DocumentSection: {
          orderBy: { order: "asc" }
        },
        DocumentTheme: true,
        TreeBranchLeafTree: {
          select: {
            id: true,
            name: true
          }
        },
        User: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        _count: {
          select: { GeneratedDocument: true }
        }
      },
      orderBy: { createdAt: "desc" }
    });
    res.json(templates);
  } catch (error) {
    console.error("Erreur r\xE9cup\xE9ration templates:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router70.get("/templates/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.headers["x-organization-id"];
    const isSuperAdmin2 = req2.headers["x-is-super-admin"] === "true";
    const whereClause = { id };
    if (!isSuperAdmin2 && organizationId) {
      whereClause.organizationId = organizationId;
    }
    const template = await prisma41.documentTemplate.findFirst({
      where: whereClause,
      include: {
        DocumentSection: {
          orderBy: { order: "asc" }
        },
        DocumentTheme: true
      }
    });
    if (!template) {
      return res.status(404).json({ error: "Template non trouv\xE9" });
    }
    res.json(template);
  } catch (error) {
    console.error("Erreur r\xE9cup\xE9ration template:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router70.post("/templates", async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"];
    const userId = req2.headers["x-user-id"];
    const {
      name,
      type,
      description,
      translations,
      defaultLanguage,
      themeId,
      sections
    } = req2.body;
    if (!name || !type) {
      return res.status(400).json({ error: "Nom et type requis" });
    }
    const template = await prisma41.documentTemplate.create({
      data: {
        id: (0, import_nanoid2.nanoid)(),
        name,
        type,
        description,
        organizationId,
        translations: translations || {},
        defaultLanguage: defaultLanguage || "fr",
        themeId,
        createdBy: userId,
        updatedAt: /* @__PURE__ */ new Date(),
        DocumentSection: {
          create: (sections || []).map((section, index) => ({
            id: (0, import_nanoid2.nanoid)(),
            order: section.order || index,
            type: section.type,
            config: section.config || {},
            displayConditions: section.displayConditions,
            linkedNodeIds: section.linkedNodeIds || [],
            linkedVariables: section.linkedVariables || [],
            translations: section.translations || {},
            updatedAt: /* @__PURE__ */ new Date()
          }))
        }
      },
      include: {
        DocumentSection: true,
        DocumentTheme: true
      }
    });
    res.status(201).json(template);
  } catch (error) {
    console.error("Erreur cr\xE9ation template:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router70.put("/templates/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.headers["x-organization-id"];
    const isSuperAdmin2 = req2.headers["x-is-super-admin"] === "true";
    const {
      name,
      type,
      description,
      treeId,
      translations,
      defaultLanguage,
      themeId,
      isActive,
      sections
    } = req2.body;
    console.log("\u{1F4DD} [TEMPLATE UPDATE] Mise \xE0 jour template:", { id, name, treeId, type });
    const whereClause = { id };
    if (!isSuperAdmin2 && organizationId) {
      whereClause.organizationId = organizationId;
    }
    const existing = await prisma41.documentTemplate.findFirst({
      where: whereClause
    });
    if (!existing) {
      return res.status(404).json({ error: "Template non trouv\xE9" });
    }
    if (sections) {
      await prisma41.documentSection.deleteMany({
        where: { templateId: id }
      });
    }
    const template = await prisma41.documentTemplate.update({
      where: { id },
      data: {
        name,
        type,
        description,
        treeId: treeId || null,
        // Permet de mettre √† null pour revenir √† g√©n√©rique
        translations,
        defaultLanguage,
        themeId,
        isActive,
        updatedAt: /* @__PURE__ */ new Date(),
        ...sections && {
          DocumentSection: {
            create: sections.map((section, index) => ({
              id: (0, import_nanoid2.nanoid)(),
              order: section.order || index,
              type: section.type,
              config: section.config || {},
              displayConditions: section.displayConditions,
              linkedNodeIds: section.linkedNodeIds || [],
              linkedVariables: section.linkedVariables || [],
              translations: section.translations || {},
              updatedAt: /* @__PURE__ */ new Date()
            }))
          }
        }
      },
      include: {
        DocumentSection: { orderBy: { order: "asc" } },
        DocumentTheme: true,
        TreeBranchLeafTree: {
          select: { id: true, name: true }
        }
      }
    });
    res.json(template);
  } catch (error) {
    console.error("Erreur mise \xE0 jour template:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router70.delete("/templates/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.headers["x-organization-id"];
    const template = await prisma41.documentTemplate.findFirst({
      where: { id, organizationId }
    });
    if (!template) {
      return res.status(404).json({ error: "Template non trouv\xE9" });
    }
    const documentsCount = await prisma41.generatedDocument.count({
      where: { templateId: id }
    });
    if (documentsCount > 0) {
      return res.status(400).json({
        error: "Impossible de supprimer : des documents utilisent ce template",
        documentsCount
      });
    }
    await prisma41.documentTemplate.delete({
      where: { id }
    });
    res.json({ success: true, message: "Template supprim\xE9" });
  } catch (error) {
    console.error("Erreur suppression template:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router70.get("/themes", async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"];
    const themes = await prisma41.documentTheme.findMany({
      where: { organizationId },
      orderBy: [
        { isDefault: "desc" },
        { name: "asc" }
      ]
    });
    res.json(themes);
  } catch (error) {
    console.error("Erreur r\xE9cup\xE9ration th\xE8mes:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router70.post("/themes", async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"];
    const themeData = req2.body;
    if (themeData.isDefault) {
      await prisma41.documentTheme.updateMany({
        where: { organizationId, isDefault: true },
        data: { isDefault: false }
      });
    }
    const theme = await prisma41.documentTheme.create({
      data: {
        id: (0, import_nanoid2.nanoid)(),
        ...themeData,
        organizationId
      }
    });
    res.status(201).json(theme);
  } catch (error) {
    console.error("Erreur cr\xE9ation th\xE8me:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router70.put("/themes/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.headers["x-organization-id"];
    const themeData = req2.body;
    if (themeData.isDefault) {
      await prisma41.documentTheme.updateMany({
        where: {
          organizationId,
          isDefault: true,
          id: { not: id }
        },
        data: { isDefault: false }
      });
    }
    const theme = await prisma41.documentTheme.update({
      where: { id },
      data: themeData
    });
    res.json(theme);
  } catch (error) {
    console.error("Erreur mise \xE0 jour th\xE8me:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router70.delete("/themes/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const templatesCount = await prisma41.documentTemplate.count({
      where: { themeId: id }
    });
    if (templatesCount > 0) {
      return res.status(400).json({
        error: "Impossible de supprimer : des templates utilisent ce th\xE8me",
        templatesCount
      });
    }
    await prisma41.documentTheme.delete({
      where: { id }
    });
    res.json({ success: true });
  } catch (error) {
    console.error("Erreur suppression th\xE8me:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router70.get("/templates/:templateId/sections", async (req2, res) => {
  try {
    const { templateId } = req2.params;
    const organizationId = req2.headers["x-organization-id"];
    const isSuperAdmin2 = req2.headers["x-is-super-admin"] === "true";
    const whereClause = { id: templateId };
    if (!isSuperAdmin2 && organizationId) {
      whereClause.organizationId = organizationId;
    }
    const template = await prisma41.documentTemplate.findFirst({
      where: whereClause
    });
    if (!template) {
      console.log(`[DOCUMENTS] Template ${templateId} non trouv\xE9 (orgId: ${organizationId}, isSuperAdmin: ${isSuperAdmin2})`);
      return res.status(404).json({ error: "Template non trouv\xE9" });
    }
    const sections = await prisma41.documentSection.findMany({
      where: { templateId },
      orderBy: { order: "asc" }
    });
    res.json(sections);
  } catch (error) {
    console.error("Erreur r\xE9cup\xE9ration sections:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router70.post("/templates/:templateId/sections", async (req2, res) => {
  try {
    const { templateId } = req2.params;
    const { type, order, config } = req2.body;
    const organizationId = req2.headers["x-organization-id"];
    const isSuperAdmin2 = req2.headers["x-is-super-admin"] === "true";
    const whereClause = { id: templateId };
    if (!isSuperAdmin2 && organizationId) {
      whereClause.organizationId = organizationId;
    }
    const template = await prisma41.documentTemplate.findFirst({
      where: whereClause
    });
    if (!template) {
      return res.status(404).json({ error: "Template non trouv\xE9" });
    }
    const section = await prisma41.documentSection.create({
      data: {
        id: (0, import_nanoid2.nanoid)(),
        templateId,
        type,
        order: order ?? 0,
        config: config || {},
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    res.json(section);
  } catch (error) {
    console.error("Erreur cr\xE9ation section:", error?.message || error);
    console.error("Stack:", error?.stack);
    res.status(500).json({ error: "Erreur serveur", details: error?.message });
  }
});
router70.put("/templates/:templateId/sections/:sectionId", async (req2, res) => {
  try {
    const { templateId, sectionId } = req2.params;
    const { order, config } = req2.body;
    const organizationId = req2.headers["x-organization-id"];
    const isSuperAdmin2 = req2.headers["x-is-super-admin"] === "true";
    const whereClause = { id: templateId };
    if (!isSuperAdmin2 && organizationId) {
      whereClause.organizationId = organizationId;
    }
    const template = await prisma41.documentTemplate.findFirst({
      where: whereClause
    });
    if (!template) {
      return res.status(404).json({ error: "Template non trouv\xE9" });
    }
    const section = await prisma41.documentSection.update({
      where: { id: sectionId },
      data: {
        ...order !== void 0 && { order },
        ...config && { config }
      }
    });
    res.json(section);
  } catch (error) {
    console.error("Erreur mise \xE0 jour section:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router70.delete("/templates/:templateId/sections/:sectionId", async (req2, res) => {
  try {
    const { templateId, sectionId } = req2.params;
    const organizationId = req2.headers["x-organization-id"];
    const isSuperAdmin2 = req2.headers["x-is-super-admin"] === "true";
    const whereClause = { id: templateId };
    if (!isSuperAdmin2 && organizationId) {
      whereClause.organizationId = organizationId;
    }
    const template = await prisma41.documentTemplate.findFirst({
      where: whereClause
    });
    if (!template) {
      return res.status(404).json({ error: "Template non trouv\xE9" });
    }
    await prisma41.documentSection.delete({
      where: { id: sectionId }
    });
    res.json({ success: true });
  } catch (error) {
    console.error("Erreur suppression section:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router70.get("/generated", async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"];
    const { leadId, submissionId, templateId } = req2.query;
    if (!organizationId) {
      return res.status(400).json({ error: "Organization ID requis" });
    }
    const where = {
      organizationId
    };
    if (leadId) {
      where.leadId = leadId;
    }
    if (submissionId) {
      where.submissionId = submissionId;
    }
    if (templateId) {
      where.templateId = templateId;
    }
    const documents = await prisma41.generatedDocument.findMany({
      where,
      include: {
        DocumentTemplate: {
          select: {
            id: true,
            name: true,
            type: true
          }
        },
        User_GeneratedDocument_sentByToUser: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        Lead: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: "desc" }
    });
    const mappedDocuments = documents.map((doc) => ({
      ...doc,
      template: doc.DocumentTemplate,
      sentByUser: doc.User_GeneratedDocument_sentByToUser,
      lead: doc.Lead,
      DocumentTemplate: void 0,
      User_GeneratedDocument_sentByToUser: void 0,
      Lead: void 0
    }));
    res.json(mappedDocuments);
  } catch (error) {
    console.error("\u274C [GET /generated] Erreur r\xE9cup\xE9ration documents g\xE9n\xE9r\xE9s:", error?.message);
    res.status(500).json({ error: "Erreur serveur", details: error?.message });
  }
});
router70.get("/generated/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.headers["x-organization-id"];
    const document = await prisma41.generatedDocument.findFirst({
      where: {
        id,
        organizationId
      },
      include: {
        DocumentTemplate: true,
        User_GeneratedDocument_sentByToUser: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        Lead: true
      }
    });
    if (!document) {
      return res.status(404).json({ error: "Document non trouv\xE9" });
    }
    const mappedDocument = {
      ...document,
      template: document.DocumentTemplate,
      sentByUser: document.User_GeneratedDocument_sentByToUser,
      lead: document.Lead,
      DocumentTemplate: void 0,
      User_GeneratedDocument_sentByToUser: void 0,
      Lead: void 0
    };
    res.json(mappedDocument);
  } catch (error) {
    console.error("Erreur r\xE9cup\xE9ration document:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router70.post("/generated/generate", async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"];
    const userId = req2.headers["x-user-id"];
    const {
      templateId,
      leadId,
      submissionId,
      tblData,
      lead: leadData,
      language
    } = req2.body;
    console.log("\u{1F4C4} [GENERATE DOC] Demande de g\xE9n\xE9ration:", { templateId, leadId, submissionId, organizationId, userId });
    console.log("\u{1F4C4} [GENERATE DOC] Body complet:", JSON.stringify(req2.body, null, 2));
    if (!templateId) {
      return res.status(400).json({ error: "Template ID requis" });
    }
    console.log("\u{1F4C4} [GENERATE DOC] Recherche du template...");
    const template = await prisma41.documentTemplate.findFirst({
      where: {
        id: templateId,
        organizationId
      },
      include: {
        DocumentSection: {
          orderBy: { order: "asc" }
        },
        DocumentTheme: true
      }
    });
    console.log("\u{1F4C4} [GENERATE DOC] Template trouv\xE9:", template ? template.id : "null");
    if (!template) {
      return res.status(404).json({ error: "Template non trouv\xE9" });
    }
    const documentCount = await prisma41.generatedDocument.count({
      where: { templateId }
    });
    const documentNumber = `${template.type}-${String(documentCount + 1).padStart(6, "0")}`;
    const generatedDocument = await prisma41.generatedDocument.create({
      data: {
        id: (0, import_nanoid2.nanoid)(),
        templateId,
        organizationId,
        leadId: leadId || null,
        submissionId: submissionId || null,
        type: template.type,
        status: "DRAFT",
        language: language || template.defaultLanguage || "fr",
        documentNumber,
        pdfUrl: null,
        // Sera rempli apr√®s g√©n√©ration r√©elle du PDF
        dataSnapshot: {
          tblData: tblData || {},
          lead: leadData || {},
          generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          generatedBy: userId
        },
        createdBy: userId || null,
        updatedAt: /* @__PURE__ */ new Date()
      },
      include: {
        DocumentTemplate: {
          select: {
            id: true,
            name: true,
            type: true
          }
        }
      }
    });
    console.log("\u{1F4C4} [GENERATE DOC] Document cr\xE9\xE9:", generatedDocument.id);
    console.log("\u{1F4C4} [GENERATE DOC] Mise \xE0 jour du document avec statut SENT...");
    const updatedDocument = await prisma41.generatedDocument.update({
      where: { id: generatedDocument.id },
      data: {
        status: "SENT",
        // Le PDF est "pr√™t"
        pdfUrl: `/api/documents/generated/${generatedDocument.id}/download`
      },
      include: {
        template: {
          select: {
            id: true,
            name: true,
            type: true
          }
        },
        sentByUser: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        },
        lead: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        }
      }
    });
    console.log("\u{1F4C4} [GENERATE DOC] Document mis \xE0 jour avec succ\xE8s:", updatedDocument.id);
    res.status(201).json(updatedDocument);
  } catch (error) {
    console.error("\u274C [GENERATE DOC] Erreur g\xE9n\xE9ration document:", error);
    console.error("\u274C [GENERATE DOC] Error name:", error?.name);
    console.error("\u274C [GENERATE DOC] Error code:", error?.code);
    console.error("\u274C [GENERATE DOC] Error message:", error?.message);
    console.error("\u274C [GENERATE DOC] Error meta:", error?.meta);
    res.status(500).json({ error: "Erreur serveur lors de la g\xE9n\xE9ration", details: error?.message });
  }
});
router70.delete("/generated/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.headers["x-organization-id"];
    const document = await prisma41.generatedDocument.findFirst({
      where: {
        id,
        organizationId
      }
    });
    if (!document) {
      return res.status(404).json({ error: "Document non trouv\xE9" });
    }
    await prisma41.generatedDocument.delete({
      where: { id }
    });
    res.json({ success: true, message: "Document supprim\xE9" });
  } catch (error) {
    console.error("Erreur suppression document:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router70.get("/generated/:id/download", async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.headers["x-organization-id"];
    console.log("\u{1F4E5} [DOWNLOAD] Demande de t\xE9l\xE9chargement:", { id, organizationId });
    const document = await prisma41.generatedDocument.findFirst({
      where: {
        id,
        organizationId
      },
      include: {
        DocumentTemplate: {
          include: {
            DocumentSection: {
              orderBy: { order: "asc" }
            },
            DocumentTheme: true
          }
        },
        Lead: true
      }
    });
    if (!document) {
      console.log("\u{1F4E5} [DOWNLOAD] Document non trouv\xE9");
      return res.status(404).json({ error: "Document non trouv\xE9" });
    }
    console.log("\u{1F4E5} [DOWNLOAD] Document trouv\xE9:", document.documentNumber);
    const defaultTheme = await prisma41.documentTheme.findFirst({
      where: {
        organizationId,
        isDefault: true
      }
    });
    const organization = await prisma41.organization.findFirst({
      where: { id: organizationId }
    });
    const dataSnapshot = document.dataSnapshot || {};
    const templateTheme = document.DocumentTemplate?.DocumentTheme;
    const themeSource = templateTheme || defaultTheme;
    const theme = themeSource ? {
      primaryColor: themeSource.primaryColor || "#1890ff",
      secondaryColor: themeSource.secondaryColor || "#52c41a",
      accentColor: themeSource.accentColor || "#faad14",
      textColor: themeSource.textColor || "#333333",
      backgroundColor: themeSource.backgroundColor || "#ffffff",
      fontFamily: themeSource.fontFamily || "Helvetica",
      fontSize: themeSource.fontSize || 12,
      logoUrl: themeSource.logoUrl || ""
    } : {
      primaryColor: "#1890ff",
      secondaryColor: "#52c41a",
      accentColor: "#faad14",
      textColor: "#333333",
      backgroundColor: "#ffffff",
      fontFamily: "Helvetica",
      fontSize: 12,
      logoUrl: ""
    };
    console.log("\u{1F4E5} [DOWNLOAD] Theme utilis\xE9:", {
      source: templateTheme ? "template" : defaultTheme ? "default" : "fallback",
      primaryColor: theme.primaryColor,
      fontFamily: theme.fontFamily
    });
    const sections = document.DocumentTemplate?.DocumentSection?.map((s) => ({
      id: s.id,
      type: s.type,
      name: s.name || s.type,
      config: s.config || {},
      translations: s.translations || {},
      linkedNodeIds: s.linkedNodeIds || [],
      order: s.order,
      isActive: s.isActive !== false
    })) || [];
    console.log("\u{1F4E5} [DOWNLOAD] Sections mapp\xE9es:", sections.length);
    for (const sec of sections) {
      console.log(`\u{1F4E5} [DOWNLOAD] Section ${sec.type}:`, {
        id: sec.id,
        configKeys: Object.keys(sec.config || {}),
        hasModules: !!sec.config?.modules,
        modulesCount: sec.config?.modules?.length || 0
      });
      if (sec.config?.modules?.length > 0) {
        console.log("\u{1F4E5} [DOWNLOAD] Premier module:", JSON.stringify(sec.config.modules[0], null, 2).substring(0, 500));
      }
    }
    const renderContext = {
      template: document.template ? {
        id: document.template.id,
        name: document.template.name,
        type: document.template.type,
        theme,
        sections
        // Sections DANS le template comme attendu par le renderer
      } : {
        id: "default",
        name: "Document",
        type: "QUOTE",
        theme,
        sections: []
      },
      lead: (() => {
        const dbLead = document.lead || {};
        const snapshotLead = dataSnapshot.lead || {};
        const mergedLead = {
          ...snapshotLead,
          ...dbLead,
          // S'assurer que l'adresse vient de l'une des deux sources
          address: dbLead.address || snapshotLead.address || "",
          data: dbLead.data || {}
        };
        const addressComponents = extractAddressComponents(mergedLead);
        return {
          id: dbLead.id || snapshotLead.id || "",
          firstName: dbLead.firstName || snapshotLead.firstName || "",
          lastName: dbLead.lastName || snapshotLead.lastName || "",
          fullName: [dbLead.firstName || snapshotLead.firstName, dbLead.lastName || snapshotLead.lastName].filter(Boolean).join(" "),
          email: dbLead.email || snapshotLead.email || "",
          phone: dbLead.phone || snapshotLead.phone || "",
          company: dbLead.company || snapshotLead.company || "",
          // Adresse compl√®te
          address: addressComponents.address,
          // Composants s√©par√©s
          street: addressComponents.street,
          number: addressComponents.number,
          box: addressComponents.box,
          postalCode: addressComponents.postalCode,
          city: addressComponents.city,
          country: addressComponents.country
        };
      })(),
      organization: organization ? {
        name: organization.name || "",
        email: organization.email || "",
        phone: organization.phone || "",
        address: organization.address || "",
        vatNumber: organization.vatNumber || "",
        logo: organization.logo || ""
      } : void 0,
      tblData: dataSnapshot.tblData || dataSnapshot,
      quote: dataSnapshot.quote || {
        number: document.documentNumber,
        date: document.createdAt?.toISOString().split("T")[0] || (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        validUntil: dataSnapshot.validUntil || "",
        totalHT: dataSnapshot.totalHT || 0,
        totalTVA: dataSnapshot.totalTVA || 0,
        totalTTC: dataSnapshot.totalTTC || 0
      },
      documentNumber: document.documentNumber || "",
      language: document.language || "fr"
    };
    console.log("\u{1F4E5} [DOWNLOAD] Contexte de rendu:", {
      templateId: renderContext.template.id,
      sectionsCount: renderContext.template.sections.length,
      leadName: renderContext.lead.firstName + " " + renderContext.lead.lastName,
      language: renderContext.language,
      tblDataKeys: Object.keys(renderContext.tblData || {}),
      tblDataKeysCount: Object.keys(renderContext.tblData || {}).length,
      dataSnapshotKeys: Object.keys(dataSnapshot || {})
    });
    console.log("\u{1F4E5} [DOWNLOAD] Lead data (avec adresse pars\xE9e):", {
      address: renderContext.lead.address,
      street: renderContext.lead.street,
      number: renderContext.lead.number,
      box: renderContext.lead.box,
      postalCode: renderContext.lead.postalCode,
      city: renderContext.lead.city,
      country: renderContext.lead.country
    });
    console.log("\u{1F4E5} [DOWNLOAD] tblData complet:", JSON.stringify(renderContext.tblData, null, 2).substring(0, 2e3));
    const pdfBuffer = await renderDocumentPdf(renderContext);
    const filename = `${document.documentNumber || document.id}.pdf`;
    console.log("\u{1F4E5} [DOWNLOAD] PDF g\xE9n\xE9r\xE9, taille:", pdfBuffer.length, "bytes");
    res.setHeader("Content-Type", "application/pdf");
    res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
    res.setHeader("Content-Length", pdfBuffer.length.toString());
    res.send(pdfBuffer);
  } catch (error) {
    console.error("\u274C [DOWNLOAD] Erreur t\xE9l\xE9chargement:", error);
    res.status(500).json({ error: "Erreur serveur", details: error?.message });
  }
});
router70.get("/generated/:id/preview", async (req2, res) => {
  try {
    const { id } = req2.params;
    const organizationId = req2.headers["x-organization-id"];
    console.log("\u{1F441}\uFE0F [PREVIEW] Demande d'aper\xE7u:", { id, organizationId });
    const document = await prisma41.generatedDocument.findFirst({
      where: {
        id,
        organizationId
      },
      include: {
        DocumentTemplate: {
          include: {
            DocumentSection: {
              orderBy: { order: "asc" }
            },
            DocumentTheme: true
          }
        },
        Lead: true,
        TreeBranchLeafSubmission: true
      }
    });
    if (!document) {
      console.log("\u{1F441}\uFE0F [PREVIEW] Document non trouv\xE9");
      return res.status(404).json({ error: "Document non trouv\xE9" });
    }
    console.log("\u{1F441}\uFE0F [PREVIEW] Document trouv\xE9:", document.documentNumber);
    res.json({
      id: document.id,
      documentNumber: document.documentNumber,
      type: document.type,
      status: document.status,
      language: document.language,
      title: document.title,
      notes: document.notes,
      createdAt: document.createdAt,
      updatedAt: document.updatedAt,
      template: document.DocumentTemplate,
      lead: document.Lead,
      dataSnapshot: document.dataSnapshot,
      // Informations de signature/paiement
      signedAt: document.signedAt,
      signatureUrl: document.signatureUrl,
      paidAt: document.paidAt,
      paymentAmount: document.paymentAmount,
      paymentMethod: document.paymentMethod
    });
  } catch (error) {
    console.error("\u274C [PREVIEW] Erreur aper\xE7u:", error);
    res.status(500).json({ error: "Erreur serveur", details: error?.message });
  }
});
var documents_default = router70;

// src/routes/sync-temp.ts
var import_express72 = require("express");
init_database();
var router71 = (0, import_express72.Router)();
var prisma42 = db;
router71.post("/sync-documents", async (req2, res) => {
  const { secret } = req2.body;
  if (secret !== "SYNC_2THIER_2024") {
    return res.status(401).json({ error: "Non autoris\xE9" });
  }
  try {
    const themes = [
      { id: "zy-AWfNv7kwiFiAIxYCyy", name: "Corporate Bleu", primaryColor: "#1890ff", secondaryColor: "#096dd9", fontFamily: "Arial, Helvetica, sans-serif", organizationId: "1757366075153-otief8knu" },
      { id: "LoVb38f8kOfL2r8rIpVMm", name: "\xC9l\xE9gant Gris", primaryColor: "#595959", secondaryColor: "#8c8c8c", fontFamily: "Georgia, serif", organizationId: "1757366075153-otief8knu" },
      { id: "xMHttG0zrN81_Fu-gHnwN", name: "Moderne Vert", primaryColor: "#52c41a", secondaryColor: "#73d13d", fontFamily: "Verdana, Geneva, sans-serif", organizationId: "1757366075153-otief8knu" },
      { id: "bfQB_aDQX2bs5d02ASZi7", name: "Professionnel Violet", primaryColor: "#722ed1", secondaryColor: "#9254de", fontFamily: "Trebuchet MS, sans-serif", organizationId: "1757366075153-otief8knu" },
      { id: "QfHTFecgN_BB0me-PAZZG", name: "Dynamique Orange", primaryColor: "#fa8c16", secondaryColor: "#ffa940", fontFamily: "Arial, sans-serif", organizationId: "1757366075153-otief8knu" },
      { id: "fw6tmVAi26iAEQBbVlkaw", name: "Sobre Noir & Blanc", primaryColor: "#000000", secondaryColor: "#262626", fontFamily: "Times New Roman, serif", organizationId: "1757366075153-otief8knu" },
      { id: "vvZ4U2NJ_wxaP8rSmqOXD", name: "Corporate Bleu", primaryColor: "#1890ff", secondaryColor: "#096dd9", fontFamily: "Arial, Helvetica, sans-serif", organizationId: "1757366075154-i554z93kl" },
      { id: "KZrfAoWjOYpKPVNd_CGEq", name: "\xC9l\xE9gant Gris", primaryColor: "#595959", secondaryColor: "#8c8c8c", fontFamily: "Georgia, serif", organizationId: "1757366075154-i554z93kl" },
      { id: "ABaRcqHtCJyxsYkIL7bwV", name: "Moderne Vert", primaryColor: "#52c41a", secondaryColor: "#73d13d", fontFamily: "Verdana, Geneva, sans-serif", organizationId: "1757366075154-i554z93kl" },
      { id: "EPG4Rme8JoZuAObPxlCfu", name: "Professionnel Violet", primaryColor: "#722ed1", secondaryColor: "#9254de", fontFamily: "Trebuchet MS, sans-serif", organizationId: "1757366075154-i554z93kl" },
      { id: "ggBUu9jdk5qe0uyChmQoQ", name: "Dynamique Orange", primaryColor: "#fa8c16", secondaryColor: "#ffa940", fontFamily: "Arial, sans-serif", organizationId: "1757366075154-i554z93kl" },
      { id: "Zgj4_Kicsk6_zGGkFKnV1", name: "Sobre Noir & Blanc", primaryColor: "#000000", secondaryColor: "#262626", fontFamily: "Times New Roman, serif", organizationId: "1757366075154-i554z93kl" }
    ];
    const templates = [
      { id: "G7YU14mfKT9rEj7wD38lD", name: "Bilan \xE9nerg\xE9tique", type: "QUOTE", organizationId: "1757366075154-i554z93kl" },
      { id: "lKcJIIkGPzAZZL6E7VGA9", name: "PV", type: "QUOTE", organizationId: "1757366075154-i554z93kl" }
    ];
    const sections = [
      { id: "oySHrW8g46r5zbtrFxULg", templateId: "lKcJIIkGPzAZZL6E7VGA9", type: "MODULAR_PAGE", order: 0 },
      { id: "pN8RSMjUtymo9balcF4ux", templateId: "G7YU14mfKT9rEj7wD38lD", type: "MODULAR_PAGE", order: 0 },
      { id: "m2_i4PAXeQwgVM2O2HX_7", templateId: "G7YU14mfKT9rEj7wD38lD", type: "MODULAR_PAGE", order: 1 },
      { id: "4Snr4bjuSzky1oG_Ex03o", templateId: "G7YU14mfKT9rEj7wD38lD", type: "MODULAR_PAGE", order: 2 },
      { id: "q9v4OwgdrazlRQFdPBJs0", templateId: "G7YU14mfKT9rEj7wD38lD", type: "MODULAR_PAGE", order: 3 }
    ];
    for (const theme of themes) {
      await prisma42.documentTheme.upsert({
        where: { id: theme.id },
        update: theme,
        create: theme
      });
    }
    for (const template of templates) {
      await prisma42.documentTemplate.upsert({
        where: { id: template.id },
        update: template,
        create: template
      });
    }
    for (const section of sections) {
      await prisma42.documentSection.upsert({
        where: { id: section.id },
        update: section,
        create: section
      });
    }
    res.json({
      success: true,
      synced: {
        themes: themes.length,
        templates: templates.length,
        sections: sections.length
      }
    });
  } catch (error) {
    console.error("Sync error:", error);
    res.status(500).json({ error: error.message });
  }
});
var sync_temp_default = router71;

// src/routes/join-requests.ts
var import_express73 = require("express");
init_database();
var import_client6 = require("@prisma/client");
var router72 = (0, import_express73.Router)();
router72.post("/", authMiddleware, async (req2, res) => {
  try {
    const userId = req2.user?.userId;
    const { organizationId, message } = req2.body;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Non authentifi\xE9" });
    }
    if (!organizationId) {
      return res.status(400).json({ success: false, error: "organizationId requis" });
    }
    const organization = await db.organization.findUnique({
      where: { id: organizationId }
    });
    if (!organization) {
      return res.status(404).json({ success: false, error: "Organisation non trouv\xE9e" });
    }
    const existingMembership = await db.userOrganization.findFirst({
      where: { userId, organizationId }
    });
    if (existingMembership) {
      return res.status(409).json({
        success: false,
        error: "Vous \xEAtes d\xE9j\xE0 membre de cette organisation"
      });
    }
    const existingRequest = await db.joinRequest.findUnique({
      where: { userId_organizationId: { userId, organizationId } }
    });
    if (existingRequest) {
      return res.status(409).json({
        success: false,
        error: "Une demande existe d\xE9j\xE0 pour cette organisation",
        status: existingRequest.status
      });
    }
    const joinRequest = await db.joinRequest.create({
      data: {
        userId,
        organizationId,
        message: message?.trim() || null,
        status: import_client6.JoinRequestStatus.PENDING
      },
      include: {
        Organization: { select: { id: true, name: true } }
      }
    });
    console.log(`[JoinRequest] Nouvelle demande cr\xE9\xE9e: user=${userId} -> org=${organizationId}`);
    res.status(201).json({
      success: true,
      data: joinRequest,
      message: "Demande d'adh\xE9sion envoy\xE9e avec succ\xE8s"
    });
  } catch (error) {
    console.error("[JoinRequest] Erreur cr\xE9ation:", error);
    res.status(500).json({ success: false, error: "Erreur serveur" });
  }
});
router72.get("/my-requests", authMiddleware, async (req2, res) => {
  try {
    const userId = req2.user?.userId;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Non authentifi\xE9" });
    }
    const requests = await db.joinRequest.findMany({
      where: { userId },
      include: {
        Organization: { select: { id: true, name: true, description: true } }
      },
      orderBy: { createdAt: "desc" }
    });
    res.json({ success: true, data: requests });
  } catch (error) {
    console.error("[JoinRequest] Erreur r\xE9cup\xE9ration:", error);
    res.status(500).json({ success: false, error: "Erreur serveur" });
  }
});
router72.get("/pending", authMiddleware, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const organizationId = req2.user?.organizationId;
    const isSuperAdmin2 = req2.user?.role === "super_admin";
    const whereClause = isSuperAdmin2 ? { status: import_client6.JoinRequestStatus.PENDING } : { organizationId, status: import_client6.JoinRequestStatus.PENDING };
    if (!isSuperAdmin2 && !organizationId) {
      return res.status(403).json({ success: false, error: "Organisation requise" });
    }
    const requests = await db.joinRequest.findMany({
      where: whereClause,
      include: {
        User: { select: { id: true, firstName: true, lastName: true, email: true } },
        Organization: { select: { id: true, name: true } }
      },
      orderBy: { createdAt: "asc" }
    });
    res.json({ success: true, data: requests });
  } catch (error) {
    console.error("[JoinRequest] Erreur liste pending:", error);
    res.status(500).json({ success: false, error: "Erreur serveur" });
  }
});
router72.post("/:id/approve", authMiddleware, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const { roleId } = req2.body;
    const adminId = req2.user?.userId;
    const adminOrgId = req2.user?.organizationId;
    const isSuperAdmin2 = req2.user?.role === "super_admin";
    const joinRequest = await db.joinRequest.findUnique({
      where: { id },
      include: { Organization: true, User: true }
    });
    if (!joinRequest) {
      return res.status(404).json({ success: false, error: "Demande non trouv\xE9e" });
    }
    if (!isSuperAdmin2 && joinRequest.organizationId !== adminOrgId) {
      return res.status(403).json({ success: false, error: "Non autoris\xE9" });
    }
    if (joinRequest.status !== import_client6.JoinRequestStatus.PENDING) {
      return res.status(400).json({
        success: false,
        error: `Demande d\xE9j\xE0 trait\xE9e (${joinRequest.status})`
      });
    }
    let finalRoleId = roleId;
    if (!finalRoleId) {
      const defaultRole = await db.role.findFirst({
        where: {
          organizationId: joinRequest.organizationId,
          name: "user"
          // R√¥le par d√©faut
        }
      });
      finalRoleId = defaultRole?.id;
    }
    if (!finalRoleId) {
      return res.status(400).json({
        success: false,
        error: "Aucun r\xF4le disponible. Veuillez sp\xE9cifier un roleId."
      });
    }
    const result = await db.$transaction(async (tx) => {
      const updatedRequest = await tx.joinRequest.update({
        where: { id },
        data: {
          status: import_client6.JoinRequestStatus.APPROVED,
          reviewedBy: adminId,
          reviewedAt: /* @__PURE__ */ new Date()
        }
      });
      const userOrg = await tx.userOrganization.create({
        data: {
          id: crypto.randomUUID(),
          userId: joinRequest.userId,
          organizationId: joinRequest.organizationId,
          roleId: finalRoleId,
          status: import_client6.UserOrganizationStatus.ACTIVE,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
      return { request: updatedRequest, userOrganization: userOrg };
    });
    console.log(`[JoinRequest] Demande ${id} approuv\xE9e par ${adminId}`);
    res.json({
      success: true,
      data: result,
      message: `Demande approuv\xE9e. ${joinRequest.User?.firstName} ${joinRequest.User?.lastName} est maintenant membre de ${joinRequest.Organization?.name}`
    });
  } catch (error) {
    console.error("[JoinRequest] Erreur approbation:", error);
    res.status(500).json({ success: false, error: "Erreur serveur" });
  }
});
router72.post("/:id/reject", authMiddleware, requireRole2(["admin", "super_admin"]), async (req2, res) => {
  try {
    const { id } = req2.params;
    const { reason } = req2.body;
    const adminId = req2.user?.userId;
    const adminOrgId = req2.user?.organizationId;
    const isSuperAdmin2 = req2.user?.role === "super_admin";
    const joinRequest = await db.joinRequest.findUnique({
      where: { id }
    });
    if (!joinRequest) {
      return res.status(404).json({ success: false, error: "Demande non trouv\xE9e" });
    }
    if (!isSuperAdmin2 && joinRequest.organizationId !== adminOrgId) {
      return res.status(403).json({ success: false, error: "Non autoris\xE9" });
    }
    if (joinRequest.status !== import_client6.JoinRequestStatus.PENDING) {
      return res.status(400).json({
        success: false,
        error: `Demande d\xE9j\xE0 trait\xE9e (${joinRequest.status})`
      });
    }
    const updatedRequest = await db.joinRequest.update({
      where: { id },
      data: {
        status: import_client6.JoinRequestStatus.REJECTED,
        reviewedBy: adminId,
        reviewedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log(`[JoinRequest] Demande ${id} rejet\xE9e par ${adminId}. Raison: ${reason || "Non sp\xE9cifi\xE9e"}`);
    res.json({
      success: true,
      data: updatedRequest,
      message: "Demande rejet\xE9e"
    });
  } catch (error) {
    console.error("[JoinRequest] Erreur rejet:", error);
    res.status(500).json({ success: false, error: "Erreur serveur" });
  }
});
router72.delete("/:id", authMiddleware, async (req2, res) => {
  try {
    const { id } = req2.params;
    const userId = req2.user?.userId;
    const joinRequest = await db.joinRequest.findUnique({
      where: { id }
    });
    if (!joinRequest) {
      return res.status(404).json({ success: false, error: "Demande non trouv\xE9e" });
    }
    if (joinRequest.userId !== userId) {
      return res.status(403).json({ success: false, error: "Non autoris\xE9" });
    }
    if (joinRequest.status !== import_client6.JoinRequestStatus.PENDING) {
      return res.status(400).json({
        success: false,
        error: "Impossible d'annuler une demande d\xE9j\xE0 trait\xE9e"
      });
    }
    await db.joinRequest.delete({ where: { id } });
    res.json({ success: true, message: "Demande annul\xE9e" });
  } catch (error) {
    console.error("[JoinRequest] Erreur suppression:", error);
    res.status(500).json({ success: false, error: "Erreur serveur" });
  }
});
var join_requests_default = router72;

// src/routes/index.ts
var apiRouter = (0, import_express74.Router)();
apiRouter.use("/auth", authRoutes_default);
console.log("[ROUTER] Routes d'authentification mont\xE9es sur /auth");
apiRouter.use("/auto-google-auth", autoGoogleAuthRoutes_default);
apiRouter.use("/", misc_default);
apiRouter.use("/profile", profile_default);
apiRouter.post("/logout", logout);
apiRouter.use("/organizations", organizations_default);
apiRouter.use("/organizations", googleWorkspace_default);
apiRouter.use("/google-workspace", googleWorkspace_default);
apiRouter.use("/modules", modules_default);
apiRouter.use("/admin-modules", admin_modules_default);
apiRouter.use("/icons", icons_default);
apiRouter.use("/blocks", blocks_default);
apiRouter.use("/fields", fields_default);
apiRouter.use("/sections", sections_default);
apiRouter.use("/module-navigation", module_navigation_default);
apiRouter.use("/form-sections", form_sections_default);
apiRouter.use("/field-types", fieldTypes_default);
apiRouter.use("/option-nodes", optionNodes_default);
apiRouter.use("/notifications", notifications_default);
apiRouter.use("/notifications-system", notificationSystemRoutes_default);
apiRouter.use("/settings", settingsRoutes_default);
apiRouter.use("/leads", leadsRoutes_default);
apiRouter.use("/dashboard", dashboard_default);
apiRouter.use("/clients", clients_default);
apiRouter.use("/company", company_default);
apiRouter.use("/projects", projects_default);
apiRouter.use("/emails", emails_default);
apiRouter.use("/gemini", gemini_default);
apiRouter.use("/roles", rolesRoutes_default);
apiRouter.use("/permissions", permissions_default);
apiRouter.use("/users", usersRoutes_default);
apiRouter.use("/admin", admin_default);
apiRouter.use("/impersonate", impersonate_default);
apiRouter.use("/admin-password", adminPasswordRoutes_default);
apiRouter.use("/gmail", gmailRoutes_default);
apiRouter.use("/calendar", calendar_default);
apiRouter.use("/google-auth", google_auth_default);
apiRouter.use("/google/scheduler", google_scheduler_default);
apiRouter.use("/google-tokens", google_tokens_default);
apiRouter.use("/auth/google", google_auth_default);
apiRouter.use("/services", services_default);
apiRouter.use("/telnyx", telnyx_default2);
apiRouter.use("/quotes", quotes_default);
apiRouter.use("/google-drive", google_drive_default);
apiRouter.use("/google-meet", google_meet_default);
apiRouter.use("/analytics", analytics_default);
apiRouter.use("/ai", ai_default);
apiRouter.use("/ai", ai_code_default);
apiRouter.use("/advanced-select", advanced_select_default);
apiRouter.use("/dynamic-formulas", dynamic_formulas_default);
apiRouter.use("/treebranchleaf", authenticateToken, fetchFullUser, treebranchleaf_routes_default);
apiRouter.use("/tbl", tbl_intelligence_routes_default);
apiRouter.use("/tbl", tbl_routes_default);
apiRouter.use("/tbl", tbl_capabilities_default);
apiRouter.use("/validations", validations_default);
apiRouter.use("/formulas", formulas_default2);
apiRouter.use("/dependencies", dependencies_default2);
apiRouter.use("/invitations", invitations_default);
apiRouter.use("/join-requests", join_requests_default);
apiRouter.use("/lead-generation", leadGeneration_default);
apiRouter.use("/marketplace", marketplace_fixed_default);
apiRouter.use("/partner", partner_default);
apiRouter.use("/forms", publicForms_default);
apiRouter.use("/public-forms", publicForms_default);
apiRouter.use("/landing-pages", landingPages_default);
apiRouter.use("/campaign-analytics", campaignAnalytics_default);
apiRouter.use("/dispatch", dispatch_default);
apiRouter.use("/integrations", integrations_default);
apiRouter.use("/integrations", integrationsStatus_default);
apiRouter.use("/public", publicLeads_default);
apiRouter.use("/documents", documents_default);
apiRouter.use("/sync", sync_temp_default);
apiRouter.get("/health", (_req, res) => {
  res.json({ status: "ok", timestamp: (/* @__PURE__ */ new Date()).toISOString() });
});
var routes_default = apiRouter;

// src/api-server-clean.ts
init_prisma();

// src/components/TreeBranchLeaf/tbl-bridge/routes/tbl-submission-evaluator.ts
var import_express75 = require("express");
init_database();
var import_crypto22 = require("crypto");
init_operation_interpreter();
var router73 = (0, import_express75.Router)();
var prisma43 = db;
function normalizeRefForTriggers(ref) {
  if (!ref || typeof ref !== "string") return "";
  return ref.replace(/^@value\./, "").replace(/^@table\./, "").replace(/^node-formula:/, "").replace(/^node-table:/, "").replace(/^node-condition:/, "").replace(/^condition:/, "").trim();
}
function collectReferencedNodeIdsForTriggers(data, out) {
  if (!data) return;
  if (Array.isArray(data)) {
    for (const item of data) collectReferencedNodeIdsForTriggers(item, out);
    return;
  }
  if (typeof data === "object") {
    const obj = data;
    if (typeof obj.ref === "string") {
      const id = normalizeRefForTriggers(obj.ref);
      if (id && isAcceptedNodeId(id)) out.add(id);
    }
    const leftRef = obj?.left?.ref;
    if (typeof leftRef === "string") {
      const id = normalizeRefForTriggers(leftRef);
      if (id && isAcceptedNodeId(id)) out.add(id);
    }
    const rightRef = obj?.right?.ref;
    if (typeof rightRef === "string") {
      const id = normalizeRefForTriggers(rightRef);
      if (id && isAcceptedNodeId(id)) out.add(id);
    }
    if (Array.isArray(obj.nodeIds)) {
      for (const raw of obj.nodeIds) {
        if (typeof raw !== "string") continue;
        const id = normalizeRefForTriggers(raw);
        if (id && isAcceptedNodeId(id)) out.add(id);
      }
    }
    const lookup = obj.lookup;
    if (lookup?.selectors?.rowFieldId) {
      const id = String(lookup.selectors.rowFieldId);
      if (id && isAcceptedNodeId(id)) out.add(id);
    }
    if (lookup?.selectors?.columnFieldId) {
      const id = String(lookup.selectors.columnFieldId);
      if (id && isAcceptedNodeId(id)) out.add(id);
    }
    for (const key2 of Object.keys(obj)) {
      collectReferencedNodeIdsForTriggers(obj[key2], out);
    }
    return;
  }
  if (typeof data === "string") {
    const s = data.trim();
    if (!s) return;
    if (s.startsWith("@value.") || s.startsWith("@table.")) {
      const id = normalizeRefForTriggers(s);
      if (id && isAcceptedNodeId(id)) out.add(id);
      return;
    }
    if (isAcceptedNodeId(s)) out.add(s);
  }
}
function deriveTriggerNodeIdsFromCapacity(capacity, ownerNodeId) {
  const c = capacity;
  const out = /* @__PURE__ */ new Set();
  collectReferencedNodeIdsForTriggers(c?.tokens, out);
  collectReferencedNodeIdsForTriggers(c?.meta, out);
  collectReferencedNodeIdsForTriggers(c?.conditionSet, out);
  collectReferencedNodeIdsForTriggers(c?.metadata, out);
  out.delete(ownerNodeId);
  for (const id of Array.from(out)) {
    if (id.includes(".")) out.delete(id);
  }
  return Array.from(out);
}
function uniqStrings(items) {
  return Array.from(new Set((items || []).filter((x) => typeof x === "string" && x.trim())));
}
async function deriveTriggerNodeIdsFromNodeId(nodeId) {
  const out = /* @__PURE__ */ new Set();
  const [formulas, conditions, tables, variable, selectConfig] = await Promise.all([
    prisma43.treeBranchLeafNodeFormula.findMany({ where: { nodeId }, select: { tokens: true } }),
    prisma43.treeBranchLeafNodeCondition.findMany({ where: { nodeId }, select: { conditionSet: true } }),
    prisma43.treeBranchLeafNodeTable.findMany({ where: { nodeId }, select: { meta: true } }),
    prisma43.treeBranchLeafNodeVariable.findUnique({ where: { nodeId }, select: { metadata: true } }),
    prisma43.treeBranchLeafSelectConfig.findFirst({ where: { nodeId } })
  ]);
  for (const f of formulas) collectReferencedNodeIdsForTriggers(f.tokens, out);
  for (const c of conditions) collectReferencedNodeIdsForTriggers(c.conditionSet, out);
  for (const t of tables) collectReferencedNodeIdsForTriggers(t.meta, out);
  if (variable) collectReferencedNodeIdsForTriggers(variable.metadata, out);
  if (selectConfig) collectReferencedNodeIdsForTriggers(selectConfig, out);
  out.delete(nodeId);
  for (const id of Array.from(out)) {
    if (id.includes(".")) out.delete(id);
  }
  return Array.from(out);
}
function isAdminOrSuperAdmin(req2) {
  const u = req2.user;
  if (!u) return false;
  if (u.isSuperAdmin) return true;
  const normalizedRole = typeof u.role === "string" ? u.role.toLowerCase().replace(/_/g, "") : "";
  if (normalizedRole === "superadmin" || normalizedRole === "admin") return true;
  if (Array.isArray(u.roles)) {
    const normalizedRoles = u.roles.filter((r) => typeof r === "string").map((r) => r.toLowerCase().replace(/_/g, ""));
    if (normalizedRoles.includes("superadmin") || normalizedRoles.includes("admin")) return true;
  }
  return false;
}
async function cloneCompletedSubmissionToDraft(params) {
  const { originalSubmissionId, requestedByUserId } = params;
  const now = /* @__PURE__ */ new Date();
  const targetStatus = params.targetStatus ?? "draft";
  const providedName = typeof params.providedName === "string" ? params.providedName.trim() : "";
  return prisma43.$transaction(async (tx) => {
    const original = await tx.treeBranchLeafSubmission.findUnique({
      where: { id: originalSubmissionId }
    });
    if (!original) {
      throw new Error(`Soumission introuvable: ${originalSubmissionId}`);
    }
    const newSubmissionId = `tbl-rev-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
    const originalSummary = original.summary || {};
    const baseName = typeof originalSummary.name === "string" && originalSummary.name.trim() ? originalSummary.name.trim() : `Devis ${original.id.slice(0, 8)}`;
    const nextSummary = {
      ...originalSummary,
      name: providedName || `${baseName} (r\xE9vision)`,
      revisionOfSubmissionId: original.id,
      revisionCreatedAt: now.toISOString(),
      revisionCreatedByUserId: requestedByUserId
    };
    await tx.treeBranchLeafSubmission.create({
      data: {
        id: newSubmissionId,
        treeId: original.treeId,
        userId: original.userId,
        leadId: original.leadId,
        sessionId: original.sessionId,
        status: targetStatus,
        totalScore: original.totalScore,
        summary: nextSummary,
        exportData: original.exportData ?? {},
        completedAt: targetStatus === "completed" ? now : null,
        updatedAt: now,
        organizationId: original.organizationId,
        lastEditedBy: requestedByUserId,
        lockedBy: null,
        lockedAt: null,
        currentVersion: 1
      }
    });
    const originalRows = await tx.treeBranchLeafSubmissionData.findMany({
      where: { submissionId: original.id },
      orderBy: [{ lastResolved: "desc" }, { createdAt: "desc" }]
    });
    const seenNodeIds = /* @__PURE__ */ new Set();
    const uniqueOriginalRows = [];
    let duplicateCount = 0;
    for (const r of originalRows) {
      if (!r.nodeId) continue;
      if (seenNodeIds.has(r.nodeId)) {
        duplicateCount++;
        continue;
      }
      seenNodeIds.add(r.nodeId);
      uniqueOriginalRows.push(r);
    }
    if (duplicateCount > 0) {
      console.warn("\u26A0\uFE0F [TBL][REVISION] Doublons TreeBranchLeafSubmissionData d\xE9tect\xE9s, d\xE9dupliqu\xE9s", {
        submissionId: original.id,
        duplicateCount,
        totalRows: originalRows.length,
        keptRows: uniqueOriginalRows.length
      });
    }
    if (uniqueOriginalRows.length > 0) {
      await tx.treeBranchLeafSubmissionData.createMany({
        // ‚ö†Ô∏è Robustesse: m√™me apr√®s d√©duplication, on s√©curise contre un double appel concurrent.
        // (Prisma/Postgres) Emp√™che un crash si (submissionId,nodeId) existe d√©j√†.
        skipDuplicates: true,
        data: uniqueOriginalRows.map((r) => ({
          id: (0, import_crypto22.randomUUID)(),
          submissionId: newSubmissionId,
          nodeId: r.nodeId,
          value: r.value,
          createdAt: now,
          lastResolved: r.lastResolved,
          operationDetail: r.operationDetail,
          operationResult: r.operationResult,
          operationSource: r.operationSource,
          sourceRef: r.sourceRef,
          fieldLabel: r.fieldLabel,
          isVariable: r.isVariable,
          variableDisplayName: r.variableDisplayName,
          variableKey: r.variableKey,
          variableUnit: r.variableUnit
        }))
      });
    }
    return newSubmissionId;
  });
}
function coerceOperationSource(value) {
  const lowered = typeof value === "string" ? value.toLowerCase().trim() : "";
  if (lowered === "condition" || lowered === "formula" || lowered === "table" || lowered === "neutral") return lowered;
  return "formula";
}
async function upsertComputedValuesForSubmission(submissionId, rows) {
  if (!submissionId || !rows.length) return 0;
  let stored = 0;
  for (const row of rows) {
    if (!row.nodeId) continue;
    await prisma43.treeBranchLeafSubmissionData.upsert({
      where: { submissionId_nodeId: { submissionId, nodeId: row.nodeId } },
      create: {
        id: `${submissionId}-${row.nodeId}-calc-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`,
        submissionId,
        nodeId: row.nodeId,
        value: row.value,
        sourceRef: row.sourceRef ?? null,
        operationSource: row.operationSource ?? null,
        fieldLabel: row.fieldLabel ?? null,
        operationDetail: row.operationDetail ?? null,
        operationResult: row.operationResult ?? null,
        lastResolved: /* @__PURE__ */ new Date()
      },
      update: {
        value: row.value,
        sourceRef: row.sourceRef ?? null,
        operationSource: row.operationSource ?? null,
        fieldLabel: row.fieldLabel ?? null,
        operationDetail: row.operationDetail ?? null,
        operationResult: row.operationResult ?? null,
        lastResolved: /* @__PURE__ */ new Date()
      }
    });
    stored++;
  }
  return stored;
}
var stagingStore = /* @__PURE__ */ new Map();
var STAGE_TTL_MS = 1e3 * 60 * 60;
function pruneStages() {
  const now = Date.now();
  for (const [k, v] of stagingStore) {
    if (now - v.updatedAt > STAGE_TTL_MS) stagingStore.delete(k);
  }
}
function newStageId() {
  return `stage-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
}
function sanitizeFormData(input) {
  if (Array.isArray(input)) {
    return input.map(sanitizeFormData);
  }
  if (input && typeof input === "object") {
    const result = {};
    for (const [k, v] of Object.entries(input)) {
      if (k.startsWith("__") || k.startsWith("__mirror_") || k.startsWith("__formula_") || k.startsWith("__condition_")) {
        continue;
      }
      result[k] = sanitizeFormData(v);
    }
    return result;
  }
  return input;
}
var UUID_NODE_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
var UUID_WITH_SUFFIX_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}-\d+$/i;
var GENERATED_NODE_REGEX = /^node_[0-9]+_[a-z0-9]+$/i;
var SHARED_REFERENCE_REGEX = /^shared-ref-[a-z0-9-]+$/i;
function normalizeTriggerCandidate(trigger) {
  const trimmed = String(trigger || "").trim();
  if (!trimmed) return "";
  if (trimmed.startsWith("@value.")) return trimmed.substring(7);
  if (trimmed.startsWith("{") && trimmed.endsWith("}")) return trimmed.slice(1, -1);
  return trimmed;
}
function extractNumericSuffix(nodeId) {
  const m = String(nodeId || "").match(/-(\d+)$/);
  return m ? m[1] : null;
}
function applyCopyScopedInputAliases(valueMap, ownerNodeId, capacity) {
  const suffix = extractNumericSuffix(ownerNodeId);
  if (!suffix) return [];
  const suffixToken = `-${suffix}`;
  const referenced = deriveTriggerNodeIdsFromCapacity(capacity, ownerNodeId);
  const injected = [];
  for (const refIdRaw of referenced) {
    const refId = normalizeTriggerCandidate(refIdRaw);
    if (!refId) continue;
    if (UUID_NODE_REGEX.test(refId)) {
      const suffixed = `${refId}${suffixToken}`;
      if (!valueMap.has(refId) && valueMap.has(suffixed)) {
        valueMap.set(refId, valueMap.get(suffixed));
        injected.push(refId);
      }
    }
  }
  if (injected.length) {
    console.log(`\u{1F501} [COPY INPUT ALIAS] ${ownerNodeId}: ${injected.length} refs base \u2192 suffix '${suffixToken}'`);
  }
  return injected;
}
function expandTriggersForCopy(displayNodeId2, triggerIds) {
  const suffix = extractNumericSuffix(displayNodeId2);
  if (!suffix) return triggerIds;
  const suffixToken = `-${suffix}`;
  const out = /* @__PURE__ */ new Set();
  for (const raw of triggerIds || []) {
    const normalized = normalizeTriggerCandidate(raw);
    if (!normalized) continue;
    out.add(normalized);
    if (UUID_NODE_REGEX.test(normalized)) {
      out.add(`${normalized}${suffixToken}`);
    }
  }
  return Array.from(out);
}
function matchesAnyEffectiveTrigger(triggers, effectiveTriggers) {
  for (const t of triggers || []) {
    const normalized = normalizeTriggerCandidate(t);
    if (!normalized) continue;
    for (const eff of effectiveTriggers) {
      const normalizedEff = normalizeTriggerCandidate(eff);
      if (normalizedEff && normalized === normalizedEff) return true;
    }
  }
  return false;
}
function isSharedReferenceId(nodeId) {
  return SHARED_REFERENCE_REGEX.test(nodeId);
}
function isAcceptedNodeId(nodeId) {
  return UUID_NODE_REGEX.test(nodeId) || UUID_WITH_SUFFIX_REGEX.test(nodeId) || // üî• NOUVEAU: Accepter UUID avec suffixe -1, -2, etc.
  GENERATED_NODE_REGEX.test(nodeId) || isSharedReferenceId(nodeId);
}
async function resolveSharedReferenceAliases(sharedRefs, treeId) {
  if (!sharedRefs.length) {
    return /* @__PURE__ */ new Map();
  }
  const where = {
    sharedReferenceId: { in: sharedRefs }
  };
  if (treeId) {
    where.treeId = treeId;
  }
  const aliases = await prisma43.treeBranchLeafNode.findMany({
    where,
    select: { id: true, sharedReferenceId: true }
  });
  const map = /* @__PURE__ */ new Map();
  for (const alias of aliases) {
    if (!alias.sharedReferenceId) continue;
    if (!map.has(alias.sharedReferenceId)) {
      map.set(alias.sharedReferenceId, []);
    }
    map.get(alias.sharedReferenceId).push(alias.id);
  }
  return map;
}
async function resolveAliasToSharedReferenceId(nodeIds, treeId) {
  const ids = (nodeIds || []).filter((id) => typeof id === "string" && id.trim());
  if (!ids.length) return /* @__PURE__ */ new Map();
  const rows = await prisma43.treeBranchLeafNode.findMany({
    where: {
      id: { in: ids },
      ...treeId ? { treeId } : {},
      sharedReferenceId: { not: null }
    },
    select: { id: true, sharedReferenceId: true }
  });
  const map = /* @__PURE__ */ new Map();
  for (const r of rows) {
    const sharedRef = r.sharedReferenceId;
    if (sharedRef && typeof sharedRef === "string" && sharedRef.trim()) {
      map.set(r.id, sharedRef);
    }
  }
  return map;
}
async function applySharedReferenceValues(target, entries, treeId) {
  if (!entries.length) return;
  const sharedRefKeys = entries.map(([key2]) => key2).filter(isSharedReferenceId);
  const aliasMap = sharedRefKeys.length ? await resolveSharedReferenceAliases(sharedRefKeys, treeId) : /* @__PURE__ */ new Map();
  for (const [key2, value] of entries) {
    target.set(key2, value);
    if (!isSharedReferenceId(key2)) continue;
    const aliases = aliasMap.get(key2) || [];
    for (const alias of aliases) {
      target.set(alias, value);
    }
  }
  try {
    const aliasCandidates = entries.map(([key2]) => key2).filter((k) => !isSharedReferenceId(k) && isAcceptedNodeId(k));
    if (aliasCandidates.length) {
      const reverse = await resolveAliasToSharedReferenceId(aliasCandidates, treeId);
      for (const [key2, value] of entries) {
        if (isSharedReferenceId(key2)) continue;
        const sharedRef = reverse.get(key2);
        if (!sharedRef) continue;
        if (!target.has(sharedRef)) {
          target.set(sharedRef, value);
        }
      }
    }
  } catch {
  }
}
async function saveUserEntriesNeutral(submissionId, formData, treeId) {
  if (!formData || typeof formData !== "object") return 0;
  let saved = 0;
  const entries = /* @__PURE__ */ new Map();
  const entriesToDelete = /* @__PURE__ */ new Set();
  const excludedNodes = treeId ? await prisma43.treeBranchLeafNode.findMany({
    where: {
      treeId,
      OR: [
        { fieldType: "DISPLAY" },
        {
          type: { in: ["leaf_field", "LEAF_FIELD"] },
          subType: { in: ["display", "DISPLAY", "Display"] }
        }
      ]
    },
    select: { id: true, label: true }
  }) : [];
  const excludedNodeIds = new Set(excludedNodes.map((n) => n.id));
  if (excludedNodeIds.size > 0) {
    console.log(`\u{1F6AB} [SAVE] ${excludedNodeIds.size} champs calcul\xE9s/DISPLAY exclus:`, excludedNodes.map((n) => n.label).join(", "));
  }
  const sharedRefKeys = Object.keys(formData).filter(isSharedReferenceId);
  const sharedRefAliasMap = sharedRefKeys.length ? await resolveSharedReferenceAliases(sharedRefKeys, treeId) : /* @__PURE__ */ new Map();
  const aliasKeys = Object.keys(formData).filter((k) => !isSharedReferenceId(k) && isAcceptedNodeId(k));
  const aliasToSharedRefMap = aliasKeys.length ? await resolveAliasToSharedReferenceId(aliasKeys, treeId) : /* @__PURE__ */ new Map();
  for (const [key2, value] of Object.entries(formData)) {
    if (key2.startsWith("__mirror_") || key2.startsWith("__formula_") || key2.startsWith("__condition_")) {
      continue;
    }
    if (!isAcceptedNodeId(key2)) continue;
    if (excludedNodeIds.has(key2)) {
      continue;
    }
    const isEmpty = value === null || value === void 0 || value === "";
    const storageIds = isSharedReferenceId(key2) ? [key2, ...sharedRefAliasMap.get(key2) || []] : [key2, ...aliasToSharedRefMap.get(key2) ? [aliasToSharedRefMap.get(key2)] : []];
    for (const nodeId of storageIds) {
      if (!isAcceptedNodeId(nodeId)) continue;
      if (isEmpty) {
        entriesToDelete.add(nodeId);
      } else {
        const serializedValue = typeof value === "string" ? value : JSON.stringify(value);
        const entry = {
          id: `${submissionId}-${nodeId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          submissionId,
          nodeId,
          value: serializedValue,
          operationSource: "neutral",
          operationDetail: {
            inputValue: value,
            nodeId,
            action: "user_input",
            sourceNodeId: key2,
            aliasResolved: nodeId !== key2
          }
        };
        entries.set(nodeId, entry);
      }
    }
  }
  for (const entry of entries.values()) {
    const key2 = { submissionId_nodeId: { submissionId: entry.submissionId, nodeId: entry.nodeId } };
    const existing = await prisma43.treeBranchLeafSubmissionData.findUnique({ where: key2 });
    const normalize2 = (v) => {
      if (v === null || v === void 0) return null;
      if (typeof v === "string") return v;
      try {
        return JSON.stringify(v);
      } catch {
        return String(v);
      }
    };
    if (existing) {
      const changed = normalize2(existing.value) !== normalize2(entry.value) || (existing.operationSource || null) !== (entry.operationSource || null);
      if (changed) {
        await prisma43.treeBranchLeafSubmissionData.update({
          where: key2,
          data: {
            value: entry.value,
            operationSource: "neutral",
            operationDetail: entry.operationDetail
          }
        });
        saved++;
      }
    } else {
      await prisma43.treeBranchLeafSubmissionData.create({ data: entry });
      saved++;
    }
  }
  for (const nodeId of entriesToDelete) {
    if (entries.has(nodeId)) continue;
    const key2 = { submissionId_nodeId: { submissionId, nodeId } };
    const existing = await prisma43.treeBranchLeafSubmissionData.findUnique({ where: key2 });
    if (existing) {
      await prisma43.treeBranchLeafSubmissionData.delete({ where: key2 });
      console.log(`\u{1F5D1}\uFE0F [SAVE] Champ vid\xE9 supprim\xE9: ${nodeId}`);
      saved++;
    }
  }
  return saved;
}
async function evaluateCapacitiesForSubmission(submissionId, organizationId, userId, treeId, formData, mode = "change", changedFieldId) {
  console.log(`\u{1F3AF} [EVALUATE] Mode: ${mode}, changedFieldId: ${changedFieldId || "N/A"}`);
  const effectiveTriggers = /* @__PURE__ */ new Set();
  if (changedFieldId) {
    effectiveTriggers.add(changedFieldId);
  }
  const valueMap = /* @__PURE__ */ new Map();
  try {
    const existingData = await prisma43.treeBranchLeafSubmissionData.findMany({
      where: {
        submissionId,
        OR: [
          { operationSource: null },
          { operationSource: "neutral" }
        ]
      },
      select: { nodeId: true, value: true, operationSource: true }
    });
    if (existingData.length) {
      const existingEntries = existingData.map((r) => [r.nodeId, r.value]);
      await applySharedReferenceValues(valueMap, existingEntries, treeId);
      console.log(`\u{1F511} [EVALUATE] valueMap hydrat\xE9 depuis DB (inputs only): ${existingData.length} entr\xE9es \u2192 ${valueMap.size} cl\xE9s`);
    }
  } catch (e) {
    console.warn("\u26A0\uFE0F [EVALUATE] Hydratation DB du valueMap \xE9chou\xE9e (best-effort):", e?.message || e);
  }
  if (formData && typeof formData === "object") {
    const entries = Object.entries(formData).filter(([k]) => !k.startsWith("__"));
    await applySharedReferenceValues(valueMap, entries, treeId);
    console.log(`\u{1F511} [EVALUATE] valueMap initialis\xE9 avec ${valueMap.size} entr\xE9es depuis formData`);
  }
  const [variablesRaw, formulasRaw] = await Promise.all([
    prisma43.treeBranchLeafNodeVariable.findMany({
      where: { TreeBranchLeafNode: { treeId }, sourceRef: { not: null } },
      include: { TreeBranchLeafNode: { select: { id: true, label: true, fieldType: true, type: true } } }
    }),
    prisma43.treeBranchLeafNodeFormula.findMany({
      where: {
        nodeId: {
          in: (await prisma43.treeBranchLeafNode.findMany({
            where: { treeId, hasFormula: true },
            select: { id: true }
          })).map((n) => n.id)
        }
      }
    })
  ]);
  const formulaNodeIds = formulasRaw.map((f) => f.nodeId);
  const formulaNodes = await prisma43.treeBranchLeafNode.findMany({
    where: { id: { in: formulaNodeIds } },
    select: { id: true, label: true, fieldType: true, type: true, hasFormula: true }
  });
  const nodeMap = new Map(formulaNodes.map((n) => [n.id, n]));
  const capacitiesRaw = [
    ...variablesRaw,
    ...formulasRaw.map((f) => ({
      ...f,
      sourceRef: `formula:${f.id}`,
      TreeBranchLeafNode: nodeMap.get(f.nodeId)
    }))
  ];
  const capacities = capacitiesRaw.sort((a, b) => {
    const aIsSumFormula = a.sourceRef?.includes("sum-formula") || a.sourceRef?.includes("sum-total") ? 1 : 0;
    const bIsSumFormula = b.sourceRef?.includes("sum-formula") || b.sourceRef?.includes("sum-total") ? 1 : 0;
    return aIsSumFormula - bIsSumFormula;
  });
  const results = {
    updated: 0,
    created: 0,
    stored: 0,
    displayFieldsUpdated: 0
  };
  const computedValuesToStore = [];
  const triggerDerivationCache = /* @__PURE__ */ new Map();
  const skippedDisplayFields = [];
  const processedNodeIds = /* @__PURE__ */ new Set();
  for (const capacity of capacities) {
    const sourceRef = capacity.sourceRef;
    const isDisplayField = capacity.TreeBranchLeafNode?.fieldType === "DISPLAY" || capacity.TreeBranchLeafNode?.type === "DISPLAY" || capacity.TreeBranchLeafNode?.type === "leaf_field";
    if (isDisplayField && mode === "autosave") {
      console.log(`\u23F8\uFE0F [AUTOSAVE] Display field ${capacity.nodeId} (${capacity.TreeBranchLeafNode?.label}) skipp\xE9 - mode autosave`);
      continue;
    }
    if (isDisplayField && mode === "open") {
      console.log(`\u{1F504} [OPEN] Display field ${capacity.nodeId} (${capacity.TreeBranchLeafNode?.label}) recalcul\xE9 - mode open`);
    }
    if (isDisplayField && mode === "change" && changedFieldId) {
      const node = await prisma43.treeBranchLeafNode.findUnique({
        where: { id: capacity.nodeId },
        select: { metadata: true }
      });
      const metaTriggerNodeIds = node?.metadata?.triggerNodeIds;
      let triggerNodeIds = Array.isArray(metaTriggerNodeIds) ? metaTriggerNodeIds.filter(Boolean) : [];
      console.log(`\u{1F50E} [TRIGGER LOAD] Display field ${capacity.nodeId} - changedFieldId: ${changedFieldId}`);
      console.log(`   \u{1F50E} Node trouv\xE9: ${node ? "OUI" : "NON"}, triggers: ${triggerNodeIds.length}`);
      if (triggerNodeIds.length > 0 && triggerNodeIds.length <= 12) {
        console.log(`   \u{1F50E} Triggers: ${JSON.stringify(triggerNodeIds)}`);
      }
      console.log(`   \u{1F50E} changedFieldId dans triggers? ${triggerNodeIds.includes(changedFieldId)}`);
      if (triggerNodeIds.length === 0) {
        const derived = deriveTriggerNodeIdsFromCapacity(capacity, capacity.nodeId);
        if (derived.length > 0) {
          triggerNodeIds = derived;
          try {
            const existingMeta = node?.metadata && typeof node.metadata === "object" ? node.metadata : {};
            await prisma43.treeBranchLeafNode.update({
              where: { id: capacity.nodeId },
              data: {
                metadata: {
                  ...existingMeta,
                  triggerNodeIds: derived
                }
              }
            });
            console.log(
              `\u{1F9E9} [TRIGGERS AUTO] Display field ${capacity.nodeId} (${capacity.TreeBranchLeafNode?.label}) triggers auto-d\xE9duits: ${derived.length}`
            );
          } catch (e) {
            console.warn(
              `\u26A0\uFE0F [TRIGGERS AUTO] Impossible de persister les triggerNodeIds pour ${capacity.nodeId}:`,
              e?.message || e
            );
          }
        }
      }
      if (triggerNodeIds && Array.isArray(triggerNodeIds) && triggerNodeIds.length > 0) {
        const expanded = expandTriggersForCopy(capacity.nodeId, triggerNodeIds);
        let matchesTrigger = matchesAnyEffectiveTrigger(expanded, effectiveTriggers);
        if (!matchesTrigger) {
          try {
            const cached = triggerDerivationCache.get(capacity.nodeId);
            const derived = cached ?? await deriveTriggerNodeIdsFromNodeId(capacity.nodeId);
            if (!cached) triggerDerivationCache.set(capacity.nodeId, derived);
            const merged = uniqStrings([...triggerNodeIds, ...derived]);
            if (merged.length > triggerNodeIds.length) {
              const reExpanded = expandTriggersForCopy(capacity.nodeId, merged);
              matchesTrigger = matchesAnyEffectiveTrigger(reExpanded, effectiveTriggers);
              if (matchesTrigger) {
                const existingMeta = node?.metadata && typeof node.metadata === "object" ? node.metadata : {};
                await prisma43.treeBranchLeafNode.update({
                  where: { id: capacity.nodeId },
                  data: {
                    metadata: {
                      ...existingMeta,
                      triggerNodeIds: merged
                    }
                  }
                });
                console.log(
                  `\u{1F9E9} [TRIGGERS REPAIR] Display field ${capacity.nodeId} (${capacity.TreeBranchLeafNode?.label}) triggers \xE9tendus: ${triggerNodeIds.length} \u2192 ${merged.length}`
                );
              }
            }
          } catch (e) {
            console.warn(
              `\u26A0\uFE0F [TRIGGERS REPAIR] \xC9chec r\xE9paration triggers pour ${capacity.nodeId}:`,
              e?.message || e
            );
          }
          if (!matchesTrigger) {
            skippedDisplayFields.push(capacity);
            console.log(`\u23F8\uFE0F [TRIGGER FILTER] Display field ${capacity.nodeId} (${capacity.TreeBranchLeafNode?.label}) skipp\xE9 - effectiveTriggers [${effectiveTriggers.size}] pas dans triggers [${triggerNodeIds.length}]`);
            continue;
          }
        } else {
          console.log(`\u2705 [TRIGGER MATCH] Display field ${capacity.nodeId} (${capacity.TreeBranchLeafNode?.label}) recalcul\xE9 - match avec effectiveTriggers [${effectiveTriggers.size}]`);
        }
      } else {
        console.log(`\u23F8\uFE0F [NO TRIGGERS] Display field ${capacity.nodeId} (${capacity.TreeBranchLeafNode?.label}) skipp\xE9 - aucun trigger d\xE9fini, calcul\xE9 uniquement au chargement initial`);
        continue;
      }
    }
    try {
      const injectedBaseKeys = applyCopyScopedInputAliases(valueMap, capacity.nodeId, capacity);
      const capacityResult = await evaluateVariableOperation(
        capacity.nodeId,
        submissionId,
        prisma43,
        valueMap
        // üîë PASSER LE VALUEMAP avec les donn√©es fra√Æches !
      );
      const rawValue = capacityResult.value ?? capacityResult.calculatedValue ?? capacityResult.result;
      const stringified = rawValue === null || rawValue === void 0 ? null : String(rawValue).trim();
      const hasValidValue = rawValue !== null && rawValue !== void 0 && stringified !== "" && stringified !== "\u2205";
      if (hasValidValue) {
        valueMap.set(capacity.nodeId, rawValue);
      }
      const normalizedOperationSource = coerceOperationSource(
        capacityResult.operationSource
      );
      let parsedDetail = null;
      try {
        parsedDetail = typeof capacityResult.operationDetail === "string" ? JSON.parse(capacityResult.operationDetail) : capacityResult.operationDetail;
      } catch {
        parsedDetail = capacityResult.operationDetail;
      }
      let parsedResult = null;
      try {
        parsedResult = typeof capacityResult.operationResult === "string" ? JSON.parse(capacityResult.operationResult) : capacityResult.operationResult;
      } catch {
        parsedResult = capacityResult.operationResult;
      }
      if (isDisplayField) {
        computedValuesToStore.push({
          nodeId: capacity.nodeId,
          value: hasValidValue ? String(rawValue) : null,
          sourceRef,
          operationSource: normalizedOperationSource,
          fieldLabel: capacity.TreeBranchLeafNode?.label || null,
          operationDetail: parsedDetail,
          operationResult: parsedResult,
          calculatedBy: `reactive-${userId || "unknown"}`
        });
        effectiveTriggers.add(capacity.nodeId);
        processedNodeIds.add(capacity.nodeId);
        console.log(
          `\u2705 [DISPLAY FIELD] ${capacity.nodeId} (${capacity.TreeBranchLeafNode?.label}) = ${hasValidValue ? String(rawValue) : "null"} \u2192 ajout\xE9 aux effectiveTriggers [${effectiveTriggers.size}]`
        );
        continue;
      }
      processedNodeIds.add(capacity.nodeId);
      const key2 = { submissionId_nodeId: { submissionId, nodeId: capacity.nodeId } };
      const existing = await prisma43.treeBranchLeafSubmissionData.findUnique({ where: key2 });
      const normalize2 = (v) => {
        if (v === null || v === void 0) return null;
        if (typeof v === "string") return v;
        try {
          return JSON.stringify(v);
        } catch {
          return String(v);
        }
      };
      if (existing) {
        const changed = (existing.sourceRef || null) !== (sourceRef || null) || (existing.operationSource || null) !== (normalizedOperationSource || null) || (existing.fieldLabel || null) !== (capacity.TreeBranchLeafNode?.label || null) || normalize2(existing.operationDetail) !== normalize2(parsedDetail);
        if (changed) {
          await prisma43.treeBranchLeafSubmissionData.update({
            where: key2,
            data: {
              value: hasValidValue ? String(rawValue) : null,
              sourceRef,
              operationSource: normalizedOperationSource,
              fieldLabel: capacity.TreeBranchLeafNode?.label || null,
              operationDetail: parsedDetail,
              lastResolved: /* @__PURE__ */ new Date()
            }
          });
          results.updated++;
        }
      } else {
        await prisma43.treeBranchLeafSubmissionData.create({
          data: {
            id: `${submissionId}-${capacity.nodeId}-cap-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            submissionId,
            nodeId: capacity.nodeId,
            value: hasValidValue ? String(rawValue) : null,
            sourceRef,
            operationSource: normalizedOperationSource,
            fieldLabel: capacity.TreeBranchLeafNode?.label || null,
            operationDetail: parsedDetail,
            lastResolved: /* @__PURE__ */ new Date()
          }
        });
        results.created++;
      }
      if (injectedBaseKeys.length) {
        for (const k of injectedBaseKeys) {
          valueMap.delete(k);
        }
      }
    } catch (error) {
      console.error(`[TBL CAPACITY ERROR] ${sourceRef}:`, error);
    }
  }
  if (computedValuesToStore.length > 0) {
    try {
      console.log(`\u{1F3AF} [COMPUTED VALUES] Stockage de ${computedValuesToStore.length} valeurs calcul\xE9es (DISPLAY inclus) dans SubmissionData`);
      const stored = await upsertComputedValuesForSubmission(submissionId, computedValuesToStore);
      results.displayFieldsUpdated = stored;
      console.log(`\u2705 [COMPUTED VALUES] ${stored} valeurs calcul\xE9es stock\xE9es (submission scoped)`);
    } catch (computedStoreError) {
      console.error("[COMPUTED VALUES] Erreur stockage:", computedStoreError);
    }
  }
  return results;
}
router73.post("/submissions/:submissionId/evaluate-all", async (req2, res) => {
  try {
    const { submissionId } = req2.params;
    const { forceUpdate = false } = req2.body || {};
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    const userId = req2.headers["x-user-id"] || req2.user?.userId || "unknown-user";
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        error: "Organisation ID manquant - authentification requise"
      });
    }
    console.log("\u{1F525} [TBL EVALUATE ALL] D\xE9but \xE9valuation compl\xE8te:", submissionId);
    console.log(`\u{1F3E2} [TBL EVALUATE ALL] Organisation: ${organizationId}, Utilisateur: ${userId}`);
    const submissionData = await prisma43.treeBranchLeafSubmissionData.findMany({
      where: {
        submissionId,
        sourceRef: { not: null }
      },
      include: {
        TreeBranchLeafNode: {
          select: { label: true, type: true }
        }
      }
    });
    console.log(`\u{1F4CA} [TBL EVALUATE ALL] ${submissionData.length} \xE9l\xE9ments avec capacit\xE9s trouv\xE9s`);
    if (submissionData.length === 0) {
      return res.json({
        success: true,
        message: "Aucune capacit\xE9 \xE0 \xE9valuer",
        evaluated: 0
      });
    }
    const _context = {
      submissionId,
      organizationId,
      // ‚úÖ VRAIE ORGANISATION!
      userId,
      // ‚úÖ VRAI UTILISATEUR!
      labelMap: /* @__PURE__ */ new Map(),
      // üî• MAPS INITIALIS√âES
      valueMap: /* @__PURE__ */ new Map()
    };
    let evaluatedCount = 0;
    let errorCount = 0;
    const results = [];
    for (const data of submissionData) {
      try {
        if (!forceUpdate && data.operationResult && data.lastResolved) {
          console.log(`\u23ED\uFE0F [TBL EVALUATE ALL] Skip ${data.sourceRef} (d\xE9j\xE0 \xE9valu\xE9)`);
          continue;
        }
        console.log(`\u{1F504} [TBL EVALUATE ALL] \xC9valuation ${data.sourceRef}...`);
        const calculationResult = await evaluateVariableOperation(
          data.nodeId,
          submissionId,
          prisma43
        );
        console.log(`\u2705 [TBL EVALUATE ALL] R\xE9sultat pour ${data.sourceRef}:`, calculationResult.operationResult);
        const normalize2 = (v) => {
          if (v === null || v === void 0) return null;
          if (typeof v === "string") return v;
          try {
            return JSON.stringify(v);
          } catch {
            return String(v);
          }
        };
        const normalizedSource = typeof calculationResult.operationSource === "string" ? calculationResult.operationSource.toLowerCase() : "neutral";
        const nextDetail = (() => {
          try {
            return typeof calculationResult.operationDetail === "string" ? JSON.parse(calculationResult.operationDetail) : calculationResult.operationDetail;
          } catch {
            return calculationResult.operationDetail;
          }
        })();
        const changed = (data.operationSource || null) !== (normalizedSource || null) || normalize2(data.operationDetail) !== normalize2(nextDetail);
        if (changed) {
          await prisma43.treeBranchLeafSubmissionData.update({
            where: { id: data.id },
            data: {
              operationDetail: nextDetail,
              operationSource: normalizedSource,
              lastResolved: /* @__PURE__ */ new Date()
            }
          });
        } else {
          console.log(`\u23ED\uFE0F [TBL EVALUATE ALL] NO-OP ${data.sourceRef} (inchang\xE9)`);
        }
        results.push({
          id: data.id,
          sourceRef: data.sourceRef,
          nodeLabel: data.TreeBranchLeafNode?.label,
          operationResult: calculationResult.operationResult,
          success: true
        });
        evaluatedCount++;
      } catch (error) {
        console.error(`\u274C [TBL EVALUATE ALL] Erreur pour ${data.sourceRef}:`, error);
        results.push({
          id: data.id,
          sourceRef: data.sourceRef,
          nodeLabel: data.TreeBranchLeafNode?.label,
          error: error instanceof Error ? error.message : "Erreur inconnue",
          success: false
        });
        errorCount++;
      }
    }
    console.log(`\u{1F389} [TBL EVALUATE ALL] Termin\xE9: ${evaluatedCount} \xE9valu\xE9s, ${errorCount} erreurs`);
    return res.json({
      success: true,
      submissionId,
      evaluated: evaluatedCount,
      errors: errorCount,
      total: submissionData.length,
      results,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("\u274C [TBL EVALUATE ALL] Erreur globale:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors de l'\xE9valuation compl\xE8te",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router73.get("/submissions/:submissionId/verification", async (req2, res) => {
  try {
    const { submissionId } = req2.params;
    console.log("\u{1F50D} [TBL VERIFICATION] V\xE9rification soumission:", submissionId);
    const rows = await prisma43.treeBranchLeafSubmissionData.findMany({
      where: { submissionId, sourceRef: { not: null } },
      select: { operationResult: true }
    });
    const total = rows.length;
    const toStringSafely = (val) => {
      if (val === null || val === void 0) return "";
      if (typeof val === "string") return val;
      try {
        return JSON.stringify(val);
      } catch {
        return String(val);
      }
    };
    let withIntelligentTranslations = 0;
    let withOldMessages = 0;
    let withErrors = 0;
    for (const r of rows) {
      const s = toStringSafely(r.operationResult).trim();
      if (!s) {
        withErrors++;
        continue;
      }
      if (s.includes("\xC9valu\xE9 dynamiquement par TBL Prisma")) {
        withOldMessages++;
      }
      if (s.includes("Si ") || /(=) Result \(/.test(s) || s.includes("(/)")) {
        withIntelligentTranslations++;
      }
    }
    const successRate = total > 0 ? Math.round((total - withOldMessages - withErrors) / total * 100) : 100;
    return res.json({
      success: true,
      submissionId,
      verification: {
        total,
        withIntelligentTranslations,
        withOldMessages,
        withErrors,
        successRate: `${successRate}%`
      },
      status: withOldMessages === 0 && withErrors === 0 ? "perfect" : "needs_improvement",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("\u274C [TBL VERIFICATION] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors de la v\xE9rification"
    });
  }
});
router73.post("/submissions/create-and-evaluate", async (req2, res) => {
  try {
    const {
      treeId,
      clientId,
      formData,
      status = "draft",
      providedName,
      reuseSubmissionId,
      submissionId: requestedSubmissionId,
      changedFieldId,
      evaluationMode,
      forceNewSubmission
    } = req2.body;
    let mode = "change";
    if (evaluationMode === "open" || evaluationMode === "autosave" || evaluationMode === "change") {
      mode = evaluationMode;
    } else if (changedFieldId === "NULL") {
      mode = "autosave";
    }
    const cleanFormData = formData && typeof formData === "object" ? sanitizeFormData(formData) : void 0;
    const triggerFieldId = changedFieldId;
    const shouldForceNewSubmission = Boolean(forceNewSubmission);
    console.log(`\u{1F3AF} [TRIGGER DEBUG] changedFieldId re\xE7u du frontend: "${triggerFieldId || "NULL"}"`);
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    const userId = req2.headers["x-user-id"] || req2.user?.userId || "unknown-user";
    const canEditCompletedInPlace = isAdminOrSuperAdmin(req2);
    const isSuperAdmin2 = Boolean(req2.user?.isSuperAdmin) || req2.user?.role === "super_admin";
    if (!organizationId) {
      return res.status(400).json({
        success: false,
        error: "Organisation ID manquant - authentification requise"
      });
    }
    console.log("\u{1F525} [TBL CREATE-AND-EVALUATE] D\xE9but cr\xE9ation compl\xE8te TBL Prisma");
    console.log(`\u{1F3E2} [TBL CREATE-AND-EVALUATE] Organisation: ${organizationId}, Utilisateur: ${userId}`);
    console.log(`\u{1F4CB} [TBL CREATE-AND-EVALUATE] TreeId re\xE7u: ${treeId}, ClientId: ${clientId}`);
    let effectiveTreeId = treeId;
    if (!effectiveTreeId) {
      console.log("\u26A0\uFE0F [TBL CREATE-AND-EVALUATE] Aucun treeId fourni, recherche du premier arbre disponible...");
      const firstTree = await prisma43.treeBranchLeafTree.findFirst({
        select: { id: true, name: true }
      });
      if (!firstTree) {
        throw new Error("Aucun arbre TreeBranchLeaf trouv\xE9 dans la base de donn\xE9es");
      }
      effectiveTreeId = firstTree.id;
      console.log(`\u{1F333} [TBL CREATE-AND-EVALUATE] Arbre par d\xE9faut s\xE9lectionn\xE9: ${effectiveTreeId} (${firstTree.name})`);
    } else {
      const treeExists = await prisma43.treeBranchLeafTree.findUnique({
        where: { id: effectiveTreeId },
        select: { id: true, name: true }
      });
      if (!treeExists) {
        console.log(`\u274C [TBL CREATE-AND-EVALUATE] Arbre ${effectiveTreeId} introuvable, recherche d'un arbre alternatif...`);
        const firstTree = await prisma43.treeBranchLeafTree.findFirst({
          select: { id: true, name: true }
        });
        if (!firstTree) {
          throw new Error("Aucun arbre TreeBranchLeaf trouv\xE9 dans la base de donn\xE9es");
        }
        effectiveTreeId = firstTree.id;
        console.log(`\u{1F333} [TBL CREATE-AND-EVALUATE] Arbre alternatif s\xE9lectionn\xE9: ${effectiveTreeId} (${firstTree.name})`);
      } else {
        console.log(`\u2705 [TBL CREATE-AND-EVALUATE] Arbre valid\xE9: ${effectiveTreeId} (${treeExists.name})`);
      }
    }
    let effectiveLeadId = clientId || null;
    const isDefaultDraft = status === "default-draft";
    if (!clientId && !isDefaultDraft) {
      console.log("\u274C [TBL CREATE-AND-EVALUATE] Aucun leadId fourni - REQUIS (sauf pour default-draft)");
      return res.status(400).json({
        success: false,
        error: "Lead obligatoire",
        message: "Un lead doit \xEAtre s\xE9lectionn\xE9 pour cr\xE9er un devis. Veuillez s\xE9lectionner ou cr\xE9er un lead."
      });
    }
    if (clientId) {
      const leadExists = await prisma43.lead.findUnique({
        where: { id: clientId },
        select: { id: true, firstName: true, lastName: true, email: true, organizationId: true }
      });
      if (!leadExists) {
        console.log(`\u274C [TBL CREATE-AND-EVALUATE] Lead ${clientId} introuvable`);
        return res.status(404).json({
          success: false,
          error: "Lead introuvable",
          message: `Le lead ${clientId} n'existe pas. Veuillez s\xE9lectionner un lead valide.`
        });
      }
      if (!isSuperAdmin2 && leadExists.organizationId !== organizationId) {
        console.log(`\u274C [TBL CREATE-AND-EVALUATE] Le lead ${clientId} n'appartient pas \xE0 l'organisation ${organizationId}`);
        return res.status(403).json({
          success: false,
          error: "Lead non autoris\xE9",
          message: "Le lead s\xE9lectionn\xE9 n'appartient pas \xE0 votre organisation."
        });
      }
      if (isSuperAdmin2 && leadExists.organizationId !== organizationId) {
        console.log(`\u{1F511} [TBL CREATE-AND-EVALUATE] Super Admin - Bypass v\xE9rification organisation pour lead ${clientId}`);
      }
      console.log(`\u2705 [TBL CREATE-AND-EVALUATE] Lead valid\xE9: ${clientId} (${leadExists.firstName} ${leadExists.lastName})`);
      effectiveLeadId = leadExists.id;
    } else {
      console.log("\u{1F4DD} [TBL CREATE-AND-EVALUATE] Cr\xE9ation default-draft SANS lead");
    }
    let effectiveUserId = userId;
    if (effectiveUserId) {
      const userExists = await prisma43.user.findUnique({
        where: { id: effectiveUserId },
        select: { id: true, firstName: true, lastName: true }
      });
      if (!userExists) {
        console.log(`\u274C [TBL CREATE-AND-EVALUATE] User ${effectiveUserId} introuvable, soumission sans utilisateur`);
        effectiveUserId = null;
      } else {
        console.log(`\u2705 [TBL CREATE-AND-EVALUATE] User valid\xE9: ${effectiveUserId} (${userExists.firstName} ${userExists.lastName})`);
      }
    }
    let submissionId = requestedSubmissionId || reuseSubmissionId;
    let existingSubmission = null;
    if (submissionId) {
      existingSubmission = await prisma43.treeBranchLeafSubmission.findUnique({
        where: { id: submissionId },
        select: {
          id: true,
          treeId: true,
          leadId: true,
          userId: true,
          status: true,
          organizationId: true,
          summary: true,
          exportData: true,
          completedAt: true
        }
      });
      if (!existingSubmission) {
        submissionId = void 0;
      } else {
        if (!isSuperAdmin2 && existingSubmission.organizationId && existingSubmission.organizationId !== organizationId) {
          return res.status(403).json({
            success: false,
            error: "Soumission non autoris\xE9e",
            message: "Cette soumission n'appartient pas \xE0 votre organisation."
          });
        }
        if (effectiveTreeId && effectiveTreeId !== existingSubmission.treeId) {
          return res.status(400).json({
            success: false,
            error: "treeId invalide",
            message: "treeId ne correspond pas \xE0 la soumission existante."
          });
        }
        effectiveTreeId = existingSubmission.treeId;
        if (clientId && existingSubmission.leadId && clientId !== existingSubmission.leadId) {
          return res.status(400).json({
            success: false,
            error: "leadId invalide",
            message: "clientId ne correspond pas au lead de la soumission existante."
          });
        }
        if (existingSubmission.leadId) {
          effectiveLeadId = existingSubmission.leadId;
        }
        const isCompleted = existingSubmission.status === "completed";
        const isRealUserChange = Boolean(triggerFieldId && triggerFieldId !== "NULL");
        const summaryObj = existingSubmission.summary && typeof existingSubmission.summary === "object" ? existingSubmission.summary : null;
        const summaryName = summaryObj && typeof summaryObj.name === "string" ? summaryObj.name : "";
        const isRevision = Boolean(
          summaryObj && typeof summaryObj.revisionOfSubmissionId === "string" && summaryObj.revisionOfSubmissionId.trim()
        ) || /-\d+\s*$/.test(summaryName);
        if (isCompleted && !canEditCompletedInPlace && isRealUserChange) {
          if (shouldForceNewSubmission) {
            const newId = await cloneCompletedSubmissionToDraft({
              originalSubmissionId: existingSubmission.id,
              requestedByUserId: userId && userId !== "unknown-user" ? userId : null,
              targetStatus: status === "completed" ? "completed" : "draft",
              providedName: typeof providedName === "string" ? providedName : null
            });
            submissionId = newId;
            existingSubmission = null;
            console.log(`\u{1F195} [TBL VERSIONING] Soumission completed ${requestedSubmissionId} clon\xE9e (forceNewSubmission) \u2192 ${newId}`);
          } else if (!isRevision) {
            const newId = await cloneCompletedSubmissionToDraft({
              originalSubmissionId: existingSubmission.id,
              requestedByUserId: userId && userId !== "unknown-user" ? userId : null,
              targetStatus: "draft"
            });
            submissionId = newId;
            existingSubmission = null;
            console.log(`\u{1F195} [TBL VERSIONING] Soumission completed ${requestedSubmissionId} clon\xE9e \u2192 ${newId}`);
          }
        }
      }
    }
    if (!submissionId) {
      let existingDraft;
      if (isDefaultDraft) {
        existingDraft = await prisma43.treeBranchLeafSubmission.findFirst({
          where: {
            treeId: effectiveTreeId,
            userId: effectiveUserId,
            organizationId,
            status: "default-draft"
          },
          orderBy: { updatedAt: "desc" },
          select: { id: true }
        });
        if (existingDraft) {
          console.log(`\u267B\uFE0F [TBL CREATE-AND-EVALUATE] R\xE9utilisation du default-draft existant: ${existingDraft.id}`);
        }
      } else if (effectiveLeadId && !shouldForceNewSubmission) {
        existingDraft = await prisma43.treeBranchLeafSubmission.findFirst({
          where: {
            treeId: effectiveTreeId,
            leadId: effectiveLeadId,
            organizationId,
            status: "draft"
          },
          orderBy: { updatedAt: "desc" },
          select: { id: true }
        });
        if (existingDraft) {
          console.log(`\u267B\uFE0F [TBL CREATE-AND-EVALUATE] R\xE9utilisation du draft existant: ${existingDraft.id} (leadId: ${effectiveLeadId})`);
        }
      }
      if (existingDraft) {
        submissionId = existingDraft.id;
      }
    }
    if (!submissionId) {
      submissionId = `tbl-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      await prisma43.treeBranchLeafSubmission.create({
        data: {
          id: submissionId,
          treeId: effectiveTreeId,
          userId: effectiveUserId,
          leadId: effectiveLeadId,
          organizationId,
          // üî• IMPORTANT pour retrouver les drafts
          status: status || "draft",
          summary: { name: providedName || `Devis TBL ${(/* @__PURE__ */ new Date()).toLocaleDateString()}` },
          exportData: cleanFormData || {},
          completedAt: status === "completed" ? /* @__PURE__ */ new Date() : null,
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
      console.log(`\u2705 [TBL CREATE-AND-EVALUATE] Soumission cr\xE9\xE9e: ${submissionId} pour organization ${organizationId}`);
    } else {
      const current = await prisma43.treeBranchLeafSubmission.findUnique({
        where: { id: submissionId },
        select: { id: true, status: true, completedAt: true }
      });
      const keepCompleted = current?.status === "completed" && canEditCompletedInPlace;
      const nextStatus = keepCompleted ? "completed" : status || "draft";
      const updateData = {
        status: nextStatus,
        updatedAt: /* @__PURE__ */ new Date(),
        completedAt: keepCompleted ? current?.completedAt ?? /* @__PURE__ */ new Date() : nextStatus === "completed" ? /* @__PURE__ */ new Date() : null
      };
      if (providedName && typeof providedName === "string" && providedName.trim()) {
        updateData.summary = { name: providedName.trim() };
      }
      if (cleanFormData && typeof cleanFormData === "object" && Object.keys(cleanFormData).length > 0) {
        updateData.exportData = cleanFormData;
      }
      await prisma43.treeBranchLeafSubmission.update({
        where: { id: submissionId },
        data: updateData
      });
      console.log(`\u267B\uFE0F [TBL CREATE-AND-EVALUATE] Soumission mise \xE0 jour: ${submissionId}`);
    }
    if (cleanFormData && typeof cleanFormData === "object") {
      const savedCount = await saveUserEntriesNeutral(submissionId, cleanFormData, effectiveTreeId);
      if (savedCount > 0) console.log(`\u2705 [TBL CREATE-AND-EVALUATE] ${savedCount} entr\xE9es utilisateur enregistr\xE9es`);
      const capacities = await prisma43.treeBranchLeafNodeVariable.findMany({
        where: {
          TreeBranchLeafNode: {
            treeId: effectiveTreeId
          },
          sourceRef: { not: null }
        },
        include: {
          TreeBranchLeafNode: {
            select: { id: true, label: true }
          }
        }
      });
      console.log(`\u{1F3AF} [TBL CREATE-AND-EVALUATE] ${capacities.length} capacit\xE9s trouv\xE9es`);
      const evalStats = await evaluateCapacitiesForSubmission(submissionId, organizationId, userId || null, effectiveTreeId, cleanFormData, mode, triggerFieldId);
      console.log(`\u2705 [TBL CREATE-AND-EVALUATE] Capacit\xE9s: ${evalStats.updated} mises \xE0 jour, ${evalStats.created} cr\xE9\xE9es, ${evalStats.displayFieldsUpdated} display fields r\xE9actifs (mode: ${mode})`);
    }
    const finalSubmission = await prisma43.treeBranchLeafSubmission.findUnique({
      where: { id: submissionId }
    });
    const submissionData = await prisma43.treeBranchLeafSubmissionData.findMany({
      where: { submissionId }
    });
    return res.status(201).json({
      success: true,
      message: "Soumission cr\xE9\xE9e et \xE9valu\xE9e avec TBL Prisma",
      submission: {
        ...finalSubmission,
        TreeBranchLeafSubmissionData: submissionData
      }
    });
  } catch (error) {
    console.error("\u274C [TBL CREATE-AND-EVALUATE] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : "Erreur interne"
    });
  }
});
router73.put("/submissions/:submissionId/update-and-evaluate", async (req2, res) => {
  try {
    const { submissionId } = req2.params;
    const { formData, status } = req2.body || {};
    const cleanFormData = formData && typeof formData === "object" ? sanitizeFormData(formData) : void 0;
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    const userId = req2.user?.userId || null;
    if (!organizationId) {
      return res.status(400).json({ success: false, error: "Organisation ID manquant - authentification requise" });
    }
    const submission = await prisma43.treeBranchLeafSubmission.findUnique({
      where: { id: submissionId },
      select: { id: true, treeId: true, status: true, exportData: true }
    });
    if (!submission) {
      return res.status(404).json({ success: false, error: "Soumission introuvable" });
    }
    const saved = await saveUserEntriesNeutral(submissionId, cleanFormData, submission.treeId);
    const updateData = {};
    if (status && status !== submission.status) {
      updateData.status = status;
    }
    if (cleanFormData) {
      if (typeof cleanFormData === "object" && Object.keys(cleanFormData).length === 0) {
      } else {
        const normalize2 = (v) => {
          if (v === null || v === void 0) return null;
          if (typeof v === "string") return v;
          try {
            return JSON.stringify(v);
          } catch {
            return String(v);
          }
        };
        if (normalize2(submission.exportData) !== normalize2(cleanFormData)) {
          updateData.exportData = cleanFormData;
        }
      }
    }
    if (Object.keys(updateData).length > 0) {
      await prisma43.treeBranchLeafSubmission.update({ where: { id: submissionId }, data: updateData });
    }
    const stats = await evaluateCapacitiesForSubmission(submissionId, organizationId, userId, submission.treeId, cleanFormData, "change");
    const finalSubmission = await prisma43.treeBranchLeafSubmission.findUnique({
      where: { id: submissionId },
      include: { TreeBranchLeafSubmissionData: true }
    });
    return res.json({
      success: true,
      message: `Soumission mise \xE0 jour (${saved} entr\xE9es) et \xE9valu\xE9e (${stats.updated} mises \xE0 jour, ${stats.created} cr\xE9\xE9es, ${stats.displayFieldsUpdated} display fields r\xE9actifs)`,
      submission: finalSubmission
    });
  } catch (error) {
    console.error("\u274C [TBL UPDATE-AND-EVALUATE] Erreur:", error);
    return res.status(500).json({ success: false, error: error instanceof Error ? error.message : "Erreur interne" });
  }
});
router73.post("/submissions/preview-evaluate", async (req2, res) => {
  try {
    const { treeId, formData, baseSubmissionId, leadId } = req2.body || {};
    if (formData) {
      const keys = Object.keys(formData).filter((k) => !k.startsWith("__"));
      const orientationKeys = keys.filter((k) => k.includes("c071a466") || k.includes("Orientation"));
      const inclinaisonKeys = keys.filter((k) => k.includes("76a40eb1") || k.includes("Inclinaison"));
      console.log("\u{1F50D} [PREVIEW-EVALUATE DEBUG] formData keys contenant Orientation:", orientationKeys);
      console.log("\u{1F50D} [PREVIEW-EVALUATE DEBUG] formData keys contenant Inclinaison:", inclinaisonKeys);
      console.log("\u{1F50D} [PREVIEW-EVALUATE DEBUG] Toutes les cl\xE9s -1:", keys.filter((k) => k.endsWith("-1")));
    }
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    const userId = req2.headers["x-user-id"] || req2.user?.userId || "unknown-user";
    if (!organizationId) {
      return res.status(400).json({ success: false, error: "Organisation ID manquant - authentification requise" });
    }
    let effectiveTreeId = treeId;
    if (!effectiveTreeId) {
      const firstTree = await prisma43.treeBranchLeafTree.findFirst({ select: { id: true } });
      if (!firstTree) {
        return res.status(404).json({ success: false, error: "Aucun arbre TreeBranchLeaf trouv\xE9" });
      }
      effectiveTreeId = firstTree.id;
    } else {
      const exists = await prisma43.treeBranchLeafTree.findUnique({ where: { id: effectiveTreeId }, select: { id: true } });
      if (!exists) {
        return res.status(404).json({ success: false, error: `Arbre introuvable: ${effectiveTreeId}` });
      }
    }
    const nodes = await prisma43.treeBranchLeafNode.findMany({ where: { treeId: effectiveTreeId }, select: { id: true, label: true } });
    const labelMap = /* @__PURE__ */ new Map();
    for (const n of nodes) labelMap.set(n.id, n.label);
    const valueMap = /* @__PURE__ */ new Map();
    if (leadId) {
      const lead = await prisma43.lead.findUnique({
        where: { id: leadId },
        select: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
          phone: true,
          company: true,
          leadNumber: true,
          linkedin: true,
          website: true,
          status: true,
          notes: true,
          data: true
        }
      });
      if (lead) {
        valueMap.set("lead.id", lead.id);
        valueMap.set("lead.firstName", lead.firstName);
        valueMap.set("lead.lastName", lead.lastName);
        valueMap.set("lead.email", lead.email);
        valueMap.set("lead.phone", lead.phone);
        valueMap.set("lead.company", lead.company);
        valueMap.set("lead.leadNumber", lead.leadNumber);
        valueMap.set("lead.linkedin", lead.linkedin);
        valueMap.set("lead.website", lead.website);
        valueMap.set("lead.status", lead.status);
        valueMap.set("lead.notes", lead.notes);
        if (lead.data && typeof lead.data === "object") {
          const leadData = lead.data;
          if (leadData.postalCode) {
            valueMap.set("lead.postalCode", leadData.postalCode);
          } else if (leadData.address && typeof leadData.address === "string") {
            const postalCodeMatch = leadData.address.match(/\b(\d{4})\b/);
            if (postalCodeMatch) {
              const extractedPostalCode = postalCodeMatch[1];
              valueMap.set("lead.postalCode", extractedPostalCode);
            }
          }
          if (leadData.address) {
            valueMap.set("lead.address", leadData.address);
          }
          if (leadData.city) {
            valueMap.set("lead.city", leadData.city);
          }
          if (leadData.country) {
            valueMap.set("lead.country", leadData.country);
          }
        }
      }
    }
    if (baseSubmissionId) {
      const existingData = await prisma43.treeBranchLeafSubmissionData.findMany({
        where: {
          submissionId: baseSubmissionId,
          OR: [
            { operationSource: null },
            { operationSource: "neutral" }
          ]
        },
        select: { nodeId: true, value: true }
      });
      const existingEntries = existingData.map((row) => [row.nodeId, row.value]);
      await applySharedReferenceValues(valueMap, existingEntries, effectiveTreeId);
    }
    if (formData && typeof formData === "object") {
      const overrides = Object.entries(formData).filter(([k]) => !k.startsWith("__"));
      await applySharedReferenceValues(valueMap, overrides, effectiveTreeId);
    }
    if (formData && typeof formData === "object") {
      const formEntries = Object.entries(formData);
      const sharedReferenceMapping = {
        "plan": ["shared-ref-1764095668124-l53956", "shared-ref-1764095679973-fad7d7", "shared-ref-1764093957109-52vog", "shared-ref-1764093355187-f83m8h"],
        "inclinaison": ["shared-ref-1764093957109-52vog", "shared-ref-1764093355187-f83m8h"]
      };
      for (const [nodeId, value] of formEntries) {
        if (!nodeId.startsWith("__") && value !== null && value !== void 0 && value !== "") {
          const nodeInfo = await prisma43.treeBranchLeafNode.findUnique({
            where: { id: nodeId },
            select: {
              id: true,
              label: true,
              sharedReferenceIds: true,
              TreeBranchLeafSelectConfig: {
                select: {
                  id: true,
                  options: true
                }
              }
            }
          });
          if (nodeInfo?.TreeBranchLeafSelectConfig?.options) {
            const options = Array.isArray(nodeInfo.TreeBranchLeafSelectConfig.options) ? nodeInfo.TreeBranchLeafSelectConfig.options : [];
            const selectedOption = options.find((opt) => opt.value === value);
            if (selectedOption?.sharedReferenceIds?.length) {
              let optionType = null;
              if (JSON.stringify(selectedOption.sharedReferenceIds) === JSON.stringify(sharedReferenceMapping.plan)) {
                optionType = "plan";
              } else if (JSON.stringify(selectedOption.sharedReferenceIds) === JSON.stringify(sharedReferenceMapping.inclinaison)) {
                optionType = "inclinaison";
              }
              if (optionType) {
                const referencesToClean = optionType === "plan" ? sharedReferenceMapping.inclinaison : sharedReferenceMapping.plan;
                const nodesToClean = await prisma43.treeBranchLeafNode.findMany({
                  where: {
                    treeId: effectiveTreeId,
                    sharedReferenceIds: { hasSome: referencesToClean }
                  },
                  select: { id: true, label: true, sharedReferenceIds: true }
                });
                for (const nodeToClean of nodesToClean) {
                  if (valueMap.has(nodeToClean.id)) {
                    valueMap.delete(nodeToClean.id);
                  }
                }
              }
            }
          }
        }
      }
    }
    const [variablesRaw, formulasRaw] = await Promise.all([
      prisma43.treeBranchLeafNodeVariable.findMany({
        where: { TreeBranchLeafNode: { treeId: effectiveTreeId }, sourceRef: { not: null } },
        include: { TreeBranchLeafNode: { select: { id: true, label: true } } }
      }),
      prisma43.treeBranchLeafNodeFormula.findMany({
        where: {
          nodeId: {
            in: (await prisma43.treeBranchLeafNode.findMany({
              where: { treeId: effectiveTreeId, hasFormula: true },
              select: { id: true }
            })).map((n) => n.id)
          }
        }
      })
    ]);
    const formulaNodeIds = formulasRaw.map((f) => f.nodeId);
    const formulaNodes = await prisma43.treeBranchLeafNode.findMany({
      where: { id: { in: formulaNodeIds } },
      select: { id: true, label: true }
    });
    const nodeMapForFormulas = new Map(formulaNodes.map((n) => [n.id, n]));
    const capacitiesRaw = [
      ...variablesRaw,
      ...formulasRaw.map((f) => ({
        ...f,
        sourceRef: `formula:${f.id}`,
        TreeBranchLeafNode: nodeMapForFormulas.get(f.nodeId)
      }))
    ];
    const capacities = capacitiesRaw.sort((a, b) => {
      const aIsSumFormula = a.sourceRef?.includes("sum-formula") || a.sourceRef?.includes("sum-total") ? 1 : 0;
      const bIsSumFormula = b.sourceRef?.includes("sum-formula") || b.sourceRef?.includes("sum-total") ? 1 : 0;
      return aIsSumFormula - bIsSumFormula;
    });
    const submissionId = baseSubmissionId || `preview-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
    const context = {
      submissionId,
      organizationId,
      userId,
      treeId: effectiveTreeId,
      labelMap,
      valueMap
    };
    const results = [];
    let evaluated = 0;
    for (const cap of capacities) {
      try {
        const evaluation = await evaluateVariableOperation(
          cap.nodeId,
          // variableNodeId
          context.submissionId,
          // submissionId
          prisma43,
          // prismaClient
          context.valueMap
          // valueMap (donn√©es temporaires du formulaire)
        );
        if (evaluation.value !== null && evaluation.value !== void 0 && evaluation.value !== "\u2205") {
          context.valueMap.set(cap.nodeId, evaluation.value);
        }
        results.push({
          nodeId: cap.nodeId,
          nodeLabel: cap.TreeBranchLeafNode?.label || null,
          sourceRef: cap.sourceRef,
          operationSource: evaluation.operationSource,
          // üî• STRUCTURE CORRECTE: value directement au niveau racine pour SmartCalculatedField
          value: evaluation.value,
          // ‚úÖ VALEUR CALCUL√âE (utilis√©e par SmartCalculatedField)
          calculatedValue: evaluation.value,
          // ‚úÖ ALIAS pour compatibilit√©
          operationResult: {
            value: evaluation.value,
            // ‚úÖ Aussi dans operationResult pour tra√ßabilit√©
            humanText: evaluation.operationResult,
            // ‚úÖ Le texte explicatif
            detail: evaluation.operationDetail
          },
          operationDetail: evaluation.operationDetail,
          // üé® NOUVEAU: Configuration d'affichage depuis TreeBranchLeafNodeVariable
          displayConfig: {
            displayFormat: cap.displayFormat || "number",
            unit: cap.unit || null,
            precision: cap.precision ?? 2,
            visibleToUser: cap.visibleToUser ?? true
          }
        });
        evaluated++;
      } catch (e) {
        const errorMessage = e instanceof Error ? e.message : "Erreur inconnue";
        results.push({
          nodeId: cap.nodeId,
          nodeLabel: cap.TreeBranchLeafNode?.label || null,
          sourceRef: cap.sourceRef,
          operationSource: "error",
          value: null,
          // ‚úÖ Valeur nulle pour les erreurs
          calculatedValue: null,
          // ‚úÖ ALIAS
          operationResult: {
            value: null,
            // ‚úÖ Valeur nulle
            humanText: errorMessage,
            // ‚úÖ Message d'erreur
            error: errorMessage
          },
          operationDetail: null,
          // üé® Configuration d'affichage m√™me en cas d'erreur
          displayConfig: {
            displayFormat: cap.displayFormat || "number",
            unit: cap.unit || null,
            precision: cap.precision ?? 2,
            visibleToUser: cap.visibleToUser ?? true
          }
        });
      }
    }
    try {
      const nodeIds = results.map((r) => r.nodeId);
      const nodesInfo = await prisma43.treeBranchLeafNode.findMany({
        where: { id: { in: nodeIds } },
        select: { id: true, fieldType: true, type: true }
      });
      const displayFieldIds = new Set(
        nodesInfo.filter((n) => n.fieldType === "DISPLAY" || n.type === "DISPLAY" || n.type === "leaf_field").map((n) => n.id)
      );
      const computedRows = results.map((r) => {
        const candidate = r.value ?? r.calculatedValue;
        return { ...r, candidate };
      }).filter((r) => {
        if (r.candidate === null || r.candidate === void 0) return false;
        const strValue = String(r.candidate).trim();
        if (strValue === "" || strValue === "\u2205") return false;
        return true;
      }).map((r) => ({
        nodeId: r.nodeId,
        value: String(r.candidate),
        sourceRef: r.sourceRef || null,
        operationSource: coerceOperationSource(r.operationSource),
        fieldLabel: r.nodeLabel || null,
        operationDetail: r.operationDetail ?? null,
        operationResult: r.operationResult ?? null,
        calculatedBy: `preview-${userId}`
      }));
      if (computedRows.length > 0) {
        console.log(`\u{1F3AF} [PREVIEW] Stockage de ${computedRows.length} valeurs calcul\xE9es dans SubmissionData`);
        await upsertComputedValuesForSubmission(submissionId, computedRows);
      }
    } catch (storeError) {
      console.error("[PREVIEW] Erreur stockage:", storeError);
    }
    return res.json({
      success: true,
      mode: "preview",
      submissionId,
      treeId: effectiveTreeId,
      evaluated,
      results
    });
  } catch (error) {
    console.error("\u274C [TBL PREVIEW-EVALUATE] Erreur:", error);
    return res.status(500).json({ success: false, error: error instanceof Error ? error.message : "Erreur interne" });
  }
});
router73.post("/submissions/stage", async (req2, res) => {
  try {
    pruneStages();
    const { stageId, treeId, submissionId, formData } = req2.body || {};
    const organizationId = req2.headers["x-organization-id"] || req2.user?.organizationId;
    const userId = req2.headers["x-user-id"] || req2.user?.userId || "unknown-user";
    if (!organizationId) return res.status(400).json({ success: false, error: "Organisation ID manquant" });
    let effectiveTreeId = treeId;
    if (!effectiveTreeId) {
      const firstTree = await prisma43.treeBranchLeafTree.findFirst({ select: { id: true } });
      if (!firstTree) return res.status(404).json({ success: false, error: "Aucun arbre trouv\xE9" });
      effectiveTreeId = firstTree.id;
    }
    const id = stageId || newStageId();
    const clean = formData && typeof formData === "object" ? sanitizeFormData(formData) : {};
    const existing = stagingStore.get(id);
    const merged = {
      id,
      organizationId,
      userId,
      treeId: effectiveTreeId,
      submissionId: submissionId || existing?.submissionId,
      formData: { ...existing?.formData || {}, ...clean },
      updatedAt: Date.now()
    };
    stagingStore.set(id, merged);
    return res.json({ success: true, stage: merged });
  } catch (e) {
    return res.status(500).json({ success: false, error: e instanceof Error ? e.message : "Erreur interne" });
  }
});
router73.post("/submissions/stage/preview", async (req2, res) => {
  try {
    pruneStages();
    const { stageId } = req2.body || {};
    const stage = stageId ? stagingStore.get(stageId) : void 0;
    if (!stage) return res.status(404).json({ success: false, error: "Stage introuvable" });
    const nodes = await prisma43.treeBranchLeafNode.findMany({ where: { treeId: stage.treeId }, select: { id: true, label: true } });
    const labelMap = new Map(nodes.map((n) => [n.id, n.label]));
    const valueMap = /* @__PURE__ */ new Map();
    if (stage.submissionId) {
      const existingData = await prisma43.treeBranchLeafSubmissionData.findMany({
        where: { submissionId: stage.submissionId },
        select: { nodeId: true, value: true }
      });
      const existingEntries = existingData.map((r) => [r.nodeId, r.value]);
      await applySharedReferenceValues(valueMap, existingEntries, stage.treeId);
    }
    const stageEntries = Object.entries(stage.formData);
    await applySharedReferenceValues(valueMap, stageEntries, stage.treeId);
    const capacitiesRaw = await prisma43.treeBranchLeafNodeVariable.findMany({ where: { TreeBranchLeafNode: { treeId: stage.treeId }, sourceRef: { not: null } }, include: { TreeBranchLeafNode: { select: { id: true, label: true } } } });
    const capacities = capacitiesRaw.sort((a, b) => {
      const aIsSumFormula = a.sourceRef?.includes("sum-formula") || a.sourceRef?.includes("sum-total") ? 1 : 0;
      const bIsSumFormula = b.sourceRef?.includes("sum-formula") || b.sourceRef?.includes("sum-total") ? 1 : 0;
      return aIsSumFormula - bIsSumFormula;
    });
    const context = { submissionId: stage.submissionId || `preview-${Date.now()}`, organizationId: stage.organizationId, userId: stage.userId, treeId: stage.treeId, labelMap, valueMap };
    const results = [];
    for (const c of capacities) {
      try {
        const injectedBaseKeys = applyCopyScopedInputAliases(valueMap, c.nodeId, c);
        const r = await evaluateVariableOperation(
          c.nodeId,
          context.submissionId,
          prisma43,
          context.valueMap
        );
        if (injectedBaseKeys.length) {
          for (const k of injectedBaseKeys) {
            context.valueMap.delete(k);
          }
        }
        if (r.value !== null && r.value !== void 0 && r.value !== "\u2205") {
          context.valueMap.set(c.nodeId, r.value);
        }
        results.push({
          nodeId: c.nodeId,
          nodeLabel: c.TreeBranchLeafNode?.label || null,
          sourceRef: c.sourceRef,
          operationSource: r.operationSource || "neutral",
          value: r.value,
          // ‚úÖ VALEUR CALCUL√âE
          calculatedValue: r.value,
          // ‚úÖ ALIAS
          operationResult: {
            value: r.value,
            humanText: r.operationResult,
            detail: r.operationDetail
          },
          operationDetail: r.operationDetail
        });
      } catch (e) {
        const errorMessage = e instanceof Error ? e.message : "Erreur";
        results.push({
          nodeId: c.nodeId,
          nodeLabel: c.TreeBranchLeafNode?.label || null,
          sourceRef: c.sourceRef,
          operationSource: "error",
          value: null,
          // ‚úÖ Valeur nulle
          calculatedValue: null,
          // ‚úÖ ALIAS
          operationResult: {
            value: null,
            humanText: errorMessage,
            error: errorMessage
          },
          operationDetail: null
        });
      }
    }
    return res.json({ success: true, stageId: stage.id, results });
  } catch (e) {
    return res.status(500).json({ success: false, error: e instanceof Error ? e.message : "Erreur interne" });
  }
});
router73.post("/submissions/stage/commit", async (req2, res) => {
  try {
    pruneStages();
    const { stageId, asNew } = req2.body || {};
    const stage = stageId ? stagingStore.get(stageId) : void 0;
    if (!stage) return res.status(404).json({ success: false, error: "Stage introuvable" });
    if (!asNew && stage.submissionId) {
      const submission = await prisma43.treeBranchLeafSubmission.findUnique({ where: { id: stage.submissionId } });
      if (!submission) return res.status(404).json({ success: false, error: "Soumission introuvable" });
      await prisma43.treeBranchLeafSubmission.update({ where: { id: stage.submissionId }, data: { exportData: stage.formData } });
      const saved2 = await saveUserEntriesNeutral(stage.submissionId, stage.formData, stage.treeId);
      const stats2 = await evaluateCapacitiesForSubmission(stage.submissionId, stage.organizationId, stage.userId, stage.treeId, void 0, "change");
      return res.json({ success: true, submissionId: stage.submissionId, saved: saved2, stats: stats2 });
    }
    const submissionId = `tbl-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
    await prisma43.treeBranchLeafSubmission.create({ data: { id: submissionId, treeId: stage.treeId, userId: stage.userId, status: "draft", summary: { name: `Devis TBL ${(/* @__PURE__ */ new Date()).toLocaleDateString()}` }, exportData: stage.formData, updatedAt: /* @__PURE__ */ new Date() } });
    const saved = await saveUserEntriesNeutral(submissionId, stage.formData, stage.treeId);
    const stats = await evaluateCapacitiesForSubmission(submissionId, stage.organizationId, stage.userId, stage.treeId, void 0, "open");
    stage.submissionId = submissionId;
    stage.updatedAt = Date.now();
    stagingStore.set(stage.id, stage);
    return res.status(201).json({ success: true, submissionId, saved, stats });
  } catch (e) {
    return res.status(500).json({ success: false, error: e instanceof Error ? e.message : "Erreur interne" });
  }
});
router73.post("/submissions/stage/discard", (req2, res) => {
  pruneStages();
  const { stageId } = req2.body || {};
  if (!stageId || !stagingStore.has(stageId)) return res.json({ success: true, discarded: false });
  stagingStore.delete(stageId);
  return res.json({ success: true, discarded: true });
});
router73.get("/tables/:tableId", async (req2, res) => {
  try {
    const { tableId } = req2.params;
    console.log(`\u{1F4CA} [GET TABLE] R\xE9cup\xE9ration table: ${tableId}`);
    const table = await prisma43.treeBranchLeafNodeTable.findUnique({
      where: { id: tableId },
      select: {
        id: true,
        name: true,
        nodeId: true,
        meta: true
      }
    });
    if (!table) {
      console.log(`\u274C [GET TABLE] Table introuvable: ${tableId}`);
      return res.status(404).json({
        success: false,
        error: "Table introuvable"
      });
    }
    console.log(`\u2705 [GET TABLE] Table trouv\xE9e: ${table.name || tableId}`);
    const meta = table.meta;
    const lookupConfig = meta?.lookup || {};
    const tableData = meta?.data || {};
    const columns = tableData.columns || [];
    const rows = tableData.rows || [];
    const data = tableData.matrix || [];
    console.log(`\u{1F4CA} [GET TABLE] Donn\xE9es extraites:`, {
      columnsCount: columns.length,
      rowsCount: rows.length,
      dataRowsCount: data.length,
      lookupEnabled: lookupConfig.rowLookupEnabled || lookupConfig.columnLookupEnabled
    });
    return res.json({
      success: true,
      table: {
        id: table.id,
        nodeId: table.nodeId,
        name: table.name || null,
        type: "matrix",
        // Type de table
        sourceRef: `@table.${table.id}`,
        // üî• DONN√âES DE LA TABLE (colonnes, lignes, data)
        columns,
        rows,
        data,
        // üî• CONFIGURATION DE LOOKUP
        meta: {
          lookup: {
            enabled: lookupConfig.rowLookupEnabled || lookupConfig.columnLookupEnabled || false,
            mode: lookupConfig.mode || "columns",
            rowLookupEnabled: lookupConfig.rowLookupEnabled || false,
            columnLookupEnabled: lookupConfig.columnLookupEnabled || false,
            selectors: {
              rowFieldId: lookupConfig.selectors?.rowFieldId || null,
              columnFieldId: lookupConfig.selectors?.columnFieldId || null
            },
            displayRow: lookupConfig.displayRow || null,
            displayColumn: lookupConfig.displayColumn || null
          }
        }
      }
    });
  } catch (error) {
    console.error("\u274C [GET TABLE] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur lors de la r\xE9cup\xE9ration de la table",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
var tbl_submission_evaluator_default = router73;

// src/components/TreeBranchLeaf/treebranchleaf-new/TBL/routes/ia-config-routes.ts
var import_express76 = __toESM(require("express"), 1);
init_database();
var router74 = import_express76.default.Router();
router74.get("/nodes/:nodeId/ia-config", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    console.log(`\u{1F4CA} [IA-CONFIG] R\xE9cup\xE9ration config pour node ${nodeId}`);
    const node = await db.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      select: { iaMesureConfig: true }
    });
    if (!node) {
      console.warn(`\u26A0\uFE0F [IA-CONFIG] Node ${nodeId} non trouv\xE9`);
      return res.status(404).json({ error: "Node not found" });
    }
    const defaultConfig = {
      enabled: false,
      referenceObjects: [],
      detectionSettings: {
        minPhotos: 3,
        confidenceThreshold: 0.7,
        useSharp: true,
        useFusion: true
      }
    };
    const config = node.iaMesureConfig || defaultConfig;
    console.log(`\u2705 [IA-CONFIG] Config r\xE9cup\xE9r\xE9e:`, JSON.stringify(config).substring(0, 100));
    res.json(config);
  } catch (error) {
    console.error("\u274C [IA-CONFIG] Erreur r\xE9cup\xE9ration config:", error);
    res.status(500).json({ error: "Failed to fetch IA config" });
  }
});
router74.put("/nodes/:nodeId/ia-config", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const config = req2.body;
    console.log(`\u{1F4BE} [IA-CONFIG] Mise \xE0 jour config pour node ${nodeId}`);
    if (!config || typeof config !== "object") {
      console.warn(`\u26A0\uFE0F [IA-CONFIG] Format de config invalide`);
      return res.status(400).json({ error: "Invalid config format" });
    }
    if (config.enabled !== void 0 && typeof config.enabled !== "boolean") {
      return res.status(400).json({ error: "enabled must be a boolean" });
    }
    if (config.referenceObjects && !Array.isArray(config.referenceObjects)) {
      return res.status(400).json({ error: "referenceObjects must be an array" });
    }
    await db.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: {
        iaMesureConfig: config,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log(`\u2705 [IA-CONFIG] Config sauvegard\xE9e avec succ\xE8s`);
    res.json({ success: true, config });
  } catch (error) {
    console.error("\u274C [IA-CONFIG] Erreur sauvegarde config:", error);
    res.status(500).json({ error: "Failed to update IA config" });
  }
});
router74.delete("/nodes/:nodeId/ia-config", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    console.log(`\u{1F5D1}\uFE0F [IA-CONFIG] Suppression config pour node ${nodeId}`);
    await db.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: {
        iaMesureConfig: null,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log(`\u2705 [IA-CONFIG] Config supprim\xE9e`);
    res.json({ success: true });
  } catch (error) {
    console.error("\u274C [IA-CONFIG] Erreur suppression config:", error);
    res.status(500).json({ error: "Failed to delete IA config" });
  }
});
var ia_config_routes_default = router74;

// src/controllers/calculatedValueController.ts
var import_express77 = require("express");
var import_crypto23 = require("crypto");
init_database();
var router75 = (0, import_express77.Router)();
var prisma44 = db;
var parseStoredStringValue = (raw) => {
  if (raw === null || raw === void 0) {
    return null;
  }
  const trimmed = String(raw).trim();
  if (!trimmed || trimmed === "\u2205") {
    return null;
  }
  const looksJson = trimmed.startsWith("{") && trimmed.endsWith("}") || trimmed.startsWith("[") && trimmed.endsWith("]");
  if (looksJson) {
    try {
      const parsed = JSON.parse(trimmed);
      if (typeof parsed === "object" && parsed !== null) {
        const candidate = parsed;
        if (candidate.value !== void 0) return candidate.value;
        if (candidate.result !== void 0) return candidate.result;
      }
      if (typeof parsed === "string" || typeof parsed === "number" || typeof parsed === "boolean") {
        return parsed;
      }
    } catch {
    }
  }
  if (trimmed === "true") return true;
  if (trimmed === "false") return false;
  const numeric = Number(trimmed);
  if (!Number.isNaN(numeric) && trimmed === numeric.toString()) {
    return numeric;
  }
  return trimmed;
};
var extractValueFromOperationResult = (raw) => {
  if (raw === null || raw === void 0) {
    return null;
  }
  if (typeof raw === "string" || typeof raw === "number" || typeof raw === "boolean") {
    return raw;
  }
  if (typeof raw === "object") {
    const record = raw;
    const candidate = record.value ?? record.result ?? record.humanText ?? record.text;
    if (candidate === void 0 || candidate === null) {
      return null;
    }
    if (typeof candidate === "string" || typeof candidate === "number" || typeof candidate === "boolean") {
      return candidate;
    }
  }
  return null;
};
var hasMeaningfulValue = (val) => {
  if (val === null || val === void 0) return false;
  if (typeof val === "string") {
    return val.trim() !== "" && val.trim() !== "\u2205";
  }
  return true;
};
var toIsoString = (date) => {
  if (!date) {
    return void 0;
  }
  try {
    return date instanceof Date ? date.toISOString() : new Date(date).toISOString();
  } catch {
    return void 0;
  }
};
router75.get("/:nodeId/calculated-value", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const pickQueryString = (key2) => {
      const rawValue = req2.query[key2];
      if (typeof rawValue === "string") return rawValue;
      if (Array.isArray(rawValue) && rawValue.length > 0 && typeof rawValue[0] === "string") {
        return rawValue[0];
      }
      return void 0;
    };
    const submissionId = pickQueryString("submissionId") || pickQueryString("_submissionId") || pickQueryString("subId") || pickQueryString("tblSubmissionId");
    if (!nodeId) {
      return res.status(400).json({ error: "nodeId requis" });
    }
    const node = await prisma44.treeBranchLeafNode.findUnique({
      where: {
        id: nodeId
      },
      select: {
        id: true,
        label: true,
        calculatedValue: true,
        metadata: true,
        calculatedAt: true,
        calculatedBy: true,
        type: true,
        fieldType: true,
        table_activeId: true,
        linkedTableIds: true,
        treeId: true
        // ‚ú® Ajout√© pour operation-interpreter
      }
    });
    if (!node) {
      return res.status(404).json({ error: "N\u0153ud non trouv\xE9" });
    }
    const isDisplayField = node.fieldType === "DISPLAY" || node.type === "DISPLAY" || node.type === "leaf_field";
    const nodeMetadata = node.metadata && typeof node.metadata === "object" ? node.metadata : null;
    const forceFlag = pickQueryString("force") || pickQueryString("forceRefresh") || pickQueryString("refresh") || pickQueryString("forceRecompute");
    const forceRecompute = Boolean(
      forceFlag && ["1", "true", "yes", "force"].includes(forceFlag.toLowerCase())
    );
    const requiresFreshCalculation = (() => {
      if (!nodeMetadata) return false;
      const metaAny = nodeMetadata;
      return Boolean(
        metaAny?.mustRecalculate || metaAny?.requiresFreshCalculation || metaAny?.calculationInvalidated || metaAny?.calculatedValueReset || metaAny?.forceIndependentCalc || metaAny?.independentCalculation
      );
    })();
    if (isDisplayField) {
      if (submissionId && !forceRecompute) {
        const scoped = await prisma44.treeBranchLeafSubmissionData.findUnique({
          where: { submissionId_nodeId: { submissionId, nodeId } },
          select: {
            value: true,
            lastResolved: true,
            operationSource: true,
            sourceRef: true,
            operationResult: true
          }
        });
        const scopedValue = scoped?.value ?? null;
        const parsedScoped = parseStoredStringValue(scopedValue);
        const hasValidScoped = hasMeaningfulValue(parsedScoped);
        const fromOpResult = hasValidScoped ? null : extractValueFromOperationResult(scoped?.operationResult);
        const resolved = hasValidScoped ? parsedScoped : fromOpResult;
        if (hasMeaningfulValue(resolved)) {
          console.log(`\u2705 [DISPLAY FIELD] ${nodeId} (${node.label}) retourne valeur SubmissionData: ${resolved}`);
          return res.json({
            success: true,
            nodeId: node.id,
            label: node.label,
            value: resolved,
            calculatedAt: toIsoString(scoped?.lastResolved || void 0),
            calculatedBy: scoped?.operationSource || node.calculatedBy,
            type: node.type,
            fieldType: node.fieldType,
            fromSubmissionData: true,
            isDisplayField: true
          });
        }
        console.log(`\u26A0\uFE0F [DISPLAY FIELD] ${nodeId} (${node.label}) pas de valeur SubmissionData, recalcul n\xE9cessaire`);
      }
    }
    const preferSubmissionData = Boolean(submissionId) && !isDisplayField;
    let submissionDataEntry = null;
    let submissionResolvedValue = null;
    if (preferSubmissionData && submissionId) {
      submissionDataEntry = await prisma44.treeBranchLeafSubmissionData.findUnique({
        where: { submissionId_nodeId: { submissionId, nodeId } },
        select: {
          value: true,
          lastResolved: true,
          operationResult: true,
          operationDetail: true,
          operationSource: true,
          sourceRef: true,
          fieldLabel: true
        }
      });
      if (submissionDataEntry) {
        submissionResolvedValue = parseStoredStringValue(submissionDataEntry.value);
        if (!hasMeaningfulValue(submissionResolvedValue)) {
          submissionResolvedValue = extractValueFromOperationResult(submissionDataEntry.operationResult);
        }
      }
      const needsSubmissionRecompute = forceRecompute || !submissionDataEntry || !hasMeaningfulValue(submissionResolvedValue);
      if (needsSubmissionRecompute) {
        const variableMeta = await prisma44.treeBranchLeafNodeVariable.findUnique({
          where: { nodeId },
          select: { nodeId: true, displayName: true, exposedKey: true, unit: true }
        });
        if (variableMeta) {
          try {
            const { evaluateVariableOperation: evaluateVariableOperation2 } = await Promise.resolve().then(() => (init_operation_interpreter(), operation_interpreter_exports));
            const evaluation = await evaluateVariableOperation2(nodeId, submissionId, prisma44);
            const recomputedValue = evaluation.value ?? evaluation.operationResult ?? null;
            const persistedValue = recomputedValue === null || recomputedValue === void 0 ? null : String(recomputedValue);
            const resolvedAt = /* @__PURE__ */ new Date();
            const isDisplayField2 = node.fieldType === "DISPLAY" || node.type === "DISPLAY";
            if (!isDisplayField2) {
              await prisma44.treeBranchLeafSubmissionData.upsert({
                where: { submissionId_nodeId: { submissionId, nodeId } },
                update: {
                  value: persistedValue,
                  operationDetail: evaluation.operationDetail,
                  operationSource: evaluation.operationSource,
                  sourceRef: evaluation.sourceRef,
                  fieldLabel: node.label,
                  isVariable: true,
                  variableDisplayName: variableMeta.displayName,
                  variableKey: variableMeta.exposedKey,
                  variableUnit: variableMeta.unit,
                  lastResolved: resolvedAt
                },
                create: {
                  id: (0, import_crypto23.randomUUID)(),
                  submissionId,
                  nodeId,
                  value: persistedValue,
                  operationDetail: evaluation.operationDetail,
                  operationSource: evaluation.operationSource,
                  sourceRef: evaluation.sourceRef,
                  fieldLabel: node.label,
                  isVariable: true,
                  variableDisplayName: variableMeta.displayName,
                  variableKey: variableMeta.exposedKey,
                  variableUnit: variableMeta.unit,
                  lastResolved: resolvedAt
                }
              });
            }
            return res.json({
              success: true,
              nodeId: node.id,
              label: node.label,
              value: recomputedValue,
              calculatedAt: resolvedAt.toISOString(),
              calculatedBy: evaluation.operationSource || "operation-interpreter-auto",
              type: node.type,
              fieldType: node.fieldType,
              submissionId,
              sourceRef: evaluation.sourceRef,
              operationDetail: evaluation.operationDetail,
              freshCalculation: true
            });
          } catch (recomputeErr) {
            console.error("\u274C [CalculatedValueController] Recompute error:", recomputeErr);
          }
        }
      }
      if (submissionDataEntry && hasMeaningfulValue(submissionResolvedValue)) {
        return res.json({
          success: true,
          nodeId: node.id,
          label: node.label || submissionDataEntry.fieldLabel,
          value: submissionResolvedValue,
          calculatedAt: toIsoString(submissionDataEntry.lastResolved) || toIsoString(node.calculatedAt),
          calculatedBy: submissionDataEntry.operationSource || node.calculatedBy,
          type: node.type,
          fieldType: node.fieldType,
          submissionId,
          sourceRef: submissionDataEntry.sourceRef,
          operationDetail: submissionDataEntry.operationDetail,
          fromSubmission: true
        });
      }
    }
    const isTBLField = (node.type === "field" || node.type === "leaf_field") && node.metadata && typeof node.metadata === "object";
    const variableMeta2 = await prisma44.treeBranchLeafNodeVariable.findUnique({
      where: { nodeId },
      select: { sourceType: true, sourceRef: true }
    });
    const hasLookupEnabled = isTBLField && nodeMetadata?.lookup?.enabled === true && nodeMetadata?.lookup?.tableReference;
    const datasArray = nodeMetadata?.capabilities?.datas;
    const hasTableInDatas = Array.isArray(datasArray) && datasArray.some(
      (d) => d?.config?.sourceRef?.startsWith("@table.")
    );
    const hasTableInVariable = variableMeta2?.sourceRef?.startsWith("@table.");
    const hasTableLookup = hasLookupEnabled || hasTableInDatas || hasTableInVariable;
    const hasFormulaVariable = variableMeta2?.sourceRef?.startsWith("node-formula:");
    const hasConditionVariable = variableMeta2?.sourceRef?.startsWith("condition:");
    const hasTreeSourceVariable = variableMeta2?.sourceType === "tree" && (hasFormulaVariable || hasConditionVariable);
    const existingValue = node.calculatedValue;
    const hasValidExistingValue = existingValue && existingValue !== "" && existingValue !== "[]" && existingValue !== "null" && existingValue !== "undefined" && !requiresFreshCalculation;
    const isRealSubmissionForRecompute = submissionId && !submissionId.startsWith("preview-");
    if (requiresFreshCalculation && node.treeId) {
      try {
        const resolvedSubmissionId = isRealSubmissionForRecompute ? submissionId : (await prisma44.treeBranchLeafSubmission.findFirst({
          where: {
            treeId: node.treeId,
            status: { not: "archived" }
          },
          orderBy: { updatedAt: "desc" },
          select: { id: true }
        }))?.id;
        if (resolvedSubmissionId) {
          const metaAny = nodeMetadata || {};
          const looksLikeDuplicatedCopy = Boolean(
            metaAny?.duplicatedFromRepeater || metaAny?.autoCreatedDisplayNode || metaAny?.copiedFromNodeId
          );
          if (!node.table_activeId && looksLikeDuplicatedCopy && Array.isArray(node.linkedTableIds) && node.linkedTableIds.length > 0) {
            const candidateTableId = node.linkedTableIds[node.linkedTableIds.length - 1];
            if (candidateTableId) {
              const candidateExists = await prisma44.treeBranchLeafNodeTable.findUnique({
                where: { id: candidateTableId },
                select: { id: true }
              });
              if (candidateExists) {
                await prisma44.treeBranchLeafNode.update({
                  where: { id: nodeId },
                  data: { table_activeId: candidateTableId }
                });
              }
            }
          }
          const { evaluateVariableOperation: evaluateVariableOperation2 } = await Promise.resolve().then(() => (init_operation_interpreter(), operation_interpreter_exports));
          const evaluation = await evaluateVariableOperation2(nodeId, resolvedSubmissionId, prisma44);
          const recomputedValue = evaluation.value ?? evaluation.operationResult ?? null;
          const resolvedAt = /* @__PURE__ */ new Date();
          await prisma44.treeBranchLeafNode.update({
            where: { id: nodeId },
            data: {
              calculatedValue: recomputedValue === null || recomputedValue === void 0 ? null : String(recomputedValue),
              calculatedAt: resolvedAt,
              calculatedBy: evaluation.operationSource || "operation-interpreter-auto"
            }
          });
          return res.json({
            success: true,
            nodeId: node.id,
            label: node.label,
            value: recomputedValue,
            calculatedAt: resolvedAt.toISOString(),
            calculatedBy: evaluation.operationSource || "operation-interpreter-auto",
            type: node.type,
            fieldType: node.fieldType,
            submissionId: resolvedSubmissionId,
            sourceRef: evaluation.sourceRef,
            operationDetail: evaluation.operationDetail,
            freshCalculation: true
          });
        }
      } catch (recomputeErr) {
        console.error("\u274C [CalculatedValueController] Recompute (requiresFreshCalculation) error:", recomputeErr);
      }
    }
    if (hasValidExistingValue && !isDisplayField) {
      return res.json({
        success: true,
        nodeId: node.id,
        label: node.label,
        value: parseStoredStringValue(existingValue),
        calculatedAt: toIsoString(node.calculatedAt),
        calculatedBy: node.calculatedBy,
        type: node.type,
        fieldType: node.fieldType,
        fromStoredValue: true
      });
    }
    const isRealSubmission = submissionId && !submissionId.startsWith("preview-");
    const canRecalculateHere = hasTableLookup && !hasConditionVariable && !hasTreeSourceVariable;
    const canRecalculateDisplayField = isDisplayField && isRealSubmission && (hasTableLookup || hasFormulaVariable || hasConditionVariable || hasTreeSourceVariable);
    if ((canRecalculateHere || canRecalculateDisplayField) && node.treeId && isRealSubmission) {
      console.log(`\u{1F525} [CalculatedValueController] Node "${node.label}" - recalcul ${isDisplayField ? "DISPLAY field" : "table lookup"}:`, {
        nodeId,
        hasTableLookup,
        hasFormulaVariable,
        hasConditionVariable,
        isDisplayField,
        submissionId
      });
      try {
        const { evaluateVariableOperation: evaluateVariableOperation2 } = await Promise.resolve().then(() => (init_operation_interpreter(), operation_interpreter_exports));
        const result = await evaluateVariableOperation2(
          nodeId,
          submissionId,
          prisma44
        );
        console.log("\u{1F3AF} [CalculatedValueController] R\xE9sultat operation-interpreter:", result);
        if (result && (result.value !== void 0 || result.operationResult !== void 0)) {
          const stringValue = String(result.value ?? result.operationResult);
          if (isDisplayField) {
            await prisma44.treeBranchLeafSubmissionData.upsert({
              where: { submissionId_nodeId: { submissionId, nodeId } },
              update: {
                value: stringValue,
                lastResolved: /* @__PURE__ */ new Date(),
                operationSource: result.operationSource || "operation-interpreter-display",
                sourceRef: result.sourceRef,
                operationDetail: result.operationDetail,
                fieldLabel: node.label
              },
              create: {
                id: (0, import_crypto23.randomUUID)(),
                submissionId,
                nodeId,
                value: stringValue,
                lastResolved: /* @__PURE__ */ new Date(),
                operationSource: result.operationSource || "operation-interpreter-display",
                sourceRef: result.sourceRef,
                operationDetail: result.operationDetail,
                fieldLabel: node.label
              }
            });
          } else {
            if (stringValue && stringValue !== "0" && stringValue !== "") {
              await prisma44.treeBranchLeafNode.update({
                where: { id: nodeId },
                data: {
                  calculatedValue: stringValue,
                  calculatedAt: /* @__PURE__ */ new Date(),
                  calculatedBy: "operation-interpreter-auto"
                }
              });
            }
          }
          return res.json({
            success: true,
            nodeId: node.id,
            label: node.label,
            value: stringValue,
            calculatedAt: (/* @__PURE__ */ new Date()).toISOString(),
            calculatedBy: result.operationSource || "operation-interpreter-auto",
            type: node.type,
            fieldType: node.fieldType,
            freshCalculation: true,
            isDisplayField,
            submissionScoped: isDisplayField
          });
        }
      } catch (operationErr) {
        console.error("\u274C [CalculatedValueController] Erreur operation-interpreter:", operationErr);
      }
    }
    if (isDisplayField) {
      console.log(`\u26A0\uFE0F [CalculatedValueController] DISPLAY field "${node.label}" - pas de valeur scop\xE9e, retourne null`);
      return res.json({
        success: true,
        nodeId: node.id,
        label: node.label,
        value: null,
        // Pas de valeur GLOBALE pour les DISPLAY fields
        calculatedAt: node.calculatedAt,
        calculatedBy: node.calculatedBy,
        type: node.type,
        fieldType: node.fieldType,
        noScopedValue: true
      });
    }
    return res.json({
      success: true,
      nodeId: node.id,
      label: node.label,
      value: node.calculatedValue,
      calculatedAt: node.calculatedAt,
      calculatedBy: node.calculatedBy,
      type: node.type,
      fieldType: node.fieldType
    });
  } catch (error) {
    console.error("[CalculatedValueController] GET erreur:", error);
    return res.status(500).json({ error: String(error) });
  }
});
router75.post("/:nodeId/store-calculated-value", async (req2, res) => {
  try {
    const { nodeId } = req2.params;
    const { calculatedValue, calculatedBy, submissionId } = req2.body;
    if (!nodeId) {
      return res.status(400).json({ error: "nodeId requis" });
    }
    if (calculatedValue === void 0) {
      return res.status(400).json({ error: "calculatedValue requis" });
    }
    console.log("[CalculatedValueController] POST store-calculated-value", {
      nodeId,
      calculatedValue,
      calculatedBy,
      submissionId,
      headers: {
        organization: req2.headers["x-organization-id"],
        referer: req2.headers["referer"]
      }
    });
    const updated = await prisma44.treeBranchLeafNode.update({
      where: { id: nodeId },
      data: {
        calculatedValue: String(calculatedValue),
        calculatedAt: /* @__PURE__ */ new Date(),
        calculatedBy: calculatedBy || "unknown"
      },
      select: {
        id: true,
        label: true,
        calculatedValue: true,
        calculatedAt: true,
        calculatedBy: true
      }
    });
    console.log("\u2705 [CalculatedValueController] Valeur stock\xE9e:", {
      nodeId,
      calculatedValue,
      calculatedBy,
      submissionId
    });
    return res.json({
      success: true,
      nodeId: updated.id,
      calculatedValue: updated.calculatedValue,
      calculatedAt: updated.calculatedAt,
      calculatedBy: updated.calculatedBy
    });
  } catch (error) {
    console.error("[CalculatedValueController] POST erreur:", error);
    return res.status(500).json({ error: String(error) });
  }
});
router75.post("/store-batch-calculated-values", async (req2, res) => {
  try {
    const { values, submissionId } = req2.body;
    if (!Array.isArray(values) || values.length === 0) {
      return res.status(400).json({ error: "values doit \xEAtre un tableau non-vide" });
    }
    const results = [];
    for (const { nodeId, calculatedValue, calculatedBy } of values) {
      if (!nodeId) continue;
      try {
        const updated = await prisma44.treeBranchLeafNode.update({
          where: { id: nodeId },
          data: {
            calculatedValue: String(calculatedValue),
            calculatedAt: /* @__PURE__ */ new Date(),
            calculatedBy: calculatedBy || "unknown"
          }
        });
        results.push({
          nodeId,
          success: true,
          calculatedValue: updated.calculatedValue
        });
      } catch (err) {
        results.push({
          nodeId,
          success: false,
          error: String(err)
        });
      }
    }
    console.log("\u2705 [CalculatedValueController] BATCH stockage:", {
      submissionId,
      total: values.length,
      success: results.filter((r) => r.success).length,
      failed: results.filter((r) => !r.success).length
    });
    return res.json({
      success: true,
      results,
      submissionId
    });
  } catch (error) {
    console.error("[CalculatedValueController] BATCH POST erreur:", error);
    return res.status(500).json({ error: String(error) });
  }
});
var calculatedValueController_default = router75;

// src/routes/tbl-batch-routes.ts
var import_express78 = require("express");
init_database();
var router76 = (0, import_express78.Router)();
function getAuthCtx5(req2) {
  const user = req2.user;
  return {
    organizationId: user?.organizationId || null,
    isSuperAdmin: user?.isSuperAdmin || false
  };
}
router76.get("/trees/:treeId/formulas", async (req2, res) => {
  try {
    const { treeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx5(req2);
    const treeWhereFilter = isSuperAdmin2 || !organizationId ? { id: treeId } : { id: treeId, organizationId };
    const tree = await db.treeBranchLeafTree.findFirst({ where: treeWhereFilter });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xE9" });
    }
    const nodes = await db.treeBranchLeafNode.findMany({
      where: { treeId },
      select: { id: true }
    });
    const nodeIds = nodes.map((n) => n.id);
    const allFormulas = await db.treeBranchLeafNodeFormula.findMany({
      where: { nodeId: { in: nodeIds } },
      orderBy: { createdAt: "asc" }
    });
    const formulasByNode = {};
    for (const formula of allFormulas) {
      if (!formulasByNode[formula.nodeId]) {
        formulasByNode[formula.nodeId] = [];
      }
      formulasByNode[formula.nodeId].push(formula);
    }
    return res.json({
      success: true,
      treeId,
      totalFormulas: allFormulas.length,
      nodesWithFormulas: Object.keys(formulasByNode).length,
      formulasByNode
    });
  } catch (error) {
    console.error("[TBL Batch API] Error batch fetching formulas:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration batch des formules" });
  }
});
router76.get("/trees/:treeId/calculated-values", async (req2, res) => {
  try {
    const { treeId } = req2.params;
    const { leadId } = req2.query;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx5(req2);
    const treeWhereFilter = isSuperAdmin2 || !organizationId ? { id: treeId } : { id: treeId, organizationId };
    const tree = await db.treeBranchLeafTree.findFirst({ where: treeWhereFilter });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xE9" });
    }
    const nodes = await db.treeBranchLeafNode.findMany({
      where: { treeId },
      select: {
        id: true,
        fieldType: true,
        calculatedValue: true,
        calculatedAt: true,
        calculatedBy: true
      }
    });
    let submissionValues = {};
    if (leadId && typeof leadId === "string") {
      const submission = await db.treeBranchLeafSubmission.findFirst({
        where: {
          treeId,
          leadId
        },
        orderBy: { updatedAt: "desc" },
        select: { id: true }
      });
      if (submission?.id) {
        const submissionData = await db.treeBranchLeafSubmissionData.findMany({
          where: { submissionId: submission.id },
          select: { nodeId: true, value: true }
        });
        for (const data of submissionData) {
          if (data.value !== null) {
            submissionValues[data.nodeId] = data.value;
          }
        }
      }
    }
    const valuesByNode = {};
    for (const node of nodes) {
      if (node.calculatedValue !== null || submissionValues[node.id] !== void 0) {
        valuesByNode[node.id] = {
          calculatedValue: node.calculatedValue,
          calculatedAt: node.calculatedAt,
          calculatedBy: node.calculatedBy,
          submissionValue: submissionValues[node.id]
        };
      }
    }
    return res.json({
      success: true,
      treeId,
      leadId: leadId || null,
      totalValues: Object.keys(valuesByNode).length,
      valuesByNode
    });
  } catch (error) {
    console.error("[TBL Batch API] Error batch fetching calculated values:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration batch des valeurs calcul\xE9es" });
  }
});
router76.get("/trees/:treeId/select-configs", async (req2, res) => {
  try {
    const { treeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx5(req2);
    const treeWhereFilter = isSuperAdmin2 || !organizationId ? { id: treeId } : { id: treeId, organizationId };
    const tree = await db.treeBranchLeafTree.findFirst({ where: treeWhereFilter });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xE9" });
    }
    const selectNodes = await db.treeBranchLeafNode.findMany({
      where: {
        treeId,
        OR: [
          { fieldType: "select" },
          { fieldType: "radio" },
          { fieldType: "checkbox" },
          { fieldType: "multi-select" },
          { fieldType: { contains: "select" } },
          // üî• CRITICAL: Inclure aussi les n≈ìuds avec SelectConfig m√™me si fieldType: null
          { TreeBranchLeafSelectConfig: { isNot: null } }
        ]
      },
      select: {
        id: true,
        fieldType: true,
        select_options: true,
        // Utiliser la relation pour les configs avanc√©es
        TreeBranchLeafSelectConfig: {
          select: {
            optionsSource: true,
            tableReference: true,
            keyColumn: true,
            displayColumn: true
          }
        }
      }
    });
    const configsByNode = {};
    for (const node of selectNodes) {
      const selectConfig = node.TreeBranchLeafSelectConfig;
      configsByNode[node.id] = {
        fieldType: node.fieldType,
        options: node.select_options,
        sourceType: selectConfig?.optionsSource || null,
        sourceTableId: selectConfig?.tableReference || null,
        sourceColumn: selectConfig?.keyColumn || null,
        displayColumn: selectConfig?.displayColumn || null
      };
    }
    return res.json({
      success: true,
      treeId,
      totalSelectFields: Object.keys(configsByNode).length,
      configsByNode
    });
  } catch (error) {
    console.error("[TBL Batch API] Error batch fetching select configs:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration batch des configs select" });
  }
});
router76.get("/trees/:treeId/all", async (req2, res) => {
  const { treeId } = req2.params;
  console.log(`[TBL Batch API] /all called for treeId: ${treeId}`);
  try {
    const { leadId } = req2.query;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx5(req2);
    console.log(`[TBL Batch API] Auth context: org=${organizationId}, superAdmin=${isSuperAdmin2}`);
    const treeWhereFilter = isSuperAdmin2 || !organizationId ? { id: treeId } : { id: treeId, organizationId };
    const tree = await db.treeBranchLeafTree.findFirst({ where: treeWhereFilter });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xE9" });
    }
    const nodes = await db.treeBranchLeafNode.findMany({
      where: { treeId },
      select: {
        id: true,
        fieldType: true,
        calculatedValue: true,
        calculatedAt: true,
        calculatedBy: true,
        select_options: true,
        // Inclure la config select si elle existe (relation 1-1)
        TreeBranchLeafSelectConfig: {
          select: {
            optionsSource: true,
            tableReference: true,
            displayColumn: true,
            keyColumn: true,
            valueColumn: true
          }
        }
      }
    });
    const nodeIds = nodes.map((n) => n.id);
    const [allFormulas, submission] = await Promise.all([
      // Toutes les formules (en utilisant nodeId: { in: nodeIds })
      db.treeBranchLeafNodeFormula.findMany({
        where: {
          nodeId: { in: nodeIds }
        },
        orderBy: { createdAt: "asc" }
      }),
      // Submission si leadId
      leadId && typeof leadId === "string" ? db.treeBranchLeafSubmission.findFirst({
        where: { treeId, leadId },
        orderBy: { updatedAt: "desc" },
        select: { id: true }
      }) : Promise.resolve(null)
    ]);
    let submissionValues = {};
    if (submission?.id) {
      const submissionData = await db.treeBranchLeafSubmissionData.findMany({
        where: { submissionId: submission.id },
        select: { nodeId: true, value: true }
      });
      for (const data of submissionData) {
        if (data.value !== null) {
          submissionValues[data.nodeId] = data.value;
        }
      }
    }
    const formulasByNode = {};
    for (const formula of allFormulas) {
      if (!formulasByNode[formula.nodeId]) {
        formulasByNode[formula.nodeId] = [];
      }
      formulasByNode[formula.nodeId].push(formula);
    }
    const valuesByNode = {};
    const configsByNode = {};
    for (const node of nodes) {
      if (node.calculatedValue !== null || submissionValues[node.id] !== void 0) {
        valuesByNode[node.id] = {
          calculatedValue: node.calculatedValue,
          calculatedAt: node.calculatedAt,
          calculatedBy: node.calculatedBy,
          submissionValue: submissionValues[node.id]
        };
      }
      const isSelectType = ["select", "radio", "checkbox", "multi-select"].includes(node.fieldType || "") || (node.fieldType || "").includes("select");
      if (isSelectType) {
        const selectConfig = node.TreeBranchLeafSelectConfig;
        if (node.id.match(/-\d{1,3}$/)) {
          console.log(`[TBL Batch] \u{1F50D} Champ suffix\xE9 d\xE9tect\xE9: ${node.id}`);
          console.log(`[TBL Batch]    - TreeBranchLeafSelectConfig pr\xE9sente: ${!!selectConfig}`);
          if (selectConfig) {
            console.log(`[TBL Batch]    - displayColumn: ${selectConfig.displayColumn}`);
          }
        }
        configsByNode[node.id] = {
          fieldType: node.fieldType,
          options: node.select_options,
          sourceType: selectConfig?.optionsSource || null,
          sourceTableId: selectConfig?.tableReference || null,
          sourceColumn: selectConfig?.keyColumn || null,
          displayColumn: selectConfig?.displayColumn || null
        };
      }
    }
    return res.json({
      success: true,
      treeId,
      leadId: leadId || null,
      stats: {
        totalNodes: nodes.length,
        totalFormulas: allFormulas.length,
        nodesWithFormulas: Object.keys(formulasByNode).length,
        nodesWithValues: Object.keys(valuesByNode).length,
        selectFields: Object.keys(configsByNode).length
      },
      formulasByNode,
      valuesByNode,
      configsByNode
    });
  } catch (error) {
    const errorDetails = {
      message: error instanceof Error ? error.message : String(error),
      name: error instanceof Error ? error.name : "Unknown",
      stack: error instanceof Error ? error.stack : void 0
    };
    console.error("[TBL Batch API] Error super batch fetching:", JSON.stringify(errorDetails, null, 2));
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration batch compl\xE8te",
      details: errorDetails.message
    });
  }
});
router76.get("/trees/:treeId/node-data", async (req2, res) => {
  try {
    const { treeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx5(req2);
    const treeWhereFilter = isSuperAdmin2 || !organizationId ? { id: treeId } : { id: treeId, organizationId };
    const tree = await db.treeBranchLeafTree.findFirst({ where: treeWhereFilter });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xE9" });
    }
    const nodesWithData = await db.treeBranchLeafNode.findMany({
      where: {
        treeId,
        hasData: true
      },
      select: {
        id: true,
        data_activeId: true,
        linkedVariableIds: true
      }
    });
    const allVariableIds = /* @__PURE__ */ new Set();
    for (const node of nodesWithData) {
      if (node.data_activeId) allVariableIds.add(node.data_activeId);
      if (node.linkedVariableIds && Array.isArray(node.linkedVariableIds)) {
        for (const vid of node.linkedVariableIds) {
          if (typeof vid === "string") allVariableIds.add(vid);
        }
      }
    }
    const allVariables = await db.treeBranchLeafNodeVariable.findMany({
      where: {
        id: { in: Array.from(allVariableIds) }
      }
    });
    const variablesMap = new Map(allVariables.map((v) => [v.id, v]));
    const dataByNode = {};
    for (const node of nodesWithData) {
      let variable = null;
      let ownerNodeId = null;
      if (node.data_activeId) {
        variable = variablesMap.get(node.data_activeId) || null;
        ownerNodeId = variable?.nodeId || null;
      } else if (node.linkedVariableIds && Array.isArray(node.linkedVariableIds)) {
        for (const vid of node.linkedVariableIds) {
          if (typeof vid === "string" && variablesMap.has(vid)) {
            variable = variablesMap.get(vid) || null;
            ownerNodeId = variable?.nodeId || null;
            break;
          }
        }
      }
      dataByNode[node.id] = {
        usedVariableId: node.data_activeId || variable?.id || null,
        variable,
        ownerNodeId
      };
    }
    return res.json({
      success: true,
      treeId,
      totalNodesWithData: Object.keys(dataByNode).length,
      dataByNode
    });
  } catch (error) {
    console.error("[TBL Batch API] Error batch fetching node data:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration batch des donn\xE9es de noeuds" });
  }
});
router76.get("/trees/:treeId/conditions", async (req2, res) => {
  try {
    const { treeId } = req2.params;
    const { organizationId, isSuperAdmin: isSuperAdmin2 } = getAuthCtx5(req2);
    const treeWhereFilter = isSuperAdmin2 || !organizationId ? { id: treeId } : { id: treeId, organizationId };
    const tree = await db.treeBranchLeafTree.findFirst({ where: treeWhereFilter });
    if (!tree) {
      return res.status(404).json({ error: "Arbre non trouv\xE9" });
    }
    const nodes = await db.treeBranchLeafNode.findMany({
      where: { treeId },
      select: { id: true, condition_activeId: true, linkedConditionIds: true }
    });
    const nodeIds = nodes.map((n) => n.id);
    const allConditions = await db.treeBranchLeafNodeCondition.findMany({
      where: { nodeId: { in: nodeIds } },
      orderBy: { createdAt: "asc" }
    });
    const conditionsByNode = {};
    for (const condition of allConditions) {
      if (!conditionsByNode[condition.nodeId]) {
        conditionsByNode[condition.nodeId] = [];
      }
      conditionsByNode[condition.nodeId].push(condition);
    }
    const conditionsById = {};
    for (const condition of allConditions) {
      conditionsById[condition.id] = condition;
    }
    const activeConditionByNode = {};
    for (const node of nodes) {
      activeConditionByNode[node.id] = node.condition_activeId;
    }
    return res.json({
      success: true,
      treeId,
      totalConditions: allConditions.length,
      nodesWithConditions: Object.keys(conditionsByNode).length,
      conditionsByNode,
      conditionsById,
      activeConditionByNode
    });
  } catch (error) {
    console.error("[TBL Batch API] Error batch fetching conditions:", error);
    res.status(500).json({ error: "Erreur lors de la r\xE9cup\xE9ration batch des conditions" });
  }
});
var tbl_batch_routes_default = router76;

// src/routes/batch-routes.ts
var import_express79 = require("express");
init_database();
var import_googleapis10 = require("googleapis");
var router77 = (0, import_express79.Router)();
function getAuthCtx6(req2) {
  const user = req2.user;
  return {
    userId: user?.id,
    organizationId: user?.organizationId || null,
    isSuperAdmin: user?.isSuperAdmin || false
  };
}
router77.post("/gmail/modify", async (req2, res) => {
  try {
    const { userId, organizationId } = getAuthCtx6(req2);
    const { messageIds, addLabelIds = [], removeLabelIds = [] } = req2.body;
    if (!messageIds || !Array.isArray(messageIds) || messageIds.length === 0) {
      return res.status(400).json({ error: "messageIds requis (array non vide)" });
    }
    const googleToken = await db.googleToken.findFirst({
      where: { userId }
    });
    if (!googleToken) {
      return res.status(401).json({ error: "Tokens Google non trouv\xE9s" });
    }
    const oauth2Client = new import_googleapis10.google.auth.OAuth2();
    oauth2Client.setCredentials({
      access_token: googleToken.accessToken,
      refresh_token: googleToken.refreshToken
    });
    const gmail = import_googleapis10.google.gmail({ version: "v1", auth: oauth2Client });
    await gmail.users.messages.batchModify({
      userId: "me",
      requestBody: {
        ids: messageIds,
        addLabelIds,
        removeLabelIds
      }
    });
    console.log(`[BATCH] \u2705 Gmail: ${messageIds.length} messages modifi\xE9s`);
    res.json({
      success: true,
      count: messageIds.length,
      message: `${messageIds.length} message(s) modifi\xE9(s)`
    });
  } catch (error) {
    console.error("[BATCH] \u274C Gmail modify error:", error);
    res.status(500).json({ error: error.message || "Erreur batch Gmail" });
  }
});
router77.post("/gmail/trash", async (req2, res) => {
  try {
    const { userId } = getAuthCtx6(req2);
    const { messageIds } = req2.body;
    if (!messageIds || !Array.isArray(messageIds) || messageIds.length === 0) {
      return res.status(400).json({ error: "messageIds requis (array non vide)" });
    }
    const googleToken = await db.googleToken.findFirst({
      where: { userId }
    });
    if (!googleToken) {
      return res.status(401).json({ error: "Tokens Google non trouv\xE9s" });
    }
    const oauth2Client = new import_googleapis10.google.auth.OAuth2();
    oauth2Client.setCredentials({
      access_token: googleToken.accessToken,
      refresh_token: googleToken.refreshToken
    });
    const gmail = import_googleapis10.google.gmail({ version: "v1", auth: oauth2Client });
    await gmail.users.messages.batchModify({
      userId: "me",
      requestBody: {
        ids: messageIds,
        addLabelIds: ["TRASH"],
        removeLabelIds: ["INBOX"]
      }
    });
    console.log(`[BATCH] \u2705 Gmail: ${messageIds.length} messages mis \xE0 la corbeille`);
    res.json({
      success: true,
      count: messageIds.length,
      message: `${messageIds.length} message(s) mis \xE0 la corbeille`
    });
  } catch (error) {
    console.error("[BATCH] \u274C Gmail trash error:", error);
    res.status(500).json({ error: error.message || "Erreur batch Gmail" });
  }
});
router77.delete("/gmail/delete", async (req2, res) => {
  try {
    const { userId } = getAuthCtx6(req2);
    const { messageIds } = req2.body;
    if (!messageIds || !Array.isArray(messageIds) || messageIds.length === 0) {
      return res.status(400).json({ error: "messageIds requis (array non vide)" });
    }
    const googleToken = await db.googleToken.findFirst({
      where: { userId }
    });
    if (!googleToken) {
      return res.status(401).json({ error: "Tokens Google non trouv\xE9s" });
    }
    const oauth2Client = new import_googleapis10.google.auth.OAuth2();
    oauth2Client.setCredentials({
      access_token: googleToken.accessToken,
      refresh_token: googleToken.refreshToken
    });
    const gmail = import_googleapis10.google.gmail({ version: "v1", auth: oauth2Client });
    await gmail.users.messages.batchDelete({
      userId: "me",
      requestBody: {
        ids: messageIds
      }
    });
    console.log(`[BATCH] \u2705 Gmail: ${messageIds.length} messages supprim\xE9s d\xE9finitivement`);
    res.json({
      success: true,
      count: messageIds.length,
      message: `${messageIds.length} message(s) supprim\xE9(s) d\xE9finitivement`
    });
  } catch (error) {
    console.error("[BATCH] \u274C Gmail delete error:", error);
    res.status(500).json({ error: error.message || "Erreur batch Gmail" });
  }
});
router77.patch("/leads/status", async (req2, res) => {
  try {
    const { organizationId } = getAuthCtx6(req2);
    const { leadIds, statusId } = req2.body;
    if (!leadIds || !Array.isArray(leadIds) || leadIds.length === 0) {
      return res.status(400).json({ error: "leadIds requis (array non vide)" });
    }
    if (!statusId) {
      return res.status(400).json({ error: "statusId requis" });
    }
    const status = await db.leadStatus.findUnique({
      where: { id: statusId }
    });
    if (!status) {
      return res.status(404).json({ error: "Statut non trouv\xE9" });
    }
    const result = await db.lead.updateMany({
      where: {
        id: { in: leadIds },
        organizationId: organizationId || void 0
      },
      data: {
        leadStatusId: statusId,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log(`[BATCH] \u2705 Leads: ${result.count} leads mis \xE0 jour vers statut "${status.name}"`);
    res.json({
      success: true,
      count: result.count,
      message: `${result.count} lead(s) mis \xE0 jour`
    });
  } catch (error) {
    console.error("[BATCH] \u274C Leads status error:", error);
    res.status(500).json({ error: error.message || "Erreur batch leads" });
  }
});
router77.patch("/leads/assign", async (req2, res) => {
  try {
    const { organizationId } = getAuthCtx6(req2);
    const { leadIds, assignedToId } = req2.body;
    if (!leadIds || !Array.isArray(leadIds) || leadIds.length === 0) {
      return res.status(400).json({ error: "leadIds requis (array non vide)" });
    }
    const result = await db.lead.updateMany({
      where: {
        id: { in: leadIds },
        organizationId: organizationId || void 0
      },
      data: {
        assignedToId: assignedToId || null,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log(`[BATCH] \u2705 Leads: ${result.count} leads assign\xE9s`);
    res.json({
      success: true,
      count: result.count,
      message: `${result.count} lead(s) assign\xE9(s)`
    });
  } catch (error) {
    console.error("[BATCH] \u274C Leads assign error:", error);
    res.status(500).json({ error: error.message || "Erreur batch leads" });
  }
});
router77.delete("/leads", async (req2, res) => {
  try {
    const { organizationId } = getAuthCtx6(req2);
    const { leadIds } = req2.body;
    if (!leadIds || !Array.isArray(leadIds) || leadIds.length === 0) {
      return res.status(400).json({ error: "leadIds requis (array non vide)" });
    }
    const result = await db.lead.deleteMany({
      where: {
        id: { in: leadIds },
        organizationId: organizationId || void 0
      }
    });
    console.log(`[BATCH] \u2705 Leads: ${result.count} leads supprim\xE9s`);
    res.json({
      success: true,
      count: result.count,
      message: `${result.count} lead(s) supprim\xE9(s)`
    });
  } catch (error) {
    console.error("[BATCH] \u274C Leads delete error:", error);
    res.status(500).json({ error: error.message || "Erreur batch leads" });
  }
});
router77.post("/fields/configs", async (req2, res) => {
  try {
    const { fieldIds } = req2.body;
    if (!fieldIds || !Array.isArray(fieldIds) || fieldIds.length === 0) {
      return res.status(400).json({ error: "fieldIds requis (array non vide)" });
    }
    const configs = await db.fieldConfig.findMany({
      where: {
        fieldId: { in: fieldIds }
      },
      include: {
        field: true
      }
    });
    const configsByFieldId = {};
    for (const config of configs) {
      configsByFieldId[config.fieldId] = config;
    }
    console.log(`[BATCH] \u2705 Fields: ${configs.length} configs charg\xE9es pour ${fieldIds.length} fields`);
    res.json({
      success: true,
      count: configs.length,
      configs: configsByFieldId
    });
  } catch (error) {
    console.error("[BATCH] \u274C Fields configs error:", error);
    res.status(500).json({ error: error.message || "Erreur batch fields" });
  }
});
router77.patch("/modules/toggle", async (req2, res) => {
  try {
    const { organizationId } = getAuthCtx6(req2);
    const { moduleIds, enabled } = req2.body;
    if (!moduleIds || !Array.isArray(moduleIds) || moduleIds.length === 0) {
      return res.status(400).json({ error: "moduleIds requis (array non vide)" });
    }
    if (typeof enabled !== "boolean") {
      return res.status(400).json({ error: "enabled requis (boolean)" });
    }
    const result = await db.organizationModule.updateMany({
      where: {
        moduleId: { in: moduleIds },
        organizationId: organizationId || void 0
      },
      data: {
        enabled,
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log(`[BATCH] \u2705 Modules: ${result.count} modules ${enabled ? "activ\xE9s" : "d\xE9sactiv\xE9s"}`);
    res.json({
      success: true,
      count: result.count,
      message: `${result.count} module(s) ${enabled ? "activ\xE9(s)" : "d\xE9sactiv\xE9(s)"}`
    });
  } catch (error) {
    console.error("[BATCH] \u274C Modules toggle error:", error);
    res.status(500).json({ error: error.message || "Erreur batch modules" });
  }
});
router77.get("/analytics/leads-by-status", async (req2, res) => {
  try {
    const { organizationId } = getAuthCtx6(req2);
    const counts = await db.lead.groupBy({
      by: ["leadStatusId"],
      where: {
        organizationId: organizationId || void 0
      },
      _count: {
        id: true
      }
    });
    const statusIds = counts.map((c) => c.leadStatusId).filter(Boolean);
    const statuses = await db.leadStatus.findMany({
      where: { id: { in: statusIds } },
      select: { id: true, name: true, color: true }
    });
    const statusMap = new Map(statuses.map((s) => [s.id, s]));
    const result = counts.map((c) => ({
      statusId: c.leadStatusId,
      statusName: c.leadStatusId ? statusMap.get(c.leadStatusId)?.name : "Sans statut",
      statusColor: c.leadStatusId ? statusMap.get(c.leadStatusId)?.color : "#999",
      count: c._count.id
    }));
    console.log(`[BATCH] \u2705 Analytics: Leads par statut (${counts.length} groupes)`);
    res.json({ success: true, data: result });
  } catch (error) {
    console.error("[BATCH] \u274C Analytics leads-by-status error:", error);
    res.status(500).json({ error: error.message || "Erreur analytics" });
  }
});
router77.get("/analytics/leads-by-source", async (req2, res) => {
  try {
    const { organizationId } = getAuthCtx6(req2);
    const counts = await db.lead.groupBy({
      by: ["source"],
      where: {
        organizationId: organizationId || void 0
      },
      _count: {
        id: true
      }
    });
    const result = counts.map((c) => ({
      source: c.source || "Non d\xE9finie",
      count: c._count.id
    }));
    console.log(`[BATCH] \u2705 Analytics: Leads par source (${counts.length} sources)`);
    res.json({ success: true, data: result });
  } catch (error) {
    console.error("[BATCH] \u274C Analytics leads-by-source error:", error);
    res.status(500).json({ error: error.message || "Erreur analytics" });
  }
});
router77.get("/analytics/leads-by-assignee", async (req2, res) => {
  try {
    const { organizationId } = getAuthCtx6(req2);
    const counts = await db.lead.groupBy({
      by: ["assignedToId"],
      where: {
        organizationId: organizationId || void 0
      },
      _count: {
        id: true
      }
    });
    const userIds = counts.map((c) => c.assignedToId).filter(Boolean);
    const users = await db.user.findMany({
      where: { id: { in: userIds } },
      select: { id: true, firstName: true, lastName: true }
    });
    const userMap = new Map(users.map((u) => [u.id, u]));
    const result = counts.map((c) => ({
      assignedToId: c.assignedToId,
      assigneeName: c.assignedToId ? `${userMap.get(c.assignedToId)?.firstName || ""} ${userMap.get(c.assignedToId)?.lastName || ""}`.trim() : "Non assign\xE9",
      count: c._count.id
    }));
    console.log(`[BATCH] \u2705 Analytics: Leads par assign\xE9 (${counts.length} groupes)`);
    res.json({ success: true, data: result });
  } catch (error) {
    console.error("[BATCH] \u274C Analytics leads-by-assignee error:", error);
    res.status(500).json({ error: error.message || "Erreur analytics" });
  }
});
var batch_routes_default = router77;

// src/api/websites.ts
var import_express80 = require("express");
init_database();
var router78 = (0, import_express80.Router)();
router78.get("/websites", authenticateToken, async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"];
    const showAll = req2.query.all === "true";
    if (!organizationId && !showAll) {
      return res.status(400).json({ error: "Organization ID is required" });
    }
    const whereClause = {
      isActive: true
    };
    if (!showAll && organizationId) {
      whereClause.organizationId = organizationId;
    }
    const websites = await db.websites.findMany({
      where: whereClause,
      include: {
        website_configs: true
      },
      orderBy: {
        createdAt: "desc"
      }
    });
    res.json(websites);
  } catch (error) {
    console.error("Error fetching websites:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router78.get("/websites/id/:id", authenticateToken, async (req2, res) => {
  try {
    const { id } = req2.params;
    const websiteId = parseInt(id, 10);
    if (isNaN(websiteId)) {
      return res.status(400).json({ error: "Invalid website ID" });
    }
    const website = await db.websites.findUnique({
      where: { id: websiteId },
      include: {
        website_configs: true,
        website_themes: true
      }
    });
    if (!website) {
      return res.status(404).json({ error: "Website not found" });
    }
    res.json(website);
  } catch (error) {
    console.error("Error fetching website by ID:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router78.put("/websites/:id", authenticateToken, async (req2, res) => {
  try {
    const websiteId = parseInt(req2.params.id);
    const organizationId = req2.headers["x-organization-id"];
    const isSuperAdmin2 = req2.headers["x-is-super-admin"] === "true";
    const data = req2.body;
    console.log("\u{1F50D} [WEBSITES PUT] ===== D\xC9BUT =====");
    console.log("\u{1F50D} [WEBSITES PUT] websiteId:", websiteId);
    console.log("\u{1F50D} [WEBSITES PUT] organizationId from header:", organizationId);
    console.log("\u{1F50D} [WEBSITES PUT] isSuperAdmin:", isSuperAdmin2);
    console.log("\u{1F50D} [WEBSITES PUT] All headers:", JSON.stringify(req2.headers, null, 2));
    console.log("\u{1F50D} [WEBSITES PUT] Body:", JSON.stringify(data, null, 2));
    if (!organizationId && !isSuperAdmin2) {
      console.log("\u{1F50D} [WEBSITES PUT] \u274C Pas d'organizationId dans les headers");
      return res.status(400).json({ error: "Organization ID is required" });
    }
    const whereClause = { id: websiteId };
    if (!isSuperAdmin2) {
      whereClause.organizationId = organizationId;
    }
    console.log("\u{1F50D} [WEBSITES PUT] Recherche du site avec:", whereClause);
    const existingWebsite = await db.websites.findFirst({
      where: whereClause
    });
    console.log("\u{1F50D} [WEBSITES PUT] R\xE9sultat recherche:", existingWebsite ? "TROUV\xC9" : "NON TROUV\xC9");
    if (existingWebsite) {
      console.log("\u{1F50D} [WEBSITES PUT] Site trouv\xE9:", {
        id: existingWebsite.id,
        organizationId: existingWebsite.organizationId,
        siteName: existingWebsite.siteName
      });
    }
    if (!existingWebsite) {
      console.log("\u{1F50D} [WEBSITES PUT] \u274C Website not found - 404");
      return res.status(404).json({ error: "Website not found" });
    }
    const updateData = {
      updatedAt: /* @__PURE__ */ new Date()
    };
    if (data.siteName !== void 0) updateData.siteName = data.siteName;
    if (data.siteType !== void 0) updateData.siteType = data.siteType;
    if (data.slug !== void 0) updateData.slug = data.slug;
    if (data.domain !== void 0) updateData.domain = data.domain;
    if (data.isActive !== void 0) updateData.isActive = data.isActive;
    if (data.isPublished !== void 0) updateData.isPublished = data.isPublished;
    if (data.maintenanceMode !== void 0) updateData.maintenanceMode = data.maintenanceMode;
    if (data.maintenanceMessage !== void 0) updateData.maintenanceMessage = data.maintenanceMessage;
    if (data.cloudRunDomain !== void 0) updateData.cloudRunDomain = data.cloudRunDomain;
    if (data.cloudRunServiceName !== void 0) updateData.cloudRunServiceName = data.cloudRunServiceName;
    if (data.cloudRunRegion !== void 0) updateData.cloudRunRegion = data.cloudRunRegion;
    console.log("\u{1F4DD} [WEBSITES] Donn\xE9es de mise \xE0 jour:", updateData);
    const updatedWebsite = await db.websites.update({
      where: { id: websiteId },
      data: updateData,
      include: {
        website_configs: true
      }
    });
    console.log("\u2705 [WEBSITES] Site mis \xE0 jour:", updatedWebsite.id);
    res.json(updatedWebsite);
  } catch (error) {
    console.error("Error updating website:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router78.delete("/websites/:id", authenticateToken, async (req2, res) => {
  try {
    const websiteId = parseInt(req2.params.id);
    const organizationId = req2.headers["x-organization-id"];
    const isSuperAdmin2 = req2.headers["x-is-super-admin"] === "true";
    const whereClause = { id: websiteId };
    if (!isSuperAdmin2 || organizationId && organizationId !== "all") {
      whereClause.organizationId = organizationId;
    }
    const existingWebsite = await db.websites.findFirst({
      where: whereClause
    });
    if (!existingWebsite) {
      return res.status(404).json({ error: "Website not found" });
    }
    await db.websites.delete({
      where: { id: websiteId }
    });
    res.json({ success: true });
  } catch (error) {
    console.error("Error deleting website:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router78.post("/websites", authenticateToken, async (req2, res) => {
  try {
    const organizationId = req2.headers["x-organization-id"];
    const data = req2.body;
    if (!organizationId) {
      return res.status(400).json({ error: "Organization ID is required" });
    }
    const newWebsite = await db.websites.create({
      data: {
        organizationId,
        siteName: data.siteName,
        siteType: data.siteType || "vitrine",
        slug: data.slug,
        domain: data.domain,
        cloudRunDomain: data.cloudRunDomain,
        cloudRunServiceName: data.cloudRunServiceName,
        cloudRunRegion: data.cloudRunRegion || "europe-west1",
        isActive: true,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      },
      include: {
        website_configs: true
      }
    });
    res.status(201).json(newWebsite);
  } catch (error) {
    console.error("Error creating website:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router78.get("/websites/:idOrSlug", async (req2, res) => {
  try {
    const { idOrSlug } = req2.params;
    const organizationId = req2.headers["x-organization-id"];
    const isId = /^\d+$/.test(idOrSlug);
    const whereClause = { isActive: true };
    if (isId) {
      whereClause.id = parseInt(idOrSlug, 10);
    } else {
      whereClause.slug = idOrSlug;
    }
    if (organizationId) {
      whereClause.organizationId = organizationId;
    }
    const website = await db.websites.findFirst({
      where: whereClause,
      include: {
        website_configs: true,
        website_sections: {
          where: { isActive: true },
          orderBy: { displayOrder: "asc" }
        },
        website_services: {
          where: { isActive: true },
          orderBy: { displayOrder: "asc" }
        },
        website_projects: {
          where: { isActive: true },
          orderBy: { displayOrder: "asc" }
        },
        website_testimonials: {
          where: { isActive: true },
          orderBy: { displayOrder: "asc" }
        },
        website_blog_posts: {
          where: { isPublished: true },
          orderBy: { publishedAt: "desc" },
          take: 10
        },
        website_media_files: {
          where: { isPublic: true },
          orderBy: { createdAt: "desc" }
        }
      }
    });
    if (!website) {
      return res.status(404).json({ error: "Website not found" });
    }
    if (website.maintenanceMode && !organizationId) {
      return res.status(503).json({
        error: "Site en maintenance",
        message: website.maintenanceMessage || "Le site est temporairement indisponible."
      });
    }
    res.json(website);
  } catch (error) {
    console.error("Error fetching website:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router78.get("/websites/:slug/services", async (req2, res) => {
  try {
    const { slug } = req2.params;
    const website = await db.websites.findFirst({
      where: { slug, isActive: true },
      select: { id: true }
    });
    if (!website) {
      return res.status(404).json({ error: "Website not found" });
    }
    const services = await db.website_services.findMany({
      where: {
        websiteId: website.id,
        isActive: true
      },
      orderBy: { displayOrder: "asc" }
    });
    res.json(services);
  } catch (error) {
    console.error("Error fetching services:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router78.get("/websites/:slug/projects", async (req2, res) => {
  try {
    const { slug } = req2.params;
    const { featured } = req2.query;
    const website = await db.websites.findFirst({
      where: { slug, isActive: true },
      select: { id: true }
    });
    if (!website) {
      return res.status(404).json({ error: "Website not found" });
    }
    const whereClause = {
      websiteId: website.id,
      isActive: true
    };
    if (featured === "true") {
      whereClause.isFeatured = true;
    }
    const projects = await db.website_projects.findMany({
      where: whereClause,
      orderBy: { displayOrder: "asc" }
    });
    res.json(projects);
  } catch (error) {
    console.error("Error fetching projects:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router78.get("/websites/:slug/testimonials", async (req2, res) => {
  try {
    const { slug } = req2.params;
    const { featured } = req2.query;
    const website = await db.websites.findFirst({
      where: { slug, isActive: true },
      select: { id: true }
    });
    if (!website) {
      return res.status(404).json({ error: "Website not found" });
    }
    const whereClause = {
      websiteId: website.id,
      isActive: true
    };
    if (featured === "true") {
      whereClause.isFeatured = true;
    }
    const testimonials = await db.website_testimonials.findMany({
      where: whereClause,
      orderBy: { displayOrder: "asc" }
    });
    res.json(testimonials);
  } catch (error) {
    console.error("Error fetching testimonials:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router78.get("/websites/:slug/blog", async (req2, res) => {
  try {
    const { slug } = req2.params;
    const { limit = "10", featured } = req2.query;
    const website = await db.websites.findFirst({
      where: { slug, isActive: true },
      select: { id: true }
    });
    if (!website) {
      return res.status(404).json({ error: "Website not found" });
    }
    const whereClause = {
      websiteId: website.id,
      isPublished: true
    };
    if (featured === "true") {
      whereClause.isFeatured = true;
    }
    const blogPosts = await db.website_blog_posts.findMany({
      where: whereClause,
      orderBy: { publishedAt: "desc" },
      take: parseInt(limit),
      include: {
        author: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            avatarUrl: true
          }
        }
      }
    });
    res.json(blogPosts);
  } catch (error) {
    console.error("Error fetching blog posts:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router78.get("/websites/:slug/blog/:postSlug", async (req2, res) => {
  try {
    const { slug, postSlug } = req2.params;
    const website = await db.websites.findFirst({
      where: { slug, isActive: true },
      select: { id: true }
    });
    if (!website) {
      return res.status(404).json({ error: "Website not found" });
    }
    const blogPost = await db.website_blog_posts.findFirst({
      where: {
        websiteId: website.id,
        slug: postSlug,
        isPublished: true
      },
      include: {
        author: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            avatarUrl: true,
            email: true
          }
        }
      }
    });
    if (!blogPost) {
      return res.status(404).json({ error: "Blog post not found" });
    }
    res.json(blogPost);
  } catch (error) {
    console.error("Error fetching blog post:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
var websites_default = router78;

// src/api/website-services.ts
var import_express81 = require("express");
init_database();
var router79 = (0, import_express81.Router)();
var prisma45 = db;
router79.get("/website-services/:websiteId", async (req2, res) => {
  try {
    const { websiteId } = req2.params;
    const services = await prisma45.webSiteService.findMany({
      where: {
        websiteId: parseInt(websiteId)
      },
      orderBy: {
        displayOrder: "asc"
      }
    });
    res.json(services);
  } catch (error) {
    console.error("Error fetching services:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router79.post("/website-services", async (req2, res) => {
  try {
    const { websiteId, key: key2, icon, title, description, features, ctaText, ctaUrl, isActive } = req2.body;
    if (!websiteId || !key2 || !title) {
      return res.status(400).json({ error: "websiteId, key, and title are required" });
    }
    const maxOrder = await prisma45.webSiteService.aggregate({
      where: { websiteId: parseInt(websiteId) },
      _max: { displayOrder: true }
    });
    const service = await prisma45.webSiteService.create({
      data: {
        websiteId: parseInt(websiteId),
        key: key2,
        icon: icon || "CheckCircleOutlined",
        title,
        description: description || "",
        features: features || [],
        ctaText: ctaText || "En savoir plus",
        ctaUrl: ctaUrl || "",
        isActive: isActive !== void 0 ? isActive : true,
        displayOrder: (maxOrder._max.displayOrder || 0) + 1
      }
    });
    res.json(service);
  } catch (error) {
    console.error("Error creating service:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router79.put("/website-services/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { key: key2, icon, title, description, features, ctaText, ctaUrl, isActive } = req2.body;
    const service = await prisma45.webSiteService.update({
      where: { id: parseInt(id) },
      data: {
        ...key2 && { key: key2 },
        ...icon && { icon },
        ...title && { title },
        ...description !== void 0 && { description },
        ...features && { features },
        ...ctaText !== void 0 && { ctaText },
        ...ctaUrl !== void 0 && { ctaUrl },
        ...isActive !== void 0 && { isActive }
      }
    });
    res.json(service);
  } catch (error) {
    console.error("Error updating service:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router79.delete("/website-services/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    await prisma45.webSiteService.delete({
      where: { id: parseInt(id) }
    });
    res.json({ success: true });
  } catch (error) {
    console.error("Error deleting service:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router79.post("/website-services/reorder", async (req2, res) => {
  try {
    const { services } = req2.body;
    if (!Array.isArray(services)) {
      return res.status(400).json({ error: "services array is required" });
    }
    await Promise.all(
      services.map(
        (service) => prisma45.webSiteService.update({
          where: { id: service.id },
          data: { displayOrder: service.displayOrder }
        })
      )
    );
    res.json({ success: true });
  } catch (error) {
    console.error("Error reordering services:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
var website_services_default = router79;

// src/api/website-projects.ts
var import_express82 = require("express");
init_database();
var router80 = (0, import_express82.Router)();
var prisma46 = db;
router80.get("/website-projects/:websiteId", async (req2, res) => {
  try {
    const { websiteId } = req2.params;
    const projects = await prisma46.webSiteProject.findMany({
      where: {
        websiteId: parseInt(websiteId)
      },
      orderBy: {
        displayOrder: "asc"
      }
    });
    res.json(projects);
  } catch (error) {
    console.error("Error fetching projects:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router80.post("/website-projects", async (req2, res) => {
  try {
    const { websiteId, title, location, details, tags, isActive, isFeatured, completedAt } = req2.body;
    if (!websiteId || !title) {
      return res.status(400).json({ error: "websiteId and title are required" });
    }
    const maxOrder = await prisma46.webSiteProject.aggregate({
      where: { websiteId: parseInt(websiteId) },
      _max: { displayOrder: true }
    });
    const project = await prisma46.webSiteProject.create({
      data: {
        websiteId: parseInt(websiteId),
        title,
        location: location || "",
        details: details || "",
        tags: tags || [],
        isActive: isActive !== void 0 ? isActive : true,
        isFeatured: isFeatured || false,
        displayOrder: (maxOrder._max.displayOrder || 0) + 1,
        completedAt: completedAt ? new Date(completedAt) : /* @__PURE__ */ new Date()
      }
    });
    res.json(project);
  } catch (error) {
    console.error("Error creating project:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router80.put("/website-projects/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { title, location, details, tags, isActive, isFeatured, completedAt } = req2.body;
    const project = await prisma46.webSiteProject.update({
      where: { id: parseInt(id) },
      data: {
        ...title && { title },
        ...location !== void 0 && { location },
        ...details !== void 0 && { details },
        ...tags && { tags },
        ...isActive !== void 0 && { isActive },
        ...isFeatured !== void 0 && { isFeatured },
        ...completedAt && { completedAt: new Date(completedAt) }
      }
    });
    res.json(project);
  } catch (error) {
    console.error("Error updating project:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router80.delete("/website-projects/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    await prisma46.webSiteProject.delete({
      where: { id: parseInt(id) }
    });
    res.json({ success: true });
  } catch (error) {
    console.error("Error deleting project:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router80.post("/website-projects/reorder", async (req2, res) => {
  try {
    const { projects } = req2.body;
    if (!Array.isArray(projects)) {
      return res.status(400).json({ error: "projects array is required" });
    }
    await Promise.all(
      projects.map(
        (project) => prisma46.webSiteProject.update({
          where: { id: project.id },
          data: { displayOrder: project.displayOrder }
        })
      )
    );
    res.json({ success: true });
  } catch (error) {
    console.error("Error reordering projects:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
var website_projects_default = router80;

// src/api/website-testimonials.ts
var import_express83 = require("express");
init_database();
var router81 = (0, import_express83.Router)();
var prisma47 = db;
router81.get("/website-testimonials/:websiteId", async (req2, res) => {
  try {
    const { websiteId } = req2.params;
    const testimonials = await prisma47.webSiteTestimonial.findMany({
      where: {
        websiteId: parseInt(websiteId)
      },
      orderBy: {
        displayOrder: "asc"
      }
    });
    res.json(testimonials);
  } catch (error) {
    console.error("Error fetching testimonials:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router81.post("/website-testimonials", async (req2, res) => {
  try {
    const { websiteId, customerName, location, service, rating, text, isActive, isFeatured, publishedAt } = req2.body;
    if (!websiteId || !customerName || !text) {
      return res.status(400).json({ error: "websiteId, customerName, and text are required" });
    }
    const maxOrder = await prisma47.webSiteTestimonial.aggregate({
      where: { websiteId: parseInt(websiteId) },
      _max: { displayOrder: true }
    });
    const testimonial = await prisma47.webSiteTestimonial.create({
      data: {
        websiteId: parseInt(websiteId),
        customerName,
        location: location || "",
        service: service || "",
        rating: rating || 5,
        text,
        isActive: isActive !== void 0 ? isActive : true,
        isFeatured: isFeatured || false,
        displayOrder: (maxOrder._max.displayOrder || 0) + 1,
        publishedAt: publishedAt ? new Date(publishedAt) : /* @__PURE__ */ new Date()
      }
    });
    res.json(testimonial);
  } catch (error) {
    console.error("Error creating testimonial:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router81.put("/website-testimonials/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { customerName, location, service, rating, text, isActive, isFeatured, publishedAt } = req2.body;
    const testimonial = await prisma47.webSiteTestimonial.update({
      where: { id: parseInt(id) },
      data: {
        ...customerName && { customerName },
        ...location !== void 0 && { location },
        ...service !== void 0 && { service },
        ...rating !== void 0 && { rating },
        ...text !== void 0 && { text },
        ...isActive !== void 0 && { isActive },
        ...isFeatured !== void 0 && { isFeatured },
        ...publishedAt && { publishedAt: new Date(publishedAt) }
      }
    });
    res.json(testimonial);
  } catch (error) {
    console.error("Error updating testimonial:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router81.delete("/website-testimonials/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    await prisma47.webSiteTestimonial.delete({
      where: { id: parseInt(id) }
    });
    res.json({ success: true });
  } catch (error) {
    console.error("Error deleting testimonial:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
router81.post("/website-testimonials/reorder", async (req2, res) => {
  try {
    const { testimonials } = req2.body;
    if (!Array.isArray(testimonials)) {
      return res.status(400).json({ error: "testimonials array is required" });
    }
    await Promise.all(
      testimonials.map(
        (testimonial) => prisma47.webSiteTestimonial.update({
          where: { id: testimonial.id },
          data: { displayOrder: testimonial.displayOrder }
        })
      )
    );
    res.json({ success: true });
  } catch (error) {
    console.error("Error reordering testimonials:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
var website_testimonials_default = router81;

// src/api/website-sections.ts
var import_express84 = __toESM(require("express"), 1);
init_database();
var router82 = import_express84.default.Router();
router82.get("/website-sections/:websiteId", async (req2, res) => {
  try {
    const { websiteId } = req2.params;
    const sections = await db.website_sections.findMany({
      where: {
        websiteId: parseInt(websiteId)
      },
      orderBy: {
        displayOrder: "asc"
      }
    });
    res.json(sections);
  } catch (error) {
    console.error("\u274C Erreur r\xE9cup\xE9ration sections:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router82.post("/website-sections", async (req2, res) => {
  try {
    const { websiteId, key: key2, type, name, content, backgroundColor, textColor, customCss } = req2.body;
    const maxOrder = await db.website_sections.aggregate({
      where: { websiteId: parseInt(websiteId) },
      _max: { displayOrder: true }
    });
    const section = await db.website_sections.create({
      data: {
        websiteId: parseInt(websiteId),
        key: key2,
        type,
        name,
        content: content || {},
        backgroundColor,
        textColor,
        customCss,
        displayOrder: (maxOrder._max.displayOrder || 0) + 1,
        isActive: true,
        isLocked: false
      }
    });
    res.json(section);
  } catch (error) {
    console.error("\u274C Erreur cr\xE9ation section:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router82.put("/website-sections/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { name, content, backgroundColor, textColor, customCss, isActive } = req2.body;
    console.log("\u{1F527} PUT /api/website-sections/:id");
    console.log("  ID:", id);
    console.log("  Body keys:", Object.keys(req2.body));
    console.log("  Content keys:", content ? Object.keys(content) : "undefined");
    const existing = await db.website_sections.findUnique({
      where: { id: parseInt(id) }
    });
    if (!existing) {
      return res.status(404).json({ error: "Section introuvable" });
    }
    const deepMerge = (target, source) => {
      if (!source || typeof source !== "object" || Array.isArray(source)) {
        return source;
      }
      const result = { ...target || {} };
      for (const key2 in source) {
        if (source[key2] !== void 0) {
          if (result[key2] && typeof result[key2] === "object" && !Array.isArray(result[key2]) && typeof source[key2] === "object" && !Array.isArray(source[key2])) {
            result[key2] = deepMerge(result[key2], source[key2]);
          } else {
            result[key2] = source[key2];
          }
        }
      }
      return result;
    };
    const mergedContent = content !== void 0 ? deepMerge(existing.content, content) : existing.content;
    console.log("  \u{1F50D} Existing content keys:", existing.content ? Object.keys(existing.content) : "none");
    console.log("  \u{1F50D} Merged content keys:", mergedContent ? Object.keys(mergedContent) : "none");
    const section = await db.website_sections.update({
      where: { id: parseInt(id) },
      data: {
        ...name !== void 0 && { name },
        ...content !== void 0 && { content: mergedContent },
        ...backgroundColor !== void 0 && { backgroundColor },
        ...textColor !== void 0 && { textColor },
        ...customCss !== void 0 && { customCss },
        ...isActive !== void 0 && { isActive }
      }
    });
    console.log("\u2705 Section mise \xE0 jour ID:", section.id);
    res.json(section);
  } catch (error) {
    console.error("\u274C Erreur modification section:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router82.patch("/website-sections/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { name, content, backgroundColor, textColor, customCss, isActive } = req2.body;
    console.log("\u{1F527} PATCH /api/website-sections/:id");
    console.log("  ID:", id);
    console.log("  Body keys:", Object.keys(req2.body));
    const existing = await db.website_sections.findUnique({
      where: { id: parseInt(id) }
    });
    if (!existing) {
      return res.status(404).json({ error: "Section introuvable" });
    }
    const deepMerge = (target, source) => {
      if (!source || typeof source !== "object" || Array.isArray(source)) {
        return source;
      }
      const result = { ...target || {} };
      for (const key2 in source) {
        if (source[key2] !== void 0) {
          if (result[key2] && typeof result[key2] === "object" && !Array.isArray(result[key2]) && typeof source[key2] === "object" && !Array.isArray(source[key2])) {
            result[key2] = deepMerge(result[key2], source[key2]);
          } else {
            result[key2] = source[key2];
          }
        }
      }
      return result;
    };
    const mergedContent = content !== void 0 ? deepMerge(existing.content, content) : existing.content;
    const section = await db.website_sections.update({
      where: { id: parseInt(id) },
      data: {
        ...name !== void 0 && { name },
        ...content !== void 0 && { content: mergedContent },
        ...backgroundColor !== void 0 && { backgroundColor },
        ...textColor !== void 0 && { textColor },
        ...customCss !== void 0 && { customCss },
        ...isActive !== void 0 && { isActive }
      }
    });
    console.log("\u2705 Section mise \xE0 jour:", section);
    res.json(section);
  } catch (error) {
    console.error("\u274C Erreur modification section:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router82.delete("/website-sections/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const section = await db.website_sections.findUnique({
      where: { id: parseInt(id) }
    });
    if (section?.isLocked) {
      return res.status(403).json({ error: "Cette section est verrouill\xE9e et ne peut pas \xEAtre supprim\xE9e" });
    }
    await db.website_sections.delete({
      where: { id: parseInt(id) }
    });
    res.json({ success: true });
  } catch (error) {
    console.error("\u274C Erreur suppression section:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router82.post("/website-sections/reorder", async (req2, res) => {
  try {
    const { sections } = req2.body;
    await db.$transaction(
      sections.map(
        (section) => db.website_sections.update({
          where: { id: section.id },
          data: { displayOrder: section.displayOrder }
        })
      )
    );
    res.json({ success: true });
  } catch (error) {
    console.error("\u274C Erreur r\xE9organisation sections:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router82.post("/website-sections/duplicate/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const original = await db.website_sections.findUnique({
      where: { id: parseInt(id) }
    });
    if (!original) {
      return res.status(404).json({ error: "Section introuvable" });
    }
    const newKey = `${original.key}-copy-${Date.now()}`;
    const duplicate = await db.website_sections.create({
      data: {
        websiteId: original.websiteId,
        key: newKey,
        type: original.type,
        name: `${original.name} (Copie)`,
        content: original.content,
        backgroundColor: original.backgroundColor,
        textColor: original.textColor,
        customCss: original.customCss,
        displayOrder: original.displayOrder + 1,
        isActive: original.isActive,
        isLocked: false
      }
    });
    res.json(duplicate);
  } catch (error) {
    console.error("\u274C Erreur duplication section:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
var website_sections_default = router82;

// src/api/website-themes.ts
var import_express85 = require("express");
init_prisma();
var router83 = (0, import_express85.Router)();
router83.get("/:websiteId", async (req2, res) => {
  try {
    const { websiteId } = req2.params;
    console.log("\u{1F4E1} [API] GET theme websiteId:", websiteId);
    const theme = await db.webSiteTheme.findUnique({
      where: { websiteId: parseInt(websiteId) }
    });
    if (!theme) {
      return res.status(404).json({ message: "Th\xE8me non trouv\xE9" });
    }
    res.json(theme);
  } catch (error) {
    console.error("\u274C [API] Erreur GET theme:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router83.post("/", async (req2, res) => {
  try {
    const themeData = req2.body;
    console.log("\u{1F4E1} [API] POST theme:", themeData);
    const theme = await db.webSiteTheme.create({
      data: themeData
    });
    res.status(201).json(theme);
  } catch (error) {
    console.error("\u274C [API] Erreur POST theme:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router83.put("/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    const themeData = req2.body;
    console.log("\u{1F4E1} [API] PUT theme:", id, themeData);
    const theme = await db.webSiteTheme.update({
      where: { id: parseInt(id) },
      data: themeData
    });
    res.json(theme);
  } catch (error) {
    console.error("\u274C [API] Erreur PUT theme:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
router83.delete("/:id", async (req2, res) => {
  try {
    const { id } = req2.params;
    console.log("\u{1F4E1} [API] DELETE theme:", id);
    await db.webSiteTheme.delete({
      where: { id: parseInt(id) }
    });
    res.json({ message: "Th\xE8me supprim\xE9 avec succ\xE8s" });
  } catch (error) {
    console.error("\u274C [API] Erreur DELETE theme:", error);
    res.status(500).json({ error: "Erreur serveur" });
  }
});
var website_themes_default = router83;

// src/api/contact-form.ts
var import_express86 = require("express");
init_database();
var router84 = (0, import_express86.Router)();
var prisma48 = db;
var isValidEmail = (email) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
};
var isSpam = (data) => {
  if (data.message) {
    const urlCount = (data.message.match(/https?:\/\//g) || []).length;
    if (urlCount > 3) return true;
  }
  const spamKeywords = ["viagra", "casino", "bitcoin", "forex", "seo service", "make money"];
  const text = `${data.name} ${data.message || ""}`.toLowerCase();
  if (spamKeywords.some((keyword) => text.includes(keyword))) {
    return true;
  }
  return false;
};
router84.post("/contact-form", async (req2, res) => {
  try {
    const data = req2.body;
    if (!data.name || data.name.trim().length < 2) {
      return res.status(400).json({
        success: false,
        message: "Le nom doit contenir au moins 2 caract\xE8res"
      });
    }
    if (!data.email || !isValidEmail(data.email)) {
      return res.status(400).json({
        success: false,
        message: "Email invalide"
      });
    }
    if (!data.websiteId) {
      return res.status(400).json({
        success: false,
        message: "Website ID manquant"
      });
    }
    const website = await prisma48.webSite.findUnique({
      where: { id: data.websiteId },
      select: { id: true, organizationId: true }
    });
    if (!website) {
      return res.status(404).json({
        success: false,
        message: "Site web introuvable"
      });
    }
    const spam = isSpam(data);
    const ipAddress = req2.headers["x-forwarded-for"]?.split(",")[0]?.trim() || req2.socket.remoteAddress || "unknown";
    const userAgent = req2.headers["user-agent"] || "unknown";
    const submission = await prisma48.contactSubmission.create({
      data: {
        websiteId: data.websiteId,
        organizationId: website.organizationId,
        name: data.name.trim(),
        email: data.email.toLowerCase().trim(),
        phone: data.phone?.trim() || null,
        service: data.service?.trim() || null,
        message: data.message?.trim() || null,
        source: "website",
        ipAddress,
        userAgent,
        status: spam ? "spam" : "new",
        isRead: false
      }
    });
    console.log("\u{1F4E7} \u2705 Nouveau formulaire de contact re\xE7u:", {
      id: submission.id,
      name: data.name,
      email: data.email,
      service: data.service,
      websiteId: data.websiteId,
      organizationId: website.organizationId,
      spam,
      date: (/* @__PURE__ */ new Date()).toISOString()
    });
    if (spam) {
      console.log("\u26A0\uFE0F SPAM D\xC9TECT\xC9 - Marqu\xE9 comme spam dans la BDD");
    }
    res.json({
      success: true,
      message: "Merci ! Nous avons bien re\xE7u votre demande. Nous vous r\xE9pondrons sous 24h.",
      submissionId: submission.id
    });
  } catch (error) {
    console.error("\u274C Erreur lors de la soumission du formulaire:", error);
    res.status(500).json({
      success: false,
      message: "Une erreur est survenue. Veuillez r\xE9essayer ou nous contacter directement par t\xE9l\xE9phone."
    });
  }
});
router84.get("/contact-submissions/:websiteId", async (req2, res) => {
  try {
    const websiteId = parseInt(req2.params.websiteId);
    const submissions = await prisma48.contactSubmission.findMany({
      where: { websiteId },
      orderBy: { submittedAt: "desc" },
      take: 100
      // Limiter √† 100 derni√®res soumissions
    });
    res.json(submissions);
  } catch (error) {
    console.error("Erreur r\xE9cup\xE9ration soumissions:", error);
    res.status(500).json({ success: false, message: "Erreur serveur" });
  }
});
router84.patch("/contact-submission/:id/read", async (req2, res) => {
  try {
    const id = parseInt(req2.params.id);
    const submission = await prisma48.contactSubmission.update({
      where: { id },
      data: { isRead: true }
    });
    res.json({ success: true, submission });
  } catch (error) {
    console.error("Erreur marquage lu:", error);
    res.status(500).json({ success: false, message: "Erreur serveur" });
  }
});
router84.patch("/contact-submission/:id/status", async (req2, res) => {
  try {
    const id = parseInt(req2.params.id);
    const { status, notes } = req2.body;
    const validStatuses = ["new", "contacted", "converted", "spam"];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({ success: false, message: "Statut invalide" });
    }
    const submission = await prisma48.contactSubmission.update({
      where: { id },
      data: {
        status,
        notes: notes || void 0,
        respondedAt: status === "contacted" ? /* @__PURE__ */ new Date() : void 0
      }
    });
    res.json({ success: true, submission });
  } catch (error) {
    console.error("Erreur changement statut:", error);
    res.status(500).json({ success: false, message: "Erreur serveur" });
  }
});
router84.delete("/contact-submission/:id", async (req2, res) => {
  try {
    const id = parseInt(req2.params.id);
    await prisma48.contactSubmission.delete({
      where: { id }
    });
    res.json({ success: true, message: "Soumission supprim\xE9e" });
  } catch (error) {
    console.error("Erreur suppression:", error);
    res.status(500).json({ success: false, message: "Erreur serveur" });
  }
});
var contact_form_default = router84;

// src/api/image-upload.ts
var import_express87 = require("express");
var import_multer2 = __toESM(require("multer"), 1);
var import_path7 = __toESM(require("path"), 1);
var import_promises = __toESM(require("fs/promises"), 1);
init_database();
var router85 = (0, import_express87.Router)();
var prisma49 = db;
var storage2 = import_multer2.default.diskStorage({
  destination: async (req2, file, cb) => {
    const uploadDir = import_path7.default.join(process.cwd(), "public", "uploads", "websites");
    await import_promises.default.mkdir(uploadDir, { recursive: true });
    cb(null, uploadDir);
  },
  filename: (req2, file, cb) => {
    const uniqueName = `${Date.now()}_${file.originalname.replace(/\s+/g, "_")}`;
    cb(null, uniqueName);
  }
});
var fileFilter = (req2, file, cb) => {
  const allowedTypes = ["image/jpeg", "image/jpg", "image/png", "image/gif", "image/webp", "image/svg+xml"];
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error("Type de fichier non autoris\xE9. Utilisez JPG, PNG, GIF, WEBP ou SVG."));
  }
};
var upload2 = (0, import_multer2.default)({
  storage: storage2,
  fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024
    // 5MB max
  }
});
router85.post("/upload", upload2.single("file"), async (req2, res) => {
  try {
    if (!req2.file) {
      return res.status(400).json({
        success: false,
        message: "Aucun fichier fourni"
      });
    }
    console.log("\u{1F4F8} [IMAGE-UPLOAD] Fichier re\xE7u:", {
      originalName: req2.file.originalname,
      size: req2.file.size,
      mimetype: req2.file.mimetype,
      filename: req2.file.filename
    });
    const fileUrl = `/uploads/websites/${req2.file.filename}`;
    const fullUrl = `http://localhost:4000${fileUrl}`;
    console.log("\u{1F4F8} \u2705 Upload r\xE9ussi:", {
      fileName: req2.file.originalname,
      url: fullUrl,
      size: `${(req2.file.size / 1024).toFixed(2)} KB`
    });
    res.json({
      success: true,
      message: "Image upload\xE9e avec succ\xE8s",
      url: fullUrl,
      // URL compl√®te utilisable dans le frontend
      fileUrl,
      // Chemin relatif
      file: {
        fileName: req2.file.originalname,
        size: req2.file.size,
        mimetype: req2.file.mimetype
      }
    });
  } catch (error) {
    console.error("\u274C [IMAGE-UPLOAD] Erreur:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de l'upload",
      error: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router85.post("/upload-image", upload2.single("image"), async (req2, res) => {
  try {
    if (!req2.file) {
      return res.status(400).json({
        success: false,
        message: "Aucune image fournie"
      });
    }
    const { websiteId, category = "general" } = req2.body;
    if (!websiteId) {
      return res.status(400).json({
        success: false,
        message: "Website ID manquant"
      });
    }
    const fileUrl = `/uploads/websites/${req2.file.filename}`;
    const mediaFile = await prisma49.webSiteMediaFile.create({
      data: {
        websiteId: parseInt(websiteId),
        fileName: req2.file.originalname,
        fileType: req2.file.mimetype,
        // ‚úÖ CORRECTION: fileType au lieu de mimeType
        fileUrl,
        filePath: req2.file.path,
        fileSize: req2.file.size,
        category,
        // 'logo', 'project', 'service', 'general'
        uploadedById: req2.user?.id || null
      }
    });
    console.log("\u{1F4F8} \u2705 Image upload\xE9e:", {
      id: mediaFile.id,
      fileName: mediaFile.fileName,
      url: fileUrl,
      size: `${(req2.file.size / 1024).toFixed(2)} KB`,
      category
    });
    res.json({
      success: true,
      message: "Image upload\xE9e avec succ\xE8s",
      file: {
        id: mediaFile.id,
        fileName: mediaFile.fileName,
        url: fileUrl,
        size: mediaFile.fileSize,
        mimeType: mediaFile.fileType
        // ‚úÖ CORRECTION: retourne fileType
      }
    });
  } catch (error) {
    console.error("\u274C Erreur upload image:", error);
    res.status(500).json({
      success: false,
      message: "Erreur lors de l'upload"
    });
  }
});
router85.get("/images/:websiteId", async (req2, res) => {
  try {
    const websiteId = parseInt(req2.params.websiteId);
    const { category } = req2.query;
    const where = { websiteId };
    if (category) {
      where.category = category;
    }
    const images = await prisma49.webSiteMediaFile.findMany({
      where,
      orderBy: { uploadedAt: "desc" }
    });
    res.json({
      success: true,
      images
    });
  } catch (error) {
    console.error("Erreur r\xE9cup\xE9ration images:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur"
    });
  }
});
router85.delete("/image/:id", async (req2, res) => {
  try {
    const id = parseInt(req2.params.id);
    const mediaFile = await prisma49.webSiteMediaFile.findUnique({
      where: { id }
    });
    if (!mediaFile) {
      return res.status(404).json({
        success: false,
        message: "Image introuvable"
      });
    }
    try {
      await import_promises.default.unlink(mediaFile.filePath);
    } catch (err) {
      console.warn("Fichier d\xE9j\xE0 supprim\xE9 ou inexistant");
    }
    await prisma49.webSiteMediaFile.delete({
      where: { id }
    });
    res.json({
      success: true,
      message: "Image supprim\xE9e"
    });
  } catch (error) {
    console.error("Erreur suppression image:", error);
    res.status(500).json({
      success: false,
      message: "Erreur serveur"
    });
  }
});
var image_upload_default = router85;

// src/api/ai-content.ts
var import_express88 = require("express");

// src/services/aiContentService.ts
var AIContentService = class {
  geminiService;
  constructor() {
    this.geminiService = getGeminiService();
  }
  /**
   * Option A : G√©n√®re le contenu d'un service
   */
  async generateService(context) {
    const prompt = `Tu es un expert en r\xE9daction web et marketing pour le secteur ${context.industry}.

G\xE9n\xE8re le contenu complet d'un service pour le site "${context.siteName}".

Type de service : ${context.serviceType}
${context.keywords ? `Mots-cl\xE9s sugg\xE9r\xE9s : ${context.keywords.join(", ")}` : ""}

Retourne UNIQUEMENT un objet JSON valide avec cette structure exacte :
{
  "key": "identifiant-technique-du-service (slug, kebab-case)",
  "icon": "Nom d'une ic\xF4ne Ant Design pertinente (ex: ThunderboltOutlined, FireOutlined, etc.)",
  "title": "Titre accrocheur du service (3-6 mots)",
  "description": "Description persuasive en 1-2 phrases (max 150 caract\xE8res)",
  "features": ["Caract\xE9ristique 1 (5-8 mots)", "Caract\xE9ristique 2", "Caract\xE9ristique 3", "Caract\xE9ristique 4"],
  "ctaText": "Texte du call-to-action (3-5 mots)",
  "keywords": ["mot-cl\xE9 1", "mot-cl\xE9 2", "mot-cl\xE9 3", "mot-cl\xE9 4", "mot-cl\xE9 5", "mot-cl\xE9 6", "mot-cl\xE9 7", "mot-cl\xE9 8"]
}

\u26A0\uFE0F IMPORTANT pour les keywords :
- G\xE9n\xE8re AU MINIMUM 8 mots-cl\xE9s SEO pertinents et vari\xE9s
- Inclus des synonymes, termes techniques, b\xE9n\xE9fices clients
- Pense r\xE9f\xE9rencement naturel (longue tra\xEEne + termes courts)
- Exemples : "panneaux solaires", "installation photovolta\xEFque", "\xE9nergie renouvelable", "\xE9conomies \xE9lectricit\xE9", "autoconsommation", "primes photovolta\xEFques", "panneaux haute performance", "autonomie \xE9nerg\xE9tique"

R\xE8gles :
- Ton professionnel et convaincant
- Orient\xE9 b\xE9n\xE9fices client
- Optimis\xE9 SEO naturellement
- Pas de texte superflu, UNIQUEMENT le JSON`;
    const response = await this.geminiService.generateContentStream(prompt);
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error("Format de r\xE9ponse invalide de l'IA");
    }
    return JSON.parse(jsonMatch[0]);
  }
  /**
   * Option A : G√©n√®re le contenu d'un projet
   */
  async generateProject(context) {
    const prompt = `Tu es un expert en r\xE9daction web et marketing pour le secteur ${context.industry}.

G\xE9n\xE8re le contenu complet d'un projet r\xE9alis\xE9 pour le site "${context.siteName}".

Type de projet : ${context.projectType}
${context.location ? `Localisation : ${context.location}` : ""}

Retourne UNIQUEMENT un objet JSON valide avec cette structure exacte :
{
  "title": "Titre technique du projet (ex: 12.5 kWp + Batterie 15 kWh)",
  "location": "Ville ou r\xE9gion",
  "details": "Description d\xE9taill\xE9e du projet en 2-3 phrases (max 200 caract\xE8res)",
  "tags": ["Tag1", "Tag2", "Tag3"]
}

R\xE8gles :
- Titre technique et pr\xE9cis
- D\xE9tails concrets et mesurables
- Tags pertinents (2-4 tags)
- Pas de texte superflu, UNIQUEMENT le JSON`;
    const response = await this.geminiService.generateContentStream(prompt);
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error("Format de r\xE9ponse invalide de l'IA");
    }
    return JSON.parse(jsonMatch[0]);
  }
  /**
   * Option A : G√©n√®re le contenu d'un t√©moignage
   */
  async generateTestimonial(context) {
    const prompt = `Tu es un expert en r\xE9daction web et marketing pour le secteur ${context.industry}.

G\xE9n\xE8re un t\xE9moignage client r\xE9aliste et convaincant pour le site "${context.siteName}".

Service concern\xE9 : ${context.serviceType}
Type de client : ${context.customerType || "particulier"}

Retourne UNIQUEMENT un objet JSON valide avec cette structure exacte :
{
  "customerName": "Pr\xE9nom Nom (belge francophone)",
  "location": "Ville belge",
  "service": "Nom du service utilis\xE9",
  "rating": 5,
  "text": "T\xE9moignage authentique et d\xE9taill\xE9 (3-4 phrases, max 300 caract\xE8res). Doit mentionner des d\xE9tails concrets, l'exp\xE9rience v\xE9cue, et les r\xE9sultats obtenus."
}

R\xE8gles :
- T\xE9moignage cr\xE9dible et authentique
- D\xE9tails concrets et sp\xE9cifiques
- Ton positif mais naturel
- Pas de superlatifs exag\xE9r\xE9s
- Pas de texte superflu, UNIQUEMENT le JSON`;
    const response = await this.geminiService.generateContentStream(prompt);
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error("Format de r\xE9ponse invalide de l'IA");
    }
    return JSON.parse(jsonMatch[0]);
  }
  /**
   * Option B : G√©n√®re le contenu complet d'une page
   */
  async generatePageContent(context) {
    const prompt = `Tu es un expert en r\xE9daction web et marketing pour le secteur ${context.industry}.

G\xE9n\xE8re le contenu complet de la page d'accueil pour "${context.siteName}".

Type de site : ${context.siteType}
Services principaux : ${context.mainServices.join(", ")}
${context.targetAudience ? `Audience cible : ${context.targetAudience}` : ""}

Retourne UNIQUEMENT un objet JSON valide avec cette structure exacte :
{
  "heroTitle": "Titre principal accrocheur (max 60 caract\xE8res)",
  "heroSubtitle": "Sous-titre avec liste des services s\xE9par\xE9s par \u2022",
  "heroCtaPrimary": "Texte bouton principal (3-5 mots)",
  "heroCtaSecondary": "Texte bouton secondaire (2-4 mots)",
  "metaTitle": "Titre SEO optimis\xE9 (50-60 caract\xE8res)",
  "metaDescription": "Description SEO persuasive (140-160 caract\xE8res)",
  "metaKeywords": "Liste de mots-cl\xE9s SEO s\xE9par\xE9s par des virgules",
  "aboutText": "Texte de pr\xE9sentation de l'entreprise (3-4 phrases, max 400 caract\xE8res)"
}

R\xE8gles :
- Titres percutants et orient\xE9s b\xE9n\xE9fices
- SEO naturel et optimis\xE9
- Ton professionnel et convaincant
- Int\xE9grer les mots-cl\xE9s de mani\xE8re naturelle
- Pas de texte superflu, UNIQUEMENT le JSON`;
    const response = await this.geminiService.generateContentStream(prompt);
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error("Format de r\xE9ponse invalide de l'IA");
    }
    return JSON.parse(jsonMatch[0]);
  }
  /**
   * Option C : Optimisation SEO d'un contenu existant
   */
  async optimizeSEO(content) {
    const prompt = `Tu es un expert SEO sp\xE9cialis\xE9 dans le secteur ${content.industry}.

Analyse et optimise le contenu SEO pour "${content.siteName}".

Titre actuel : ${content.currentTitle || "Non d\xE9fini"}
Description actuelle : ${content.currentDescription || "Non d\xE9finie"}
${content.targetKeywords ? `Mots-cl\xE9s cibles : ${content.targetKeywords.join(", ")}` : ""}

Contenu de la page :
${content.pageContent.substring(0, 1e3)}

Retourne UNIQUEMENT un objet JSON valide avec cette structure exacte :
{
  "metaTitle": "Titre SEO optimis\xE9 (50-60 caract\xE8res)",
  "metaDescription": "Description SEO optimis\xE9e (140-160 caract\xE8res)",
  "metaKeywords": "Liste de mots-cl\xE9s SEO pertinents s\xE9par\xE9s par des virgules",
  "improvements": [
    "Am\xE9lioration 1 sugg\xE9r\xE9e",
    "Am\xE9lioration 2 sugg\xE9r\xE9e",
    "Am\xE9lioration 3 sugg\xE9r\xE9e",
    "Am\xE9lioration 4 sugg\xE9r\xE9e"
  ]
}

R\xE8gles :
- Optimisation SEO technique
- Mots-cl\xE9s int\xE9gr\xE9s naturellement
- Appel \xE0 l'action dans la description
- Suggestions concr\xE8tes et actionnables
- Pas de texte superflu, UNIQUEMENT le JSON`;
    const response = await this.geminiService.generateContentStream(prompt);
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error("Format de r\xE9ponse invalide de l'IA");
    }
    return JSON.parse(jsonMatch[0]);
  }
  /**
   * G√©n√®re plusieurs services d'un coup pour un site complet
   */
  async generateMultipleServices(context) {
    const services = [];
    for (const serviceType of context.serviceTypes) {
      try {
        const service = await this.generateService({
          siteName: context.siteName,
          industry: context.industry,
          serviceType
        });
        services.push(service);
      } catch (error) {
        console.error(`Erreur g\xE9n\xE9ration service ${serviceType}:`, error);
      }
    }
    return services;
  }
};
var aiContentService = new AIContentService();

// src/api/ai-content.ts
var router86 = (0, import_express88.Router)();
router86.post("/generate-service", async (req2, res) => {
  try {
    const { siteName, industry, serviceType, keywords } = req2.body;
    if (!siteName || !industry || !serviceType) {
      return res.status(400).json({
        error: "Param\xE8tres manquants : siteName, industry, serviceType requis"
      });
    }
    const content = await aiContentService.generateService({
      siteName,
      industry,
      serviceType,
      keywords
    });
    res.json({
      success: true,
      content
    });
  } catch (error) {
    console.error("Erreur g\xE9n\xE9ration service:", error);
    res.status(500).json({
      error: "Erreur lors de la g\xE9n\xE9ration du service",
      details: error.message
    });
  }
});
router86.post("/generate-project", async (req2, res) => {
  try {
    const { siteName, industry, projectType, location } = req2.body;
    if (!siteName || !industry || !projectType) {
      return res.status(400).json({
        error: "Param\xE8tres manquants : siteName, industry, projectType requis"
      });
    }
    const content = await aiContentService.generateProject({
      siteName,
      industry,
      projectType,
      location
    });
    res.json({
      success: true,
      content
    });
  } catch (error) {
    console.error("Erreur g\xE9n\xE9ration projet:", error);
    res.status(500).json({
      error: "Erreur lors de la g\xE9n\xE9ration du projet",
      details: error.message
    });
  }
});
router86.post("/generate-testimonial", async (req2, res) => {
  try {
    const { siteName, industry, serviceType, customerType } = req2.body;
    if (!siteName || !industry || !serviceType) {
      return res.status(400).json({
        error: "Param\xE8tres manquants : siteName, industry, serviceType requis"
      });
    }
    const content = await aiContentService.generateTestimonial({
      siteName,
      industry,
      serviceType,
      customerType
    });
    res.json({
      success: true,
      content
    });
  } catch (error) {
    console.error("Erreur g\xE9n\xE9ration t\xE9moignage:", error);
    res.status(500).json({
      error: "Erreur lors de la g\xE9n\xE9ration du t\xE9moignage",
      details: error.message
    });
  }
});
router86.post("/generate-page", async (req2, res) => {
  try {
    const { siteName, siteType, industry, mainServices, targetAudience } = req2.body;
    if (!siteName || !siteType || !industry || !mainServices) {
      return res.status(400).json({
        error: "Param\xE8tres manquants : siteName, siteType, industry, mainServices requis"
      });
    }
    const content = await aiContentService.generatePageContent({
      siteName,
      siteType,
      industry,
      mainServices,
      targetAudience
    });
    res.json({
      success: true,
      content
    });
  } catch (error) {
    console.error("Erreur g\xE9n\xE9ration page:", error);
    res.status(500).json({
      error: "Erreur lors de la g\xE9n\xE9ration de la page",
      details: error.message
    });
  }
});
router86.post("/optimize-seo", async (req2, res) => {
  try {
    const { currentTitle, currentDescription, pageContent, targetKeywords, siteName, industry } = req2.body;
    if (!pageContent || !siteName || !industry) {
      return res.status(400).json({
        error: "Param\xE8tres manquants : pageContent, siteName, industry requis"
      });
    }
    const suggestions = await aiContentService.optimizeSEO({
      currentTitle,
      currentDescription,
      pageContent,
      targetKeywords,
      siteName,
      industry
    });
    res.json({
      success: true,
      suggestions
    });
  } catch (error) {
    console.error("Erreur optimisation SEO:", error);
    res.status(500).json({
      error: "Erreur lors de l'optimisation SEO",
      details: error.message
    });
  }
});
router86.post("/generate-multiple-services", async (req2, res) => {
  try {
    const { siteName, industry, serviceTypes } = req2.body;
    if (!siteName || !industry || !serviceTypes || !Array.isArray(serviceTypes)) {
      return res.status(400).json({
        error: "Param\xE8tres manquants : siteName, industry, serviceTypes (array) requis"
      });
    }
    const services = await aiContentService.generateMultipleServices({
      siteName,
      industry,
      serviceTypes
    });
    res.json({
      success: true,
      services,
      count: services.length
    });
  } catch (error) {
    console.error("Erreur g\xE9n\xE9ration multiple services:", error);
    res.status(500).json({
      error: "Erreur lors de la g\xE9n\xE9ration des services",
      details: error.message
    });
  }
});
var ai_content_default = router86;

// src/api/ai.ts
var import_express89 = __toESM(require("express"), 1);
var import_generative_ai2 = require("@google/generative-ai");
var router87 = import_express89.default.Router();
var genAI = new import_generative_ai2.GoogleGenerativeAI(process.env.GEMINI_API_KEY || "");
var MODEL_NAME = "gemini-pro";
router87.post("/generate", async (req2, res) => {
  try {
    const { prompt, context, sectionType, currentValue } = req2.body;
    if (!prompt) {
      return res.status(400).json({
        success: false,
        error: "Le prompt est requis"
      });
    }
    if (!process.env.GEMINI_API_KEY) {
      return res.status(500).json({
        success: false,
        error: "GEMINI_API_KEY non configur\xE9e"
      });
    }
    console.log(`[AI] G\xE9n\xE9ration pour context="${context}", section="${sectionType}"`);
    const model = genAI.getGenerativeModel({ model: MODEL_NAME });
    const generationConfig = {
      temperature: 0.8,
      topK: 40,
      topP: 0.95,
      maxOutputTokens: 2048
    };
    const result = await model.generateContent({
      contents: [{ role: "user", parts: [{ text: prompt }] }],
      generationConfig
    });
    const response = await result.response;
    const text = response.text();
    console.log(`[AI] R\xE9ponse re\xE7ue (${text.length} caract\xE8res)`);
    let suggestions;
    try {
      const jsonMatch = text.match(/\[[\s\S]*\]|\{[\s\S]*\}/);
      if (jsonMatch) {
        suggestions = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error("Pas de JSON trouv\xE9");
      }
    } catch (parseError) {
      console.warn("[AI] R\xE9ponse non-JSON, conversion en array");
      suggestions = parseNonJSONResponse(text, context);
    }
    const formattedSuggestions = formatSuggestions(suggestions, context);
    res.json({
      success: true,
      suggestions: formattedSuggestions,
      raw: text
      // Pour debug
    });
  } catch (error) {
    console.error("[AI] Erreur:", error);
    res.status(500).json({
      success: false,
      error: error.message || "Erreur lors de la g\xE9n\xE9ration IA",
      details: error.toString()
    });
  }
});
function parseNonJSONResponse(text, context) {
  const lines = text.split(/\n\n+|\n\d+\.\s+/).filter((l) => l.trim());
  switch (context) {
    case "title":
    case "subtitle":
    case "description":
      return lines.slice(0, 5).map((line) => line.trim());
    case "fullSection":
      return {
        title: lines[0] || "Titre g\xE9n\xE9r\xE9",
        subtitle: lines[1] || "Sous-titre g\xE9n\xE9r\xE9",
        description: lines[2] || "Description g\xE9n\xE9r\xE9e",
        items: lines.slice(3, 9).map((line, idx) => ({
          title: `\xC9l\xE9ment ${idx + 1}`,
          description: line
        }))
      };
    default:
      return lines;
  }
}
function formatSuggestions(data, context) {
  switch (context) {
    case "title":
    case "subtitle":
    case "description":
      if (Array.isArray(data)) {
        return data.map((item) => ({
          value: typeof item === "string" ? item : item.value || item.text || String(item),
          reason: typeof item === "object" ? item.reason : void 0
        }));
      }
      return [{ value: String(data) }];
    case "fullSection":
      if (Array.isArray(data)) {
        return data.map((item) => ({
          value: {
            title: item.title || "Titre",
            subtitle: item.subtitle || "Sous-titre",
            description: item.description || "Description",
            items: item.items || []
          },
          reason: item.reason
        }));
      }
      return [{
        value: {
          title: data.title || "Titre",
          subtitle: data.subtitle || "Sous-titre",
          description: data.description || "Description",
          items: data.items || []
        }
      }];
    case "layout":
      if (Array.isArray(data)) {
        return data.map((item) => ({
          value: {
            columns: item.columns || 3,
            rows: item.rows,
            gap: item.gap || 24,
            responsive: item.responsive || { mobile: 1, tablet: 2, desktop: 3 }
          },
          reason: item.reason
        }));
      }
      return [{
        value: {
          columns: data.columns || 3,
          rows: data.rows,
          gap: data.gap || 24,
          responsive: data.responsive || { mobile: 1, tablet: 2, desktop: 3 }
        }
      }];
    case "colors":
      if (Array.isArray(data)) {
        return data.map((item) => ({
          value: {
            primary: item.primary || "#1890ff",
            secondary: item.secondary || "#52c41a",
            accent: item.accent || "#faad14",
            background: item.background || "#ffffff",
            text: item.text || "#000000"
          },
          reason: item.reason
        }));
      }
      return [{
        value: {
          primary: data.primary || "#1890ff",
          secondary: data.secondary || "#52c41a",
          accent: data.accent || "#faad14",
          background: data.background || "#ffffff",
          text: data.text || "#000000"
        }
      }];
    default:
      if (Array.isArray(data)) {
        return data.map((item) => ({
          value: item,
          reason: typeof item === "object" ? item.reason : void 0
        }));
      }
      return [{ value: data }];
  }
}
router87.post("/analyze-section", async (req2, res) => {
  try {
    const { sectionType, content, prompt } = req2.body;
    if (!process.env.GEMINI_API_KEY) {
      return res.status(500).json({
        success: false,
        error: "GEMINI_API_KEY non configur\xE9e"
      });
    }
    console.log(`[AI Analyze] Section="${sectionType}"`);
    const model = genAI.getGenerativeModel({ model: MODEL_NAME });
    const generationConfig = {
      temperature: 0.7,
      // Moins cr√©atif, plus factuel
      topK: 40,
      topP: 0.95,
      maxOutputTokens: 4096
      // Plus long pour analyse d√©taill√©e
    };
    const result = await model.generateContent({
      contents: [{ role: "user", parts: [{ text: prompt }] }],
      generationConfig
    });
    const response = await result.response;
    const text = response.text();
    console.log(`[AI Analyze] R\xE9ponse re\xE7ue (${text.length} caract\xE8res)`);
    let analysis;
    try {
      const jsonMatch = text.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        analysis = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error("Pas de JSON trouv\xE9");
      }
    } catch (parseError) {
      console.warn("[AI Analyze] Parsing \xE9chou\xE9, g\xE9n\xE9ration d'analyse par d\xE9faut");
      analysis = generateFallbackAnalysis(sectionType, content);
    }
    const validatedAnalysis = validateAnalysis(analysis);
    res.json(validatedAnalysis);
  } catch (error) {
    console.error("[AI Analyze] Erreur:", error);
    res.json(generateFallbackAnalysis(req2.body.sectionType, req2.body.content));
  }
});
function validateAnalysis(analysis) {
  return {
    score: analysis.score || 70,
    suggestions: Array.isArray(analysis.suggestions) ? analysis.suggestions.map((s) => ({
      id: s.id || `suggestion-${Date.now()}-${Math.random()}`,
      category: s.category || "design",
      type: s.type || "improvement",
      title: s.title || "Am\xE9lioration sugg\xE9r\xE9e",
      description: s.description || "D\xE9tails non disponibles",
      impact: s.impact || "medium",
      changes: s.changes || {},
      preview: s.preview
    })) : [],
    summary: {
      strengths: Array.isArray(analysis.summary?.strengths) ? analysis.summary.strengths : ["Contenu pr\xE9sent"],
      weaknesses: Array.isArray(analysis.summary?.weaknesses) ? analysis.summary.weaknesses : ["Optimisation possible"],
      opportunities: Array.isArray(analysis.summary?.opportunities) ? analysis.summary.opportunities : ["Am\xE9lioration continue"]
    }
  };
}
function generateFallbackAnalysis(sectionType, content) {
  const itemCount = content?.values?.length || content?.stats?.length || content?.items?.length || 6;
  return {
    score: 65,
    suggestions: [
      {
        id: "layout-optimize",
        category: "layout",
        type: "improvement",
        title: "Optimiser le layout de la grille",
        description: `Avec ${itemCount} \xE9l\xE9ments, une disposition diff\xE9rente pourrait am\xE9liorer l'\xE9quilibre visuel.`,
        impact: "medium",
        changes: {
          "gridLayout": {
            columns: itemCount <= 4 ? itemCount : 3,
            gap: 32,
            responsive: { mobile: 1, tablet: 2, desktop: itemCount <= 4 ? itemCount : 3 }
          }
        },
        preview: {
          before: `Layout actuel`,
          after: `Layout optimis\xE9 pour ${itemCount} \xE9l\xE9ments`
        }
      },
      {
        id: "spacing-increase",
        category: "design",
        type: "improvement",
        title: "Augmenter l'espacement",
        description: "Un espacement de 32px am\xE9liorerait la respiration visuelle.",
        impact: "low",
        changes: {
          "gridLayout.gap": 32
        },
        preview: {
          before: "Espacement standard",
          after: "Espacement am\xE9lior\xE9 (32px)"
        }
      },
      {
        id: "header-improve",
        category: "content",
        type: "improvement",
        title: "Renforcer l'en-t\xEAte",
        description: "Ajouter un sous-titre explicatif renforcerait le message.",
        impact: "medium",
        changes: {
          "sectionHeader.subtitle": `D\xE9couvrez nos ${sectionType} adapt\xE9s \xE0 vos besoins`
        }
      }
    ],
    summary: {
      strengths: [
        "Structure claire",
        "Contenu pr\xE9sent",
        "Design coh\xE9rent"
      ],
      weaknesses: [
        "Layout pourrait \xEAtre optimis\xE9",
        "Espacement \xE0 am\xE9liorer",
        "En-t\xEAte \xE0 renforcer"
      ],
      opportunities: [
        "Meilleure utilisation de l'espace",
        "Plus d'impact visuel",
        "Message plus clair"
      ]
    }
  };
}
router87.post("/optimize-seo", async (req2, res) => {
  try {
    const { content, sectionType } = req2.body;
    if (!process.env.GEMINI_API_KEY) {
      return res.status(500).json({
        success: false,
        error: "GEMINI_API_KEY non configur\xE9e"
      });
    }
    const model = genAI.getGenerativeModel({ model: MODEL_NAME });
    const prompt = `Tu es un expert SEO. Optimise ce contenu pour le r\xE9f\xE9rencement :

Section : ${sectionType}
Contenu actuel : ${JSON.stringify(content)}

G\xE9n\xE8re :
1. Meta title (max 60 caract\xE8res, optimis\xE9 SEO)
2. Meta description (max 160 caract\xE8res, incite au clic)
3. 5 mots-cl\xE9s pertinents
4. Slug URL optimis\xE9
5. Balises alt pour images (3 suggestions)

Format de r\xE9ponse : JSON avec { metaTitle, metaDescription, keywords: [], slug, altTexts: [] }`;
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    const seoData = jsonMatch ? JSON.parse(jsonMatch[0]) : {};
    res.json({
      success: true,
      seo: seoData
    });
  } catch (error) {
    console.error("[AI SEO] Erreur:", error);
    res.status(500).json({
      success: false,
      error: error.message || "Erreur lors de l'optimisation SEO"
    });
  }
});
router87.post("/improve-content", async (req2, res) => {
  try {
    const { content, instructions } = req2.body;
    if (!process.env.GEMINI_API_KEY) {
      return res.status(500).json({
        success: false,
        error: "GEMINI_API_KEY non configur\xE9e"
      });
    }
    const model = genAI.getGenerativeModel({ model: MODEL_NAME });
    const prompt = `Am\xE9liore ce contenu selon les instructions suivantes :

Contenu actuel :
${JSON.stringify(content, null, 2)}

Instructions :
${instructions || "Rendre plus engageant, professionnel et optimis\xE9 pour la conversion"}

Retourne le contenu am\xE9lior\xE9 au format JSON identique \xE0 l'original.`;
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    const improvedContent = jsonMatch ? JSON.parse(jsonMatch[0]) : content;
    res.json({
      success: true,
      improved: improvedContent,
      original: content
    });
  } catch (error) {
    console.error("[AI Improve] Erreur:", error);
    res.status(500).json({
      success: false,
      error: error.message || "Erreur lors de l'am\xE9lioration du contenu"
    });
  }
});
router87.post("/optimize-layout", async (req2, res) => {
  try {
    const { itemCount, sectionType, currentLayout } = req2.body;
    if (!process.env.GEMINI_API_KEY) {
      return res.status(500).json({
        success: false,
        error: "GEMINI_API_KEY non configur\xE9e"
      });
    }
    const model = genAI.getGenerativeModel({ model: MODEL_NAME });
    const prompt = `Tu es un expert en UI/UX et design responsive.

Type de section : ${sectionType}
Nombre d'\xE9l\xE9ments : ${itemCount}
Layout actuel : ${JSON.stringify(currentLayout || {})}

Sugg\xE8re 3 configurations de grille CSS optimales pour cette section.
Pour chaque configuration, explique pourquoi elle est adapt\xE9e.

Format de r\xE9ponse : JSON array avec :
[
  {
    "preset": "3x2" (ou "custom"),
    "columns": 3,
    "rows": 2,
    "gap": 24,
    "responsive": {
      "mobile": 1,
      "tablet": 2,
      "desktop": 3
    },
    "reason": "Explication de pourquoi ce layout est optimal"
  }
]`;
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();
    const jsonMatch = text.match(/\[[\s\S]*\]/);
    let layouts = jsonMatch ? JSON.parse(jsonMatch[0]) : [];
    if (!Array.isArray(layouts) || layouts.length === 0) {
      layouts = generateFallbackLayouts(itemCount);
    }
    res.json({
      success: true,
      layouts: layouts.slice(0, 3)
      // Max 3 suggestions
    });
  } catch (error) {
    console.error("[AI Layout] Erreur:", error);
    res.json({
      success: true,
      layouts: generateFallbackLayouts(req2.body.itemCount || 6)
    });
  }
});
router87.post("/generate-palette", async (req2, res) => {
  try {
    const { baseColor, mood, industry } = req2.body;
    if (!process.env.GEMINI_API_KEY) {
      return res.status(500).json({
        success: false,
        error: "GEMINI_API_KEY non configur\xE9e"
      });
    }
    const model = genAI.getGenerativeModel({ model: MODEL_NAME });
    const prompt = `Tu es un expert en th\xE9orie des couleurs et design.

Couleur de base : ${baseColor || "#1890ff"}
Ambiance souhait\xE9e : ${mood || "professionnelle, moderne"}
Secteur d'activit\xE9 : ${industry || "technologie"}

G\xE9n\xE8re 3 palettes de couleurs harmonieuses avec :
- primary : couleur principale
- secondary : couleur secondaire
- accent : couleur d'accentuation
- background : couleur de fond
- text : couleur de texte
- success, warning, error : couleurs de statut

Format : JSON array avec :
[
  {
    "name": "Nom de la palette",
    "primary": "#RRGGBB",
    "secondary": "#RRGGBB",
    "accent": "#RRGGBB",
    "background": "#RRGGBB",
    "text": "#RRGGBB",
    "success": "#RRGGBB",
    "warning": "#RRGGBB",
    "error": "#RRGGBB",
    "reason": "Pourquoi cette palette est adapt\xE9e"
  }
]`;
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();
    const jsonMatch = text.match(/\[[\s\S]*\]/);
    let palettes = jsonMatch ? JSON.parse(jsonMatch[0]) : [];
    if (!Array.isArray(palettes) || palettes.length === 0) {
      palettes = generateFallbackPalettes(baseColor);
    }
    res.json({
      success: true,
      palettes: palettes.slice(0, 3)
    });
  } catch (error) {
    console.error("[AI Palette] Erreur:", error);
    res.json({
      success: true,
      palettes: generateFallbackPalettes(req2.body.baseColor || "#1890ff")
    });
  }
});
function generateFallbackLayouts(itemCount) {
  const layouts = [];
  if (itemCount <= 3) {
    layouts.push({
      preset: "1x1",
      columns: itemCount,
      gap: 24,
      responsive: { mobile: 1, tablet: 2, desktop: itemCount },
      reason: "Layout horizontal adapt\xE9 pour peu d'\xE9l\xE9ments"
    });
  } else if (itemCount <= 6) {
    layouts.push({
      preset: "3x2",
      columns: 3,
      rows: 2,
      gap: 24,
      responsive: { mobile: 1, tablet: 2, desktop: 3 },
      reason: "Grille 3 colonnes \xE9quilibr\xE9e"
    });
  } else if (itemCount <= 9) {
    layouts.push({
      preset: "3x3",
      columns: 3,
      rows: 3,
      gap: 20,
      responsive: { mobile: 1, tablet: 2, desktop: 3 },
      reason: "Grille 3x3 pour 7-9 \xE9l\xE9ments"
    });
  } else {
    layouts.push({
      preset: "4x3",
      columns: 4,
      rows: Math.ceil(itemCount / 4),
      gap: 16,
      responsive: { mobile: 1, tablet: 2, desktop: 4 },
      reason: "Grille dense pour nombreux \xE9l\xE9ments"
    });
  }
  return layouts;
}
function generateFallbackPalettes(baseColor) {
  return [
    {
      name: "Palette Professionnelle",
      primary: baseColor || "#1890ff",
      secondary: "#52c41a",
      accent: "#faad14",
      background: "#ffffff",
      text: "#000000",
      success: "#52c41a",
      warning: "#faad14",
      error: "#ff4d4f",
      reason: "Couleurs \xE9quilibr\xE9es et professionnelles"
    },
    {
      name: "Palette Moderne",
      primary: "#722ed1",
      secondary: "#13c2c2",
      accent: "#fadb14",
      background: "#f0f2f5",
      text: "#262626",
      success: "#52c41a",
      warning: "#fa8c16",
      error: "#f5222d",
      reason: "Design moderne avec contraste \xE9lev\xE9"
    },
    {
      name: "Palette \xC9l\xE9gante",
      primary: "#2f54eb",
      secondary: "#eb2f96",
      accent: "#faad14",
      background: "#fafafa",
      text: "#141414",
      success: "#73d13d",
      warning: "#ffc53d",
      error: "#ff7875",
      reason: "\xC9l\xE9gance et sophistication"
    }
  ];
}
var geminiMeasureService = getGeminiService();
router87.post("/measure-image", async (req2, res) => {
  const startTime = Date.now();
  try {
    const {
      imageBase64,
      // Image en base64 (sans le pr√©fixe data:image/...)
      mimeType,
      // Type MIME (image/jpeg, image/png, etc.)
      prompt,
      // Prompt personnalis√© pour l'analyse
      measureKeys,
      // Cl√©s √† extraire (ex: ["largeur", "hauteur", "type"])
      nodeId,
      // ID du n≈ìud source (pour logging)
      treeId
      // ID de l'arbre (pour logging)
    } = req2.body;
    if (!imageBase64) {
      return res.status(400).json({
        success: false,
        error: "Image base64 requise"
      });
    }
    if (!mimeType) {
      return res.status(400).json({
        success: false,
        error: "Type MIME requis"
      });
    }
    if (!prompt) {
      return res.status(400).json({
        success: false,
        error: "Prompt requis"
      });
    }
    if (!measureKeys || !Array.isArray(measureKeys) || measureKeys.length === 0) {
      return res.status(400).json({
        success: false,
        error: "Liste des cl\xE9s \xE0 extraire requise"
      });
    }
    console.log(`\u{1F4D0} [AI Measure] Analyse pour node=${nodeId}, tree=${treeId}, ${measureKeys.length} cl\xE9s`);
    const result = await geminiMeasureService.analyzeImageForMeasures(
      imageBase64,
      mimeType,
      prompt,
      measureKeys
    );
    const duration = Date.now() - startTime;
    if (!result.success) {
      console.error(`\u274C [AI Measure] \xC9chec apr\xE8s ${duration}ms:`, result.error);
      return res.status(500).json({
        success: false,
        error: result.error || "Erreur lors de l'analyse de l'image",
        duration
      });
    }
    console.log(`\u2705 [AI Measure] Succ\xE8s en ${duration}ms, ${Object.keys(result.measurements || {}).length} mesures extraites`);
    return res.json({
      success: true,
      measurements: result.measurements,
      rawResponse: result.rawResponse,
      metadata: {
        model: result.model,
        duration,
        nodeId,
        treeId,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }
    });
  } catch (error) {
    const duration = Date.now() - startTime;
    console.error("\u274C [AI Measure] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: error.message || "Erreur interne",
      duration
    });
  }
});
router87.post("/measure-image/apply", async (req2, res) => {
  try {
    const {
      measurements,
      // Mesures extraites { key: value }
      mappings,
      // Mappings { key, targetRef, type }[]
      treeId,
      organizationId
    } = req2.body;
    if (!measurements || typeof measurements !== "object") {
      return res.status(400).json({
        success: false,
        error: "Mesures requises"
      });
    }
    if (!mappings || !Array.isArray(mappings) || mappings.length === 0) {
      return res.status(400).json({
        success: false,
        error: "Mappings requis"
      });
    }
    console.log(`\u{1F3AF} [AI Measure Apply] Application de ${Object.keys(measurements).length} mesures vers ${mappings.length} champs`);
    const updates = [];
    for (const mapping of mappings) {
      const { key: key2, targetRef, type } = mapping;
      const value = measurements[key2];
      if (value !== void 0 && value !== "non_visible") {
        let finalValue = value;
        if (type === "number" && typeof value === "string") {
          const parsed = parseFloat(value);
          if (!isNaN(parsed)) {
            finalValue = parsed;
          }
        }
        updates.push({
          targetRef,
          value: finalValue,
          key: key2
        });
      }
    }
    console.log(`\u2705 [AI Measure Apply] ${updates.length} mises \xE0 jour pr\xE9par\xE9es`);
    return res.json({
      success: true,
      updates,
      skipped: mappings.length - updates.length,
      metadata: {
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }
    });
  } catch (error) {
    console.error("\u274C [AI Measure Apply] Erreur:", error);
    return res.status(500).json({
      success: false,
      error: error.message || "Erreur interne"
    });
  }
});
router87.get("/measure-image/status", async (_req, res) => {
  try {
    const status = geminiMeasureService.getStatus();
    res.json({
      success: true,
      available: status.mode === "live",
      service: "Google Gemini Vision",
      model: status.model,
      mode: status.mode,
      degraded: status.degraded,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      available: false,
      error: error.message
    });
  }
});
var ai_default2 = router87;

// src/routes/ai-field-generator.ts
var import_express90 = __toESM(require("express"), 1);
var router88 = import_express90.default.Router();
var geminiService3 = getGeminiService();
router88.use(authMiddleware);
var SmartPromptBuilder = class {
  /**
   * Construit un prompt optimis√© selon le type de champ
   */
  static buildPrompt(params) {
    const { fieldId, fieldType, fieldLabel, currentValue, aiContext } = params;
    const language = aiContext.language || "fran\xE7ais";
    const tone = aiContext.tone || "professionnel et convaincant";
    const audience = aiContext.targetAudience || "clients potentiels";
    const business = aiContext.businessType || "services \xE9nerg\xE9tiques";
    const keywords = aiContext.keywords?.join(", ") || "";
    const baseContext = `
Tu es un expert en r\xE9daction web, marketing digital et SEO pour le secteur ${business}.

CONTEXTE:
- Type de section: ${aiContext.sectionType}
- Champ \xE0 g\xE9n\xE9rer: ${fieldLabel} (${fieldId})
- Public cible: ${audience}
- Ton: ${tone}
- Langue: ${language}
${keywords ? `- Mots-cl\xE9s sugg\xE9r\xE9s: ${keywords}` : ""}
${currentValue ? `- Valeur actuelle: "${currentValue}"` : ""}
`;
    switch (fieldType) {
      case "text":
        return this.buildTextPrompt(baseContext, fieldId, fieldLabel, currentValue);
      case "textarea":
        return this.buildTextareaPrompt(baseContext, fieldId, fieldLabel, currentValue);
      case "select":
      case "multiselect":
        return this.buildSelectPrompt(baseContext, fieldId, fieldLabel, currentValue);
      case "richtext":
        return this.buildRichtextPrompt(baseContext, fieldId, fieldLabel, currentValue);
      default:
        return this.buildGenericPrompt(baseContext, fieldLabel, currentValue);
    }
  }
  /**
   * Prompt pour champs texte courts (titres, labels, CTA)
   */
  static buildTextPrompt(context, fieldId, label, current) {
    const isTitle = fieldId.toLowerCase().includes("title") || label.toLowerCase().includes("titre");
    const isCTA = fieldId.toLowerCase().includes("cta") || label.toLowerCase().includes("bouton");
    const isLabel = fieldId.toLowerCase().includes("label");
    let specificGuidelines = "";
    let maxLength = 60;
    if (isTitle) {
      specificGuidelines = `
GUIDELINES SP\xC9CIFIQUES TITRE:
- Accrocheur et m\xE9morable
- Orient\xE9 b\xE9n\xE9fice client
- Inclure un chiffre ou statistique si pertinent
- \xC9voquer la transformation ou le r\xE9sultat
- Cr\xE9er de la curiosit\xE9 ou urgence
`;
      maxLength = 60;
    } else if (isCTA) {
      specificGuidelines = `
GUIDELINES SP\xC9CIFIQUES CTA:
- Verbe d'action \xE0 l'imp\xE9ratif
- Court et percutant (3-5 mots maximum)
- Cr\xE9er l'urgence ou la valeur
- Exemples: "Demander un devis gratuit", "D\xE9couvrir nos solutions", "Calculer mes \xE9conomies"
`;
      maxLength = 40;
    } else if (isLabel) {
      specificGuidelines = `
GUIDELINES SP\xC9CIFIQUES LABEL:
- Clair et descriptif
- Terme professionnel mais accessible
- Coh\xE9rent avec le secteur
`;
      maxLength = 40;
    }
    return `${context}

${specificGuidelines}

T\xC2CHE: G\xE9n\xE8re 3 PROPOSITIONS VARI\xC9ES pour ce champ texte court.

CONTRAINTES:
- Maximum ${maxLength} caract\xE8res par proposition
- Ton professionnel et convaincant
- Optimis\xE9 SEO naturellement
- \xC9viter les clich\xE9s et phrases creuses
- Vari\xE9t\xE9 dans les approches (angle diff\xE9rent pour chaque proposition)

Retourne UNIQUEMENT un objet JSON valide avec cette structure:
{
  "suggestions": [
    {
      "content": "Proposition 1",
      "reasoning": "Pourquoi cette proposition (1 phrase)",
      "score": 85
    },
    {
      "content": "Proposition 2", 
      "reasoning": "Pourquoi cette proposition (1 phrase)",
      "score": 90
    },
    {
      "content": "Proposition 3",
      "reasoning": "Pourquoi cette proposition (1 phrase)", 
      "score": 80
    }
  ],
  "analysis": {
    "fieldType": "${fieldId}",
    "bestApproach": "Approche recommand\xE9e (1 phrase)",
    "keywords": ["mot-cl\xE9 1", "mot-cl\xE9 2", "mot-cl\xE9 3"],
    "avgScore": 85
  }
}

\u26A0\uFE0F IMPORTANT: Retourne UNIQUEMENT le JSON, aucun texte avant ou apr\xE8s.`;
  }
  /**
   * Prompt pour champs textarea (descriptions, paragraphes)
   */
  static buildTextareaPrompt(context, fieldId, label, current) {
    const isDescription = fieldId.toLowerCase().includes("description") || label.toLowerCase().includes("description");
    const isAbout = fieldId.toLowerCase().includes("about") || label.toLowerCase().includes("pr\xE9sentation");
    let specificGuidelines = "";
    let maxLength = 200;
    if (isDescription) {
      specificGuidelines = `
GUIDELINES SP\xC9CIFIQUES DESCRIPTION:
- 2-3 phrases persuasives
- Structure: Probl\xE8me \u2192 Solution \u2192 B\xE9n\xE9fice
- Inclure des chiffres/donn\xE9es si pertinent
- Call-to-action implicite
- Optimis\xE9 pour la conversion
`;
      maxLength = 200;
    } else if (isAbout) {
      specificGuidelines = `
GUIDELINES SP\xC9CIFIQUES \xC0 PROPOS:
- 3-4 phrases engageantes
- Histoire/mission de l'entreprise
- Valeurs et diff\xE9renciateurs
- Preuve sociale ou chiffres cl\xE9s
- Cr\xE9er la confiance
`;
      maxLength = 300;
    }
    return `${context}

${specificGuidelines}

T\xC2CHE: G\xE9n\xE8re 3 PROPOSITIONS VARI\xC9ES pour ce champ texte long.

CONTRAINTES:
- Maximum ${maxLength} caract\xE8res par proposition
- Style fluide et naturel
- Ponctuation et structure professionnelle
- Int\xE9gration naturelle des mots-cl\xE9s
- \xC9viter le jargon excessif
- Vari\xE9t\xE9 dans les angles (rationnel, \xE9motionnel, social proof)

Retourne UNIQUEMENT un objet JSON valide avec cette structure:
{
  "suggestions": [
    {
      "content": "Proposition 1 (2-3 phrases)",
      "reasoning": "Pourquoi cette proposition (1 phrase)",
      "score": 88,
      "angle": "angle rationnel / \xE9motionnel / social proof"
    },
    {
      "content": "Proposition 2 (2-3 phrases)",
      "reasoning": "Pourquoi cette proposition (1 phrase)",
      "score": 92,
      "angle": "angle rationnel / \xE9motionnel / social proof"
    },
    {
      "content": "Proposition 3 (2-3 phrases)",
      "reasoning": "Pourquoi cette proposition (1 phrase)",
      "score": 85,
      "angle": "angle rationnel / \xE9motionnel / social proof"
    }
  ],
  "analysis": {
    "fieldType": "${fieldId}",
    "bestApproach": "Approche recommand\xE9e (1 phrase)",
    "keywords": ["mot-cl\xE9 1", "mot-cl\xE9 2", "mot-cl\xE9 3", "mot-cl\xE9 4"],
    "avgScore": 88,
    "readabilityTips": ["Conseil 1", "Conseil 2"]
  }
}

\u26A0\uFE0F IMPORTANT: Retourne UNIQUEMENT le JSON, aucun texte avant ou apr\xE8s.`;
  }
  /**
   * Prompt pour champs select/multiselect (features, tags, options)
   */
  static buildSelectPrompt(context, fieldId, label, current) {
    const isFeatures = fieldId.toLowerCase().includes("feature") || label.toLowerCase().includes("caract\xE9ristique");
    const isTags = fieldId.toLowerCase().includes("tag") || label.toLowerCase().includes("\xE9tiquette");
    const isBenefits = fieldId.toLowerCase().includes("benefit") || label.toLowerCase().includes("avantage");
    let specificGuidelines = "";
    let itemCount = 4;
    if (isFeatures) {
      specificGuidelines = `
GUIDELINES SP\xC9CIFIQUES FEATURES:
- Caract\xE9ristiques techniques ET b\xE9n\xE9fices
- Format: "B\xE9n\xE9fice concret + d\xE9tail technique"
- Exemples: "Garantie 25 ans sur les panneaux", "Installation en 2 jours chrono"
- M\xE9langer aspects techniques, pratiques, et commerciaux
`;
      itemCount = 4;
    } else if (isTags) {
      specificGuidelines = `
GUIDELINES SP\xC9CIFIQUES TAGS:
- Mots-cl\xE9s courts (1-3 mots)
- Descriptifs et recherchables
- Mix: technique + cat\xE9gorie + b\xE9n\xE9fice
- Exemples: "\xC9nergie verte", "R\xE9sidentiel", "Haute performance"
`;
      itemCount = 5;
    } else if (isBenefits) {
      specificGuidelines = `
GUIDELINES SP\xC9CIFIQUES AVANTAGES:
- Orient\xE9 r\xE9sultat client
- Quantifiable si possible
- \xC9motionnel + rationnel
- Exemples: "R\xE9duisez vos factures de 60%", "Installation garantie d\xE9cennale"
`;
      itemCount = 4;
    }
    return `${context}

${specificGuidelines}

T\xC2CHE: G\xE9n\xE8re ${itemCount} ITEMS PERTINENTS ET VARI\xC9S pour ce champ liste.

CONTRAINTES:
- ${itemCount} items par proposition
- Chaque item: 5-12 mots maximum
- Coh\xE9rence et compl\xE9mentarit\xE9 entre les items
- \xC9viter les r\xE9p\xE9titions
- Mix de types: technique, pratique, \xE9motionnel, chiffr\xE9

Retourne UNIQUEMENT un objet JSON valide avec cette structure:
{
  "suggestions": [
    {
      "content": ["Item 1", "Item 2", "Item 3", "Item 4"],
      "reasoning": "Logique de s\xE9lection (1 phrase)",
      "score": 87
    },
    {
      "content": ["Item 1", "Item 2", "Item 3", "Item 4"],
      "reasoning": "Logique de s\xE9lection (1 phrase)",
      "score": 91
    },
    {
      "content": ["Item 1", "Item 2", "Item 3", "Item 4"],
      "reasoning": "Logique de s\xE9lection (1 phrase)",
      "score": 84
    }
  ],
  "analysis": {
    "fieldType": "${fieldId}",
    "bestApproach": "Approche recommand\xE9e (1 phrase)",
    "keywords": ["mot-cl\xE9 1", "mot-cl\xE9 2", "mot-cl\xE9 3"],
    "avgScore": 87
  }
}

\u26A0\uFE0F IMPORTANT: Retourne UNIQUEMENT le JSON, aucun texte avant ou apr\xE8s.`;
  }
  /**
   * Prompt pour richtext (contenu HTML/Markdown enrichi)
   */
  static buildRichtextPrompt(context, fieldId, label, current) {
    return `${context}

T\xC2CHE: G\xE9n\xE8re 2 PROPOSITIONS VARI\xC9ES de contenu enrichi (paragraphes structur\xE9s).

CONTRAINTES:
- 2-4 paragraphes par proposition
- Structure: Intro \u2192 D\xE9veloppement \u2192 Conclusion/CTA
- Ton professionnel et engageant
- Int\xE9gration naturelle des mots-cl\xE9s
- Lisibilit\xE9 optimale (phrases courtes, transitions)

Retourne UNIQUEMENT un objet JSON valide avec cette structure:
{
  "suggestions": [
    {
      "content": "Paragraphe 1

Paragraphe 2

Paragraphe 3",
      "reasoning": "Pourquoi cette proposition (1 phrase)",
      "score": 89,
      "structure": "intro + b\xE9n\xE9fices + preuve sociale"
    },
    {
      "content": "Paragraphe 1

Paragraphe 2

Paragraphe 3",
      "reasoning": "Pourquoi cette proposition (1 phrase)",
      "score": 92,
      "structure": "probl\xE8me + solution + r\xE9sultats"
    }
  ],
  "analysis": {
    "fieldType": "${fieldId}",
    "bestApproach": "Approche recommand\xE9e (1 phrase)",
    "keywords": ["mot-cl\xE9 1", "mot-cl\xE9 2", "mot-cl\xE9 3", "mot-cl\xE9 4"],
    "avgScore": 90,
    "readabilityScore": 85
  }
}

\u26A0\uFE0F IMPORTANT: Retourne UNIQUEMENT le JSON, aucun texte avant ou apr\xE8s.`;
  }
  /**
   * Prompt g√©n√©rique pour types inconnus
   */
  static buildGenericPrompt(context, label, current) {
    return `${context}

T\xC2CHE: G\xE9n\xE8re 3 PROPOSITIONS PERTINENTES pour le champ "${label}".

Retourne UNIQUEMENT un objet JSON valide avec cette structure:
{
  "suggestions": [
    {
      "content": "Proposition 1",
      "reasoning": "Pourquoi cette proposition (1 phrase)",
      "score": 85
    },
    {
      "content": "Proposition 2",
      "reasoning": "Pourquoi cette proposition (1 phrase)",
      "score": 88
    },
    {
      "content": "Proposition 3",
      "reasoning": "Pourquoi cette proposition (1 phrase)",
      "score": 82
    }
  ],
  "analysis": {
    "fieldType": "${label}",
    "bestApproach": "Approche recommand\xE9e (1 phrase)",
    "keywords": ["mot-cl\xE9 1", "mot-cl\xE9 2", "mot-cl\xE9 3"],
    "avgScore": 85
  }
}

\u26A0\uFE0F IMPORTANT: Retourne UNIQUEMENT le JSON, aucun texte avant ou apr\xE8s.`;
  }
};
var QualityAnalyzer = class {
  /**
   * Analyse et enrichit les suggestions avec des m√©triques
   */
  static analyzeSuggestions(response, fieldType) {
    try {
      const scores = response.suggestions.map((s) => s.score || 0);
      const avgScore = scores.length > 0 ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length) : 0;
      response.suggestions.sort((a, b) => (b.score || 0) - (a.score || 0));
      response.analysis = {
        ...response.analysis,
        avgScore,
        generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        fieldType,
        qualityLevel: avgScore >= 90 ? "excellent" : avgScore >= 80 ? "good" : avgScore >= 70 ? "acceptable" : "needs-improvement"
      };
      return response;
    } catch (error) {
      console.error("\u274C [QualityAnalyzer] Erreur analyse:", error);
      return response;
    }
  }
};
router88.post("/generate-field", async (req2, res) => {
  const startTime = Date.now();
  try {
    const { fieldId, fieldType, fieldLabel, currentValue, aiContext } = req2.body;
    if (!fieldId || !fieldType || !fieldLabel) {
      return res.status(400).json({
        success: false,
        error: "Param\xE8tres manquants",
        details: "fieldId, fieldType et fieldLabel sont requis"
      });
    }
    if (!aiContext || !aiContext.sectionType) {
      return res.status(400).json({
        success: false,
        error: "Contexte IA manquant",
        details: "aiContext.sectionType est requis"
      });
    }
    console.log("\u{1F916} [AI] G\xE9n\xE9ration pour:", {
      fieldId,
      fieldType,
      fieldLabel,
      sectionType: aiContext.sectionType
    });
    const prompt = SmartPromptBuilder.buildPrompt({
      fieldId,
      fieldType,
      fieldLabel,
      currentValue,
      aiContext
    });
    console.log("\u{1F4DD} [AI] Prompt construit, appel \xE0 Gemini...");
    const geminiResult = await geminiService3.chat({ prompt, raw: true });
    if (!geminiResult.success || !geminiResult.content) {
      throw new Error(geminiResult.error || "Erreur lors de l'appel \xE0 Gemini");
    }
    console.log("\u2705 [AI] R\xE9ponse brute re\xE7ue:", geminiResult.content.substring(0, 200));
    const jsonMatch = geminiResult.content.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error("Format de r\xE9ponse invalide: JSON non trouv\xE9 dans la r\xE9ponse IA");
    }
    let parsedResponse = JSON.parse(jsonMatch[0]);
    parsedResponse = QualityAnalyzer.analyzeSuggestions(parsedResponse, fieldType);
    const duration = Date.now() - startTime;
    const modelUsed = geminiResult.model || geminiService3.getStatus().model;
    console.log(`\u2705 [AI] G\xE9n\xE9ration r\xE9ussie en ${duration}ms, score moyen: ${parsedResponse.analysis.avgScore}/100`);
    return res.json({
      success: true,
      content: parsedResponse.suggestions[0]?.content,
      // Meilleure suggestion par d√©faut
      suggestions: parsedResponse.suggestions,
      analysis: parsedResponse.analysis,
      metadata: {
        generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        duration,
        model: modelUsed,
        fieldType,
        fieldId
      }
    });
  } catch (error) {
    const duration = Date.now() - startTime;
    console.error("\u274C [AI] Erreur g\xE9n\xE9ration:", error);
    if (error.message?.includes("API key")) {
      return res.status(500).json({
        success: false,
        error: "Configuration IA manquante",
        details: "La cl\xE9 API Google Gemini n'est pas configur\xE9e",
        duration
      });
    }
    if (error.message?.includes("quota") || error.message?.includes("rate limit")) {
      return res.status(429).json({
        success: false,
        error: "Limite de quota atteinte",
        details: "Trop de requ\xEAtes IA. Attendez quelques instants.",
        duration
      });
    }
    return res.status(500).json({
      success: false,
      error: "Erreur lors de la g\xE9n\xE9ration",
      details: error.message || "Erreur inconnue",
      duration
    });
  }
});
router88.get("/status", async (_req, res) => {
  try {
    const isAvailable = !!process.env.GOOGLE_API_KEY || !!process.env.GEMINI_API_KEY;
    res.json({
      success: true,
      available: isAvailable,
      service: "Google Gemini",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      available: false,
      error: error.message
    });
  }
});
var ai_field_generator_default = router88;

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/repeat-routes.ts
var import_express91 = require("express");

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/repeat-blueprint-builder.ts
var parseJsonArray = (value) => {
  if (!value) return [];
  try {
    const parsed = JSON.parse(value);
    return Array.isArray(parsed) ? parsed : [];
  } catch {
    return [];
  }
};
async function buildBlueprintForRepeater(prisma51, repeaterNodeId) {
  if (!repeaterNodeId) {
    console.warn(`[repeat-blueprint-builder] Missing repeaterNodeId`);
    return null;
  }
  const cached = captureRepeatTemplate(repeaterNodeId);
  if (cached) {
    const repeaterNodeForCache = await prisma51.treeBranchLeafNode.findUnique({
      where: { id: repeaterNodeId },
      select: { metadata: true, repeater_templateNodeIds: true }
    });
    const candidateTemplateIds = repeaterNodeForCache ? extractTemplateIds(repeaterNodeForCache) : [];
    const { validIds: cachedTemplateIds } = await filterExistingTemplateNodeIds(
      prisma51,
      repeaterNodeId,
      candidateTemplateIds
    );
    if (cachedTemplateIds.length) {
      const validTemplateSet = new Set(cachedTemplateIds);
      return {
        ...cached,
        repeaterNodeId,
        templateNodeIds: cachedTemplateIds,
        variables: cached.variables?.filter((v) => !v.nodeId || validTemplateSet.has(v.nodeId)) ?? [],
        capacities: cached.capacities?.filter((c) => !c.ownerNodeId || validTemplateSet.has(c.ownerNodeId)) ?? [],
        totalField: cached.totalField
      };
    }
    console.warn("[repeat-blueprint-builder] Cached blueprint invalid, falling back to Prisma lookup", {
      repeaterNodeId,
      candidateTemplateIds
    });
  }
  const repeaterNode = await prisma51.treeBranchLeafNode.findUnique({
    where: { id: repeaterNodeId },
    select: {
      id: true,
      repeater_templateNodeIds: true,
      metadata: true,
      treeId: true
    }
  });
  if (!repeaterNode) {
    console.warn(`[repeat-blueprint-builder] \xC3\xA2\xC2\x9D\xC5\u2019 Repeater node not found: ${repeaterNodeId}`);
    return null;
  }
  const extractedIds = extractTemplateIds(repeaterNode);
  const candidateTemplateNodeIds = extractedIds;
  const { validIds: templateNodeIds } = await filterExistingTemplateNodeIds(
    prisma51,
    repeaterNodeId,
    candidateTemplateNodeIds
  );
  if (!templateNodeIds.length) {
    console.warn(`[repeat-blueprint-builder] \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F No valid templates found!`);
    return {
      repeaterNodeId,
      templateNodeIds: [],
      variables: [],
      capacities: [],
      capturedAt: (/* @__PURE__ */ new Date()).toISOString(),
      lastUpdatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  const directVariables = await prisma51.treeBranchLeafNodeVariable.findMany({
    where: { nodeId: { in: templateNodeIds } },
    select: {
      id: true,
      nodeId: true,
      sourceRef: true,
      sourceType: true
    }
  });
  const linkedVarsByNode = /* @__PURE__ */ new Map();
  const templateNodesWithLinks = await prisma51.treeBranchLeafNode.findMany({
    where: { id: { in: templateNodeIds } },
    select: {
      id: true,
      linkedVariableIds: true
    }
  });
  const cleanVariableId = (id) => {
    if (!id) return id;
    return id.replace(/(-\d+)+$/, "");
  };
  const suffixedToOriginal = /* @__PURE__ */ new Map();
  for (const node of templateNodesWithLinks) {
    if (node.linkedVariableIds && node.linkedVariableIds.length > 0) {
      for (const varId of node.linkedVariableIds) {
        const cleanedId = cleanVariableId(varId);
        if (cleanedId !== varId) {
          suffixedToOriginal.set(varId, cleanedId);
        }
        if (!linkedVarsByNode.has(cleanedId)) {
          linkedVarsByNode.set(cleanedId, /* @__PURE__ */ new Set());
        }
        linkedVarsByNode.get(cleanedId).add(node.id);
      }
    }
  }
  const linkedVariableIds = Array.from(linkedVarsByNode.keys()).filter(
    (id) => !directVariables.some((v) => v.id === id)
    // Avoid duplicates
  );
  const linkedVariables = linkedVariableIds.length > 0 ? await prisma51.treeBranchLeafNodeVariable.findMany({
    where: { id: { in: linkedVariableIds } },
    select: {
      id: true,
      nodeId: true,
      sourceRef: true,
      sourceType: true
    }
  }) : [];
  const expandedVariables = [];
  for (const directVar of directVariables) {
    expandedVariables.push({
      ...directVar,
      variableId: directVar.id,
      linkedToNodeIds: []
      // Direct variables don't have this
    });
  }
  for (const linkedVar of linkedVariables) {
    const referencingNodeIds = Array.from(linkedVarsByNode.get(linkedVar.id) || []);
    for (const nodeId of referencingNodeIds) {
      expandedVariables.push({
        ...linkedVar,
        variableId: linkedVar.id,
        linkedToNodeIds: [nodeId],
        // This variable is linked to this template node
        primaryTargetNodeId: nodeId
        // √É¬¢√¢‚Ç¨¬†√Ç¬ê The node that should receive the copied variable's display node
      });
    }
  }
  const variables = expandedVariables;
  const [formulas, conditions, tables] = await Promise.all([
    prisma51.treeBranchLeafNodeFormula.findMany({
      where: { nodeId: { in: templateNodeIds } },
      select: { id: true, nodeId: true }
    }),
    prisma51.treeBranchLeafNodeCondition.findMany({
      where: { nodeId: { in: templateNodeIds } },
      select: { id: true, nodeId: true }
    }),
    prisma51.treeBranchLeafNodeTable.findMany({
      where: { nodeId: { in: templateNodeIds } },
      select: { id: true, nodeId: true }
    })
  ]);
  const totalField = extractTotalFieldConfig(repeaterNode.metadata);
  return {
    repeaterNodeId,
    templateNodeIds,
    variables: variables.map((v) => ({
      nodeId: v.nodeId,
      variableId: v.id,
      sourceRef: v.sourceRef,
      sourceType: v.sourceType,
      displayNodeId: null,
      metadata: void 0,
      // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬ß PRESERVE: primaryTargetNodeId for linked variables
      primaryTargetNodeId: v.primaryTargetNodeId || void 0
    })),
    capacities: [
      ...formulas.map((f) => ({
        ownerNodeId: f.nodeId,
        capacityId: f.id,
        capacityType: "formula"
      })),
      ...conditions.map((c) => ({
        ownerNodeId: c.nodeId,
        capacityId: c.id,
        capacityType: "condition"
      })),
      ...tables.map((t) => ({
        ownerNodeId: t.nodeId,
        capacityId: t.id,
        capacityType: "table"
      }))
    ],
    totalField: totalField || void 0,
    capturedAt: (/* @__PURE__ */ new Date()).toISOString(),
    lastUpdatedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
}
function extractTemplateIds(node) {
  const metaRepeater = typeof node.metadata === "object" && node.metadata !== null ? node.metadata.repeater : void 0;
  if (metaRepeater && typeof metaRepeater === "object") {
    const fromMetadata = metaRepeater.templateNodeIds;
    if (Array.isArray(fromMetadata) && fromMetadata.length > 0) {
      const filtered = fromMetadata.filter((id) => typeof id === "string");
      return filtered;
    }
  }
  const fromColumn = parseJsonArray(node.repeater_templateNodeIds);
  if (fromColumn.length) {
    return fromColumn;
  }
  console.warn(`\xC3\xA2\xC2\x9D\xC5\u2019 [extractTemplateIds] Aucun template trouv\xC3\u0192\xC2\xA9 !`);
  return [];
}
function extractTotalFieldConfig(metadata) {
  if (!metadata || typeof metadata !== "object") return null;
  const repeaterMeta = metadata.repeater;
  if (!repeaterMeta || typeof repeaterMeta !== "object") return null;
  const total = repeaterMeta.totalField;
  if (!total || typeof total !== "object") return null;
  const typed = total;
  if (!typed.aggregationType || !typed.repeaterNodeId) return null;
  return {
    repeaterNodeId: typed.repeaterNodeId,
    aggregationType: typed.aggregationType,
    targetDisplayNodeId: typed.targetDisplayNodeId ?? null,
    targetVariableId: typed.targetVariableId ?? null,
    metadata: typed.metadata ?? null
  };
}
async function filterExistingTemplateNodeIds(prisma51, repeaterNodeId, candidateIds) {
  const normalized = Array.from(new Set(candidateIds.filter((id) => typeof id === "string" && !!id)));
  if (!normalized.length) {
    return { validIds: [], missingIds: [] };
  }
  const existing = await prisma51.treeBranchLeafNode.findMany({
    where: { id: { in: normalized } },
    select: { id: true }
  });
  const existingSet = new Set(existing.map((node) => node.id));
  const validIds = normalized.filter((id) => existingSet.has(id));
  const missingIds = normalized.filter((id) => !existingSet.has(id));
  if (missingIds.length) {
    console.warn("[repeat-blueprint-builder] Missing template nodes detected", {
      repeaterNodeId,
      missingCount: missingIds.length,
      missingIds
    });
  }
  return { validIds, missingIds };
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/repeat-instantiator.ts
function createInstantiationPlan(blueprint, options) {
  const { suffix, perTemplateSuffixes } = options;
  const resolveSuffix = (templateNodeId) => {
    if (perTemplateSuffixes && perTemplateSuffixes[templateNodeId] !== void 0) {
      return perTemplateSuffixes[templateNodeId];
    }
    return suffix;
  };
  const nodes = blueprint.templateNodeIds.map((templateNodeId) => {
    const nodeSuffix = resolveSuffix(templateNodeId);
    return {
      templateNodeId,
      plannedSuffix: nodeSuffix,
      newNodeId: `${templateNodeId}-${nodeSuffix}`
    };
  });
  const variables = blueprint.variables.map((variable) => {
    const targetTemplateNodeId = variable.primaryTargetNodeId || variable.nodeId;
    const variableSuffix = resolveSuffix(targetTemplateNodeId);
    const plannedVariableId = `${variable.variableId}-${targetTemplateNodeId}-${variableSuffix}`;
    const plannedTargetNodeId = `${targetTemplateNodeId}-${variableSuffix}`;
    return {
      templateVariableId: variable.variableId,
      plannedSuffix: variableSuffix,
      targetNodeId: plannedTargetNodeId,
      // √É¬¢√¢‚Ç¨¬†√Ç¬ê NOW uses the template node that REFERENCES the variable
      plannedVariableId
    };
  });
  let totalFieldPlan;
  if (options.includeTotals && blueprint.totalField) {
    totalFieldPlan = {
      plannedSuffix: suffix,
      plannedVariableId: `${blueprint.totalField.targetVariableId ?? "total"}-${suffix}`,
      plannedDisplayNodeId: `${blueprint.totalField.targetDisplayNodeId ?? "display-total"}-${suffix}`
    };
  }
  return {
    nodes,
    variables,
    totalField: totalFieldPlan
  };
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/utils/suffix-utils.ts
function extractNumericSuffix2(candidate) {
  if (typeof candidate === "number" && Number.isFinite(candidate)) {
    return candidate;
  }
  if (typeof candidate === "string" && /^\d+$/.test(candidate)) {
    return Number(candidate);
  }
  return null;
}
function extractSuffixFromId(id) {
  if (!id) return null;
  const match = /-(\d+)$/.exec(id);
  if (!match) return null;
  const parsed = Number(match[1]);
  return Number.isFinite(parsed) ? parsed : null;
}
async function computeTemplateCopySuffixMax(prisma51, treeId, templateNodeIds) {
  if (!treeId || !templateNodeIds.length) {
    return /* @__PURE__ */ new Map();
  }
  const templateSet = new Set(templateNodeIds);
  const templateIds = Array.from(templateSet);
  const orStartsWith = templateIds.map((templateId) => ({ id: { startsWith: `${templateId}-` } }));
  const copies = await prisma51.treeBranchLeafNode.findMany({
    where: {
      treeId,
      OR: orStartsWith
    },
    select: { id: true, metadata: true }
  });
  const metaCopies = await prisma51.treeBranchLeafNode.findMany({
    where: {
      treeId,
      OR: templateIds.map((templateId) => ({
        OR: [
          { metadata: { path: ["copiedFromNodeId"], equals: templateId } },
          { metadata: { path: ["sourceTemplateId"], equals: templateId } }
        ]
      }))
    },
    select: { id: true, metadata: true }
  });
  const maxMap = /* @__PURE__ */ new Map();
  for (const copy of copies) {
    let templateId = null;
    for (const candidate of templateIds) {
      if (copy.id.startsWith(`${candidate}-`)) {
        templateId = candidate;
        break;
      }
    }
    if (!templateId || !templateSet.has(templateId)) continue;
    const rest = copy.id.slice(templateId.length + 1);
    const idSuffix = /^\d+$/.test(rest) ? Number(rest) : null;
    const metadata = copy.metadata ?? {};
    const metaSuffix = extractNumericSuffix2(metadata.copySuffix);
    const resolved = idSuffix ?? metaSuffix ?? 0;
    const prev = maxMap.get(templateId) ?? 0;
    if (resolved > prev) maxMap.set(templateId, resolved);
  }
  for (const copy of metaCopies) {
    const meta = copy.metadata ?? {};
    const metaTemplateId = meta.copiedFromNodeId || meta.sourceTemplateId || null;
    if (!metaTemplateId || !templateSet.has(metaTemplateId)) continue;
    const metaSuffix = extractNumericSuffix2(meta.copySuffix) ?? extractSuffixFromId(copy.id) ?? 0;
    const prev = maxMap.get(metaTemplateId) ?? 0;
    if (metaSuffix > prev) {
      maxMap.set(metaTemplateId, metaSuffix);
    }
  }
  return maxMap;
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/repeat-service.ts
var RepeatOperationError = class extends Error {
  status;
  details;
  constructor(message, status = 400, details) {
    super(message);
    this.name = "RepeatOperationError";
    this.status = status;
    this.details = details;
  }
};
var makeScopeId = (repeaterNodeId, suffix) => {
  const trimmedSuffix = typeof suffix === "string" ? suffix.trim() : String(suffix);
  return `${repeaterNodeId}:${trimmedSuffix}`;
};
async function planRepeatDuplication(prisma51, repeaterNodeId, options = {}) {
  if (!repeaterNodeId) {
    throw new RepeatOperationError("Missing repeaterNodeId in request path.", 400);
  }
  const blueprint = await buildBlueprintForRepeater(prisma51, repeaterNodeId);
  if (!blueprint) {
    throw new RepeatOperationError(`No blueprint available for repeater ${repeaterNodeId}.`, 404);
  }
  if (!blueprint.templateNodeIds?.length) {
    throw new RepeatOperationError(
      `Repeater ${repeaterNodeId} does not reference any template nodes.`,
      422
    );
  }
  const repeaterNode = await prisma51.treeBranchLeafNode.findUnique({
    where: { id: repeaterNodeId },
    select: { treeId: true }
  });
  if (!repeaterNode) {
    throw new RepeatOperationError(`Repeater ${repeaterNodeId} was not found.`, 404);
  }
  const cleanedTemplateIds = blueprint.templateNodeIds.filter((id) => typeof id === "string" && !!id).map((id) => id.replace(/(-\d+)+$/, "")).filter((id, idx, arr) => arr.indexOf(id) === idx);
  const needsCleaning = blueprint.templateNodeIds.length !== cleanedTemplateIds.length;
  if (needsCleaning) {
    blueprint.templateNodeIds.forEach((id, idx) => {
      const cleaned = id.replace(/(-\d+)+$/, "");
      if (id !== cleaned) {
      }
    });
  }
  let actualSuffix;
  let perTemplateSuffixes;
  if (options.suffix) {
    const parsed = parseInt(String(options.suffix), 10);
    if (Number.isNaN(parsed)) {
      throw new RepeatOperationError("Repeat suffix must be numeric when provided.", 422);
    }
    actualSuffix = parsed;
    perTemplateSuffixes = Object.fromEntries(
      cleanedTemplateIds.map((id) => [id, actualSuffix])
    );
  } else {
    const existingMax = await computeTemplateCopySuffixMax(
      prisma51,
      repeaterNode.treeId,
      cleanedTemplateIds
    );
    const globalMax = existingMax.size > 0 ? Math.max(...existingMax.values()) : 0;
    actualSuffix = globalMax + 1;
    cleanedTemplateIds.forEach((id) => {
      const mx = existingMax.get(id) ?? 0;
    });
    perTemplateSuffixes = {};
    for (const templateId of cleanedTemplateIds) {
      perTemplateSuffixes[templateId] = actualSuffix;
    }
  }
  const scopeId = options.scopeId?.trim() || makeScopeId(repeaterNodeId, actualSuffix);
  blueprint.templateNodeIds = cleanedTemplateIds;
  const plan = createInstantiationPlan(blueprint, {
    suffix: actualSuffix,
    includeTotals: options.includeTotals ?? true,
    targetParentId: options.targetParentId ?? null,
    perTemplateSuffixes
  });
  return {
    repeaterNodeId,
    suffix: actualSuffix,
    scopeId,
    blueprint,
    plan
  };
}
async function executeRepeatDuplication(prisma51, repeaterNodeId, options = {}) {
  try {
    const planned = await planRepeatDuplication(prisma51, repeaterNodeId, options);
    const operations = [
      ...planned.plan.nodes.map((nodePlan) => ({
        type: "node-copy",
        templateId: nodePlan.templateNodeId,
        targetId: nodePlan.newNodeId
      })),
      ...planned.plan.variables.map((variablePlan) => ({
        type: "variable-copy",
        templateId: variablePlan.templateVariableId,
        targetId: variablePlan.plannedVariableId
      }))
    ];
    return {
      ...planned,
      status: "pending-execution",
      operations
    };
  } catch (error) {
    console.error(`[repeat-service] \xC3\xA2\xC2\x9D\xC5\u2019 ERROR in executeRepeatDuplication:`, error instanceof Error ? error.stack : String(error));
    throw error;
  }
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/repeat-executor.ts
var import_client7 = require("@prisma/client");

// src/components/TreeBranchLeaf/treebranchleaf-new/api/copy-variable-with-capacities.ts
function parseSourceRef3(sourceRef) {
  if (!sourceRef || typeof sourceRef !== "string") return null;
  const cleaned = sourceRef.trim();
  if (!cleaned) return null;
  if (cleaned.startsWith("node-formula:")) {
    return {
      type: "formula",
      id: cleaned.replace("node-formula:", ""),
      prefix: "node-formula:"
    };
  }
  if (cleaned.startsWith("condition:")) {
    return {
      type: "condition",
      id: cleaned.replace("condition:", ""),
      prefix: "condition:"
    };
  }
  if (cleaned.startsWith("node-condition:")) {
    return {
      type: "condition",
      id: cleaned.replace("node-condition:", ""),
      prefix: "node-condition:"
    };
  }
  if (cleaned.startsWith("@table.")) {
    return {
      type: "table",
      id: cleaned.replace("@table.", ""),
      prefix: "@table."
    };
  }
  if (cleaned.startsWith("node-table:")) {
    return {
      type: "table",
      id: cleaned.replace("node-table:", ""),
      prefix: "node-table:"
    };
  }
  if (cleaned.startsWith("@calculated.")) {
    return {
      type: "calculated",
      id: cleaned.replace("@calculated.", ""),
      prefix: "@calculated."
    };
  }
  return {
    type: "field",
    id: cleaned,
    prefix: ""
  };
}
function applySuffixToSourceRef2(sourceRef, suffix) {
  if (!sourceRef) return null;
  const parsed = parseSourceRef3(sourceRef);
  if (!parsed) return sourceRef;
  const newId = `${parsed.id}-${suffix}`;
  return `${parsed.prefix}${newId}`;
}
async function copyVariableWithCapacities2(originalVarId, suffix, newNodeId, prisma51, options = {}) {
  const {
    formulaIdMap = /* @__PURE__ */ new Map(),
    conditionIdMap = /* @__PURE__ */ new Map(),
    tableIdMap: tableIdMap2 = /* @__PURE__ */ new Map(),
    nodeIdMap = /* @__PURE__ */ new Map(),
    variableCopyCache = /* @__PURE__ */ new Map(),
    autoCreateDisplayNode = false,
    displaySectionLabel = "Nouveau Section",
    linkToDisplaySection = false
    // displayNodeAlreadyCreated is not used anymore in this function; keep options API stable without reassigning
  } = options;
  try {
    const cacheKey = `${originalVarId}|${newNodeId}`;
    let cachedVariable = null;
    if (variableCopyCache.has(cacheKey)) {
      const cachedId = variableCopyCache.get(cacheKey);
      const cached = await prisma51.treeBranchLeafNodeVariable.findUnique({
        where: { id: cachedId }
      });
      if (cached) {
        const parsed = parseSourceRef3(cached.sourceRef);
        if (autoCreateDisplayNode) {
          cachedVariable = cached;
        } else {
          return {
            variableId: cached.id,
            exposedKey: cached.exposedKey,
            capacityType: parsed?.type || null,
            sourceRef: cached.sourceRef,
            success: true
          };
        }
      }
    }
    const originalVar = await prisma51.treeBranchLeafNodeVariable.findUnique({
      where: { id: originalVarId }
    });
    if (!originalVar) {
      console.error(`\xE2\x9D\u0152 Variable introuvable: ${originalVarId}`);
      return {
        variableId: "",
        exposedKey: "",
        capacityType: null,
        sourceRef: null,
        success: false,
        error: `Variable introuvable: ${originalVarId}`
      };
    }
    const stripTrailingNumeric = (raw) => {
      if (!raw) return "";
      const trimmed = raw.trim();
      return trimmed.replace(/(?:-\d+)+\s*$/, "");
    };
    const appendSuffixOnce = (value) => {
      if (!value) return value ?? "";
      const base = stripTrailingNumeric(value);
      return `${base}-${suffix}`;
    };
    let newVarId = appendSuffixOnce(originalVarId);
    let newExposedKey = appendSuffixOnce(originalVar.exposedKey);
    let newSourceRef = originalVar.sourceRef;
    let capacityType = null;
    if (originalVar.sourceRef) {
      const parsed = parseSourceRef3(originalVar.sourceRef);
      if (parsed) {
        capacityType = parsed.type;
        if (capacityType === "formula") {
          if (formulaIdMap.has(parsed.id)) {
            const mappedFormulaId = formulaIdMap.get(parsed.id);
            newSourceRef = `${parsed.prefix}${mappedFormulaId}`;
          } else {
            try {
              const formulaResult = await copyFormulaCapacity(
                parsed.id,
                newNodeId,
                suffix,
                prisma51,
                { nodeIdMap, formulaCopyCache: formulaIdMap }
              );
              if (formulaResult.success) {
                formulaIdMap.set(parsed.id, formulaResult.newFormulaId);
                newSourceRef = `${parsed.prefix}${formulaResult.newFormulaId}`;
              } else {
                newSourceRef = applySuffixToSourceRef2(originalVar.sourceRef, Number(suffix));
              }
            } catch (e) {
              console.error(`\xE2\x9D\u0152 [COPY-VAR] Exception copie formule:`, e.message, e.stack);
              newSourceRef = applySuffixToSourceRef2(originalVar.sourceRef, Number(suffix));
            }
          }
        } else if (capacityType === "condition") {
          if (conditionIdMap.has(parsed.id)) {
            const mappedConditionId = conditionIdMap.get(parsed.id);
            newSourceRef = `${parsed.prefix}${mappedConditionId}`;
          } else {
            try {
              const conditionResult = await copyConditionCapacity(
                parsed.id,
                newNodeId,
                suffix,
                prisma51,
                { nodeIdMap, formulaIdMap, conditionCopyCache: conditionIdMap }
              );
              if (conditionResult.success) {
                conditionIdMap.set(parsed.id, conditionResult.newConditionId);
                newSourceRef = `${parsed.prefix}${conditionResult.newConditionId}`;
              } else {
                newSourceRef = applySuffixToSourceRef2(originalVar.sourceRef, suffix);
              }
            } catch (e) {
              console.error(`\xE2\x9D\u0152 Exception copie condition:`, e.message);
              newSourceRef = applySuffixToSourceRef2(originalVar.sourceRef, suffix);
            }
          }
        } else if (capacityType === "table") {
          if (tableIdMap2.has(parsed.id)) {
            const mappedTableId = tableIdMap2.get(parsed.id);
            newSourceRef = `${parsed.prefix}${mappedTableId}`;
          } else {
            try {
              const tableResult = await copyTableCapacity2(
                parsed.id,
                newNodeId,
                suffix,
                prisma51,
                { nodeIdMap, tableCopyCache: tableIdMap2, tableIdMap: tableIdMap2 }
              );
              if (tableResult.success) {
                tableIdMap2.set(parsed.id, tableResult.newTableId);
                newSourceRef = `${parsed.prefix}${tableResult.newTableId}`;
              } else {
                newSourceRef = applySuffixToSourceRef2(originalVar.sourceRef, suffix);
              }
            } catch (e) {
              console.error(`\xE2\x9D\u0152 Exception copie table:`, e.message);
              newSourceRef = applySuffixToSourceRef2(originalVar.sourceRef, suffix);
            }
          }
        } else if (capacityType === "field") {
          if (nodeIdMap.has(parsed.id)) {
            newSourceRef = nodeIdMap.get(parsed.id);
          } else {
            newSourceRef = `${parsed.id}-${suffix}`;
          }
        }
      }
    }
    let finalNodeId2 = newNodeId;
    if (originalVar.nodeId && nodeIdMap.has(originalVar.nodeId)) {
      finalNodeId2 = nodeIdMap.get(originalVar.nodeId);
    } else if (autoCreateDisplayNode) {
      try {
        const originalOwnerNode = await prisma51.treeBranchLeafNode.findUnique({
          where: { id: originalVar.nodeId },
          select: {
            id: true,
            parentId: true,
            treeId: true,
            order: true,
            linkedTableIds: true,
            hasTable: true,
            table_name: true,
            table_activeId: true,
            table_instances: true,
            // √∞≈∏‚Äù‚Äò IMPORTANT: R√É¬©cup√É¬©rer subtab pour que la copie soit dans le bon sous-onglet
            subtab: true,
            subtabs: true,
            metadata: true
          }
        });
        if (originalOwnerNode) {
          const isLinkedVariable = options.isFromRepeaterDuplication && originalVar.nodeId !== newNodeId;
          let displayParentId;
          if (isLinkedVariable) {
            displayParentId = newNodeId;
          } else {
            displayParentId = originalOwnerNode.parentId || null;
          }
          const baseDisplayNodeId = stripTrailingNumeric(originalVar.nodeId) || originalVar.nodeId;
          const displayNodeId2 = `${baseDisplayNodeId}-${suffix}`;
          finalNodeId2 = displayNodeId2;
          const now = /* @__PURE__ */ new Date();
          const displayNodeData = {
            id: displayNodeId2,
            treeId: originalOwnerNode.treeId,
            parentId: displayParentId,
            type: "leaf_field",
            subType: null,
            label: originalVar.displayName || "Donn\xC3\xA9e",
            description: null,
            value: null,
            order: (originalOwnerNode.order ?? 0) + 1,
            isRequired: false,
            isVisible: true,
            isActive: true,
            isMultiple: false,
            fieldConfig: null,
            conditionConfig: null,
            formulaConfig: null,
            tableConfig: null,
            apiConfig: null,
            linkConfig: null,
            defaultValue: null,
            calculatedValue: null,
            metadata: { fromVariableId: appendSuffixOnce(originalVar.id) },
            // √∞≈∏‚Äù‚Äò IMPORTANT: Copier le subtab pour que la copie soit dans le bon sous-onglet
            subtab: originalOwnerNode.subtab,
            subtabs: originalOwnerNode.subtabs,
            createdAt: now,
            updatedAt: now,
            hasAPI: false,
            hasCondition: false,
            hasData: false,
            hasFormula: false,
            hasLink: false,
            hasMarkers: false,
            // √∞≈∏‚Äú≈† TABLE: Copier les colonnes table du n√Ö‚Äúud original
            // √¢≈ì‚Ä¶ IMPORTANT: Ajouter le suffixe aux IDs de table pour pointer aux tables copi√É¬©es
            hasTable: originalOwnerNode.hasTable ?? false,
            table_name: originalOwnerNode.table_name,
            table_activeId: originalOwnerNode.table_activeId ? `${originalOwnerNode.table_activeId}-${suffix}` : null,
            table_instances: (() => {
              if (!originalOwnerNode.table_instances) {
                return originalOwnerNode.table_instances;
              }
              let rawInstances;
              if (typeof originalOwnerNode.table_instances === "object") {
                rawInstances = JSON.parse(JSON.stringify(originalOwnerNode.table_instances));
              } else if (typeof originalOwnerNode.table_instances === "string") {
                try {
                  rawInstances = JSON.parse(originalOwnerNode.table_instances);
                } catch {
                  return originalOwnerNode.table_instances;
                }
              } else {
                return originalOwnerNode.table_instances;
              }
              const updatedInstances = {};
              for (const [key2, value] of Object.entries(rawInstances)) {
                const hasSuffixRegex = /-\d+$/;
                const newKey = hasSuffixRegex.test(key2) ? key2 : `${key2}-${suffix}`;
                if (value && typeof value === "object") {
                  const tableInstanceObj = value;
                  const updatedObj = { ...tableInstanceObj };
                  if (tableInstanceObj.tableId && typeof tableInstanceObj.tableId === "string") {
                    updatedObj.tableId = hasSuffixRegex.test(tableInstanceObj.tableId) ? tableInstanceObj.tableId : `${tableInstanceObj.tableId}-${suffix}`;
                  }
                  updatedInstances[newKey] = updatedObj;
                } else {
                  updatedInstances[newKey] = value;
                }
              }
              return updatedInstances;
            })(),
            linkedTableIds: Array.isArray(originalOwnerNode.linkedTableIds) ? originalOwnerNode.linkedTableIds.map((id) => `${id}-${suffix}`) : [],
            linkedConditionIds: [],
            linkedFormulaIds: [],
            linkedVariableIds: [],
            appearance_size: "md",
            appearance_variant: null,
            appearance_width: "100%",
            fieldType: "TEXT",
            fieldSubType: null,
            field_label: originalVar.displayName
          };
          const maybeExisting = await prisma51.treeBranchLeafNode.findUnique({ where: { id: displayNodeId2 } });
          if (maybeExisting) {
            await prisma51.treeBranchLeafNode.update({ where: { id: displayNodeId2 }, data: { ...displayNodeData, createdAt: maybeExisting.createdAt, updatedAt: now } });
          } else {
            await prisma51.treeBranchLeafNode.create({ data: displayNodeData });
          }
          if (originalOwnerNode.hasTable && Array.isArray(originalOwnerNode.linkedTableIds) && originalOwnerNode.linkedTableIds.length > 0) {
            for (const originalTableId of originalOwnerNode.linkedTableIds) {
              const newTableId = `${originalTableId}-${suffix}`;
              const existingTable = await prisma51.treeBranchLeafNodeTable.findUnique({
                where: { id: newTableId }
              });
              if (existingTable) {
                tableIdMap2.set(originalTableId, newTableId);
                continue;
              }
              try {
                const tableResult = await copyTableCapacity2(
                  originalTableId,
                  displayNodeId2,
                  // La nouvelle table appartient au display node copi√É¬©
                  Number(suffix),
                  prisma51,
                  { nodeIdMap, tableCopyCache: tableIdMap2, tableIdMap: tableIdMap2 }
                );
                if (tableResult.success) {
                  tableIdMap2.set(originalTableId, tableResult.newTableId);
                } else {
                  console.warn(`\xE2\u0161\xA0\xEF\xB8\x8F [COPY-TABLES] \xC3\u2030chec copie table ${originalTableId}: ${tableResult.error}`);
                }
              } catch (e) {
                console.error(`\xE2\x9D\u0152 [COPY-TABLES] Exception copie table ${originalTableId}:`, e.message);
              }
            }
            await prisma51.treeBranchLeafNode.update({
              where: { id: displayNodeId2 },
              data: { hasTable: originalOwnerNode.hasTable ?? false }
            });
          }
        } else {
          console.warn(`\xE2\u0161\xA0\xEF\xB8\x8F Impossible de r\xC3\xA9cup\xC3\xA9rer le n\xC5\u201Cud propri\xC3\xA9taire original ${originalVar.nodeId}. Fallback newNodeId.`);
        }
      } catch (e) {
        console.warn(`\xE2\u0161\xA0\xEF\xB8\x8F Erreur lors de la cr\xC3\xA9ation du n\xC5\u201Cud d'affichage d\xC3\xA9di\xC3\xA9:`, e.message);
      }
    } else {
    }
    try {
      const existingById = await prisma51.treeBranchLeafNodeVariable.findUnique({ where: { id: newVarId } });
      if (existingById) {
        const tail = (finalNodeId2 || newNodeId || "").slice(-6) || `${Date.now()}`;
        const adjusted = `${originalVarId}-${suffix}-${tail}`;
        newVarId = adjusted;
      }
    } catch (e) {
      console.warn(`\xE2\u0161\xA0\xEF\xB8\x8F V\xC3\xA9rification collision id variable \xC3\xA9chou\xC3\xA9e:`, e.message);
    }
    try {
      const existingByKey = await prisma51.treeBranchLeafNodeVariable.findUnique({ where: { exposedKey: newExposedKey } });
      if (existingByKey) {
        const tail = (finalNodeId2 || newNodeId || "").slice(-6) || `${Date.now()}`;
        const adjustedKey = `${originalVar.exposedKey}-${suffix}-${tail}`;
        newExposedKey = adjustedKey;
      }
    } catch (e) {
      console.warn(`\xE2\u0161\xA0\xEF\xB8\x8F V\xC3\xA9rification collision exposedKey \xC3\xA9chou\xC3\xA9e:`, e.message);
    }
    let _reusingExistingVariable = false;
    let _existingVariableForReuse = null;
    try {
      const existingForNode = await prisma51.treeBranchLeafNodeVariable.findUnique({ where: { nodeId: finalNodeId2 } });
      if (existingForNode) {
        _reusingExistingVariable = true;
        _existingVariableForReuse = existingForNode;
        try {
          await prisma51.treeBranchLeafNode.update({
            where: { id: finalNodeId2 },
            data: {
              hasData: true,
              data_activeId: existingForNode.id,
              data_exposedKey: existingForNode.exposedKey,
              data_displayFormat: existingForNode.displayFormat,
              data_precision: existingForNode.precision,
              data_unit: existingForNode.unit,
              data_visibleToUser: existingForNode.visibleToUser,
              label: existingForNode.displayName || void 0,
              field_label: existingForNode.displayName || void 0
            }
          });
          await addToNodeLinkedField8(prisma51, finalNodeId2, "linkedVariableIds", [existingForNode.id]);
        } catch (e) {
          console.warn(`\xE2\u0161\xA0\xEF\xB8\x8F Erreur MAJ display node (r\xC3\xA9utilisation):`, e.message);
        }
        variableCopyCache.set(originalVarId, existingForNode.id);
      }
    } catch (e) {
      console.warn(`\xE2\u0161\xA0\xEF\xB8\x8F V\xC3\xA9rification variable existante par nodeId \xC3\xA9chou\xC3\xA9e:`, e.message);
    }
    let newVariable;
    if (cachedVariable) {
      newVariable = cachedVariable;
    } else if (_reusingExistingVariable && _existingVariableForReuse) {
      newVariable = _existingVariableForReuse;
    } else {
      newVariable = await prisma51.treeBranchLeafNodeVariable.create({
        data: {
          id: newVarId,
          nodeId: finalNodeId2,
          exposedKey: newExposedKey,
          displayName: originalVar.displayName ? `${originalVar.displayName}-${suffix}` : originalVar.displayName,
          displayFormat: originalVar.displayFormat,
          unit: originalVar.unit,
          precision: originalVar.precision,
          visibleToUser: originalVar.visibleToUser,
          isReadonly: originalVar.isReadonly,
          defaultValue: originalVar.defaultValue,
          fixedValue: originalVar.fixedValue,
          selectedNodeId: originalVar.selectedNodeId ? nodeIdMap.get(originalVar.selectedNodeId) || appendSuffixOnce(originalVar.selectedNodeId) : null,
          sourceRef: newSourceRef,
          sourceType: originalVar.sourceType,
          metadata: originalVar.metadata,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    }
    const verification = await prisma51.treeBranchLeafNodeVariable.findUnique({
      where: { id: newVariable.id }
    });
    if (verification) {
    } else {
      console.error(`\xE2\x9D\u0152\xE2\x9D\u0152\xE2\x9D\u0152 PROBL\xC3\u02C6ME GRAVE: Variable ${newVariable.id} N'EXISTE PAS apr\xC3\xA8s cr\xC3\xA9ation !`);
    }
    try {
      await prisma51.treeBranchLeafNode.update({
        where: { id: finalNodeId2 },
        data: {
          hasData: true,
          data_activeId: newVariable.id,
          data_exposedKey: newVariable.exposedKey,
          data_displayFormat: newVariable.displayFormat,
          data_precision: newVariable.precision,
          data_unit: newVariable.unit,
          data_visibleToUser: newVariable.visibleToUser,
          // Harmoniser le label du n√Ö‚Äúud d'affichage sur le displayName de la variable
          label: newVariable.displayName || void 0,
          field_label: newVariable.displayName || void 0
        }
      });
    } catch (e) {
      console.warn(`\xE2\u0161\xA0\xEF\xB8\x8F Erreur lors de la mise \xC3\xA0 jour des param\xC3\xA8tres capacit\xC3\xA9 (display node):`, e.message);
    }
    if (linkToDisplaySection) {
      try {
        const originalOwnerNode = await prisma51.treeBranchLeafNode.findUnique({
          where: { id: originalVar.nodeId },
          select: { parentId: true, treeId: true }
        });
        if (originalOwnerNode?.parentId) {
          const displaySection = await prisma51.treeBranchLeafNode.findFirst({
            where: {
              treeId: originalOwnerNode.treeId,
              parentId: originalOwnerNode.parentId,
              type: "section",
              label: { equals: displaySectionLabel }
            },
            select: { id: true }
          });
          if (displaySection) {
            await addToNodeLinkedField8(prisma51, displaySection.id, "linkedVariableIds", [newVariable.id]);
          } else {
          }
        }
      } catch (e) {
        console.warn(`\xE2\u0161\xA0\xEF\xB8\x8F Erreur lors du linkage vers la section d'affichage:`, e.message);
      }
    } else if (autoCreateDisplayNode) {
      try {
        await addToNodeLinkedField8(prisma51, finalNodeId2, "linkedVariableIds", [newVariable.id]);
      } catch (e) {
        console.warn(`\xE2\u0161\xA0\xEF\xB8\x8F Erreur linkage variable\xE2\u2020\u2019display node:`, e.message);
      }
      try {
        if (capacityType && newSourceRef) {
          const parsedCap = parseSourceRef3(newSourceRef);
          const capId = parsedCap?.id;
          if (parsedCap && capId) {
            if (parsedCap.type === "condition") {
              await prisma51.treeBranchLeafNode.update({
                where: { id: finalNodeId2 },
                data: {
                  hasCondition: true,
                  condition_activeId: capId
                }
              });
              await addToNodeLinkedField8(prisma51, finalNodeId2, "linkedConditionIds", [capId]);
            } else if (parsedCap.type === "formula") {
              const frm = await prisma51.treeBranchLeafNodeFormula.findUnique({ where: { id: capId }, select: { name: true } });
              await prisma51.treeBranchLeafNode.update({
                where: { id: finalNodeId2 },
                data: {
                  hasFormula: true,
                  formula_activeId: capId,
                  formula_name: frm?.name || null
                }
              });
              await addToNodeLinkedField8(prisma51, finalNodeId2, "linkedFormulaIds", [capId]);
            } else if (parsedCap.type === "table") {
              const tbl = await prisma51.treeBranchLeafNodeTable.findUnique({ where: { id: capId }, select: { name: true, type: true } });
              await prisma51.treeBranchLeafNode.update({
                where: { id: finalNodeId2 },
                data: {
                  hasTable: true,
                  table_activeId: capId,
                  table_name: tbl?.name || null,
                  table_type: tbl?.type || null
                }
              });
              await addToNodeLinkedField8(prisma51, finalNodeId2, "linkedTableIds", [capId]);
            }
          }
        }
      } catch (e) {
        console.warn(`\xE2\u0161\xA0\xEF\xB8\x8F Synchronisation capacit\xC3\xA9s condition/table sur le n\xC5\u201Cud d'affichage:`, e.message);
      }
    }
    variableCopyCache.set(cacheKey, newVariable.id);
    if (capacityType && newSourceRef) {
      const parsed = parseSourceRef3(newSourceRef);
      if (parsed && parsed.id) {
        try {
          if (capacityType === "formula") {
            const formula = await prisma51.treeBranchLeafNodeFormula.findUnique({
              where: { id: parsed.id },
              select: { nodeId: true }
            });
            if (formula) {
              await addToNodeLinkedField8(prisma51, formula.nodeId, "linkedFormulaIds", [parsed.id]);
            }
          } else if (capacityType === "condition") {
            const condition = await prisma51.treeBranchLeafNodeCondition.findUnique({
              where: { id: parsed.id },
              select: { nodeId: true }
            });
            if (condition) {
              await addToNodeLinkedField8(prisma51, condition.nodeId, "linkedConditionIds", [parsed.id]);
            }
          } else if (capacityType === "table") {
            const table = await prisma51.treeBranchLeafNodeTable.findUnique({
              where: { id: parsed.id },
              select: { nodeId: true }
            });
            if (table) {
              await addToNodeLinkedField8(prisma51, table.nodeId, "linkedTableIds", [parsed.id]);
            }
          }
        } catch (e) {
          console.warn(`\xE2\u0161\xA0\xEF\xB8\x8F Erreur MAJ bidirectionnelle:`, e.message);
        }
      }
    }
    return {
      variableId: newVariable.id,
      exposedKey: newExposedKey,
      capacityType,
      sourceRef: newSourceRef,
      success: true,
      displayNodeId: finalNodeId2
      // √∞≈∏‚Äù‚Äò IMPORTANT: Retourner l'ID du display node cr√É¬©√É¬©!
    };
  } catch (error) {
    console.error(`\xE2\x9D\u0152 Erreur lors de la copie de la variable:`, error);
    return {
      variableId: "",
      exposedKey: "",
      capacityType: null,
      sourceRef: null,
      success: false,
      error: error instanceof Error ? error.message : String(error),
      displayNodeId: void 0
      // Pas de display node en cas d'erreur
    };
  }
}
async function addToNodeLinkedField8(prisma51, nodeId, field, idsToAdd) {
  if (!idsToAdd || idsToAdd.length === 0) return;
  const node = await prisma51.treeBranchLeafNode.findUnique({
    where: { id: nodeId },
    select: { [field]: true }
  });
  if (!node) {
    console.warn(`\xE2\u0161\xA0\xEF\xB8\x8F N\xC5\u201Cud ${nodeId} introuvable pour MAJ ${field}`);
    return;
  }
  const current = node[field] || [];
  const newIds = [.../* @__PURE__ */ new Set([...current, ...idsToAdd])];
  await prisma51.treeBranchLeafNode.update({
    where: { id: nodeId },
    data: { [field]: { set: newIds } }
  });
}

// src/components/TreeBranchLeaf/treebranchleaf-new/shared/shared-reference-helpers.ts
async function applySharedReferencesFromOriginalInternal2(params) {
  const { prisma: prisma51, nodeId, authCtx } = params;
  const { organizationId, isSuperAdmin: isSuperAdmin2 } = authCtx;
  const copyRoot = await prisma51.treeBranchLeafNode.findFirst({
    where: { id: nodeId },
    include: { TreeBranchLeafTree: { select: { id: true, organizationId: true } } }
  });
  if (!copyRoot) throw new Error("N\u0153ud introuvable");
  if (!isSuperAdmin2 && organizationId && copyRoot.TreeBranchLeafTree?.organizationId && copyRoot.TreeBranchLeafTree.organizationId !== organizationId) {
    throw new Error("Acc\xE8s non autoris\xE9");
  }
  const all = await prisma51.treeBranchLeafNode.findMany({ where: { treeId: copyRoot.treeId } });
  const nodeVariableIdByNodeId = /* @__PURE__ */ new Map();
  if (all.length > 0) {
    const nodeVariables = await prisma51.treeBranchLeafNodeVariable.findMany({
      where: { nodeId: { in: all.map((n) => n.id) } },
      select: { nodeId: true, id: true }
    });
    for (const variable of nodeVariables) {
      if (variable.nodeId && variable.id) {
        nodeVariableIdByNodeId.set(variable.nodeId, variable.id);
      }
    }
  }
  const byId = new Map(all.map((n) => [n.id, n]));
  const childrenByParent = /* @__PURE__ */ new Map();
  for (const n of all) {
    if (!n.parentId) continue;
    const arr = childrenByParent.get(n.parentId) || [];
    arr.push(n.id);
    childrenByParent.set(n.parentId, arr);
  }
  const collectedCopyIds = /* @__PURE__ */ new Set();
  const queue = [copyRoot.id];
  while (queue.length) {
    const cur = queue.shift();
    if (collectedCopyIds.has(cur)) continue;
    collectedCopyIds.add(cur);
    for (const c of childrenByParent.get(cur) || []) queue.push(c);
  }
  const originalToCopy = /* @__PURE__ */ new Map();
  for (const id of collectedCopyIds) {
    const n = byId.get(id);
    if (!n) continue;
    const meta = n.metadata || {};
    const origId = String(meta.copiedFromNodeId || "");
    if (origId) originalToCopy.set(origId, n.id);
  }
  if (originalToCopy.size === 0) return { success: true, applied: 0, suffix: 0 };
  const originalIds = Array.from(originalToCopy.keys());
  const originals = await prisma51.treeBranchLeafNode.findMany({ where: { id: { in: originalIds } } });
  const allRefIds = /* @__PURE__ */ new Set();
  for (const orig of originals) {
    if (orig.sharedReferenceId) allRefIds.add(orig.sharedReferenceId);
    if (Array.isArray(orig.sharedReferenceIds)) orig.sharedReferenceIds.forEach((id) => id && allRefIds.add(id));
  }
  const metaRoot = copyRoot.metadata || {};
  let chosenSuffix = typeof metaRoot.copySuffix === "number" ? metaRoot.copySuffix : null;
  if (!chosenSuffix) {
    let maxSuffix = 0;
    const SUFFIX_RE = /^(shared-ref-[A-Za-z0-9_\-]+)-(\d+)$/;
    for (const n of all) {
      const m = typeof n.id === "string" ? n.id.match(SUFFIX_RE) : null;
      if (m) {
        const num = Number(m[2]);
        if (!Number.isNaN(num)) maxSuffix = Math.max(maxSuffix, num);
      }
    }
    chosenSuffix = maxSuffix + 1 || 1;
    await prisma51.treeBranchLeafNode.update({ where: { id: copyRoot.id }, data: { metadata: { ...metaRoot, copySuffix: chosenSuffix } } });
  }
  const refCopyIdByOriginal = /* @__PURE__ */ new Map();
  const desiredIds = Array.from(allRefIds).map((id) => `${id}-${chosenSuffix}`);
  const existingRefCopies = desiredIds.length > 0 ? await prisma51.treeBranchLeafNode.findMany({ where: { id: { in: desiredIds } } }) : [];
  const existingSet = new Set(existingRefCopies.map((n) => n.id));
  const ensureRefCopy = async (origRefId) => {
    const desiredRootId = `${origRefId}-${chosenSuffix}`;
    if (existingSet.has(desiredRootId)) {
      refCopyIdByOriginal.set(origRefId, desiredRootId);
      return desiredRootId;
    }
    const subtreeIds = [];
    const q = [origRefId];
    const seen = /* @__PURE__ */ new Set();
    while (q.length) {
      const cur = q.shift();
      if (seen.has(cur)) continue;
      seen.add(cur);
      subtreeIds.push(cur);
      const kids = childrenByParent.get(cur) || [];
      for (const cid of kids) q.push(cid);
    }
    const origSubtree = subtreeIds.map((id) => byId.get(id)).filter(Boolean);
    const desired = new Set(subtreeIds.map((id) => `${id}-${chosenSuffix}`));
    if (desired.size > 0) {
      const already = await prisma51.treeBranchLeafNode.findMany({ where: { id: { in: Array.from(desired) } } });
      for (const n of already) desired.delete(n.id);
    }
    const idMap = /* @__PURE__ */ new Map();
    for (const id of subtreeIds) idMap.set(id, `${id}-${chosenSuffix}`);
    for (const orig of origSubtree) {
      const newId = idMap.get(orig.id);
      if (!desired.has(newId)) continue;
      const newParentId = orig.parentId ? idMap.get(orig.parentId) ?? null : null;
      const toCreate = {
        id: newId,
        treeId: copyRoot.treeId,
        type: orig.type,
        subType: orig.subType,
        fieldType: orig.fieldType ?? "TEXT",
        label: orig.label,
        description: orig.description,
        parentId: newParentId,
        order: orig.order ?? 9999,
        isVisible: orig.isVisible ?? true,
        isActive: orig.isActive ?? true,
        isRequired: orig.isRequired ?? false,
        isMultiple: orig.isMultiple ?? false,
        // üîß IMPORTANT: pr√©server la table active lors d'une copie (sinon les lookups tombent √† 0/‚àÖ)
        table_activeId: orig.table_activeId ? `${orig.table_activeId}-${chosenSuffix}` : null,
        hasData: false,
        hasFormula: false,
        hasCondition: false,
        hasTable: false,
        hasAPI: false,
        hasLink: false,
        hasMarkers: false,
        isSharedReference: orig.id === origRefId ? true : orig.isSharedReference ?? false,
        sharedReferenceId: null,
        sharedReferenceIds: [],
        sharedReferenceName: orig.sharedReferenceName ?? orig.label ?? null,
        sharedReferenceDescription: orig.sharedReferenceDescription ?? orig.description ?? null,
        linkedFormulaIds: Array.isArray(orig.linkedFormulaIds) ? orig.linkedFormulaIds.map((id) => `${id}-${chosenSuffix}`).filter(Boolean) : [],
        linkedConditionIds: Array.isArray(orig.linkedConditionIds) ? orig.linkedConditionIds.map((id) => `${id}-${chosenSuffix}`).filter(Boolean) : [],
        linkedTableIds: Array.isArray(orig.linkedTableIds) ? orig.linkedTableIds.map((id) => `${id}-${chosenSuffix}`).filter(Boolean) : [],
        linkedVariableIds: Array.isArray(orig.linkedVariableIds) ? orig.linkedVariableIds.map((id) => `${id}-${chosenSuffix}`).filter(Boolean) : [],
        metadata: { ...orig.metadata || {}, copiedFromNodeId: orig.id },
        updatedAt: /* @__PURE__ */ new Date()
      };
      await prisma51.treeBranchLeafNode.create({ data: toCreate });
      const sourceVariableIds = /* @__PURE__ */ new Set();
      if (Array.isArray(orig.linkedVariableIds)) {
        for (const rawId of orig.linkedVariableIds) {
          if (typeof rawId === "string") {
            const normalized = rawId.trim();
            if (normalized) {
              sourceVariableIds.add(normalized);
            }
          }
        }
      }
      const directVarId = nodeVariableIdByNodeId.get(orig.id);
      if (directVarId) {
        sourceVariableIds.add(directVarId);
      }
      if (sourceVariableIds.size > 0) {
        const variableCopyCache = /* @__PURE__ */ new Map();
        const formulaIdMap = /* @__PURE__ */ new Map();
        const conditionIdMap = /* @__PURE__ */ new Map();
        const tableIdMap2 = /* @__PURE__ */ new Map();
        const globalNodeIdMap = new Map([...originalToCopy, ...idMap]);
        for (const originalVarId of sourceVariableIds) {
          try {
            const copyResult = await copyVariableWithCapacities2(
              originalVarId,
              chosenSuffix,
              newId,
              prisma51,
              {
                formulaIdMap,
                conditionIdMap,
                tableIdMap: tableIdMap2,
                nodeIdMap: globalNodeIdMap,
                variableCopyCache,
                autoCreateDisplayNode: true
              }
            );
            if (!copyResult.success) {
              console.warn(`\u26A0\uFE0F [SHARED-REF] \xC9chec copie variable ${originalVarId}: ${copyResult.error}`);
            }
          } catch (e) {
            console.warn(`\u26A0\uFE0F [SHARED-REF] Erreur copie variable ${originalVarId}:`, e.message);
          }
        }
      }
    }
    refCopyIdByOriginal.set(origRefId, desiredRootId);
    return desiredRootId;
  };
  for (const rid of allRefIds) await ensureRefCopy(rid);
  const updates = [];
  let applied = 0;
  for (const orig of originals) {
    const copyId = originalToCopy.get(orig.id);
    const copyExists = await prisma51.treeBranchLeafNode.findUnique({
      where: { id: copyId },
      select: { id: true }
    });
    if (!copyExists) {
      console.warn(`\u26A0\uFE0F N\u0153ud ${copyId} introuvable pour MAJ linkedConditionIds`);
      continue;
    }
    const origMultiple = Array.isArray(orig.sharedReferenceIds) ? orig.sharedReferenceIds.filter(Boolean) : [];
    const origSingle = orig.sharedReferenceId ?? null;
    const mappedMultiple = origMultiple.map((id) => refCopyIdByOriginal.get(id) || `${id}-${chosenSuffix}`);
    const mappedSingle = origSingle ? refCopyIdByOriginal.get(origSingle) || `${origSingle}-${chosenSuffix}` : null;
    const finalArray = mappedMultiple.length > 0 ? mappedMultiple : mappedSingle ? [mappedSingle] : [];
    const finalSingle = finalArray.length > 0 ? finalArray[0] : null;
    updates.push(prisma51.treeBranchLeafNode.update({
      where: { id: copyId },
      data: {
        sharedReferenceId: finalSingle,
        sharedReferenceIds: finalArray,
        sharedReferenceName: orig.sharedReferenceName ?? null,
        sharedReferenceDescription: orig.sharedReferenceDescription ?? null,
        isSharedReference: false,
        hasData: orig.hasData,
        updatedAt: /* @__PURE__ */ new Date()
      }
    }));
    applied++;
  }
  await prisma51.$transaction(updates);
  return { success: true, applied, suffix: chosenSuffix };
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/services/recalculate-values-service.ts
async function resetCalculatedValuesAfterCopy(prisma51, copiedNodeIds) {
  const nodesWithCapacities = await prisma51.treeBranchLeafNode.findMany({
    where: {
      id: { in: copiedNodeIds },
      OR: [
        { hasFormula: true },
        { hasCondition: true },
        { hasTable: true }
      ]
    },
    select: {
      id: true,
      label: true,
      calculatedValue: true,
      hasFormula: true,
      hasCondition: true,
      hasTable: true
    }
  });
  for (const node of nodesWithCapacities) {
  }
  const result = await prisma51.treeBranchLeafNode.updateMany({
    where: {
      id: { in: copiedNodeIds },
      OR: [
        { hasFormula: true },
        { hasCondition: true },
        { hasTable: true }
      ]
    },
    data: {
      calculatedValue: null
    }
  });
  return result.count;
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/services/strict-isolation-service.ts
async function enforceStrictIsolation(prisma51, copiedNodeIds) {
  const result = {
    isolatedNodes: [],
    errors: []
  };
  for (const nodeId of copiedNodeIds) {
    try {
      const changes = [];
      const node = await prisma51.treeBranchLeafNode.findUnique({
        where: { id: nodeId },
        include: {
          TreeBranchLeafNodeTable: true
        }
      });
      if (!node) {
        result.errors.push({ nodeId, error: "N\u0153ud non trouv\xE9" });
        continue;
      }
      if (node.hasFormula || node.hasCondition || node.hasTable) {
        if (node.calculatedValue !== null) {
          await prisma51.treeBranchLeafNode.update({
            where: { id: nodeId },
            data: { calculatedValue: null }
          });
          changes.push(`calculatedValue: ${node.calculatedValue} \u2192 null`);
        }
      }
      if (node.hasTable && (!node.TreeBranchLeafNodeTable || node.TreeBranchLeafNodeTable.length === 0)) {
        await prisma51.treeBranchLeafNode.update({
          where: { id: nodeId },
          data: { hasTable: false }
        });
        changes.push("hasTable: true \u2192 false (aucune table trouv\xE9e)");
      }
      const currentMetadata = node.metadata && typeof node.metadata === "object" ? node.metadata : {};
      const updatedMetadata = {
        ...currentMetadata,
        strictlyIsolated: true,
        isolatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        calculatedValueReset: true,
        independentCalculation: true
      };
      await prisma51.treeBranchLeafNode.update({
        where: { id: nodeId },
        data: { metadata: updatedMetadata }
      });
      changes.push("metadata: marqu\xE9 comme strictement isol\xE9");
      result.isolatedNodes.push({
        nodeId: node.id,
        label: node.label,
        changes
      });
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      result.errors.push({ nodeId, error: errorMsg });
      console.error(`\u274C [ISOLATION] Erreur pour ${nodeId}:`, errorMsg);
    }
  }
  return result;
}
async function verifyIsolation(prisma51, copiedNodeIds) {
  for (const nodeId of copiedNodeIds) {
    const node = await prisma51.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      select: {
        id: true,
        label: true,
        calculatedValue: true,
        hasFormula: true,
        hasCondition: true,
        hasTable: true,
        metadata: true
      }
    });
    if (!node) continue;
    const metadata = node.metadata && typeof node.metadata === "object" ? node.metadata : {};
    const isIsolated = metadata.strictlyIsolated === true;
    const hasCapacity = node.hasFormula || node.hasCondition || node.hasTable;
    if (hasCapacity && node.calculatedValue !== null) {
    }
    if (!isIsolated) {
    }
  }
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/services/force-independent-calculation.ts
async function forceIndependentCalculation(prisma51, copiedNodeIds) {
  for (const nodeId of copiedNodeIds) {
    try {
      const node = await prisma51.treeBranchLeafNode.findUnique({
        where: { id: nodeId },
        include: {
          TreeBranchLeafNodeTable: true,
          TreeBranchLeafNodeVariable: true,
          TreeBranchLeafSelectConfig: true
        }
      });
      if (!node) continue;
      if (node.hasFormula || node.hasCondition || node.hasTable) {
        const currentMetadata = node.metadata && typeof node.metadata === "object" ? node.metadata : {};
        const updatedMetadata = {
          ...currentMetadata,
          lastForceRecalc: (/* @__PURE__ */ new Date()).toISOString(),
          forceIndependentCalc: true,
          // Marquer comme devant √É∆í√Ç¬™tre recalcul√É∆í√Ç¬© c√É∆í√Ç¬¥t√É∆í√Ç¬© frontend
          requiresFreshCalculation: true,
          calculationInvalidated: Date.now()
        };
        await prisma51.treeBranchLeafNode.update({
          where: { id: nodeId },
          data: {
            calculatedValue: null,
            metadata: updatedMetadata
          }
        });
      } else if (!node.hasFormula && !node.hasCondition && !node.hasTable) {
        if (node.calculatedValue !== null) {
          await prisma51.treeBranchLeafNode.update({
            where: { id: nodeId },
            data: { calculatedValue: null }
          });
        }
      }
    } catch (error) {
      console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 [FORCE-CALC] Erreur pour ${nodeId}:`, error);
    }
  }
}
async function createRecalculationTriggers(prisma51, copiedNodeIds) {
  const triggerTimestamp = Date.now();
  for (const nodeId of copiedNodeIds) {
    try {
      const currentMetadata = await prisma51.treeBranchLeafNode.findUnique({
        where: { id: nodeId },
        select: { metadata: true, label: true }
      });
      if (!currentMetadata) continue;
      const metadata = currentMetadata.metadata && typeof currentMetadata.metadata === "object" ? currentMetadata.metadata : {};
      const updatedMetadata = {
        ...metadata,
        // Marqueurs pour forcer le recalcul c√É∆í√Ç¬¥t√É∆í√Ç¬© frontend
        recalcTrigger: triggerTimestamp,
        mustRecalculate: true,
        independentNode: true,
        noFallbackToOriginal: true
      };
      await prisma51.treeBranchLeafNode.update({
        where: { id: nodeId },
        data: { metadata: updatedMetadata }
      });
    } catch (error) {
      console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 [TRIGGERS] Erreur pour ${nodeId}:`, error);
    }
  }
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/services/complete-duplication-fix.ts
async function fixCompleteDuplication(prisma51, originalNodeId, copiedNodeId, suffix = "-1") {
  const result = {
    nodeId: copiedNodeId,
    nodeLabel: null,
    capacitiesFixed: {
      formulas: 0,
      conditions: 0,
      tables: 0,
      lookups: 0
    },
    fieldConfigUpdated: false,
    calculatedValueReset: false
  };
  const [originalNode, copiedNode] = await Promise.all([
    prisma51.treeBranchLeafNode.findUnique({
      where: { id: originalNodeId },
      include: {
        TreeBranchLeafNodeTable: {
          include: {
            tableColumns: true,
            tableRows: true
          }
        }
      }
    }),
    prisma51.treeBranchLeafNode.findUnique({
      where: { id: copiedNodeId }
    })
  ]);
  if (!originalNode) {
    throw new Error(`N\xC3\u2026\xE2\u20AC\u0153ud original ${originalNodeId} non trouv\xC3\u0192\xC2\xA9`);
  }
  if (!copiedNode) {
    throw new Error(`N\xC3\u2026\xE2\u20AC\u0153ud copi\xC3\u0192\xC2\xA9 ${copiedNodeId} non trouv\xC3\u0192\xC2\xA9`);
  }
  result.nodeLabel = copiedNode.label;
  const formulaIdMap = /* @__PURE__ */ new Map();
  const suffixNum = parseInt(suffix.replace("-", "")) || 1;
  const nodeIdMap = /* @__PURE__ */ new Map();
  const treeId = copiedNode.treeId;
  if (treeId) {
    const allNodesInTree = await prisma51.treeBranchLeafNode.findMany({
      where: { treeId },
      select: { id: true }
    });
    for (const node of allNodesInTree) {
      if (node.id.match(/-\d+$/)) {
        const baseId = node.id.replace(/-\d+$/, "");
        if (!nodeIdMap.has(baseId)) {
          nodeIdMap.set(baseId, node.id);
        }
      }
    }
  }
  for (const formula of originalNode.TreeBranchLeafNodeFormula) {
    try {
      const formulaResult = await copyFormulaCapacity(
        formula.id,
        copiedNodeId,
        suffixNum,
        prisma51,
        { formulaIdMap, nodeIdMap }
      );
      if (formulaResult.success) {
        formulaIdMap.set(formula.id, formulaResult.newFormulaId);
        result.capacitiesFixed.formulas++;
      } else {
        console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 Erreur copie formule: ${formula.id}`);
      }
    } catch (error) {
      console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 Exception copie formule ${formula.id}:`, error);
    }
  }
  for (const condition of originalNode.TreeBranchLeafNodeCondition) {
    const newConditionId = `${condition.id}${suffix}`;
    const existingCondition = await prisma51.treeBranchLeafNodeCondition.findUnique({
      where: { id: newConditionId }
    });
    if (!existingCondition) {
      const adaptedConditionSet = adaptReferencesForCopiedNode(condition.conditionSet, suffix);
      await prisma51.treeBranchLeafNodeCondition.create({
        data: {
          id: newConditionId,
          nodeId: copiedNodeId,
          organizationId: condition.organizationId,
          name: condition.name ? `${condition.name}${suffix}` : condition.name,
          conditionSet: adaptedConditionSet,
          description: condition.description,
          isDefault: condition.isDefault,
          order: condition.order
        }
      });
      result.capacitiesFixed.conditions++;
    }
  }
  for (const table of originalNode.TreeBranchLeafNodeTable) {
    const newTableId = `${table.id}${suffix}`;
    const existingTable = await prisma51.treeBranchLeafNodeTable.findUnique({
      where: { id: newTableId }
    });
    if (!existingTable) {
      await prisma51.treeBranchLeafNodeTable.create({
        data: {
          id: newTableId,
          nodeId: copiedNodeId,
          organizationId: table.organizationId,
          name: table.name ? `${table.name}${suffix}` : table.name,
          description: table.description,
          type: table.type,
          rowCount: table.rowCount,
          columnCount: table.columnCount,
          // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬¢ COPIE TABLE META: suffixer comparisonColumn et UUIDs si c'est du texte
          meta: (() => {
            if (!table.meta) return table.meta;
            try {
              const metaObj = typeof table.meta === "string" ? JSON.parse(table.meta) : JSON.parse(JSON.stringify(table.meta));
              const suffixNum2 = parseInt(suffix.replace("-", "")) || 1;
              if (metaObj?.lookup?.selectors?.columnFieldId && !metaObj.lookup.selectors.columnFieldId.endsWith(`-${suffixNum2}`)) {
                metaObj.lookup.selectors.columnFieldId = `${metaObj.lookup.selectors.columnFieldId}-${suffixNum2}`;
              }
              if (metaObj?.lookup?.selectors?.rowFieldId && !metaObj.lookup.selectors.rowFieldId.endsWith(`-${suffixNum2}`)) {
                metaObj.lookup.selectors.rowFieldId = `${metaObj.lookup.selectors.rowFieldId}-${suffixNum2}`;
              }
              if (metaObj?.lookup?.rowSourceOption?.sourceField && !metaObj.lookup.rowSourceOption.sourceField.endsWith(`-${suffixNum2}`)) {
                metaObj.lookup.rowSourceOption.sourceField = `${metaObj.lookup.rowSourceOption.sourceField}-${suffixNum2}`;
              }
              if (metaObj?.lookup?.columnSourceOption?.sourceField && !metaObj.lookup.columnSourceOption.sourceField.endsWith(`-${suffixNum2}`)) {
                metaObj.lookup.columnSourceOption.sourceField = `${metaObj.lookup.columnSourceOption.sourceField}-${suffixNum2}`;
              }
              if (metaObj?.lookup?.rowSourceOption?.comparisonColumn) {
                const val = metaObj.lookup.rowSourceOption.comparisonColumn;
                if (!/^-?\d+(\.\d+)?$/.test(val.trim()) && !val.endsWith(suffix)) {
                  metaObj.lookup.rowSourceOption.comparisonColumn = `${val}${suffix}`;
                }
              }
              if (metaObj?.lookup?.columnSourceOption?.comparisonColumn) {
                const val = metaObj.lookup.columnSourceOption.comparisonColumn;
                if (!/^-?\d+(\.\d+)?$/.test(val.trim()) && !val.endsWith(suffix)) {
                  metaObj.lookup.columnSourceOption.comparisonColumn = `${val}${suffix}`;
                }
              }
              return metaObj;
            } catch {
              return table.meta;
            }
          })(),
          isDefault: table.isDefault,
          order: table.order,
          lookupDisplayColumns: table.lookupDisplayColumns,
          lookupSelectColumn: table.lookupSelectColumn
        }
      });
      await Promise.all([
        ...table.tableColumns.map(
          (col) => prisma51.treeBranchLeafNodeTableColumn.create({
            data: {
              id: `${col.id}${suffix}`,
              tableId: newTableId,
              columnIndex: col.columnIndex,
              // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬¢ COPIE TABLE COLUMN: suffixe seulement pour texte, pas pour nombres
              name: col.name ? /^-?\d+(\.\d+)?$/.test(col.name.trim()) ? col.name : `${col.name}${suffix}` : col.name,
              type: col.type,
              width: col.width,
              format: col.format,
              metadata: col.metadata
            }
          })
        ),
        ...table.tableRows.map(
          (row) => prisma51.treeBranchLeafNodeTableRow.create({
            data: {
              id: `${row.id}${suffix}`,
              tableId: newTableId,
              rowIndex: row.rowIndex,
              cells: row.cells
            }
          })
        )
      ]);
      result.capacitiesFixed.tables++;
    }
  }
  await fixAssociatedLookups(prisma51, originalNode, copiedNode, suffix);
  result.capacitiesFixed.lookups = 1;
  if (copiedNode.fieldConfig) {
    const newFieldConfig = updateFieldConfigReferences(copiedNode.fieldConfig, suffix);
    if (newFieldConfig !== copiedNode.fieldConfig) {
      await prisma51.treeBranchLeafNode.update({
        where: { id: copiedNodeId },
        data: { fieldConfig: newFieldConfig }
      });
      result.fieldConfigUpdated = true;
    }
  }
  const copiedNodeTables = await prisma51.treeBranchLeafNodeTable.count({
    where: { nodeId: copiedNodeId }
  });
  await prisma51.treeBranchLeafNode.update({
    where: { id: copiedNodeId },
    data: {
      hasFormula: originalNode.TreeBranchLeafNodeFormula.length > 0,
      hasCondition: originalNode.TreeBranchLeafNodeCondition.length > 0,
      hasTable: copiedNodeTables > 0,
      // V√©rifier les tables du node COPI√â, pas de l'original
      calculatedValue: null,
      calculatedAt: null,
      calculatedBy: null
    }
  });
  result.calculatedValueReset = true;
  return result;
}
async function fixAssociatedLookups(prisma51, originalNode, copiedNode, suffix) {
  const measureNodes = await prisma51.treeBranchLeafNode.findMany({
    where: {
      AND: [
        { label: { contains: "Mesure" } },
        { label: { endsWith: suffix } },
        { treeId: copiedNode.treeId }
      ]
    },
    include: {
      TreeBranchLeafNodeTable: {
        include: {
          tableColumns: true,
          tableRows: true
        }
      }
    }
  });
  for (const originalTable of originalNode.TreeBranchLeafNodeTable) {
    const lookupName = `Lookup ${originalNode.label}${suffix}`;
    for (const measureNode of measureNodes) {
      const lookupTable = measureNode.TreeBranchLeafNodeTable.find(
        (t) => t.name.includes("Lookup") && (t.name.includes(originalNode.label) || t.name === lookupName)
      );
      if (lookupTable && lookupTable.tableRows.length === 0) {
        await Promise.all([
          prisma51.treeBranchLeafNodeTableColumn.deleteMany({
            where: { tableId: lookupTable.id }
          }),
          prisma51.treeBranchLeafNodeTableRow.deleteMany({
            where: { tableId: lookupTable.id }
          })
        ]);
        await Promise.all([
          ...originalTable.tableColumns.map(
            (col) => prisma51.treeBranchLeafNodeTableColumn.create({
              data: {
                id: `${col.id}-lookup${suffix}`,
                tableId: lookupTable.id,
                columnIndex: col.columnIndex,
                name: col.name,
                type: col.type,
                width: col.width,
                format: col.format,
                metadata: col.metadata
              }
            })
          ),
          ...originalTable.tableRows.map(
            (row) => prisma51.treeBranchLeafNodeTableRow.create({
              data: {
                id: `${row.id}-lookup${suffix}`,
                tableId: lookupTable.id,
                rowIndex: row.rowIndex,
                cells: row.cells
              }
            })
          )
        ]);
        await prisma51.treeBranchLeafNodeTable.update({
          where: { id: lookupTable.id },
          data: {
            rowCount: originalTable.rowCount,
            columnCount: originalTable.columnCount,
            lookupSelectColumn: originalTable.lookupSelectColumn || "Orientation",
            lookupDisplayColumns: originalTable.lookupDisplayColumns.length > 0 ? originalTable.lookupDisplayColumns : ["Orientation"]
          }
        });
      }
    }
  }
}
function adaptReferencesForCopiedNode(data, suffix) {
  if (!data) return data;
  const adaptString = (str) => {
    return str.replace(/@value\.([A-Za-z0-9_:-]+)/g, (match, nodeId) => {
      if (nodeId.includes("shared-ref") || nodeId.endsWith(suffix.replace("-", ""))) {
        return match;
      }
      return `@value.${nodeId}${suffix}`;
    }).replace(/node-formula:([a-f0-9-]{36})/gi, (match, formulaId) => {
      return `node-formula:${formulaId}${suffix}`;
    });
  };
  if (Array.isArray(data)) {
    return data.map(
      (item) => typeof item === "string" ? adaptString(item) : item
    );
  }
  if (typeof data === "string") {
    return adaptString(data);
  }
  try {
    const str = JSON.stringify(data);
    const adapted = adaptString(str);
    return JSON.parse(adapted);
  } catch {
    return data;
  }
}
function updateFieldConfigReferences(fieldConfig, suffix) {
  if (!fieldConfig || typeof fieldConfig !== "object") return fieldConfig;
  const config = { ...fieldConfig };
  if (config.lookupTableId) {
    config.lookupTableId = `${config.lookupTableId}${suffix}`;
  }
  if (config.lookupNodeId) {
    config.lookupNodeId = `${config.lookupNodeId}${suffix}`;
  }
  return config;
}
async function fixAllCompleteDuplications(prisma51, repeaterNodeId) {
  const report = {
    totalNodesProcessed: 0,
    nodesFixed: [],
    errors: []
  };
  try {
    const whereClause = {
      AND: [
        { label: { endsWith: "-1" } }
      ]
    };
    if (repeaterNodeId) {
      whereClause.AND.push({
        metadata: {
          path: ["duplicatedFromRepeater"],
          equals: repeaterNodeId
        }
      });
    }
    const copiedNodes = await prisma51.treeBranchLeafNode.findMany({
      where: whereClause,
      select: {
        id: true,
        label: true,
        metadata: true
      }
    });
    for (const node of copiedNodes) {
      report.totalNodesProcessed++;
      try {
        let originalNodeId = null;
        if (node.metadata && typeof node.metadata === "object") {
          const meta = node.metadata;
          originalNodeId = meta.sourceTemplateId || meta.copiedFromNodeId || null;
        }
        if (!originalNodeId && node.label) {
          const originalLabel = node.label.replace("-1", "");
          const originalNode = await prisma51.treeBranchLeafNode.findFirst({
            where: {
              label: originalLabel,
              id: { not: node.id }
            },
            select: { id: true }
          });
          if (originalNode) {
            originalNodeId = originalNode.id;
          }
        }
        if (!originalNodeId) {
          report.errors.push({
            nodeId: node.id,
            error: "Impossible de trouver le n\xC3\u2026\xE2\u20AC\u0153ud original"
          });
          continue;
        }
        const result = await fixCompleteDuplication(prisma51, originalNodeId, node.id, "-1");
        report.nodesFixed.push(result);
      } catch (error) {
        report.errors.push({
          nodeId: node.id,
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  } catch (error) {
    console.error("\xC3\xA2\xC2\x9D\xC5\u2019 [COMPLETE-DUPLICATION-FIX] Erreur g\xC3\u0192\xC2\xA9n\xC3\u0192\xC2\xA9rale:", error);
  }
  return report;
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/services/force-recalculation-service.ts
async function forceNodeRecalculationWithOwnData(prisma51, copiedNodeId) {
  const result = {
    nodeId: copiedNodeId,
    nodeLabel: null,
    oldCalculatedValue: null,
    newCalculatedValue: null,
    recalculationForced: false,
    referencesUpdated: []
  };
  const copiedNode = await prisma51.treeBranchLeafNode.findUnique({
    where: { id: copiedNodeId },
    include: {
      TreeBranchLeafNodeTable: {
        include: {
          tableColumns: true,
          tableRows: true
        }
      }
    }
  });
  if (!copiedNode) {
    throw new Error(`N\xC3\u2026\xE2\u20AC\u0153ud copi\xC3\u0192\xC2\xA9 ${copiedNodeId} non trouv\xC3\u0192\xC2\xA9`);
  }
  result.nodeLabel = copiedNode.label;
  result.oldCalculatedValue = copiedNode.calculatedValue;
  for (const formula of copiedNode.TreeBranchLeafNodeFormula) {
    if (formula.tokens) {
      let tokensStr = JSON.stringify(formula.tokens);
      let updated = false;
      const updatedTokensStr = tokensStr.replace(
        /@value\.([A-Za-z0-9_:-]+)(?!-1)/g,
        (match, nodeId) => {
          if (nodeId.includes("shared-ref") || nodeId.endsWith("1")) {
            return match;
          }
          updated = true;
          result.referencesUpdated.push(`Formula ${formula.name}: ${nodeId} \xC3\xA2\xE2\u20AC\xA0\xE2\u20AC\u2122 ${nodeId}-1`);
          return `@value.${nodeId}-1`;
        }
      );
      if (updated) {
        const newTokens = JSON.parse(updatedTokensStr);
        await prisma51.treeBranchLeafNodeFormula.update({
          where: { id: formula.id },
          data: { tokens: newTokens }
        });
      }
    }
  }
  for (const condition of copiedNode.TreeBranchLeafNodeCondition) {
    if (condition.conditionSet) {
      let conditionStr = JSON.stringify(condition.conditionSet);
      let updated = false;
      const updatedConditionStr = conditionStr.replace(
        /@value\.([A-Za-z0-9_:-]+)(?!-1)/g,
        (match, nodeId) => {
          if (nodeId.includes("shared-ref") || nodeId.endsWith("1")) {
            return match;
          }
          updated = true;
          result.referencesUpdated.push(`Condition ${condition.name}: ${nodeId} \xC3\xA2\xE2\u20AC\xA0\xE2\u20AC\u2122 ${nodeId}-1`);
          return `@value.${nodeId}-1`;
        }
      );
      if (updated) {
        const newConditionSet = JSON.parse(updatedConditionStr);
        await prisma51.treeBranchLeafNodeCondition.update({
          where: { id: condition.id },
          data: { conditionSet: newConditionSet }
        });
      }
    }
  }
  const forceRecalcMetadata = {
    ...copiedNode.metadata && typeof copiedNode.metadata === "object" ? copiedNode.metadata : {},
    forceRecalculation: true,
    lastForceRecalc: (/* @__PURE__ */ new Date()).toISOString(),
    independentCalculation: true,
    noFallbackToOriginal: true,
    recalculationReason: "Duplication independence enforcement"
  };
  await prisma51.treeBranchLeafNode.update({
    where: { id: copiedNodeId },
    data: {
      calculatedValue: null,
      calculatedAt: null,
      calculatedBy: null,
      metadata: forceRecalcMetadata
    }
  });
  result.recalculationForced = true;
  result.newCalculatedValue = null;
  return result;
}
async function forceAllNodesRecalculationWithOwnData(prisma51, repeaterNodeId) {
  const report = {
    totalNodesProcessed: 0,
    nodesRecalculated: [],
    errors: []
  };
  try {
    const whereClause = {
      AND: [
        { label: { endsWith: "-1" } }
      ]
    };
    if (repeaterNodeId) {
      whereClause.AND.push({
        metadata: {
          path: ["duplicatedFromRepeater"],
          equals: repeaterNodeId
        }
      });
    }
    const copiedNodes = await prisma51.treeBranchLeafNode.findMany({
      where: whereClause,
      select: {
        id: true,
        label: true,
        calculatedValue: true
      }
    });
    for (const node of copiedNodes) {
      report.totalNodesProcessed++;
      try {
        if (node.calculatedValue !== null) {
          const result = await forceNodeRecalculationWithOwnData(prisma51, node.id);
          report.nodesRecalculated.push(result);
        } else {
        }
      } catch (error) {
        report.errors.push({
          nodeId: node.id,
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
  } catch (error) {
    console.error("\xC3\xA2\xC2\x9D\xC5\u2019 [FORCE-RECALC-ALL] Erreur g\xC3\u0192\xC2\xA9n\xC3\u0192\xC2\xA9rale:", error);
  }
  return report;
}
async function blockFallbackToOriginalValues(prisma51, copiedNodeIds) {
  for (const nodeId of copiedNodeIds) {
    const node = await prisma51.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      select: { metadata: true }
    });
    if (node) {
      const antiFactbackMetadata = {
        ...node.metadata && typeof node.metadata === "object" ? node.metadata : {},
        blockFallbackToOriginal: true,
        enforceIndependentCalculation: true,
        lastAntiFactbackUpdate: (/* @__PURE__ */ new Date()).toISOString(),
        calculationIsolationLevel: "STRICT"
      };
      await prisma51.treeBranchLeafNode.update({
        where: { id: nodeId },
        data: {
          metadata: antiFactbackMetadata,
          // S'assurer que la valeur est null pour forcer un nouveau calcul
          calculatedValue: null,
          calculatedAt: null
        }
      });
    }
  }
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/services/recalculate-with-interpreter.ts
init_operation_interpreter();
async function recalculateNodeWithOperationInterpreter(prisma51, nodeId, submissionId) {
  const result = {
    nodeId,
    label: null,
    hasCapacity: false,
    capacityType: "none",
    oldValue: null,
    newValue: null,
    recalculationSuccess: false
  };
  try {
    const node = await prisma51.treeBranchLeafNode.findUnique({
      where: { id: nodeId },
      select: {
        id: true,
        field_label: true,
        calculatedValue: true,
        hasFormula: true,
        hasCondition: true,
        hasTable: true,
        linkedFormulaIds: true,
        linkedConditionIds: true,
        linkedTableIds: true,
        TreeBranchLeafNodeFormula: { select: { id: true } },
        TreeBranchLeafNodeCondition: { select: { id: true } },
        TreeBranchLeafNodeTable: { select: { id: true } }
      }
    });
    if (!node) {
      result.error = `N\xC3\u2026\xE2\u20AC\u0153ud non trouv\xC3\u0192\xC2\xA9`;
      return result;
    }
    result.label = node.field_label;
    result.oldValue = node.calculatedValue;
    if (node.TreeBranchLeafNodeFormula?.length > 0) {
      result.capacityType = "formula";
      result.hasCapacity = true;
    } else if (node.TreeBranchLeafNodeCondition?.length > 0) {
      result.capacityType = "condition";
      result.hasCapacity = true;
    } else if (node.TreeBranchLeafNodeTable?.length > 0) {
      result.capacityType = "table";
      result.hasCapacity = true;
    }
    if (!result.hasCapacity) {
      return result;
    }
    let sourceRef = "";
    if (result.capacityType === "formula" && node.linkedFormulaIds?.length > 0) {
      sourceRef = `node-formula:${node.linkedFormulaIds[0]}`;
    } else if (result.capacityType === "condition" && node.linkedConditionIds?.length > 0) {
      sourceRef = `condition:${node.linkedConditionIds[0]}`;
    } else if (result.capacityType === "table" && node.linkedTableIds?.length > 0) {
      sourceRef = `node-table:${node.linkedTableIds[0]}`;
    }
    if (!sourceRef) {
      result.error = `Impossible de construire sourceRef`;
      return result;
    }
    try {
      const valuesCache = /* @__PURE__ */ new Map();
      const interpretResult = await interpretReference(
        sourceRef,
        submissionId || "",
        prisma51,
        valuesCache,
        0,
        /* @__PURE__ */ new Map(),
        /* @__PURE__ */ new Map()
      );
      result.newValue = interpretResult.result;
      result.recalculationSuccess = true;
      if (result.newValue && result.newValue !== "null" && result.newValue !== "\xC3\xA2\xCB\u2020\xE2\u20AC\xA6") {
        await prisma51.treeBranchLeafNode.update({
          where: { id: nodeId },
          data: {
            calculatedValue: result.newValue,
            calculatedAt: /* @__PURE__ */ new Date(),
            calculatedBy: `interpreter-${result.capacityType}`
          }
        });
      }
    } catch (interpretError) {
      result.error = `Erreur interpretReference: ${interpretError instanceof Error ? interpretError.message : String(interpretError)}`;
      console.warn(`   \xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F  ${result.error}`);
    }
  } catch (error) {
    result.error = error instanceof Error ? error.message : String(error);
    console.error(`   \xC3\xA2\xC2\x9D\xC5\u2019 Erreur: ${result.error}`);
  }
  return result;
}
async function recalculateAllCopiedNodesWithOperationInterpreter(prisma51, repeaterNodeId, suffixMarker = "-1") {
  const report = {
    totalNodes: 0,
    recalculated: [],
    errors: []
  };
  try {
    const repeaterChildren = await prisma51.treeBranchLeafNode.findMany({
      where: {
        parentId: repeaterNodeId
      },
      select: {
        id: true,
        field_label: true
      }
    });
    const allDescendants = [];
    const queue = [...repeaterChildren];
    while (queue.length > 0) {
      const current = queue.shift();
      if (!current) continue;
      allDescendants.push(current);
      const children = await prisma51.treeBranchLeafNode.findMany({
        where: {
          parentId: current.id
        },
        select: {
          id: true,
          field_label: true
        }
      });
      queue.push(...children);
    }
    const copiedNodes = allDescendants.filter((node) => node.id.includes(suffixMarker));
    report.totalNodes = copiedNodes.length;
    for (const node of copiedNodes) {
      try {
        const recalcResult = await recalculateNodeWithOperationInterpreter(
          prisma51,
          node.id
        );
        report.recalculated.push(recalcResult);
        if (recalcResult.recalculationSuccess && recalcResult.newValue) {
        } else if (!recalcResult.recalculationSuccess) {
        }
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        report.errors.push({ nodeId: node.id, error: errorMsg });
        console.error(`   \xC3\xA2\xC2\x9D\xC5\u2019 ${node.field_label}: ${errorMsg}`);
      }
    }
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    report.errors.push({ nodeId: repeaterNodeId, error: `Erreur globale: ${errorMsg}` });
    console.error(`\xC3\xA2\xC2\x9D\xC5\u2019 Erreur globale: ${errorMsg}`);
  }
  const successCount = report.recalculated.filter((r) => r.recalculationSuccess).length;
  return report;
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/services/repeater-template-sync.ts
var parseJsonArray2 = (value) => {
  if (!value) {
    return [];
  }
  try {
    const parsed = JSON.parse(value);
    return Array.isArray(parsed) ? parsed : [];
  } catch {
    return [];
  }
};
var extractMetaTemplateIds = (metadata) => {
  if (!metadata || typeof metadata !== "object" || Array.isArray(metadata)) {
    return [];
  }
  const meta = metadata;
  const repeaterMeta = meta.repeater && typeof meta.repeater === "object" ? meta.repeater : void 0;
  const ids = repeaterMeta?.templateNodeIds;
  return Array.isArray(ids) ? ids.filter((id) => typeof id === "string" && !!id) : [];
};
var buildMetadataPayload = (metadata, templateNodeIds) => {
  const base = metadata && typeof metadata === "object" && !Array.isArray(metadata) ? { ...metadata } : {};
  const repeaterMeta = base.repeater && typeof base.repeater === "object" ? { ...base.repeater } : {};
  repeaterMeta.templateNodeIds = templateNodeIds;
  base.repeater = repeaterMeta;
  return base;
};
async function syncRepeaterTemplateIds(prisma51, repeaterNodeId, templateNodeIds) {
  if (!repeaterNodeId || !templateNodeIds.length) {
    return;
  }
  const repeater = await prisma51.treeBranchLeafNode.findUnique({
    where: { id: repeaterNodeId },
    select: { repeater_templateNodeIds: true, metadata: true }
  });
  if (!repeater) {
    return;
  }
  const columnIds = parseJsonArray2(repeater.repeater_templateNodeIds);
  const metaIds = extractMetaTemplateIds(repeater.metadata);
  const hasCopySuffix = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}(-\d+)+$/i;
  const allIds = [...columnIds, ...metaIds].filter((id) => typeof id === "string" && !!id).filter((id) => !hasCopySuffix.test(id));
  const nextIds = Array.from(new Set(allIds));
  const columnChanged = columnIds.length !== nextIds.length || columnIds.some((id, idx) => id !== nextIds[idx]);
  const metadataChanged = metaIds.length !== nextIds.length || metaIds.some((id, idx) => id !== nextIds[idx]);
  if (!columnChanged && !metadataChanged) {
    return;
  }
  await prisma51.treeBranchLeafNode.update({
    where: { id: repeaterNodeId },
    data: {
      repeater_templateNodeIds: JSON.stringify(nextIds),
      metadata: buildMetadataPayload(repeater.metadata, nextIds)
    }
  });
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/repeat-executor.ts
async function runRepeatExecution(prisma51, req2, execution) {
  const { repeaterNodeId, scopeId, plan, blueprint } = execution;
  const authCtx = getAuthCtx(req2);
  const repeaterNode = await prisma51.treeBranchLeafNode.findUnique({
    where: { id: repeaterNodeId },
    include: { TreeBranchLeafTree: true }
  });
  if (!repeaterNode) {
    throw new RepeatOperationError(`Repeater node ${repeaterNodeId} not found.`, 404);
  }
  if (!authCtx.isSuperAdmin && authCtx.organizationId && repeaterNode.TreeBranchLeafTree?.organizationId !== authCtx.organizationId) {
    throw new RepeatOperationError("Access denied for this repeater tree.", 403);
  }
  const hasCopySuffix = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}(-\d+)+$/i;
  const rawIds = blueprint.templateNodeIds;
  const templateNodeIds = rawIds.filter((id) => typeof id === "string" && !!id).map((id) => id.replace(/(-\d+)+$/, "")).filter((id) => !hasCopySuffix.test(id));
  if (rawIds.length !== templateNodeIds.length) {
    rawIds.forEach((id, idx) => {
      const cleaned = id.replace(/(-\d+)+$/, "");
      if (id !== cleaned) {
      }
    });
  }
  templateNodeIds.forEach((id, idx) => {
  });
  if (!templateNodeIds.length) {
    throw new RepeatOperationError(`Repeater ${repeaterNodeId} does not declare template nodes to duplicate.`, 422);
  }
  const templateNodes = await loadTemplateNodesWithFallback(
    prisma51,
    templateNodeIds,
    repeaterNode.treeId,
    authCtx.organizationId,
    authCtx.isSuperAdmin
  );
  const nodesToDuplicate = templateNodes.filter((node) => node.type !== "section");
  const sectionNodes = templateNodes.filter((node) => node.type === "section");
  void sectionNodes;
  const templateById = new Map(nodesToDuplicate.map((node) => [node.id, node]));
  const templateIdsForSuffix = Array.from(templateById.keys());
  const existingMax = await computeTemplateCopySuffixMax(
    prisma51,
    repeaterNode.treeId,
    templateIdsForSuffix
  );
  templateIdsForSuffix.forEach((id) => {
  });
  const plannedSuffixByTemplate = /* @__PURE__ */ new Map();
  for (const templateId of templateIdsForSuffix) {
    const maxSeen = existingMax.get(templateId) ?? 0;
    plannedSuffixByTemplate.set(templateId, maxSeen + 1);
  }
  for (const nodePlan of plan.nodes) {
    const planned = coerceSuffix(nodePlan.plannedSuffix);
    const maxSeen = existingMax.get(nodePlan.templateNodeId) ?? 0;
    const enforcedNext = Math.max(planned ?? 0, maxSeen + 1);
    plannedSuffixByTemplate.set(nodePlan.templateNodeId, enforcedNext);
  }
  const duplicatedSummaries = [];
  const duplicatedNodeIds = /* @__PURE__ */ new Set();
  const originalNodeIdByCopyId = /* @__PURE__ */ new Map();
  const triggersFixDebug = [];
  const plannedNodeIdToRealNodeId = /* @__PURE__ */ new Map();
  const globalNodeIdMap = /* @__PURE__ */ new Map();
  const globalFormulaIdMap = /* @__PURE__ */ new Map();
  const globalConditionIdMap = /* @__PURE__ */ new Map();
  const globalTableIdMap = /* @__PURE__ */ new Map();
  const globalVariableCopyCache = /* @__PURE__ */ new Map();
  for (const template of nodesToDuplicate) {
    try {
      if (!template) continue;
      const plannedSuffix = plannedSuffixByTemplate.get(template.id);
      const baseContext = {
        repeaterNodeId,
        templateNodeId: template.id,
        duplicatedFromNodeId: template.id,
        scopeId,
        mode: "repeater"
      };
      const attemptCopy = async (forcedSuffix) => {
        const context = forcedSuffix !== void 0 ? { ...baseContext, suffix: forcedSuffix } : { ...baseContext };
        const options = {
          preserveSharedReferences: true,
          repeatContext: context
        };
        if (forcedSuffix !== void 0) {
          options.forcedSuffix = forcedSuffix;
          options.suffixNum = forcedSuffix;
        }
        try {
          const result = await deepCopyNodeInternal(prisma51, req2, template.id, options);
          return { result, appliedSuffix: forcedSuffix };
        } catch (error) {
          if (forcedSuffix !== void 0 && isUniqueConstraintError(error)) {
            console.warn("[repeat-executor] Forced suffix already exists, retrying with auto suffix", {
              templateId: template.id,
              forcedSuffix
            });
            return attemptCopy(void 0);
          }
          throw error;
        }
      };
      const { result: copyResult, appliedSuffix } = await attemptCopy(plannedSuffix);
      const newRootId = copyResult.root.newId;
      const originalTemplate = await prisma51.treeBranchLeafNode.findUnique({
        where: { id: template.id },
        select: { subType: true, metadata: true }
      });
      const created = await prisma51.treeBranchLeafNode.findUnique({
        where: { id: newRootId }
      });
      if (!created) {
        throw new RepeatOperationError(`Node copy failed to materialize for template ${template.id}.`, 500);
      }
      const originalMetadata = originalTemplate?.metadata && typeof originalTemplate.metadata === "object" ? originalTemplate.metadata : {};
      const originalTriggerNodeIds = originalMetadata.triggerNodeIds;
      const createdMetadata = created.metadata && typeof created.metadata === "object" ? created.metadata : {};
      const resolvedSuffix = coerceSuffix(createdMetadata.copySuffix) ?? extractSuffixFromId2(created.id) ?? appliedSuffix ?? null;
      const effectiveSuffix = resolvedSuffix ?? plannedSuffix ?? 1;
      const suffixTriggers = (triggerNodeIds, label) => {
        if (!Array.isArray(triggerNodeIds) || triggerNodeIds.length === 0) {
          return null;
        }
        const oldTriggers = [...triggerNodeIds];
        const suffixedTriggerNodeIds = triggerNodeIds.map((triggerId) => {
          if (typeof triggerId !== "string") return triggerId;
          const cleanId = triggerId.replace(/^@value\./, "").replace(/^{/, "").replace(/}$/, "");
          if (copyResult.idMap && copyResult.idMap[cleanId]) {
            const newTriggerId = copyResult.idMap[cleanId];
            if (triggerId.startsWith("@value.")) return `@value.${newTriggerId}`;
            else if (triggerId.startsWith("{")) return `{${newTriggerId}}`;
            return newTriggerId;
          }
          const suffixedId = `${cleanId}-${effectiveSuffix}`;
          if (triggerId.startsWith("@value.")) return `@value.${suffixedId}`;
          else if (triggerId.startsWith("{")) return `{${suffixedId}}`;
          return suffixedId;
        });
        return suffixedTriggerNodeIds;
      };
      const rootSuffixedTriggers = suffixTriggers(originalTriggerNodeIds, created.label || "root");
      const updatedMetadata = {
        ...createdMetadata,
        sourceTemplateId: template.id,
        duplicatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        duplicatedFromRepeater: repeaterNodeId,
        copiedFromNodeId: template.id,
        copySuffix: effectiveSuffix,
        repeatScopeId: scopeId,
        // IMPORTANT: Pr√©server le lookup s'il existe d√©j√† (avec suffixes appliqu√©s)
        ...createdMetadata.lookup ? { lookup: createdMetadata.lookup } : {},
        // üéØ IMPORTANT: Ajouter les triggerNodeIds suffix√©s depuis l'ORIGINAL
        ...rootSuffixedTriggers ? { triggerNodeIds: rootSuffixedTriggers } : {}
      };
      console.log("\u{1F534}\u{1F534}\u{1F534} [AVANT UPDATE] newRootId:", newRootId);
      console.log("\u{1F534}\u{1F534}\u{1F534} [AVANT UPDATE] subType \xE0 appliquer:", originalTemplate?.subType);
      console.log("\u{1F534}\u{1F534}\u{1F534} [AVANT UPDATE] triggers suffix\xE9s:", rootSuffixedTriggers);
      const updateResult = await prisma51.treeBranchLeafNode.update({
        where: { id: newRootId },
        data: {
          subType: originalTemplate?.subType || null,
          metadata: updatedMetadata
        }
      });
      console.log("\u{1F7E2}\u{1F7E2}\u{1F7E2} [APR\xC8S UPDATE] R\xE9sultat:", updateResult.id, "subType:", updateResult.subType);
      triggersFixDebug.push({
        nodeId: newRootId,
        label: created.label || "root",
        originalSubType: originalTemplate?.subType || null,
        appliedSubType: originalTemplate?.subType || null,
        originalTriggers: originalTriggerNodeIds,
        suffixedTriggers: rootSuffixedTriggers
      });
      const allIdMapEntries = Object.entries(copyResult.idMap || {}).map(([oldId, newId]) => ({
        oldId,
        newId
      }));
      triggersFixDebug.push({
        nodeId: "DEBUG_IDMAP",
        label: `TOTAL ${allIdMapEntries.length} entr\xE9es dans idMap`,
        allIds: allIdMapEntries,
        lookingFor: "d371c32e-f69e-46b0-9846-f3f60f7b4ec8"
      });
      if (copyResult.idMap && Object.keys(copyResult.idMap).length > 0) {
        const childNodeIds = Object.values(copyResult.idMap).filter((id) => id !== newRootId);
        for (const childId of childNodeIds) {
          try {
            const originalChildId = Object.entries(copyResult.idMap).find(([_, newId]) => newId === childId)?.[0];
            const originalChildNode = originalChildId ? await prisma51.treeBranchLeafNode.findUnique({
              where: { id: originalChildId },
              select: { id: true, label: true, metadata: true, subType: true }
            }) : null;
            const childNode = await prisma51.treeBranchLeafNode.findUnique({
              where: { id: childId },
              select: { id: true, label: true, metadata: true, subType: true }
            });
            if (!childNode) continue;
            const childMetadata = childNode.metadata && typeof childNode.metadata === "object" ? childNode.metadata : {};
            const originalChildMetadata = originalChildNode?.metadata && typeof originalChildNode.metadata === "object" ? originalChildNode.metadata : {};
            const originalChildTriggers = originalChildMetadata.triggerNodeIds;
            const childSuffixedTriggers = suffixTriggers(
              originalChildTriggers,
              childNode.label || childId
            );
            const needsSubTypeUpdate = originalChildNode?.subType && !childNode.subType;
            const needsTriggersUpdate = childSuffixedTriggers && childSuffixedTriggers.length > 0;
            if (needsTriggersUpdate || needsSubTypeUpdate) {
              const updatedChildMetadata = {
                ...childMetadata,
                ...needsTriggersUpdate ? { triggerNodeIds: childSuffixedTriggers } : {}
              };
              await prisma51.treeBranchLeafNode.update({
                where: { id: childId },
                data: {
                  ...needsSubTypeUpdate ? { subType: originalChildNode?.subType } : {},
                  metadata: updatedChildMetadata
                }
              });
            }
          } catch (childErr) {
            console.error(`\u274C [REPEAT-EXECUTOR] Erreur traitement triggers pour enfant ${childId}:`, childErr);
          }
        }
      }
      duplicatedSummaries.push({
        id: created.id,
        label: created.label,
        type: created.type,
        parentId: created.parentId,
        sourceTemplateId: template.id
      });
      duplicatedNodeIds.add(created.id);
      originalNodeIdByCopyId.set(created.id, template.id);
      const plannedRootId = `${template.id}-${effectiveSuffix}`;
      plannedNodeIdToRealNodeId.set(plannedRootId, newRootId);
      Object.entries(copyResult.idMap || {}).forEach(([oldId, newId]) => {
        if (!newId) return;
        duplicatedNodeIds.add(newId);
        if (oldId) {
          originalNodeIdByCopyId.set(newId, oldId);
        }
        const plannedChildId = `${oldId}-${effectiveSuffix}`;
        plannedNodeIdToRealNodeId.set(plannedChildId, newId);
        globalNodeIdMap.set(oldId, newId);
      });
      if (copyResult.formulaIdMap) {
        Object.entries(copyResult.formulaIdMap).forEach(([oldId, newId]) => {
          if (oldId && newId) globalFormulaIdMap.set(oldId, newId);
        });
      }
      if (copyResult.conditionIdMap) {
        Object.entries(copyResult.conditionIdMap).forEach(([oldId, newId]) => {
          if (oldId && newId) globalConditionIdMap.set(oldId, newId);
        });
      }
      if (copyResult.tableIdMap) {
        Object.entries(copyResult.tableIdMap).forEach(([oldId, newId]) => {
          if (oldId && newId) globalTableIdMap.set(oldId, newId);
        });
      }
      if (copyResult.displayNodeIds && copyResult.displayNodeIds.length > 0) {
        copyResult.displayNodeIds.forEach((displayNodeId2) => {
          duplicatedNodeIds.add(displayNodeId2);
          const originalDisplayNodeId = displayNodeId2.replace(/-\d+$/, "");
          originalNodeIdByCopyId.set(displayNodeId2, originalDisplayNodeId);
        });
      }
      try {
        await applySharedReferencesFromOriginalInternal2({
          prisma: prisma51,
          nodeId: newRootId,
          authCtx
        });
      } catch (sharedErr) {
        console.warn("[repeat-executor] Failed to apply shared references", sharedErr);
      }
      try {
        const selectorOptions = {
          nodeIdMap: new Map(Object.entries(copyResult.idMap || {})),
          tableCopyCache: /* @__PURE__ */ new Map(),
          tableIdMap: new Map(Object.entries(copyResult.tableIdMap || {}))
        };
        await copySelectorTablesAfterNodeCopy(
          prisma51,
          newRootId,
          template.id,
          selectorOptions,
          effectiveSuffix
        );
      } catch (selectorErr) {
        console.warn("[repeat-executor] Failed to copy selector tables", selectorErr);
      }
    } catch (nodeExecErr) {
      console.error(`[repeat-executor] Error during execution for template ${template?.id || "unknown"}:`, nodeExecErr instanceof Error ? nodeExecErr.stack || nodeExecErr.message : String(nodeExecErr));
      throw nodeExecErr;
    }
  }
  for (const variablePlan of plan.variables) {
    try {
      let { templateVariableId, targetNodeId, plannedVariableId, plannedSuffix } = variablePlan;
      const templateVar = await prisma51.treeBranchLeafNodeVariable.findUnique({
        where: { id: templateVariableId },
        select: { displayName: true }
      });
      const isLookup = templateVar?.displayName?.includes("Lookup Table");
      if (isLookup) {
        continue;
      }
      const realTargetNodeId = plannedNodeIdToRealNodeId.get(targetNodeId);
      if (realTargetNodeId) {
        targetNodeId = realTargetNodeId;
      } else {
        console.warn(`\xC3\xA2\xC5\xA1\xC2\xA0\xC3\xAF\xC2\xB8\xC2\x8F  [REPEAT-EXECUTOR] Aucun mapping trouv\xC3\u0192\xC2\xA9 pour targetNodeId "${targetNodeId}", utilisation directe`);
      }
      const variableResult = await copyVariableWithCapacities(
        templateVariableId,
        plannedSuffix,
        targetNodeId,
        prisma51,
        {
          autoCreateDisplayNode: true,
          isFromRepeaterDuplication: true,
          // √É¬∞√Ö¬∏√¢‚Ç¨¬ù√Ç¬• PASSER LES MAPS GLOBALES pour que les capacit√É∆í√Ç¬©s utilisent les bons IDs
          nodeIdMap: globalNodeIdMap,
          formulaIdMap: globalFormulaIdMap,
          conditionIdMap: globalConditionIdMap,
          tableIdMap: globalTableIdMap,
          variableCopyCache: globalVariableCopyCache,
          repeatContext: {
            repeaterNodeId,
            templateNodeId: targetNodeId.replace(`-${plannedSuffix}`, ""),
            duplicatedFromNodeId: targetNodeId.replace(`-${plannedSuffix}`, ""),
            scopeId,
            mode: "repeater"
          }
        }
      );
      if (variableResult.success) {
        if (variableResult.formulaIdMap) {
          for (const [oldId, newId] of variableResult.formulaIdMap.entries()) {
            globalFormulaIdMap.set(oldId, newId);
          }
        }
        if (variableResult.conditionIdMap) {
          for (const [oldId, newId] of variableResult.conditionIdMap.entries()) {
            globalConditionIdMap.set(oldId, newId);
          }
        }
        if (variableResult.tableIdMap) {
          for (const [oldId, newId] of variableResult.tableIdMap.entries()) {
            globalTableIdMap.set(oldId, newId);
          }
        }
      }
      if (variableResult.success && variableResult.displayNodeId) {
        const originalDisplayNodeId = variableResult.displayNodeId.replace(/-\d+$/, "");
        globalNodeIdMap.set(originalDisplayNodeId, variableResult.displayNodeId);
      }
    } catch (varErr) {
      console.error(`[repeat-executor] Erreur lors de la copie de la variable ${variablePlan.templateVariableId}:`, varErr instanceof Error ? varErr.message : String(varErr));
    }
  }
  try {
    await syncRepeaterTemplateIds(prisma51, repeaterNodeId, templateNodeIds);
  } catch (syncErr) {
    console.warn("[repeat-executor] Unable to sync repeater template IDs", syncErr);
  }
  if (duplicatedNodeIds.size > 0) {
    try {
      const completeDuplicationReport = await fixAllCompleteDuplications(prisma51, repeaterNodeId);
      for (const nodeId of duplicatedNodeIds) {
        const originalNodeId = originalNodeIdByCopyId.get(nodeId);
        if (!originalNodeId) continue;
        const suffixToken = deriveCopySuffixToken(originalNodeId, nodeId);
        if (!suffixToken) continue;
        await tableLookupDuplicationService.duplicateTableLookupSystem(prisma51, originalNodeId, {
          copiedNodeId: nodeId,
          suffixToken
        });
      }
      await reassignCopiedNodesToDuplicatedParents(prisma51, duplicatedNodeIds, originalNodeIdByCopyId);
      const isolationResult = await enforceStrictIsolation(
        prisma51,
        Array.from(duplicatedNodeIds)
      );
      await verifyIsolation(prisma51, Array.from(duplicatedNodeIds));
      const resetCount = await resetCalculatedValuesAfterCopy(
        prisma51,
        Array.from(duplicatedNodeIds)
      );
      await forceIndependentCalculation(prisma51, Array.from(duplicatedNodeIds));
      await createRecalculationTriggers(prisma51, Array.from(duplicatedNodeIds));
      const forceRecalcReport = await forceAllNodesRecalculationWithOwnData(prisma51, repeaterNodeId);
      await blockFallbackToOriginalValues(prisma51, Array.from(duplicatedNodeIds));
      const interpreterRecalcReport = await recalculateAllCopiedNodesWithOperationInterpreter(
        prisma51,
        repeaterNodeId,
        "-1"
      );
      interpreterRecalcReport.recalculated.forEach((r) => {
        if (r.hasCapacity && r.newValue) {
        }
      });
    } catch (isolationError) {
      console.warn("[REPEAT-EXECUTOR] Erreur lors de l'isolation stricte:", isolationError);
    }
  }
  let nodesPayload = [];
  if (duplicatedNodeIds.size > 0) {
    const nodes = await prisma51.treeBranchLeafNode.findMany({
      where: {
        treeId: repeaterNode.treeId,
        id: { in: Array.from(duplicatedNodeIds) }
      }
    });
    nodesPayload = nodes.map(buildResponseFromColumns);
  }
  return {
    duplicated: duplicatedSummaries,
    nodes: nodesPayload,
    count: duplicatedSummaries.length,
    debug: {
      templateNodeIds,
      nodesToDuplicateIds: nodesToDuplicate.map((n) => n.id),
      sectionIds: sectionNodes.map((n) => n.id),
      templateCount: templateNodeIds.length,
      nodesToDuplicateCount: nodesToDuplicate.length,
      sectionCount: sectionNodes.length,
      // üéØ INFOS TRIGGERS POUR DEBUG FRONTEND
      triggersFix: triggersFixDebug
    }
  };
}
async function loadTemplateNodesWithFallback(prisma51, templateNodeIds, repeaterTreeId, organizationId, isSuperAdmin2) {
  if (!templateNodeIds.length) {
    throw new RepeatOperationError("Repeater does not declare template nodes to duplicate.", 422);
  }
  const scoped = await prisma51.treeBranchLeafNode.findMany({
    where: {
      id: { in: templateNodeIds },
      treeId: repeaterTreeId
    }
  });
  const foundIds = new Set(scoped.map((n) => n.id));
  const missingIds = templateNodeIds.filter((id) => !foundIds.has(id));
  let crossTree = [];
  if (missingIds.length) {
    crossTree = await prisma51.treeBranchLeafNode.findMany({
      where: { id: { in: missingIds } },
      include: {
        TreeBranchLeafTree: { select: { organizationId: true } }
      }
    });
    if (!crossTree.length) {
      if (!scoped.length) {
        throw new RepeatOperationError("No template nodes could be loaded for this repeater.", 404);
      }
    }
    if (!isSuperAdmin2 && organizationId) {
      const unauthorized = crossTree.find(
        (node) => node.TreeBranchLeafTree?.organizationId && node.TreeBranchLeafTree.organizationId !== organizationId
      );
      if (unauthorized) {
        throw new RepeatOperationError("Access denied to template library for this repeater.", 403);
      }
    }
  }
  const merged = [
    ...scoped,
    ...crossTree.map(({ TreeBranchLeafTree, ...rest }) => rest)
  ];
  if (!merged.length) {
    throw new RepeatOperationError("No template nodes could be loaded for this repeater.", 404);
  }
  return merged;
}
function coerceSuffix(value) {
  if (typeof value === "number" && Number.isFinite(value)) {
    return value;
  }
  if (typeof value === "string" && value.trim()) {
    const parsed = Number(value);
    if (Number.isFinite(parsed)) {
      return parsed;
    }
  }
  return null;
}
function extractSuffixFromId2(id) {
  if (!id) return null;
  const match = /-(\d+)$/.exec(id);
  if (!match) return null;
  const parsed = Number(match[1]);
  return Number.isFinite(parsed) ? parsed : null;
}
function deriveCopySuffixToken(originalNodeId, copiedNodeId) {
  const baseId = normalizeNodeBase2(originalNodeId);
  if (!copiedNodeId.startsWith(baseId)) {
    return null;
  }
  const remainder = copiedNodeId.slice(baseId.length);
  if (!remainder.startsWith("-") || remainder.length <= 1) {
    return null;
  }
  return remainder;
}
function normalizeNodeBase2(value) {
  return value.replace(/-\d+(?:-\d+)*$/, "");
}
function isUniqueConstraintError(error) {
  return error instanceof import_client7.Prisma.PrismaClientKnownRequestError && error.code === "P2002";
}
async function reassignCopiedNodesToDuplicatedParents(prisma51, copiedNodeIds, originalNodeIdByCopyId) {
  if (!copiedNodeIds.size) {
    return;
  }
  const copyIds = Array.from(copiedNodeIds);
  const copies = await prisma51.treeBranchLeafNode.findMany({
    where: { id: { in: copyIds } },
    select: {
      id: true,
      parentId: true,
      metadata: true
    }
  });
  if (!copies.length) {
    return;
  }
  const originalIds = Array.from(
    new Set(
      copies.map((copy) => originalNodeIdByCopyId.get(copy.id) ?? getOriginalNodeIdFromMetadata(copy.metadata)).filter((value) => Boolean(value))
    )
  );
  if (!originalIds.length) {
    return;
  }
  const originalNodes = await prisma51.treeBranchLeafNode.findMany({
    where: { id: { in: originalIds } },
    select: { id: true, parentId: true }
  });
  const originalParentMap = new Map(originalNodes.map((node) => [node.id, node.parentId]));
  const parentIdsToCheck = /* @__PURE__ */ new Set();
  const reassignmentTargets = [];
  for (const copy of copies) {
    const originalId = originalNodeIdByCopyId.get(copy.id) ?? getOriginalNodeIdFromMetadata(copy.metadata);
    if (!originalId) {
      continue;
    }
    const originalParentId = originalParentMap.get(originalId);
    if (!originalParentId) {
      continue;
    }
    const suffixToken = getCopySuffixToken(copy.id, copy.metadata);
    if (!suffixToken) {
      continue;
    }
    const sanitizedSuffix = sanitizeSuffixToken(suffixToken);
    if (!sanitizedSuffix) {
      continue;
    }
    const parentBaseId = normalizeNodeBase2(originalParentId);
    if (!parentBaseId) {
      continue;
    }
    const desiredParentId = `${parentBaseId}-${sanitizedSuffix}`;
    if (!desiredParentId || desiredParentId === copy.parentId) {
      continue;
    }
    parentIdsToCheck.add(desiredParentId);
    reassignmentTargets.push({ nodeId: copy.id, targetParentId: desiredParentId });
  }
  if (!reassignmentTargets.length) {
    return;
  }
  const existingParents = await prisma51.treeBranchLeafNode.findMany({
    where: { id: { in: Array.from(parentIdsToCheck) } },
    select: { id: true }
  });
  const existingParentIds = new Set(existingParents.map((parent) => parent.id));
  const updates = [];
  for (const target of reassignmentTargets) {
    if (!existingParentIds.has(target.targetParentId)) {
      continue;
    }
    updates.push(
      prisma51.treeBranchLeafNode.update({
        where: { id: target.nodeId },
        data: { parentId: target.targetParentId }
      })
    );
  }
  if (!updates.length) {
    return;
  }
  await prisma51.$transaction(updates);
}
function getCopySuffixToken(nodeId, metadata) {
  const normalizedMetadata = normalizeMetadata(metadata);
  const rawSuffix = normalizedMetadata?.copySuffix;
  if (typeof rawSuffix === "number" && Number.isFinite(rawSuffix)) {
    return String(rawSuffix);
  }
  if (typeof rawSuffix === "string" && rawSuffix.trim()) {
    return rawSuffix.trim();
  }
  const parsed = extractSuffixFromId2(nodeId);
  return parsed !== null ? String(parsed) : null;
}
function getOriginalNodeIdFromMetadata(metadata) {
  const normalizedMetadata = normalizeMetadata(metadata);
  if (!normalizedMetadata) {
    return null;
  }
  const candidates = ["copiedFromNodeId", "duplicatedFromNodeId", "sourceTemplateId"];
  for (const key2 of candidates) {
    const value = normalizedMetadata[key2];
    if (typeof value === "string" && value.trim()) {
      return value.trim();
    }
  }
  return null;
}
function sanitizeSuffixToken(token) {
  return token.replace(/^[-_]+/, "").trim();
}
function normalizeMetadata(metadata) {
  if (!metadata || typeof metadata !== "object" || Array.isArray(metadata)) {
    return null;
  }
  return metadata;
}

// src/components/TreeBranchLeaf/treebranchleaf-new/api/repeat/repeat-routes.ts
function createRepeatRouter(prisma51) {
  const router94 = (0, import_express91.Router)();
  const inFlightExecuteByRepeater = /* @__PURE__ */ new Set();
  router94.use(authenticateToken);
  router94.post("/:repeaterNodeId/instances", async (req2, res) => {
    const { repeaterNodeId } = req2.params;
    const body2 = req2.body || {};
    try {
      const result = await planRepeatDuplication(prisma51, repeaterNodeId, {
        suffix: body2.suffix,
        includeTotals: body2.includeTotals,
        targetParentId: body2.targetParentId,
        scopeId: body2.scopeId
      });
      return res.status(200).json({
        status: "planned",
        repeaterNodeId,
        scopeId: result.scopeId,
        suffix: result.suffix,
        plan: result.plan,
        blueprint: result.blueprint
      });
    } catch (error) {
      if (error instanceof RepeatOperationError) {
        return res.status(error.status).json({
          error: error.message,
          details: error.details ?? null
        });
      }
      console.error("[repeat-route] Unable to plan duplication", error);
      return res.status(500).json({
        error: "Failed to plan repeat duplication.",
        details: error instanceof Error ? error.message : String(error)
      });
    }
  });
  router94.post("/:repeaterNodeId/instances/execute", async (req2, res) => {
    const { repeaterNodeId } = req2.params;
    const body2 = req2.body || {};
    if (inFlightExecuteByRepeater.has(repeaterNodeId)) {
      return res.status(409).json({
        error: "Repeat execution already in progress for this repeater.",
        details: "Another request is currently duplicating this repeater. Please retry in a moment."
      });
    }
    inFlightExecuteByRepeater.add(repeaterNodeId);
    try {
      const executionPlan = await executeRepeatDuplication(prisma51, repeaterNodeId, {
        suffix: body2.suffix,
        includeTotals: body2.includeTotals,
        targetParentId: body2.targetParentId,
        scopeId: body2.scopeId
      });
      const executionSummary = await runRepeatExecution(
        prisma51,
        req2,
        executionPlan
      );
      return res.status(201).json({
        status: "completed",
        repeaterNodeId,
        scopeId: executionPlan.scopeId,
        suffix: executionPlan.suffix,
        operations: executionPlan.operations,
        plan: executionPlan.plan,
        blueprint: executionPlan.blueprint,
        duplicated: executionSummary.duplicated,
        nodes: executionSummary.nodes,
        count: executionSummary.count,
        debug: executionSummary.debug
      });
    } catch (error) {
      if (error instanceof RepeatOperationError) {
        return res.status(error.status).json({
          error: error.message,
          details: error.details ?? null
        });
      }
      const stack = error instanceof Error ? error.stack || error.message : String(error);
      console.error("[repeat-route] Unable to execute duplication", stack);
      return res.status(500).json({
        error: "Failed to execute repeat duplication.",
        details: error instanceof Error ? error.message : String(error)
      });
    } finally {
      inFlightExecuteByRepeater.delete(repeaterNodeId);
    }
  });
  return router94;
}

// src/api/cloud-run-domains.ts
var import_express92 = require("express");
var router89 = (0, import_express92.Router)();
router89.get("/cloud-run-domains", authenticateToken, async (req2, res) => {
  try {
    const user = req2.user;
    if (!user.isSuperAdmin) {
      return res.status(403).json({
        error: "Acc\xE8s refus\xE9. Fonctionnalit\xE9 r\xE9serv\xE9e aux Super Admins."
      });
    }
    const mappedDomains = [
      {
        domain: "2thier.be",
        serviceName: "crm2thier-vite-prod",
        region: "europe-west1",
        status: "active",
        mappedAt: "2024-12-01",
        // Date approximative
        description: "Site principal 2Thier Energy"
      },
      {
        domain: "devis1minute.be",
        serviceName: "crm2thier-vite-prod",
        region: "europe-west1",
        status: "active",
        mappedAt: "2024-12-01",
        description: "Landing page Devis1Minute"
      }
      // Ajoutez ici vos autres domaines mapp√©s dans Cloud Run
    ];
    console.log("\u2705 [CloudRunDomains] R\xE9cup\xE9ration des domaines mapp\xE9s:", mappedDomains.length);
    res.json({
      success: true,
      domains: mappedDomains,
      count: mappedDomains.length
    });
  } catch (error) {
    console.error("\u274C [CloudRunDomains] Erreur:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration des domaines Cloud Run",
      details: error.message
    });
  }
});
router89.post("/cloud-run-domains/verify", authenticateToken, async (req2, res) => {
  try {
    const user = req2.user;
    const { domain } = req2.body;
    if (!user.isSuperAdmin) {
      return res.status(403).json({
        error: "Acc\xE8s refus\xE9. Fonctionnalit\xE9 r\xE9serv\xE9e aux Super Admins."
      });
    }
    if (!domain) {
      return res.status(400).json({ error: "Le domaine est requis" });
    }
    const isReachable = await checkDomainReachability(domain);
    res.json({
      success: true,
      domain,
      verified: isReachable,
      verifiedAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("\u274C [CloudRunDomains] Erreur v\xE9rification:", error);
    res.status(500).json({
      error: "Erreur lors de la v\xE9rification du domaine",
      details: error.message
    });
  }
});
async function checkDomainReachability(domain) {
  try {
    const https = await import("https");
    return new Promise((resolve) => {
      const options = {
        hostname: domain,
        port: 443,
        path: "/",
        method: "HEAD",
        timeout: 5e3
      };
      const req2 = https.request(options, (res) => {
        resolve(res.statusCode !== void 0 && res.statusCode < 500);
      });
      req2.on("error", () => resolve(false));
      req2.on("timeout", () => {
        req2.destroy();
        resolve(false);
      });
      req2.end();
    });
  } catch (error) {
    console.error("\u274C Erreur lors de la v\xE9rification du domaine:", error);
    return false;
  }
}
var cloud_run_domains_default = router89;

// src/api/measurement-reference.ts
var import_express93 = require("express");
var sharpModule = __toESM(require("sharp"), 1);

// src/lib/apriltag-detector-server.ts
var apriltagModulePromise = null;
async function loadApriltagModule() {
  if (!apriltagModulePromise) {
    apriltagModulePromise = import("@monumental-works/apriltag-node");
  }
  return apriltagModulePromise;
}
async function detectAprilTagsMetreA4(data, width, height, options = {}) {
  try {
    console.log(`\u{1F3AF} [APRILTAG] D\xE9tection AprilTags M\xE9tr\xE9 A4 V10...`);
    const { default: AprilTag, FAMILIES } = await loadApriltagModule();
    const grayscale = new Uint8Array(width * height);
    for (let i = 0; i < width * height; i++) {
      const r = data[i * 4];
      const g = data[i * 4 + 1];
      const b = data[i * 4 + 2];
      grayscale[i] = Math.floor((r + g + b) / 3);
    }
    const detector = new AprilTag(FAMILIES.TAG36H11, {
      quadDecimate: options.quadDecimate ?? 2,
      // Acc√©l√©ration sur grandes images
      quadSigma: options.quadSigma ?? 0,
      // Pas de flou gaussien
      refineEdges: options.refineEdges ?? true,
      // Meilleure pr√©cision des coins
      decodeSharpening: options.decodeSharpening ?? 0.25
    });
    const detections = detector.detect(width, height, grayscale);
    console.log(`   \u{1F50D} ${detections.length} AprilTag(s) d\xE9tect\xE9(s)`);
    if (detections.length === 0) {
      return [];
    }
    const results = [];
    for (const detection of detections) {
      const corners = [
        { x: detection.corners[0][0], y: detection.corners[0][1] },
        // Top-left
        { x: detection.corners[1][0], y: detection.corners[1][1] },
        // Top-right
        { x: detection.corners[2][0], y: detection.corners[2][1] },
        // Bottom-right
        { x: detection.corners[3][0], y: detection.corners[3][1] }
        // Bottom-left
      ];
      const distinctPixels = /* @__PURE__ */ new Set();
      for (let i = 0; i < 4; i++) {
        const key2 = `${corners[i].x.toFixed(1)},${corners[i].y.toFixed(1)}`;
        distinctPixels.add(key2);
      }
      if (distinctPixels.size < 4) {
        console.warn(`   \u274C [APRILTAG ID=${detection.id}] D\xE9tection D\xC9G\xC9N\xC9R\xC9E: ${distinctPixels.size} coins distincts au lieu de 4`);
        corners.forEach((c, i) => console.warn(`      Corner ${i}: (${c.x.toFixed(1)}, ${c.y.toFixed(1)})`));
        console.warn(`   \u23ED\uFE0F  REJET DE CETTE D\xC9TECTION`);
        continue;
      }
      const dist = (a, b) => Math.hypot(b.x - a.x, b.y - a.y);
      const diag1 = dist(corners[0], corners[2]);
      const diag2 = dist(corners[1], corners[3]);
      const perimeter = dist(corners[0], corners[1]) + dist(corners[1], corners[2]) + dist(corners[2], corners[3]) + dist(corners[3], corners[0]);
      const diagRatio = Math.min(diag1, diag2) / Math.max(diag1, diag2);
      if (diagRatio < 0.8 || diagRatio > 1.2 || perimeter < 100) {
        console.warn(`   \u26A0\uFE0F  [APRILTAG ID=${detection.id}] G\xE9om\xE9trie suspecte: diagRatio=${diagRatio.toFixed(2)}, perimeter=${perimeter.toFixed(0)}px`);
      }
      const center = {
        x: (corners[0].x + corners[1].x + corners[2].x + corners[3].x) / 4,
        y: (corners[0].y + corners[1].y + corners[2].y + corners[3].y) / 4
      };
      results.push({ id: detection.id, corners, center });
      console.log(`   \u2705 AprilTag ID=${detection.id} d\xE9tect\xE9 (diag: ${diag1.toFixed(0)}px/${diag2.toFixed(0)}px)`);
    }
    return results;
  } catch (error) {
    console.error(`\u274C [APRILTAG] Erreur d\xE9tection:`, error);
    return [];
  }
}

// src/utils/homographyUtils.ts
function computeHomography(srcPoints, dstPoints) {
  if (srcPoints.length !== 4 || dstPoints.length !== 4) {
    throw new Error("Homography requires exactly 4 points");
  }
  const srcCentroid = computeCentroid(srcPoints);
  const srcScale = computeAverageDistanceFromCentroid(srcPoints, srcCentroid);
  const dstCentroid = computeCentroid(dstPoints);
  const dstScale = computeAverageDistanceFromCentroid(dstPoints, dstCentroid);
  const normalizedSrc = normalizePoints(srcPoints, srcCentroid, srcScale);
  const normalizedDst = normalizePoints(dstPoints, dstCentroid, dstScale);
  console.log("\u{1F527} [Homography] Normalisation:", {
    srcCentroid: `(${srcCentroid[0].toFixed(1)}, ${srcCentroid[1].toFixed(1)})`,
    srcScale: srcScale.toFixed(2),
    dstCentroid: `(${dstCentroid[0].toFixed(1)}, ${dstCentroid[1].toFixed(1)})`,
    dstScale: dstScale.toFixed(2)
  });
  const A = [];
  for (let i = 0; i < 4; i++) {
    const [x, y] = normalizedSrc[i];
    const [xp, yp] = normalizedDst[i];
    A.push([-x, -y, -1, 0, 0, 0, x * xp, y * xp, xp]);
    A.push([0, 0, 0, -x, -y, -1, x * yp, y * yp, yp]);
  }
  const Hnorm = solveHomographySystem(A);
  const H = denormalizeHomography(Hnorm, srcCentroid, srcScale, dstCentroid, dstScale);
  const Hinv = invertMatrix3x3(H);
  const quality = evaluateHomographyQuality(srcPoints, dstPoints, H);
  const uncertainty = estimateUncertainty(quality, srcPoints);
  console.log(`\u{1F4D0} [Homography] Matrice calcul\xE9e, qualit\xE9: ${quality.toFixed(1)}%, incertitude: \xB1${uncertainty.toFixed(1)}%`);
  return {
    matrix: H,
    inverseMatrix: Hinv,
    quality,
    uncertainty
  };
}
function applyHomography(H, point) {
  const [x, y] = point;
  const xp = H[0][0] * x + H[0][1] * y + H[0][2];
  const yp = H[1][0] * x + H[1][1] * y + H[1][2];
  const w = H[2][0] * x + H[2][1] * y + H[2][2];
  return [xp / w, yp / w];
}
function computeRealDistance(H, p1, p2) {
  const realP1 = applyHomography(H, p1);
  const realP2 = applyHomography(H, p2);
  const dx = realP2[0] - realP1[0];
  const dy = realP2[1] - realP1[1];
  return Math.sqrt(dx * dx + dy * dy);
}
function computeRealDistanceWithUncertainty(H, p1, p2, uncertaintyPercent) {
  const distance = computeRealDistance(H, p1, p2);
  const uncertainty = distance * (uncertaintyPercent / 100);
  return {
    distance,
    uncertainty,
    min: distance - uncertainty,
    max: distance + uncertainty
  };
}
function cornersToPoints(corners) {
  return [
    [corners.topLeft.x, corners.topLeft.y],
    [corners.topRight.x, corners.topRight.y],
    [corners.bottomRight.x, corners.bottomRight.y],
    [corners.bottomLeft.x, corners.bottomLeft.y]
  ];
}
function solveHomographySystem(A) {
  const ATA = multiplyMatrices(transpose(A), A);
  const EPSILON = 1e-8;
  for (let i = 0; i < 9; i++) {
    ATA[i][i] += EPSILON;
  }
  let h = [1, 1, 1, 1, 1, 1, 1, 1, 1];
  let norm = Math.sqrt(h.reduce((s, v) => s + v * v, 0));
  h = h.map((v) => v / norm);
  for (let iter = 0; iter < 50; iter++) {
    const x = solveLinearSystem(
      ATA.map((row) => [...row]),
      // Copie pour ne pas modifier
      [...h]
    );
    const xNorm = Math.sqrt(x.reduce((s, v) => s + v * v, 0));
    if (xNorm < EPSILON || !isFinite(xNorm)) {
      console.warn("\u26A0\uFE0F [Homography] It\xE9ration divergente, arr\xEAt");
      break;
    }
    h = x.map((v) => v / xNorm);
  }
  const scale = Math.abs(h[8]) > EPSILON ? h[8] : 1;
  const normalized = h.map((v) => v / scale);
  const hasNaN = normalized.some((v) => !isFinite(v));
  if (hasNaN) {
    console.warn("\u26A0\uFE0F [Homography] Solution invalide (NaN), retour identit\xE9");
    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
  }
  return [
    [normalized[0], normalized[1], normalized[2]],
    [normalized[3], normalized[4], normalized[5]],
    [normalized[6], normalized[7], normalized[8]]
  ];
}
function invertMatrix3x3(M) {
  const [[a, b, c], [d, e, f], [g, h, i]] = M;
  const det = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);
  if (Math.abs(det) < 1e-10) {
    console.warn("\u26A0\uFE0F [Homography] Matrice singuli\xE8re, retour identit\xE9");
    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
  }
  const invDet = 1 / det;
  return [
    [(e * i - f * h) * invDet, (c * h - b * i) * invDet, (b * f - c * e) * invDet],
    [(f * g - d * i) * invDet, (a * i - c * g) * invDet, (c * d - a * f) * invDet],
    [(d * h - e * g) * invDet, (b * g - a * h) * invDet, (a * e - b * d) * invDet]
  ];
}
function evaluateHomographyQuality(srcPoints, dstPoints, H) {
  let totalError = 0;
  for (let i = 0; i < 4; i++) {
    const projected = applyHomography(H, srcPoints[i]);
    const dx = projected[0] - dstPoints[i][0];
    const dy = projected[1] - dstPoints[i][1];
    totalError += Math.sqrt(dx * dx + dy * dy);
  }
  const avgError = totalError / 4;
  const quality = Math.max(0, Math.min(100, 100 - avgError * 5));
  return quality;
}
function estimateUncertainty(quality, srcPoints) {
  let baseUncertainty = (100 - quality) / 10;
  const [tl, tr, br, bl] = srcPoints;
  const topWidth = Math.sqrt((tr[0] - tl[0]) ** 2 + (tr[1] - tl[1]) ** 2);
  const bottomWidth = Math.sqrt((br[0] - bl[0]) ** 2 + (br[1] - bl[1]) ** 2);
  const leftHeight = Math.sqrt((bl[0] - tl[0]) ** 2 + (bl[1] - tl[1]) ** 2);
  const rightHeight = Math.sqrt((br[0] - tr[0]) ** 2 + (br[1] - tr[1]) ** 2);
  const widthRatio = Math.max(topWidth, bottomWidth) / Math.min(topWidth, bottomWidth);
  const heightRatio = Math.max(leftHeight, rightHeight) / Math.min(leftHeight, rightHeight);
  if (widthRatio > 1.5 || heightRatio > 1.5) {
    baseUncertainty += (Math.max(widthRatio, heightRatio) - 1) * 3;
  }
  return Math.min(25, baseUncertainty);
}
function transpose(M) {
  const rows = M.length;
  const cols = M[0].length;
  const result = [];
  for (let j = 0; j < cols; j++) {
    result[j] = [];
    for (let i = 0; i < rows; i++) {
      result[j][i] = M[i][j];
    }
  }
  return result;
}
function multiplyMatrices(A, B) {
  const rowsA = A.length;
  const colsA = A[0].length;
  const colsB = B[0].length;
  const result = [];
  for (let i = 0; i < rowsA; i++) {
    result[i] = [];
    for (let j = 0; j < colsB; j++) {
      let sum = 0;
      for (let k = 0; k < colsA; k++) {
        sum += A[i][k] * B[k][j];
      }
      result[i][j] = sum;
    }
  }
  return result;
}
function solveLinearSystem(A, b) {
  const n = A.length;
  const aug = A.map((row, i) => [...row, b[i]]);
  for (let col = 0; col < n; col++) {
    let maxRow = col;
    for (let row = col + 1; row < n; row++) {
      if (Math.abs(aug[row][col]) > Math.abs(aug[maxRow][col])) {
        maxRow = row;
      }
    }
    [aug[col], aug[maxRow]] = [aug[maxRow], aug[col]];
    for (let row = col + 1; row < n; row++) {
      if (Math.abs(aug[col][col]) < 1e-10) continue;
      const factor = aug[row][col] / aug[col][col];
      for (let j = col; j <= n; j++) {
        aug[row][j] -= factor * aug[col][j];
      }
    }
  }
  const x = new Array(n).fill(0);
  for (let i = n - 1; i >= 0; i--) {
    let sum = aug[i][n];
    for (let j = i + 1; j < n; j++) {
      sum -= aug[i][j] * x[j];
    }
    x[i] = Math.abs(aug[i][i]) > 1e-10 ? sum / aug[i][i] : 0;
  }
  return x;
}
function computeCentroid(points) {
  const n = points.length;
  let sumX = 0, sumY = 0;
  for (const [x, y] of points) {
    sumX += x;
    sumY += y;
  }
  return [sumX / n, sumY / n];
}
function computeAverageDistanceFromCentroid(points, centroid) {
  let totalDist = 0;
  for (const [x, y] of points) {
    totalDist += Math.sqrt((x - centroid[0]) ** 2 + (y - centroid[1]) ** 2);
  }
  return totalDist / points.length;
}
function normalizePoints(points, centroid, scale) {
  const scaleFactor = Math.SQRT2 / (scale || 1);
  return points.map(([x, y]) => [
    (x - centroid[0]) * scaleFactor,
    (y - centroid[1]) * scaleFactor
  ]);
}
function denormalizeHomography(Hnorm, srcCentroid, srcScale, dstCentroid, dstScale) {
  const srcScaleFactor = Math.SQRT2 / (srcScale || 1);
  const dstScaleFactor = Math.SQRT2 / (dstScale || 1);
  const Tsrc = [
    [srcScaleFactor, 0, -srcCentroid[0] * srcScaleFactor],
    [0, srcScaleFactor, -srcCentroid[1] * srcScaleFactor],
    [0, 0, 1]
  ];
  const TdstInv = [
    [1 / dstScaleFactor, 0, dstCentroid[0]],
    [0, 1 / dstScaleFactor, dstCentroid[1]],
    [0, 0, 1]
  ];
  const temp = multiplyMatrices3x3(Hnorm, Tsrc);
  return multiplyMatrices3x3(TdstInv, temp);
}
function multiplyMatrices3x3(A, B) {
  const result = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      result[i][j] = A[i][0] * B[0][j] + A[i][1] * B[1][j] + A[i][2] * B[2][j];
    }
  }
  return result;
}

// src/lib/metre-a4-v10-detector.ts
var METRE_A4_V10_SPECS = {
  version: "A4-CALIB-V10",
  sheet: {
    width_mm: 210,
    height_mm: 297
  },
  margins_mm: {
    top: 10,
    left: 15,
    right: 15,
    bottom: 30
  },
  smallTag: {
    size_mm: 50,
    centers_mm: {
      topLeft: { x: 40, y: 35 },
      topCenter: { x: 105, y: 35 },
      topRight: { x: 170, y: 35 },
      bottomLeft: { x: 40, y: 240 },
      bottomCenter: { x: 105, y: 240 },
      bottomRight: { x: 170, y: 240 }
    }
  },
  largeTag: {
    size_mm: 100,
    center_mm: { x: 105, y: 150 }
  },
  reference: {
    width_mm: 130,
    height_mm: 205,
    width_cm: 13,
    height_cm: 20.5
  }
};
var avgSidePx = (tag) => {
  const [c0, c1, c2, c3] = tag.corners;
  const d = (a, b) => Math.hypot(b.x - a.x, b.y - a.y);
  const sides = [d(c0, c1), d(c1, c2), d(c2, c3), d(c3, c0)];
  return sides.reduce((sum, v) => sum + v, 0) / sides.length;
};
var sortByY = (a, b) => a.center.y - b.center.y;
var sortByX = (a, b) => a.center.x - b.center.x;
function fitLine(points) {
  if (points.length === 2) {
    const [p1, p2] = points;
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const length = Math.hypot(dx, dy) || 1;
    const a2 = -dy / length;
    const b2 = dx / length;
    const c2 = -(a2 * p1.x + b2 * p1.y);
    return { a: a2, b: b2, c: c2 };
  }
  const meanX = points.reduce((s, p) => s + p.x, 0) / points.length;
  const meanY = points.reduce((s, p) => s + p.y, 0) / points.length;
  let sxx = 0;
  let syy = 0;
  let sxy = 0;
  for (const p of points) {
    const dx = p.x - meanX;
    const dy = p.y - meanY;
    sxx += dx * dx;
    syy += dy * dy;
    sxy += dx * dy;
  }
  const theta = 0.5 * Math.atan2(2 * sxy, sxx - syy);
  const vx = Math.cos(theta);
  const vy = Math.sin(theta);
  const a = -vy;
  const b = vx;
  const norm = Math.hypot(a, b) || 1;
  const na = a / norm;
  const nb = b / norm;
  const c = -(na * meanX + nb * meanY);
  return { a: na, b: nb, c };
}
function intersectLines(l1, l2) {
  const det = l1.a * l2.b - l2.a * l1.b;
  if (Math.abs(det) < 1e-6) {
    return { x: 0, y: 0 };
  }
  const x = (l2.b * -l1.c - l1.b * -l2.c) / det;
  const y = (l1.a * -l2.c - l2.a * -l1.c) / det;
  return { x, y };
}
function computeReprojectionErrorMm(homography, points) {
  if (points.length === 0) return 0;
  const errors = points.map((p) => {
    const [rx, ry] = applyHomography(homography, [p.pixel.x, p.pixel.y]);
    const dx = rx - p.real.x;
    const dy = ry - p.real.y;
    return Math.hypot(dx, dy);
  });
  const mean = errors.reduce((s, v) => s + v, 0) / errors.length;
  return mean;
}
function buildCornerPairs(tag, centerMm, sizeMm) {
  const half = sizeMm / 2;
  const realCorners = [
    { x: centerMm.x - half, y: centerMm.y - half },
    { x: centerMm.x + half, y: centerMm.y - half },
    { x: centerMm.x + half, y: centerMm.y + half },
    { x: centerMm.x - half, y: centerMm.y + half }
  ];
  return tag.corners.map((corner, idx) => ({
    pixel: { x: corner.x, y: corner.y },
    real: realCorners[idx] || realCorners[0]
  }));
}
function buildCenterPair(tag, centerMm) {
  return { pixel: { x: tag.center.x, y: tag.center.y }, real: centerMm };
}
function ransacHomography(points, iterations = 200, thresholdMm = 3) {
  if (points.length < 4) return null;
  let bestInliers = [];
  let bestMatrix = null;
  for (let i = 0; i < iterations; i++) {
    const sample = [];
    const used = /* @__PURE__ */ new Set();
    while (sample.length < 4) {
      const idx = Math.floor(Math.random() * points.length);
      if (!used.has(idx)) {
        used.add(idx);
        sample.push(points[idx]);
      }
    }
    try {
      const src = sample.map((p) => [p.pixel.x, p.pixel.y]);
      const dst = sample.map((p) => [p.real.x, p.real.y]);
      const homography = computeHomography(src, dst);
      const inliers = points.filter((p) => {
        const [rx, ry] = applyHomography(homography.matrix, [p.pixel.x, p.pixel.y]);
        const err = Math.hypot(rx - p.real.x, ry - p.real.y);
        return err <= thresholdMm;
      });
      if (inliers.length > bestInliers.length) {
        bestInliers = inliers;
        bestMatrix = homography.matrix;
      }
    } catch {
    }
  }
  if (!bestMatrix) return null;
  return {
    matrix: bestMatrix,
    inliers: bestInliers.length,
    total: points.length
  };
}
function buildFallbackFromLargeTag(largeTag, largeSizePx) {
  try {
    console.log("\u26A0\uFE0F [V10] Fallback: grand tag seul (pr\xE9diction des petits tags)");
    const halfLarge = METRE_A4_V10_SPECS.largeTag.size_mm / 2;
    const largeCenterMm = METRE_A4_V10_SPECS.largeTag.center_mm;
    const largeRealCorners = [
      [largeCenterMm.x - halfLarge, largeCenterMm.y - halfLarge],
      [largeCenterMm.x + halfLarge, largeCenterMm.y - halfLarge],
      [largeCenterMm.x + halfLarge, largeCenterMm.y + halfLarge],
      [largeCenterMm.x - halfLarge, largeCenterMm.y + halfLarge]
    ];
    const largePixelCorners = largeTag.corners.map((c) => [c.x, c.y]);
    const realToPixel = computeHomography(largeRealCorners, largePixelCorners);
    const predict = (p) => {
      const [x, y] = applyHomography(realToPixel.matrix, [p.x, p.y]);
      return { x, y };
    };
    const predictedCenters = {
      topLeft: predict(METRE_A4_V10_SPECS.smallTag.centers_mm.topLeft),
      topCenter: predict(METRE_A4_V10_SPECS.smallTag.centers_mm.topCenter),
      topRight: predict(METRE_A4_V10_SPECS.smallTag.centers_mm.topRight),
      bottomLeft: predict(METRE_A4_V10_SPECS.smallTag.centers_mm.bottomLeft),
      bottomCenter: predict(METRE_A4_V10_SPECS.smallTag.centers_mm.bottomCenter),
      bottomRight: predict(METRE_A4_V10_SPECS.smallTag.centers_mm.bottomRight)
    };
    const topLine = fitLine([predictedCenters.topLeft, predictedCenters.topCenter, predictedCenters.topRight]);
    const bottomLine = fitLine([predictedCenters.bottomLeft, predictedCenters.bottomCenter, predictedCenters.bottomRight]);
    const leftLine = fitLine([predictedCenters.topLeft, predictedCenters.bottomLeft]);
    const rightLine = fitLine([predictedCenters.topRight, predictedCenters.bottomRight]);
    const fusedCorners = {
      topLeft: intersectLines(topLine, leftLine),
      topRight: intersectLines(topLine, rightLine),
      bottomRight: intersectLines(bottomLine, rightLine),
      bottomLeft: intersectLines(bottomLine, leftLine)
    };
    const dstPoints = [
      [0, 0],
      [METRE_A4_V10_SPECS.reference.width_mm, 0],
      [METRE_A4_V10_SPECS.reference.width_mm, METRE_A4_V10_SPECS.reference.height_mm],
      [0, METRE_A4_V10_SPECS.reference.height_mm]
    ];
    const srcPoints = [
      [fusedCorners.topLeft.x, fusedCorners.topLeft.y],
      [fusedCorners.topRight.x, fusedCorners.topRight.y],
      [fusedCorners.bottomRight.x, fusedCorners.bottomRight.y],
      [fusedCorners.bottomLeft.x, fusedCorners.bottomLeft.y]
    ];
    const homography = computeHomography(srcPoints, dstPoints);
    const reprojectionPoints = [
      { pixel: predictedCenters.topLeft, real: METRE_A4_V10_SPECS.smallTag.centers_mm.topLeft },
      { pixel: predictedCenters.topCenter, real: METRE_A4_V10_SPECS.smallTag.centers_mm.topCenter },
      { pixel: predictedCenters.topRight, real: METRE_A4_V10_SPECS.smallTag.centers_mm.topRight },
      { pixel: predictedCenters.bottomLeft, real: METRE_A4_V10_SPECS.smallTag.centers_mm.bottomLeft },
      { pixel: predictedCenters.bottomCenter, real: METRE_A4_V10_SPECS.smallTag.centers_mm.bottomCenter },
      { pixel: predictedCenters.bottomRight, real: METRE_A4_V10_SPECS.smallTag.centers_mm.bottomRight },
      { pixel: largeTag.center, real: METRE_A4_V10_SPECS.largeTag.center_mm }
    ];
    const reprojectionErrorMm = Math.max(5, computeReprojectionErrorMm(homography.matrix, reprojectionPoints));
    const quality = Math.min(60, homography.quality * 0.6);
    return {
      success: true,
      detectionMethod: "Metre-A4-V10",
      fallbackMode: "largeTagOnly",
      warnings: ["Grand tag seul d\xE9tect\xE9 - pr\xE9cision d\xE9grad\xE9e"],
      fusedCorners,
      largeTagCorners: largeTag.corners,
      tagCenters: {
        topLeft: predictedCenters.topLeft,
        topCenter: predictedCenters.topCenter,
        topRight: predictedCenters.topRight,
        bottomLeft: predictedCenters.bottomLeft,
        bottomCenter: predictedCenters.bottomCenter,
        bottomRight: predictedCenters.bottomRight,
        center: largeTag.center
      },
      homography: {
        matrix: homography.matrix,
        quality,
        reprojectionErrorMm
      },
      sizesPx: {
        largeTag: largeSizePx,
        smallTags: Array(6).fill(largeSizePx * 0.5)
      }
    };
  } catch (error) {
    console.error("\u274C [V10] Fallback grand tag \xE9chou\xE9:", error);
    return null;
  }
}
async function detectMetreA4V10(data, width, height) {
  const detectedTags = await detectAprilTagsMetreA4(data, width, height);
  if (!detectedTags.length) {
    console.log("   \u274C [V10] Aucun AprilTag d\xE9tect\xE9");
    return null;
  }
  const tagsWithSize = detectedTags.map((tag) => ({ tag, size: avgSidePx(tag) }));
  const sortedBySize = [...tagsWithSize].sort((a, b) => b.size - a.size);
  const largest = sortedBySize[0];
  if (!largest) return null;
  const largeTag = largest.tag;
  const largeSize = largest.size;
  const smallTarget = largeSize * 0.5;
  const smallCandidates = sortedBySize.slice(1).filter(({ size }) => size >= largeSize * 0.35 && size <= largeSize * 0.7).sort((a, b) => Math.abs(a.size - smallTarget) - Math.abs(b.size - smallTarget)).slice(0, 6);
  if (smallCandidates.length < 6) {
    console.log(`   \u26A0\uFE0F [V10] Seulement ${smallCandidates.length}/6 petits tags d\xE9tect\xE9s`);
    const fallback = buildFallbackFromLargeTag(largeTag, largeSize);
    return fallback;
  }
  const smallTags = smallCandidates.map(({ tag }) => tag);
  const sortedByRow = [...smallTags].sort(sortByY);
  const topRow = sortedByRow.slice(0, 3).sort(sortByX);
  const bottomRow = sortedByRow.slice(3, 6).sort(sortByX);
  const [topLeft, topCenter, topRight] = topRow;
  const [bottomLeft, bottomCenter, bottomRight] = bottomRow;
  if (!topLeft || !topCenter || !topRight || !bottomLeft || !bottomCenter || !bottomRight) {
    console.log("   \u274C [V10] Impossible de classer les 6 tags en lignes");
    return null;
  }
  const topLine = fitLine([topLeft.center, topCenter.center, topRight.center]);
  const bottomLine = fitLine([bottomLeft.center, bottomCenter.center, bottomRight.center]);
  const leftLine = fitLine([topLeft.center, bottomLeft.center]);
  const rightLine = fitLine([topRight.center, bottomRight.center]);
  const fusedCorners = {
    topLeft: intersectLines(topLine, leftLine),
    topRight: intersectLines(topLine, rightLine),
    bottomRight: intersectLines(bottomLine, rightLine),
    bottomLeft: intersectLines(bottomLine, leftLine)
  };
  const dstPoints = [
    [0, 0],
    [METRE_A4_V10_SPECS.reference.width_mm, 0],
    [METRE_A4_V10_SPECS.reference.width_mm, METRE_A4_V10_SPECS.reference.height_mm],
    [0, METRE_A4_V10_SPECS.reference.height_mm]
  ];
  const srcPoints = [
    [fusedCorners.topLeft.x, fusedCorners.topLeft.y],
    [fusedCorners.topRight.x, fusedCorners.topRight.y],
    [fusedCorners.bottomRight.x, fusedCorners.bottomRight.y],
    [fusedCorners.bottomLeft.x, fusedCorners.bottomLeft.y]
  ];
  const pointPairs = [
    buildCenterPair(topLeft, METRE_A4_V10_SPECS.smallTag.centers_mm.topLeft),
    buildCenterPair(topCenter, METRE_A4_V10_SPECS.smallTag.centers_mm.topCenter),
    buildCenterPair(topRight, METRE_A4_V10_SPECS.smallTag.centers_mm.topRight),
    buildCenterPair(bottomLeft, METRE_A4_V10_SPECS.smallTag.centers_mm.bottomLeft),
    buildCenterPair(bottomCenter, METRE_A4_V10_SPECS.smallTag.centers_mm.bottomCenter),
    buildCenterPair(bottomRight, METRE_A4_V10_SPECS.smallTag.centers_mm.bottomRight),
    buildCenterPair(largeTag, METRE_A4_V10_SPECS.largeTag.center_mm),
    ...buildCornerPairs(topLeft, METRE_A4_V10_SPECS.smallTag.centers_mm.topLeft, METRE_A4_V10_SPECS.smallTag.size_mm),
    ...buildCornerPairs(topCenter, METRE_A4_V10_SPECS.smallTag.centers_mm.topCenter, METRE_A4_V10_SPECS.smallTag.size_mm),
    ...buildCornerPairs(topRight, METRE_A4_V10_SPECS.smallTag.centers_mm.topRight, METRE_A4_V10_SPECS.smallTag.size_mm),
    ...buildCornerPairs(bottomLeft, METRE_A4_V10_SPECS.smallTag.centers_mm.bottomLeft, METRE_A4_V10_SPECS.smallTag.size_mm),
    ...buildCornerPairs(bottomCenter, METRE_A4_V10_SPECS.smallTag.centers_mm.bottomCenter, METRE_A4_V10_SPECS.smallTag.size_mm),
    ...buildCornerPairs(bottomRight, METRE_A4_V10_SPECS.smallTag.centers_mm.bottomRight, METRE_A4_V10_SPECS.smallTag.size_mm),
    ...buildCornerPairs(largeTag, METRE_A4_V10_SPECS.largeTag.center_mm, METRE_A4_V10_SPECS.largeTag.size_mm)
  ];
  const ransac = ransacHomography(pointPairs, 200, 3);
  const homography = ransac ? { matrix: ransac.matrix, quality: ransac.inliers / ransac.total * 100 } : computeHomography(srcPoints, dstPoints);
  const reprojectionPoints = [
    { pixel: topLeft.center, real: METRE_A4_V10_SPECS.smallTag.centers_mm.topLeft },
    { pixel: topCenter.center, real: METRE_A4_V10_SPECS.smallTag.centers_mm.topCenter },
    { pixel: topRight.center, real: METRE_A4_V10_SPECS.smallTag.centers_mm.topRight },
    { pixel: bottomLeft.center, real: METRE_A4_V10_SPECS.smallTag.centers_mm.bottomLeft },
    { pixel: bottomCenter.center, real: METRE_A4_V10_SPECS.smallTag.centers_mm.bottomCenter },
    { pixel: bottomRight.center, real: METRE_A4_V10_SPECS.smallTag.centers_mm.bottomRight },
    { pixel: largeTag.center, real: METRE_A4_V10_SPECS.largeTag.center_mm }
  ];
  const reprojectionErrorMm = computeReprojectionErrorMm(homography.matrix, reprojectionPoints);
  return {
    success: true,
    detectionMethod: "Metre-A4-V10",
    warnings: [],
    fusedCorners,
    largeTagCorners: largeTag.corners,
    tagCenters: {
      topLeft: topLeft.center,
      topCenter: topCenter.center,
      topRight: topRight.center,
      bottomLeft: bottomLeft.center,
      bottomCenter: bottomCenter.center,
      bottomRight: bottomRight.center,
      center: largeTag.center
    },
    homography: {
      matrix: homography.matrix,
      quality: homography.quality,
      reprojectionErrorMm
    },
    sizesPx: {
      largeTag: largeSize,
      smallTags: smallCandidates.map(({ size }) => size)
    }
  };
}

// src/services/measurement-calculator.ts
function computeObjectDimensions(calibration, objectCorners) {
  console.log("\n" + "\u2550".repeat(90));
  console.log("\u{1F4CA} [MEASUREMENT-CALCULATOR] D\xC9TAIL COMPLET DU CALCUL");
  console.log("\u2550".repeat(90));
  const warnings = [];
  const markerWidthCm = 13;
  const markerHeightCm = 20.5;
  const markerWidthMm = markerWidthCm * 10;
  const markerHeightMm = markerHeightCm * 10;
  console.log(`
\u{1F539} MARQUEUR DE R\xC9F\xC9RENCE:`);
  console.log(`   Type: M\xE9tr\xE9 A4 V10`);
  console.log(`   Dimensions: ${markerWidthCm}cm \xD7 ${markerHeightCm}cm = ${markerWidthMm}mm \xD7 ${markerHeightMm}mm`);
  const srcCorners = {
    topLeft: { x: calibration.markerCorners.topLeft.x, y: calibration.markerCorners.topLeft.y },
    topRight: { x: calibration.markerCorners.topRight.x, y: calibration.markerCorners.topRight.y },
    bottomLeft: { x: calibration.markerCorners.bottomLeft.x, y: calibration.markerCorners.bottomLeft.y },
    bottomRight: { x: calibration.markerCorners.bottomRight.x, y: calibration.markerCorners.bottomRight.y }
  };
  const srcPoints = cornersToPoints(srcCorners);
  const dstPoints = [
    [0, 0],
    // topLeft
    [markerWidthMm, 0],
    // topRight
    [markerWidthMm, markerHeightMm],
    // bottomRight
    [0, markerHeightMm]
    // bottomLeft
  ];
  console.log(`   \u{1F4D0} Points destination V10 ${markerWidthMm}\xD7${markerHeightMm}mm:`, dstPoints.map((p) => `(${p[0]}, ${p[1]})`).join(", "));
  const markerWidthPx = Math.hypot(
    srcPoints[1][0] - srcPoints[0][0],
    srcPoints[1][1] - srcPoints[0][1]
  );
  const markerHeightPx = Math.hypot(
    srcPoints[3][0] - srcPoints[0][0],
    srcPoints[3][1] - srcPoints[0][1]
  );
  let homography;
  console.log(`
\u{1F4D0} \xC9TAPE 2: Construction homographie basique (4 points)`);
  console.log(`   Coins marqueur (px):`);
  console.log(`      TL: (${srcPoints[0][0].toFixed(0)}, ${srcPoints[0][1].toFixed(0)})`);
  console.log(`      TR: (${srcPoints[1][0].toFixed(0)}, ${srcPoints[1][1].toFixed(0)})`);
  console.log(`      BR: (${srcPoints[2][0].toFixed(0)}, ${srcPoints[2][1].toFixed(0)})`);
  console.log(`      BL: (${srcPoints[3][0].toFixed(0)}, ${srcPoints[3][1].toFixed(0)})`);
  console.log(`   Coins destination (mm):`);
  console.log(`      TL: (0, 0), TR: (${markerWidthMm}, 0)`);
  console.log(`      BR: (${markerWidthMm}, ${markerHeightMm}), BL: (0, ${markerHeightMm})`);
  console.log(`   Taille marqueur en pixels: ${markerWidthPx.toFixed(0)} \xD7 ${markerHeightPx.toFixed(0)}`);
  try {
    homography = computeHomography(srcPoints, dstPoints);
    console.log(`   \u2705 Homographie calcul\xE9e`);
    console.log(`      Qualit\xE9: ${homography.quality.toFixed(1)}%`);
    console.log(`      Incertitude: \xB1${homography.uncertainty.toFixed(1)}%`);
  } catch (error) {
    console.error("\u274C Erreur calcul homographie:", error);
    return {
      success: false,
      largeur_cm: 0,
      hauteur_cm: 0,
      incertitude_largeur_cm: 0,
      incertitude_hauteur_cm: 0,
      method: "fallback",
      confidence: 0,
      warnings: ["\xC9chec du calcul d'homographie"]
    };
  }
  if (homography.quality < 50) {
    warnings.push("Qualit\xE9 homographie faible - mesures moins fiables");
  }
  console.log(`
\u{1F4CF} \xC9TAPE 3: Transformation des coins de l'objet`);
  const objTL = [objectCorners.topLeft.x, objectCorners.topLeft.y];
  const objTR = [objectCorners.topRight.x, objectCorners.topRight.y];
  const objBR = [objectCorners.bottomRight.x, objectCorners.bottomRight.y];
  const objBL = [objectCorners.bottomLeft.x, objectCorners.bottomLeft.y];
  console.log(`   Coins objet (px):`);
  console.log(`      TL: (${objTL[0].toFixed(0)}, ${objTL[1].toFixed(0)})`);
  console.log(`      TR: (${objTR[0].toFixed(0)}, ${objTR[1].toFixed(0)})`);
  console.log(`      BR: (${objBR[0].toFixed(0)}, ${objBR[1].toFixed(0)})`);
  console.log(`      BL: (${objBL[0].toFixed(0)}, ${objBL[1].toFixed(0)})`);
  const realTL = applyHomography(homography.matrix, objTL);
  const realTR = applyHomography(homography.matrix, objTR);
  const realBR = applyHomography(homography.matrix, objBR);
  const realBL = applyHomography(homography.matrix, objBL);
  console.log(`   Coins objet transform\xE9s (mm):`);
  console.log(`      TL: (${realTL[0].toFixed(1)}, ${realTL[1].toFixed(1)})`);
  console.log(`      TR: (${realTR[0].toFixed(1)}, ${realTR[1].toFixed(1)})`);
  console.log(`      BR: (${realBR[0].toFixed(1)}, ${realBR[1].toFixed(1)})`);
  console.log(`      BL: (${realBL[0].toFixed(1)}, ${realBL[1].toFixed(1)})`);
  console.log(`
\u{1F4CF} \xC9TAPE 4: Calcul des dimensions finales`);
  const widthTopPx = Math.hypot(objTR[0] - objTL[0], objTR[1] - objTL[1]);
  const widthBottomPx = Math.hypot(objBR[0] - objBL[0], objBR[1] - objBL[1]);
  const widthTop = computeRealDistanceWithUncertainty(
    homography.matrix,
    objTL,
    objTR,
    homography.uncertainty
  );
  const widthBottom = computeRealDistanceWithUncertainty(
    homography.matrix,
    objBL,
    objBR,
    homography.uncertainty
  );
  console.log(`   Largeur haut: ${widthTop.distance.toFixed(1)}mm (\xB1${widthTop.uncertainty.toFixed(1)}mm)`);
  console.log(`   Largeur bas: ${widthBottom.distance.toFixed(1)}mm (\xB1${widthBottom.uncertainty.toFixed(1)}mm)`);
  const heightLeft = computeRealDistanceWithUncertainty(
    homography.matrix,
    objTL,
    objBL,
    homography.uncertainty
  );
  const heightRight = computeRealDistanceWithUncertainty(
    homography.matrix,
    objTR,
    objBR,
    homography.uncertainty
  );
  const heightLeftPx = Math.hypot(objBL[0] - objTL[0], objBL[1] - objTL[1]);
  const heightRightPx = Math.hypot(objBR[0] - objTR[0], objBR[1] - objTR[1]);
  console.log(`   Hauteur gauche: ${heightLeft.distance.toFixed(1)}mm (\xB1${heightLeft.uncertainty.toFixed(1)}mm)`);
  console.log(`   Hauteur droite: ${heightRight.distance.toFixed(1)}mm (\xB1${heightRight.uncertainty.toFixed(1)}mm)`);
  const avgWidthMm = (widthTop.distance + widthBottom.distance) / 2;
  const avgHeightMm = (heightLeft.distance + heightRight.distance) / 2;
  const avgWidthUncertaintyMm = (widthTop.uncertainty + widthBottom.uncertainty) / 2;
  const avgHeightUncertaintyMm = (heightLeft.uncertainty + heightRight.uncertainty) / 2;
  const scaleFactor = 1;
  const pxPerMmMarker = (markerWidthPx + markerHeightPx) / (2 * ((markerWidthMm + markerHeightMm) / 2));
  const pxPerMmObjSamples = [
    widthTopPx / Math.max(widthTop.distance, 1e-6),
    widthBottomPx / Math.max(widthBottom.distance, 1e-6),
    heightLeftPx / Math.max(heightLeft.distance, 1e-6),
    heightRightPx / Math.max(heightRight.distance, 1e-6)
  ].filter((v) => Number.isFinite(v) && v > 0);
  if (pxPerMmObjSamples.length > 0) {
    const avgPxPerMmObj = pxPerMmObjSamples.reduce((a, b) => a + b, 0) / pxPerMmObjSamples.length;
    const ratio = avgPxPerMmObj / pxPerMmMarker;
    console.log(`   \u{1F4CA} Ratio pixels/mm (objet/marqueur): ${ratio.toFixed(2)} (info seulement, NON appliqu\xE9)`);
  }
  const widthVariation = Math.abs(widthTop.distance - widthBottom.distance) / avgWidthMm * 100;
  const heightVariation = Math.abs(heightLeft.distance - heightRight.distance) / avgHeightMm * 100;
  console.log(`
   \u{1F4CA} Variation entre c\xF4t\xE9s oppos\xE9s:`);
  console.log(`      Largeur: ${widthVariation.toFixed(1)}%`);
  console.log(`      Hauteur: ${heightVariation.toFixed(1)}%`);
  if (widthVariation > 10) {
    warnings.push(`Variation largeur ${widthVariation.toFixed(0)}% - perspective forte`);
  }
  if (heightVariation > 10) {
    warnings.push(`Variation hauteur ${heightVariation.toFixed(0)}% - perspective forte`);
  }
  const largeur_cm = avgWidthMm * scaleFactor / 10;
  const hauteur_cm = avgHeightMm * scaleFactor / 10;
  const incertitude_largeur_cm = avgWidthUncertaintyMm * scaleFactor / 10;
  const incertitude_hauteur_cm = avgHeightUncertaintyMm * scaleFactor / 10;
  const variationPenalty = Math.max(0, (widthVariation + heightVariation) / 2 - 5) * 2;
  const confidence = Math.max(0, Math.min(100, homography.quality - variationPenalty)) / 100;
  const objectWidthPx = Math.hypot(objTR[0] - objTL[0], objTR[1] - objTL[1]);
  const objectHeightPx = Math.hypot(objBL[0] - objTL[0], objBL[1] - objTL[1]);
  console.log("\n" + "=".repeat(70));
  console.log("\u2705 [MEASUREMENT-CALCULATOR] R\xC9SULTAT FORMULE 1");
  console.log("=".repeat(70));
  console.log(`   \u{1F4CF} LARGEUR: ${largeur_cm.toFixed(2)} cm (\xB1${incertitude_largeur_cm.toFixed(2)} cm)`);
  console.log(`   \u{1F4CF} HAUTEUR: ${hauteur_cm.toFixed(2)} cm (\xB1${incertitude_hauteur_cm.toFixed(2)} cm)`);
  console.log(`   \u{1F3AF} M\xE9thode: homography (4 pts) (FORMULE 1)`);
  console.log(`   \u{1F4CA} Confiance: ${(confidence * 100).toFixed(0)}%`);
  console.log(`   \u{1F4CA} Qualit\xE9 homographie: ${homography.quality.toFixed(1)}%`);
  if (warnings.length > 0) {
    console.log(`   \u26A0\uFE0F Avertissements: ${warnings.join(", ")}`);
  }
  console.log("=".repeat(70) + "\n");
  return {
    success: true,
    largeur_cm,
    hauteur_cm,
    incertitude_largeur_cm,
    incertitude_hauteur_cm,
    method: "homography",
    confidence,
    warnings,
    debug: {
      homographyQuality: homography.quality,
      widthVariationPercent: widthVariation,
      heightVariationPercent: heightVariation,
      markerSizePixels: { width: markerWidthPx, height: markerHeightPx },
      objectSizePixels: { width: objectWidthPx, height: objectHeightPx },
      transformedCorners: {
        tl: realTL,
        tr: realTR,
        br: realBR,
        bl: realBL
      }
    }
  };
}

// src/api/measurement-reference.ts
var sharp = sharpModule.default || sharpModule;
var router90 = (0, import_express93.Router)();
router90.post("/ultra-fusion-detect", authenticateToken, async (req2, res) => {
  const startTime = Date.now();
  try {
    const { photos } = req2.body;
    if (!req2.user?.id) {
      return res.status(401).json({ error: "Non authentifi\xE9" });
    }
    if (!photos || !Array.isArray(photos) || photos.length === 0) {
      return res.status(400).json({
        success: false,
        error: "Au minimum 1 photo requise dans photos[]"
      });
    }
    if (photos.length > 1) {
      console.log(`\u26A0\uFE0F [V10] ${photos.length} photos re\xE7ues \u2192 seule la premi\xE8re est analys\xE9e`);
    }
    console.log(`
${"=".repeat(80)}`);
    console.log(`\u{1F3AF} [M\xC9TR\xC9 A4 V10] POST /ultra-fusion-detect - 1 photo`);
    console.log(`${"=".repeat(80)}
`);
    const photo = photos[0];
    const base64Clean = photo.base64.includes(",") ? photo.base64.split(",")[1] : photo.base64;
    const imageBuffer = Buffer.from(base64Clean, "base64");
    const originalMetadata = await sharp(imageBuffer).metadata();
    const originalWidth = originalMetadata.width;
    const originalHeight = originalMetadata.height;
    const resizedBuffer = await sharp(imageBuffer).resize({
      width: 1200,
      height: 1200,
      fit: "inside",
      withoutEnlargement: true
    }).toBuffer();
    const metadata = await sharp(resizedBuffer).metadata();
    const width = metadata.width;
    const height = metadata.height;
    const scaleX = originalWidth / width;
    const scaleY = originalHeight / height;
    const { data: basePixels } = await sharp(resizedBuffer).ensureAlpha().raw().toBuffer({ resolveWithObject: true });
    let rgbaUsed = new Uint8ClampedArray(basePixels);
    let detection = await detectMetreA4V10(rgbaUsed, width, height);
    if (!detection) {
      console.log(`      \u{1F3A8} Preprocessing l\xE9ger (normalize + sharpen) ...`);
      const { data: enhancedPixels } = await sharp(resizedBuffer).normalize().sharpen(1.2).ensureAlpha().raw().toBuffer({ resolveWithObject: true });
      rgbaUsed = new Uint8ClampedArray(enhancedPixels);
      detection = await detectMetreA4V10(rgbaUsed, width, height);
    }
    if (!detection) {
      return res.status(400).json({
        success: false,
        error: "M\xE9tr\xE9 A4 V10 non d\xE9tect\xE9 (6 petits tags + 1 grand). V\xE9rifiez l\u2019impression et l\u2019\xE9clairage."
      });
    }
    const fusedCorners = {
      topLeft: { x: detection.fusedCorners.topLeft.x * scaleX / originalWidth * 100, y: detection.fusedCorners.topLeft.y * scaleY / originalHeight * 100 },
      topRight: { x: detection.fusedCorners.topRight.x * scaleX / originalWidth * 100, y: detection.fusedCorners.topRight.y * scaleY / originalHeight * 100 },
      bottomRight: { x: detection.fusedCorners.bottomRight.x * scaleX / originalWidth * 100, y: detection.fusedCorners.bottomRight.y * scaleY / originalHeight * 100 },
      bottomLeft: { x: detection.fusedCorners.bottomLeft.x * scaleX / originalWidth * 100, y: detection.fusedCorners.bottomLeft.y * scaleY / originalHeight * 100 }
    };
    const scaleMatrix = [
      [1 / scaleX, 0, 0],
      [0, 1 / scaleY, 0],
      [0, 0, 1]
    ];
    const multiply3x3 = (A, B) => {
      const result = [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
      ];
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          result[i][j] = A[i][0] * B[0][j] + A[i][1] * B[1][j] + A[i][2] * B[2][j];
        }
      }
      return result;
    };
    const homographyOriginal = multiply3x3(detection.homography.matrix, scaleMatrix);
    const totalTime = Date.now() - startTime;
    console.log(`
\u2705 SUCC\xC8S - ${totalTime}ms (M\xE9tr\xE9 A4 V10)
`);
    return res.json({
      success: true,
      method: "metre-a4-v10-homography",
      fallbackMode: detection.fallbackMode,
      warnings: detection.warnings || [],
      bestPhotoBase64: base64Clean,
      fusedCorners,
      homographyReady: true,
      sheetSizeMm: {
        width: METRE_A4_V10_SPECS.sheet.width_mm,
        height: METRE_A4_V10_SPECS.sheet.height_mm
      },
      referenceCentersMm: {
        width: METRE_A4_V10_SPECS.reference.width_mm,
        height: METRE_A4_V10_SPECS.reference.height_mm
      },
      homographyMatrix: homographyOriginal,
      bestPhoto: {
        index: 0,
        score: detection.homography.quality,
        sharpness: 0,
        homographyQuality: detection.homography.quality,
        captureConditions: 0,
        warnings: []
      },
      allPhotoScores: [{
        index: 0,
        score: detection.homography.quality,
        detected: true
      }],
      metrics: {
        inputPhotos: photos.length,
        successfulDetections: 1,
        processingTimeMs: totalTime,
        improvement: 0
      }
    });
  } catch (error) {
    console.error("\u274C [V10] Erreur ultra-fusion-detect:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur serveur lors de l\u2019analyse M\xE9tr\xE9 A4 V10"
    });
  }
});
router90.post("/compute-dimensions-simple", authenticateToken, async (req2, res) => {
  try {
    if (!req2.user?.id) {
      return res.status(401).json({ error: "Non authentifi\xE9" });
    }
    const {
      fusedCorners,
      objectPoints,
      imageWidth,
      imageHeight,
      canvasScale = 1,
      exif,
      detectionQuality = 95
    } = req2.body;
    if (!fusedCorners || !objectPoints || objectPoints.length !== 4) {
      return res.status(400).json({
        success: false,
        error: "fusedCorners et 4 objectPoints requis"
      });
    }
    if (!imageWidth || !imageHeight) {
      return res.status(400).json({
        success: false,
        error: "imageWidth et imageHeight requis"
      });
    }
    const markerCorners = {
      topLeft: {
        x: fusedCorners.topLeft.x / 100 * imageWidth,
        y: fusedCorners.topLeft.y / 100 * imageHeight
      },
      topRight: {
        x: fusedCorners.topRight.x / 100 * imageWidth,
        y: fusedCorners.topRight.y / 100 * imageHeight
      },
      bottomRight: {
        x: fusedCorners.bottomRight.x / 100 * imageWidth,
        y: fusedCorners.bottomRight.y / 100 * imageHeight
      },
      bottomLeft: {
        x: fusedCorners.bottomLeft.x / 100 * imageWidth,
        y: fusedCorners.bottomLeft.y / 100 * imageHeight
      }
    };
    const objectCorners = {
      topLeft: {
        x: objectPoints[0].x / canvasScale,
        y: objectPoints[0].y / canvasScale
      },
      topRight: {
        x: objectPoints[1].x / canvasScale,
        y: objectPoints[1].y / canvasScale
      },
      bottomRight: {
        x: objectPoints[2].x / canvasScale,
        y: objectPoints[2].y / canvasScale
      },
      bottomLeft: {
        x: objectPoints[3].x / canvasScale,
        y: objectPoints[3].y / canvasScale
      }
    };
    const calibration = {
      markerCorners,
      imageWidth,
      imageHeight,
      exif,
      detectionQuality
    };
    const result = computeObjectDimensions(calibration, objectCorners);
    return res.json({
      ...result,
      sheetSizeMm: {
        width: METRE_A4_V10_SPECS.sheet.width_mm,
        height: METRE_A4_V10_SPECS.sheet.height_mm
      },
      referenceCentersMm: {
        width: METRE_A4_V10_SPECS.reference.width_mm,
        height: METRE_A4_V10_SPECS.reference.height_mm
      }
    });
  } catch (error) {
    console.error("\u274C [V10] Erreur compute-dimensions-simple:", error);
    return res.status(500).json({
      success: false,
      error: "Erreur serveur lors du calcul des dimensions",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
var measurement_reference_default = router90;

// src/routes/userFavoritesRoutes.ts
var import_express94 = require("express");
init_database();
var router91 = (0, import_express94.Router)();
router91.get("/", authMiddleware, async (req2, res) => {
  try {
    const userId = req2.user?.userId;
    const organizationId = req2.user?.organizationId;
    if (!userId || !organizationId) {
      return res.status(401).json({ error: "Non authentifi\xE9" });
    }
    console.log(`[UserFavorites] GET /favorites - userId: ${userId}, orgId: ${organizationId}`);
    const favorites = await db.userFavoriteModule.findMany({
      where: {
        userId,
        organizationId
      },
      select: {
        moduleKey: true,
        createdAt: true
      },
      orderBy: {
        createdAt: "asc"
      }
    });
    const moduleKeys = favorites.map((f) => f.moduleKey);
    console.log(`[UserFavorites] \u2705 ${moduleKeys.length} favoris trouv\xE9s`, moduleKeys);
    res.json({ favorites: moduleKeys });
  } catch (error) {
    console.error("[UserFavorites] \u274C Erreur GET /favorites:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration des favoris",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router91.post("/", authMiddleware, async (req2, res) => {
  try {
    const userId = req2.user?.userId;
    const organizationId = req2.user?.organizationId;
    const { moduleKey } = req2.body;
    if (!userId || !organizationId) {
      return res.status(401).json({ error: "Non authentifi\xE9" });
    }
    if (!moduleKey || typeof moduleKey !== "string") {
      return res.status(400).json({ error: "moduleKey requis et doit \xEAtre une cha\xEEne" });
    }
    console.log(`[UserFavorites] POST /favorites - moduleKey: ${moduleKey}`);
    const existing = await db.userFavoriteModule.findUnique({
      where: {
        userId_organizationId_moduleKey: {
          userId,
          organizationId,
          moduleKey
        }
      }
    });
    if (existing) {
      console.log(`[UserFavorites] \u26A0\uFE0F Favori d\xE9j\xE0 existant: ${moduleKey}`);
      return res.status(409).json({ error: "Ce module est d\xE9j\xE0 dans les favoris" });
    }
    const favorite = await db.userFavoriteModule.create({
      data: {
        userId,
        organizationId,
        moduleKey
      }
    });
    console.log(`[UserFavorites] \u2705 Favori cr\xE9\xE9: ${moduleKey}`);
    res.status(201).json({ favorite: favorite.moduleKey });
  } catch (error) {
    console.error("[UserFavorites] \u274C Erreur POST /favorites:", error);
    res.status(500).json({
      error: "Erreur lors de l'ajout du favori",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router91.delete("/:moduleKey", authMiddleware, async (req2, res) => {
  try {
    const userId = req2.user?.userId;
    const organizationId = req2.user?.organizationId;
    const { moduleKey } = req2.params;
    if (!userId || !organizationId) {
      return res.status(401).json({ error: "Non authentifi\xE9" });
    }
    if (!moduleKey) {
      return res.status(400).json({ error: "moduleKey requis" });
    }
    console.log(`[UserFavorites] DELETE /favorites/:${moduleKey}`);
    const deleted = await db.userFavoriteModule.deleteMany({
      where: {
        userId,
        organizationId,
        moduleKey
      }
    });
    if (deleted.count === 0) {
      console.log(`[UserFavorites] \u26A0\uFE0F Favori non trouv\xE9: ${moduleKey}`);
      return res.status(404).json({ error: "Ce favori n'existe pas" });
    }
    console.log(`[UserFavorites] \u2705 Favori supprim\xE9: ${moduleKey}`);
    res.json({ message: "Favori supprim\xE9 avec succ\xE8s" });
  } catch (error) {
    console.error("[UserFavorites] \u274C Erreur DELETE /favorites/:moduleKey:", error);
    res.status(500).json({
      error: "Erreur lors de la suppression du favori",
      details: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
var userFavoritesRoutes_default = router91;

// src/routes/website-forms.ts
var import_express95 = require("express");
init_database();
var router92 = (0, import_express95.Router)();
var getOrgId2 = (req2) => {
  const orgId = req2.organizationId || req2.headers["x-organization-id"];
  if (!orgId) throw new Error("Organization ID manquant");
  return orgId;
};
router92.get("/", async (req2, res) => {
  try {
    const organizationId = getOrgId2(req2);
    const { websiteId } = req2.query;
    console.log("\u{1F4CB} [WebsiteForms] GET all forms for org:", organizationId);
    const forms = await db.website_forms.findMany({
      where: {
        organizationId,
        ...websiteId ? {
          websites: {
            some: { websiteId: Number(websiteId) }
          }
        } : {}
      },
      include: {
        steps: {
          orderBy: { order: "asc" },
          include: {
            fields: {
              orderBy: { order: "asc" }
            }
          }
        },
        websites: {
          include: {
            website: {
              select: { id: true, siteName: true, slug: true }
            }
          }
        },
        _count: {
          select: { submissions: true, steps: true, questions: true }
        }
      },
      orderBy: { createdAt: "desc" }
    });
    console.log(`\u2705 [WebsiteForms] Found ${forms.length} forms`);
    res.json(forms);
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error fetching forms:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration des formulaires",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.get("/by-website/:websiteId", async (req2, res) => {
  try {
    const organizationId = getOrgId2(req2);
    const { websiteId } = req2.params;
    console.log("\u{1F4CB} [WebsiteForms] GET forms for website:", websiteId);
    const forms = await db.website_forms.findMany({
      where: {
        organizationId,
        websites: {
          some: { websiteId: Number(websiteId) }
        }
      },
      include: {
        steps: {
          orderBy: { order: "asc" },
          include: {
            fields: {
              orderBy: { order: "asc" }
            }
          }
        },
        websites: {
          include: {
            website: {
              select: { id: true, siteName: true, slug: true }
            }
          }
        },
        _count: {
          select: { submissions: true, steps: true, questions: true }
        }
      },
      orderBy: { createdAt: "desc" }
    });
    console.log(`\u2705 [WebsiteForms] Found ${forms.length} forms for website ${websiteId}`);
    res.json(forms);
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error fetching forms by website:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration des formulaires",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.get("/my-commercial-links", authMiddleware, async (req2, res) => {
  try {
    const organizationId = getOrgId2(req2);
    const userId = req2.user.userId;
    console.log("\u{1F3AF} [WebsiteForms] GET my-commercial-links for user:", userId);
    const user = await db.user.findUnique({
      where: { id: userId },
      select: { firstName: true, lastName: true }
    });
    if (!user) {
      return res.status(404).json({ error: "Utilisateur introuvable" });
    }
    const userSlug = await generateUserSlug2(user.firstName, user.lastName, organizationId);
    const forms = await db.website_forms.findMany({
      where: {
        organizationId,
        requiresCommercialTracking: true,
        isActive: true
      },
      select: {
        id: true,
        name: true,
        description: true,
        slug: true,
        isActive: true,
        websites: {
          select: {
            website: {
              select: {
                cloudRunDomain: true,
                domain: true,
                siteName: true
              }
            },
            urlPath: true,
            isDefault: true
          }
        },
        _count: {
          select: { submissions: true }
        }
      },
      orderBy: { createdAt: "desc" }
    });
    const formattedForms = forms.map((form) => {
      const defaultWebsite = form.websites.find((w) => w.isDefault) || form.websites[0];
      const websiteUrl = defaultWebsite?.website.cloudRunDomain ? `https://${defaultWebsite.website.cloudRunDomain}` : defaultWebsite?.website.domain ? `https://${defaultWebsite.website.domain}` : null;
      return {
        id: form.id.toString(),
        name: form.name,
        description: form.description,
        slug: form.slug,
        isActive: form.isActive,
        submissionCount: form._count.submissions,
        websiteUrl,
        // URL du site associ√©
        websiteName: defaultWebsite?.website.siteName,
        urlPath: defaultWebsite?.urlPath || "/simulateur"
      };
    });
    console.log("\u2705 [WebsiteForms] Found", formattedForms.length, "nominative forms");
    res.json({
      success: true,
      userSlug,
      forms: formattedForms
    });
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error getting commercial links:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration des liens commerciaux",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.get("/:id", async (req2, res) => {
  try {
    const organizationId = getOrgId2(req2);
    const { id } = req2.params;
    console.log("\u{1F4CB} [WebsiteForms] GET form:", id);
    const form = await db.website_forms.findFirst({
      where: {
        id: Number(id),
        organizationId
      },
      include: {
        steps: {
          orderBy: { order: "asc" },
          include: {
            fields: {
              orderBy: { order: "asc" }
            }
          }
        },
        websites: {
          include: {
            website: {
              select: { id: true, siteName: true, slug: true, domain: true }
            }
          }
        },
        _count: {
          select: { submissions: true }
        }
      }
    });
    if (!form) {
      return res.status(404).json({ error: "Formulaire non trouv\xE9" });
    }
    console.log("\u2705 [WebsiteForms] Form found:", form.name);
    res.json(form);
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error fetching form:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration du formulaire",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.post("/", async (req2, res) => {
  try {
    const organizationId = getOrgId2(req2);
    const { name, slug, description, treeId, settings, successTitle, successMessage, requiresCommercialTracking } = req2.body;
    console.log("\u{1F4CB} [WebsiteForms] CREATE form:", name);
    const existing = await db.website_forms.findFirst({
      where: { organizationId, slug }
    });
    if (existing) {
      return res.status(400).json({ error: "Un formulaire avec ce slug existe d\xE9j\xE0" });
    }
    const form = await db.website_forms.create({
      data: {
        organizationId,
        name,
        slug: slug || name.toLowerCase().replace(/[^a-z0-9]+/g, "-"),
        description,
        treeId,
        settings: settings || {},
        successTitle,
        successMessage,
        isActive: true,
        requiresCommercialTracking: requiresCommercialTracking || false
        // üéØ Tracking commercial
      },
      include: {
        steps: true,
        websites: true
      }
    });
    console.log("\u2705 [WebsiteForms] Form created:", form.id);
    res.status(201).json(form);
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error creating form:", error);
    res.status(500).json({
      error: "Erreur lors de la cr\xE9ation du formulaire",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.put("/:id", async (req2, res) => {
  try {
    const organizationId = getOrgId2(req2);
    const { id } = req2.params;
    const { name, slug, description, treeId, settings, successTitle, successMessage, isActive, requiresCommercialTracking } = req2.body;
    console.log("\u{1F4CB} [WebsiteForms] UPDATE form:", id);
    const existing = await db.website_forms.findFirst({
      where: { id: Number(id), organizationId }
    });
    if (!existing) {
      return res.status(404).json({ error: "Formulaire non trouv\xE9" });
    }
    if (slug && slug !== existing.slug) {
      const slugExists = await db.website_forms.findFirst({
        where: { organizationId, slug, id: { not: Number(id) } }
      });
      if (slugExists) {
        return res.status(400).json({ error: "Ce slug est d\xE9j\xE0 utilis\xE9" });
      }
    }
    const form = await db.website_forms.update({
      where: { id: Number(id) },
      data: {
        name,
        slug,
        description,
        treeId,
        settings,
        successTitle,
        successMessage,
        isActive,
        requiresCommercialTracking: requiresCommercialTracking || false
        // üéØ Tracking commercial
      },
      include: {
        steps: {
          orderBy: { order: "asc" },
          include: { fields: { orderBy: { order: "asc" } } }
        },
        websites: {
          include: { website: { select: { id: true, siteName: true, slug: true } } }
        }
      }
    });
    console.log("\u2705 [WebsiteForms] Form updated:", form.id);
    res.json(form);
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error updating form:", error);
    res.status(500).json({
      error: "Erreur lors de la mise \xE0 jour du formulaire",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.delete("/:id", async (req2, res) => {
  try {
    const organizationId = getOrgId2(req2);
    const { id } = req2.params;
    console.log("\u{1F4CB} [WebsiteForms] DELETE form:", id);
    const existing = await db.website_forms.findFirst({
      where: { id: Number(id), organizationId }
    });
    if (!existing) {
      return res.status(404).json({ error: "Formulaire non trouv\xE9" });
    }
    await db.website_forms.delete({
      where: { id: Number(id) }
    });
    console.log("\u2705 [WebsiteForms] Form deleted:", id);
    res.json({ success: true, message: "Formulaire supprim\xE9" });
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error deleting form:", error);
    res.status(500).json({
      error: "Erreur lors de la suppression du formulaire",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.post("/:id/steps", async (req2, res) => {
  try {
    const organizationId = getOrgId2(req2);
    const { id } = req2.params;
    const { title, subtitle, helpText, stepType, isRequired, condition, settings } = req2.body;
    console.log("\u{1F4CB} [WebsiteForms] ADD step to form:", id);
    const form = await db.website_forms.findFirst({
      where: { id: Number(id), organizationId },
      include: { steps: true }
    });
    if (!form) {
      return res.status(404).json({ error: "Formulaire non trouv\xE9" });
    }
    const maxOrder = form.steps.reduce((max, s) => Math.max(max, s.order), -1);
    const step = await db.website_form_steps.create({
      data: {
        formId: Number(id),
        title,
        subtitle,
        helpText,
        stepType: stepType || "single_choice",
        order: maxOrder + 1,
        isRequired: isRequired !== false,
        condition,
        settings: settings || {}
      },
      include: { fields: true }
    });
    console.log("\u2705 [WebsiteForms] Step created:", step.id);
    res.status(201).json(step);
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error creating step:", error);
    res.status(500).json({
      error: "Erreur lors de la cr\xE9ation de l'\xE9tape",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.put("/steps/:stepId", async (req2, res) => {
  try {
    const { stepId } = req2.params;
    const { title, subtitle, helpText, stepType, order, isRequired, condition, settings } = req2.body;
    console.log("\u{1F4CB} [WebsiteForms] UPDATE step:", stepId);
    const step = await db.website_form_steps.update({
      where: { id: Number(stepId) },
      data: {
        title,
        subtitle,
        helpText,
        stepType,
        order,
        isRequired,
        condition,
        settings
      },
      include: { fields: { orderBy: { order: "asc" } } }
    });
    console.log("\u2705 [WebsiteForms] Step updated:", step.id);
    res.json(step);
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error updating step:", error);
    res.status(500).json({
      error: "Erreur lors de la mise \xE0 jour de l'\xE9tape",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.delete("/steps/:stepId", async (req2, res) => {
  try {
    const { stepId } = req2.params;
    console.log("\u{1F4CB} [WebsiteForms] DELETE step:", stepId);
    await db.website_form_steps.delete({
      where: { id: Number(stepId) }
    });
    console.log("\u2705 [WebsiteForms] Step deleted:", stepId);
    res.json({ success: true, message: "\xC9tape supprim\xE9e" });
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error deleting step:", error);
    res.status(500).json({
      error: "Erreur lors de la suppression de l'\xE9tape",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.put("/:id/steps/reorder", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { stepIds } = req2.body;
    console.log("\u{1F4CB} [WebsiteForms] REORDER steps for form:", id);
    const updates = stepIds.map(
      (stepId, index) => db.website_form_steps.update({
        where: { id: stepId },
        data: { order: index }
      })
    );
    await Promise.all(updates);
    console.log("\u2705 [WebsiteForms] Steps reordered");
    res.json({ success: true });
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error reordering steps:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9organisation",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.post("/steps/:stepId/fields", async (req2, res) => {
  try {
    const { stepId } = req2.params;
    const {
      label,
      value,
      fieldType,
      icon,
      imageUrl,
      placeholder,
      helpText,
      defaultValue,
      validation,
      tblNodeId,
      tblNodeLabel,
      isDefault,
      condition,
      metadata
    } = req2.body;
    console.log("\u{1F4CB} [WebsiteForms] ADD field to step:", stepId);
    const step = await db.website_form_steps.findUnique({
      where: { id: Number(stepId) },
      include: { fields: true }
    });
    if (!step) {
      return res.status(404).json({ error: "\xC9tape non trouv\xE9e" });
    }
    const maxOrder = step.fields.reduce((max, f) => Math.max(max, f.order), -1);
    const field = await db.website_form_fields.create({
      data: {
        stepId: Number(stepId),
        label,
        value: value || label.toLowerCase().replace(/[^a-z0-9]+/g, "_"),
        fieldType: fieldType || "option",
        icon,
        imageUrl,
        placeholder,
        helpText,
        defaultValue,
        validation,
        tblNodeId,
        tblNodeLabel,
        order: maxOrder + 1,
        isDefault: isDefault || false,
        condition,
        metadata: metadata || {}
      }
    });
    console.log("\u2705 [WebsiteForms] Field created:", field.id);
    res.status(201).json(field);
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error creating field:", error);
    res.status(500).json({
      error: "Erreur lors de la cr\xE9ation du champ",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.put("/fields/:fieldId", async (req2, res) => {
  try {
    const { fieldId } = req2.params;
    const {
      label,
      value,
      fieldType,
      icon,
      imageUrl,
      placeholder,
      helpText,
      defaultValue,
      validation,
      tblNodeId,
      tblNodeLabel,
      order,
      isDefault,
      condition,
      metadata
    } = req2.body;
    console.log("\u{1F4CB} [WebsiteForms] UPDATE field:", fieldId);
    const field = await db.website_form_fields.update({
      where: { id: Number(fieldId) },
      data: {
        label,
        value,
        fieldType,
        icon,
        imageUrl,
        placeholder,
        helpText,
        defaultValue,
        validation,
        tblNodeId,
        tblNodeLabel,
        order,
        isDefault,
        condition,
        metadata
      }
    });
    console.log("\u2705 [WebsiteForms] Field updated:", field.id);
    res.json(field);
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error updating field:", error);
    res.status(500).json({
      error: "Erreur lors de la mise \xE0 jour du champ",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.delete("/fields/:fieldId", async (req2, res) => {
  try {
    const { fieldId } = req2.params;
    console.log("\u{1F4CB} [WebsiteForms] DELETE field:", fieldId);
    await db.website_form_fields.delete({
      where: { id: Number(fieldId) }
    });
    console.log("\u2705 [WebsiteForms] Field deleted:", fieldId);
    res.json({ success: true, message: "Champ supprim\xE9" });
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error deleting field:", error);
    res.status(500).json({
      error: "Erreur lors de la suppression du champ",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.put("/steps/:stepId/fields/reorder", async (req2, res) => {
  try {
    const { stepId } = req2.params;
    const { fieldIds } = req2.body;
    console.log("\u{1F4CB} [WebsiteForms] REORDER fields for step:", stepId);
    const updates = fieldIds.map(
      (fieldId, index) => db.website_form_fields.update({
        where: { id: fieldId },
        data: { order: index }
      })
    );
    await Promise.all(updates);
    console.log("\u2705 [WebsiteForms] Fields reordered");
    res.json({ success: true });
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error reordering fields:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9organisation",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.post("/:id/link-website", async (req2, res) => {
  try {
    const { id } = req2.params;
    const { websiteId, isDefault, urlPath } = req2.body;
    console.log("\u{1F4CB} [WebsiteForms] LINK form", id, "to website", websiteId);
    const existing = await db.website_form_website.findFirst({
      where: { formId: Number(id), websiteId: Number(websiteId) }
    });
    if (existing) {
      return res.status(400).json({ error: "Ce formulaire est d\xE9j\xE0 li\xE9 \xE0 ce site" });
    }
    const link = await db.website_form_website.create({
      data: {
        formId: Number(id),
        websiteId: Number(websiteId),
        isDefault: isDefault || false,
        urlPath: urlPath || "/simulateur"
      },
      include: {
        website: { select: { id: true, siteName: true, slug: true } },
        form: { select: { id: true, name: true, slug: true } }
      }
    });
    console.log("\u2705 [WebsiteForms] Link created:", link.id);
    res.status(201).json(link);
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error linking:", error);
    res.status(500).json({
      error: "Erreur lors de la liaison",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.delete("/:id/unlink-website/:websiteId", async (req2, res) => {
  try {
    const { id, websiteId } = req2.params;
    console.log("\u{1F4CB} [WebsiteForms] UNLINK form", id, "from website", websiteId);
    await db.website_form_website.deleteMany({
      where: {
        formId: Number(id),
        websiteId: Number(websiteId)
      }
    });
    console.log("\u2705 [WebsiteForms] Link deleted");
    res.json({ success: true, message: "Liaison supprim\xE9e" });
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error unlinking:", error);
    res.status(500).json({
      error: "Erreur lors de la suppression de la liaison",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.get("/:id/stats", async (req2, res) => {
  try {
    const _organizationId = getOrgId2(req2);
    const { id } = req2.params;
    console.log("\u{1F4CB} [WebsiteForms] GET stats for form:", id);
    const [total, completed, partial, recent] = await Promise.all([
      db.website_form_submissions.count({ where: { formId: Number(id) } }),
      db.website_form_submissions.count({ where: { formId: Number(id), status: "completed" } }),
      db.website_form_submissions.count({ where: { formId: Number(id), status: "partial" } }),
      db.website_form_submissions.findMany({
        where: { formId: Number(id) },
        orderBy: { createdAt: "desc" },
        take: 10,
        select: {
          id: true,
          leadId: true,
          status: true,
          createdAt: true,
          utmSource: true,
          utmCampaign: true
        }
      })
    ]);
    res.json({
      totalSubmissions: total,
      completedSubmissions: completed,
      partialSubmissions: partial,
      conversionRate: total > 0 ? (completed / total * 100).toFixed(1) : 0,
      recentSubmissions: recent
    });
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error fetching stats:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration des statistiques",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.get("/:id/questions", async (req2, res) => {
  try {
    const organizationId = getOrgId2(req2);
    const { id } = req2.params;
    console.log("\u{1F4CB} [WebsiteForms] GET questions for form:", id);
    const form = await db.website_forms.findFirst({
      where: { id: Number(id), organizationId }
    });
    if (!form) {
      return res.status(404).json({ error: "Formulaire non trouv\xE9" });
    }
    const questions = await db.website_form_questions.findMany({
      where: { formId: Number(id) },
      orderBy: { order: "asc" }
    });
    console.log(`\u2705 [WebsiteForms] Found ${questions.length} questions`);
    res.json(questions);
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error fetching questions:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration des questions",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.post("/:id/questions", async (req2, res) => {
  try {
    const organizationId = getOrgId2(req2);
    const { id } = req2.params;
    const {
      questionKey,
      questionType,
      title,
      subtitle,
      imageUrl,
      order,
      options,
      navigation,
      defaultNextQuestionKey,
      isRequired,
      placeholder,
      validationRules
    } = req2.body;
    console.log("\u{1F4CB} [WebsiteForms] CREATE question for form:", id, questionKey);
    const form = await db.website_forms.findFirst({
      where: { id: Number(id), organizationId }
    });
    if (!form) {
      return res.status(404).json({ error: "Formulaire non trouv\xE9" });
    }
    const existingKey = await db.website_form_questions.findFirst({
      where: { formId: Number(id), questionKey }
    });
    if (existingKey) {
      return res.status(400).json({ error: "Cette cl\xE9 de question existe d\xE9j\xE0 pour ce formulaire" });
    }
    const question = await db.website_form_questions.create({
      data: {
        formId: Number(id),
        questionKey,
        questionType,
        title,
        subtitle,
        imageUrl,
        order: order || 1,
        options: options || null,
        navigation: navigation || null,
        defaultNextQuestionKey,
        isRequired: isRequired !== false,
        placeholder,
        validationRules: validationRules || null
      }
    });
    console.log("\u2705 [WebsiteForms] Question created:", question.id);
    res.status(201).json(question);
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error creating question:", error);
    res.status(500).json({
      error: "Erreur lors de la cr\xE9ation de la question",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.put("/questions/:questionId", async (req2, res) => {
  try {
    const organizationId = getOrgId2(req2);
    const { questionId } = req2.params;
    const {
      questionType,
      title,
      subtitle,
      imageUrl,
      order,
      options,
      navigation,
      defaultNextQuestionKey,
      isRequired,
      placeholder,
      validationRules
    } = req2.body;
    console.log("\u{1F4CB} [WebsiteForms] UPDATE question:", questionId);
    const existing = await db.website_form_questions.findUnique({
      where: { id: Number(questionId) },
      include: { form: true }
    });
    if (!existing || existing.form.organizationId !== organizationId) {
      return res.status(404).json({ error: "Question non trouv\xE9e" });
    }
    const question = await db.website_form_questions.update({
      where: { id: Number(questionId) },
      data: {
        questionType,
        title,
        subtitle,
        imageUrl,
        order,
        options: options !== void 0 ? options : void 0,
        navigation: navigation !== void 0 ? navigation : void 0,
        defaultNextQuestionKey,
        isRequired,
        placeholder,
        validationRules: validationRules !== void 0 ? validationRules : void 0
      }
    });
    console.log("\u2705 [WebsiteForms] Question updated:", question.id);
    res.json(question);
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error updating question:", error);
    res.status(500).json({
      error: "Erreur lors de la mise \xE0 jour de la question",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router92.delete("/questions/:questionId", async (req2, res) => {
  try {
    const organizationId = getOrgId2(req2);
    const { questionId } = req2.params;
    console.log("\u{1F4CB} [WebsiteForms] DELETE question:", questionId);
    const existing = await db.website_form_questions.findUnique({
      where: { id: Number(questionId) },
      include: { form: true }
    });
    if (!existing || existing.form.organizationId !== organizationId) {
      return res.status(404).json({ error: "Question non trouv\xE9e" });
    }
    await db.website_form_questions.delete({
      where: { id: Number(questionId) }
    });
    console.log("\u2705 [WebsiteForms] Question deleted");
    res.json({ success: true, message: "Question supprim\xE9e" });
  } catch (error) {
    console.error("\u274C [WebsiteForms] Error deleting question:", error);
    res.status(500).json({
      error: "Erreur lors de la suppression de la question",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
var generateUserSlug2 = async (firstName, lastName, organizationId) => {
  const slugify2 = (text) => {
    return text.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^a-z0-9]+/g, "-").replace(/^-+|-+$/g, "");
  };
  const baseSlug = `${slugify2(firstName)}-${slugify2(lastName)}`;
  const existingUsers = await db.user.findMany({
    where: {
      organizationId,
      OR: [
        { firstName, lastName },
        {
          firstName: { startsWith: firstName },
          lastName: { startsWith: lastName }
        }
      ]
    }
  });
  if (existingUsers.length === 0 || existingUsers.length === 1) {
    return baseSlug;
  }
  let counter = 2;
  let slug = `${baseSlug}-${counter}`;
  while (counter < 100) {
    const exists = existingUsers.some((u) => {
      const userSlug = `${slugify2(u.firstName)}-${slugify2(u.lastName)}`;
      return userSlug === slug;
    });
    if (!exists) break;
    counter++;
    slug = `${baseSlug}-${counter}`;
  }
  return slug;
};
var website_forms_default = router92;

// src/routes/public-forms.ts
var import_express96 = require("express");
init_database();
var import_uuid6 = require("uuid");
var fs10 = __toESM(require("fs"), 1);
var path9 = __toESM(require("path"), 1);
var router93 = (0, import_express96.Router)();
router93.get("/:slug", async (req2, res) => {
  try {
    const { slug } = req2.params;
    const { websiteSlug: _websiteSlug } = req2.query;
    console.log("\u{1F4CB} [PublicForms] GET form by slug:", slug);
    const form = await db.website_forms.findFirst({
      where: {
        slug,
        isActive: true
      },
      include: {
        steps: {
          orderBy: { order: "asc" },
          include: {
            fields: {
              orderBy: { order: "asc" }
            }
          }
        },
        Organization: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });
    if (!form) {
      return res.status(404).json({ error: "Formulaire non trouv\xE9 ou inactif" });
    }
    console.log("\u2705 [PublicForms] Form found:", form.name, "- Steps:", form.steps.length);
    const organizeFieldsHierarchy = (fields) => {
      const fieldMap = /* @__PURE__ */ new Map();
      const rootFields = [];
      fields.forEach((field) => {
        fieldMap.set(field.id, { ...field, childFields: [] });
      });
      fields.forEach((field) => {
        const enrichedField = fieldMap.get(field.id);
        if (field.parentFieldId) {
          const parent = fieldMap.get(field.parentFieldId);
          if (parent) {
            parent.childFields.push(enrichedField);
          } else {
            rootFields.push(enrichedField);
          }
        } else {
          rootFields.push(enrichedField);
        }
      });
      rootFields.forEach((field) => {
        if (field.childFields) {
          field.childFields.sort((a, b) => a.order - b.order);
        }
      });
      return rootFields.sort((a, b) => a.order - b.order);
    };
    res.json({
      id: form.id,
      name: form.name,
      slug: form.slug,
      description: form.description,
      settings: form.settings,
      successTitle: form.successTitle,
      successMessage: form.successMessage,
      submitButtonText: form.settings?.submitButtonText || "Envoyer",
      organizationId: form.organizationId,
      organizationName: form.Organization.name,
      steps: form.steps.map((step) => ({
        id: step.id,
        order: step.order,
        title: step.title,
        description: step.subtitle,
        icon: step.settings?.icon || "",
        helpText: step.helpText,
        stepType: step.stepType,
        isRequired: step.isRequired,
        condition: step.condition,
        settings: step.settings,
        fields: organizeFieldsHierarchy(step.fields.map((field) => ({
          id: field.id,
          stepId: field.stepId,
          parentFieldId: field.parentFieldId,
          order: field.order,
          name: field.name || `field_${field.id}`,
          label: field.label,
          value: field.value,
          fieldType: field.fieldType,
          icon: field.icon,
          imageUrl: field.imageUrl,
          placeholder: field.placeholder,
          helpText: field.helpText,
          defaultValue: field.defaultValue,
          options: field.options,
          validation: field.validation,
          isRequired: field.isRequired,
          isDefault: field.isDefault,
          allowMultiple: field.allowMultiple,
          condition: field.condition
        })))
      }))
    });
  } catch (error) {
    console.error("\u274C [PublicForms] Error fetching form:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration du formulaire",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router93.get("/:slug/questions", async (req2, res) => {
  try {
    const { slug } = req2.params;
    console.log("\u{1F3AF} [PublicForms] GET form questions (Effy mode) by slug:", slug);
    const form = await db.website_forms.findFirst({
      where: {
        slug,
        isActive: true
      },
      include: {
        questions: {
          orderBy: { order: "asc" }
        },
        Organization: {
          select: {
            id: true,
            name: true
          }
        }
      }
    });
    if (!form) {
      return res.status(404).json({ error: "Formulaire non trouv\xE9 ou inactif" });
    }
    console.log("\u2705 [PublicForms] Form found (Effy mode):", form.name, "- Questions:", form.questions.length);
    res.json({
      id: form.id,
      name: form.name,
      slug: form.slug,
      description: form.description,
      settings: form.settings,
      startQuestionKey: form.startQuestionKey || form.questions[0]?.questionKey,
      successTitle: form.successTitle,
      successMessage: form.successMessage,
      organizationId: form.organizationId,
      organizationName: form.Organization.name,
      questions: form.questions.map((q) => ({
        id: q.id,
        questionKey: q.questionKey,
        title: q.title,
        subtitle: q.subtitle,
        helpText: q.helpText,
        icon: q.icon,
        questionType: q.questionType,
        placeholder: q.placeholder,
        inputSuffix: q.inputSuffix,
        minValue: q.minValue,
        maxValue: q.maxValue,
        options: q.options,
        defaultNextQuestionKey: q.defaultNextQuestionKey,
        navigation: q.navigation,
        isEndQuestion: q.isEndQuestion,
        isRequired: q.isRequired
      }))
    });
  } catch (error) {
    console.error("\u274C [PublicForms] Error fetching form questions:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration du formulaire",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router93.get("/by-website/:websiteSlug", async (req2, res) => {
  try {
    const { websiteSlug } = req2.params;
    console.log("\u{1F4CB} [PublicForms] GET form for website:", websiteSlug);
    const website = await db.websites.findFirst({
      where: { slug: websiteSlug }
    });
    if (!website) {
      return res.status(404).json({ error: "Site non trouv\xE9" });
    }
    const formLink = await db.website_form_website.findFirst({
      where: { websiteId: website.id },
      orderBy: { isDefault: "desc" },
      include: {
        form: {
          include: {
            steps: {
              orderBy: { order: "asc" },
              include: {
                fields: {
                  orderBy: { order: "asc" }
                }
              }
            }
          }
        }
      }
    });
    if (!formLink || !formLink.form.isActive) {
      return res.status(404).json({ error: "Aucun formulaire actif pour ce site" });
    }
    const form = formLink.form;
    console.log("\u2705 [PublicForms] Form found for website:", form.name);
    res.json({
      id: form.id,
      name: form.name,
      slug: form.slug,
      description: form.description,
      settings: form.settings,
      successTitle: form.successTitle,
      successMessage: form.successMessage,
      urlPath: formLink.urlPath,
      steps: form.steps.map((step) => ({
        id: step.id,
        title: step.title,
        subtitle: step.subtitle,
        helpText: step.helpText,
        stepType: step.stepType,
        isRequired: step.isRequired,
        condition: step.condition,
        settings: step.settings,
        fields: step.fields.map((field) => ({
          id: field.id,
          label: field.label,
          value: field.value,
          fieldType: field.fieldType,
          icon: field.icon,
          imageUrl: field.imageUrl,
          placeholder: field.placeholder,
          helpText: field.helpText,
          defaultValue: field.defaultValue,
          validation: field.validation,
          isDefault: field.isDefault,
          condition: field.condition
        }))
      }))
    });
  } catch (error) {
    console.error("\u274C [PublicForms] Error fetching form by website:", error);
    res.status(500).json({
      error: "Erreur lors de la r\xE9cup\xE9ration du formulaire",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router93.post("/:slug/submit", async (req2, res) => {
  try {
    const { slug } = req2.params;
    const {
      formData,
      // Les r√©ponses du formulaire { stepId: { fieldId: value } }
      contact,
      // { firstName, lastName, email, phone }
      metadata,
      // { utmSource, utmMedium, utmCampaign, referrer }
      referredBy
      // Slug du commercial (ex: "jean-dupont")
    } = req2.body;
    const normalizeString = (value) => {
      if (value === null || value === void 0) return "";
      if (Array.isArray(value)) return value.map((v) => String(v)).join(" ").trim();
      return String(value).trim();
    };
    const extractFromFormData = (keys) => {
      if (!formData) return "";
      const direct = formData;
      for (const key2 of keys) {
        const directValue = normalizeString(direct[key2]);
        if (directValue) return directValue;
      }
      const formDataObj = formData;
      for (const stepValue of Object.values(formDataObj)) {
        if (stepValue && typeof stepValue === "object" && !Array.isArray(stepValue)) {
          for (const key2 of keys) {
            const nestedValue = normalizeString(stepValue[key2]);
            if (nestedValue) return nestedValue;
          }
        }
      }
      return "";
    };
    const normalizedContact = {
      firstName: normalizeString(contact?.firstName) || extractFromFormData(["firstName", "prenom", "pr\xE9nom"]),
      lastName: normalizeString(contact?.lastName) || extractFromFormData(["lastName", "nom"]),
      email: normalizeString(contact?.email) || extractFromFormData(["email", "mail", "e-mail"]),
      phone: normalizeString(contact?.phone) || extractFromFormData(["phone", "telephone", "t\xE9l\xE9phone", "gsm", "mobile"]),
      address: extractFromFormData(["address", "adresse", "street", "rue"]),
      civility: normalizeString(contact?.civility) || extractFromFormData(["civilite", "civility"])
    };
    console.log("\u{1F4CB} [PublicForms] SUBMIT form:", slug);
    console.log("\u{1F4CB} [PublicForms] Contact:", normalizedContact.email);
    const form = await db.website_forms.findFirst({
      where: { slug, isActive: true },
      include: {
        steps: {
          include: {
            fields: true
          }
        },
        questions: true
        // üî• Inclure les questions (nouveau syst√®me 1 √©cran = 1 question)
      }
    });
    if (!form) {
      return res.status(404).json({ error: "Formulaire non trouv\xE9 ou inactif" });
    }
    console.log("\u{1F4CB} [PublicForms] Form found:", form.name);
    if (!normalizedContact.email) {
      return res.status(400).json({ error: "L'email est requis" });
    }
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const existingLead = await db.lead.findFirst({
      where: {
        email: normalizedContact.email,
        organizationId: form.organizationId,
        createdAt: { gte: today }
      }
    });
    let leadId;
    if (existingLead) {
      console.log("\u{1F4CB} [PublicForms] Existing lead found:", existingLead.id);
      leadId = existingLead.id;
      await db.lead.update({
        where: { id: leadId },
        data: {
          firstName: normalizedContact.firstName || existingLead.firstName,
          lastName: normalizedContact.lastName || existingLead.lastName,
          phone: normalizedContact.phone || existingLead.phone,
          email: normalizedContact.email || existingLead.email,
          data: {
            ...existingLead.data && typeof existingLead.data === "object" ? existingLead.data : {},
            email: normalizedContact.email || void 0,
            phone: normalizedContact.phone || void 0,
            firstName: normalizedContact.firstName || void 0,
            lastName: normalizedContact.lastName || void 0,
            address: normalizedContact.address || void 0,
            civility: normalizedContact.civility || void 0
          },
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    } else {
      leadId = (0, import_uuid6.v4)();
      const now = /* @__PURE__ */ new Date();
      const leadCount = await db.lead.count({
        where: { organizationId: form.organizationId }
      });
      const leadNumber = `LEAD-${(leadCount + 1).toString().padStart(5, "0")}`;
      const defaultStatus = await db.leadStatus.findFirst({
        where: { organizationId: form.organizationId, isDefault: true }
      });
      let assignedToId = null;
      if (referredBy) {
        const referringUser = await db.user.findFirst({
          where: {
            organizationId: form.organizationId,
            commercialSlug: referredBy
          }
        });
        if (referringUser) {
          assignedToId = referringUser.id;
          console.log(`\u{1F3AF} [PublicForms] Lead auto-assign\xE9 \xE0 ${referredBy} (${referringUser.email})`);
        } else {
          console.warn(`\u26A0\uFE0F [PublicForms] Commercial non trouv\xE9 pour le slug: ${referredBy}`);
        }
      }
      await db.lead.create({
        data: {
          id: leadId,
          organizationId: form.organizationId,
          firstName: normalizedContact.firstName || "",
          lastName: normalizedContact.lastName || "",
          email: normalizedContact.email,
          phone: normalizedContact.phone || null,
          company: contact.company || null,
          assignedToId,
          // üéØ Lead attribu√© au commercial si referredBy existe
          // Pas de colonne address d√©di√©e, stocker dans data uniquement
          source: "website_form",
          status: "nouveau",
          statusId: defaultStatus?.id || null,
          leadNumber,
          notes: `Lead cr\xE9\xE9 depuis le formulaire "${form.name}"` + (assignedToId ? ` (via ${referredBy})` : ""),
          data: {
            formSlug: slug,
            formName: form.name,
            referredBy: referredBy || void 0,
            // üéØ Stocker aussi dans data pour historique
            email: normalizedContact.email || void 0,
            phone: normalizedContact.phone || void 0,
            firstName: normalizedContact.firstName || void 0,
            lastName: normalizedContact.lastName || void 0,
            address: normalizedContact.address || void 0,
            civility: normalizedContact.civility || void 0
          },
          createdAt: now,
          updatedAt: now
        }
      });
      console.log("\u2705 [PublicForms] Lead created:", leadId);
    }
    let tblSubmissionId = null;
    if (form.treeId) {
      tblSubmissionId = (0, import_uuid6.v4)();
      await db.treeBranchLeafSubmission.create({
        data: {
          id: tblSubmissionId,
          treeId: form.treeId,
          leadId,
          organizationId: form.organizationId,
          status: "completed",
          summary: {
            formName: form.name,
            formSlug: slug,
            submittedAt: (/* @__PURE__ */ new Date()).toISOString()
          },
          completedAt: /* @__PURE__ */ new Date(),
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
      console.log("\u2705 [PublicForms] TBL Submission created:", tblSubmissionId);
      const submissionDataEntries = [];
      for (const step of form.steps) {
        const stepData = formData?.[step.id] || formData?.[`step_${step.id}`] || {};
        for (const field of step.fields) {
          let fieldValue = stepData[field.id] || stepData[`field_${field.id}`] || stepData[field.value];
          if (field.fieldType === "option" && stepData.selectedValue === field.value) {
            fieldValue = field.value;
          }
          if (field.tblNodeId && fieldValue !== void 0 && fieldValue !== null) {
            submissionDataEntries.push({
              id: (0, import_uuid6.v4)(),
              submissionId: tblSubmissionId,
              nodeId: field.tblNodeId,
              value: String(fieldValue),
              fieldLabel: field.label,
              createdAt: /* @__PURE__ */ new Date()
            });
          }
        }
      }
      for (const question of form.questions || []) {
        const answerValue = formData?.[question.questionKey];
        if (answerValue !== void 0 && answerValue !== null) {
          if (question.tblNodeId) {
            submissionDataEntries.push({
              id: (0, import_uuid6.v4)(),
              submissionId: tblSubmissionId,
              nodeId: question.tblNodeId,
              value: Array.isArray(answerValue) ? answerValue.join(", ") : String(answerValue),
              fieldLabel: question.title,
              createdAt: /* @__PURE__ */ new Date()
            });
          }
          if (question.options && Array.isArray(question.options)) {
            const selectedValues = Array.isArray(answerValue) ? answerValue : [answerValue];
            for (const option of question.options) {
              if (selectedValues.includes(option.value) && option.tblNodeId) {
                submissionDataEntries.push({
                  id: (0, import_uuid6.v4)(),
                  submissionId: tblSubmissionId,
                  nodeId: option.tblNodeId,
                  value: option.label || option.value,
                  fieldLabel: `${question.title} - ${option.label}`,
                  createdAt: /* @__PURE__ */ new Date()
                });
              }
            }
          }
        }
      }
      if (submissionDataEntries.length > 0) {
        await db.treeBranchLeafSubmissionData.createMany({
          data: submissionDataEntries
        });
        console.log(`\u2705 [PublicForms] Created ${submissionDataEntries.length} TBL data entries`);
      }
    }
    const formSubmission = await db.website_form_submissions.create({
      data: {
        formId: form.id,
        leadId,
        submissionId: tblSubmissionId,
        referredBy: referredBy || null,
        // üéØ Enregistrer le slug du commercial
        formData: formData || {},
        ipAddress: req2.ip || req2.headers["x-forwarded-for"]?.toString().split(",")[0],
        userAgent: req2.headers["user-agent"] || null,
        referrer: metadata?.referrer || req2.headers["referer"] || null,
        utmSource: metadata?.utmSource || null,
        utmMedium: metadata?.utmMedium || null,
        utmCampaign: metadata?.utmCampaign || null,
        status: "completed"
      }
    });
    console.log("\u2705 [PublicForms] Form submission recorded:", formSubmission.id);
    let pdfUrl = null;
    try {
      const pdfData = {
        formName: form.name,
        formSlug: slug,
        submittedAt: /* @__PURE__ */ new Date(),
        contact: {
          firstName: normalizedContact.firstName,
          lastName: normalizedContact.lastName,
          email: normalizedContact.email,
          phone: normalizedContact.phone,
          civility: normalizedContact.civility
        },
        answers: formData || {},
        questions: (form.questions || []).map((q) => ({
          questionKey: q.questionKey,
          title: q.title,
          subtitle: q.subtitle,
          icon: q.icon,
          questionType: q.questionType,
          options: q.options
        })),
        leadNumber: existingLead ? void 0 : `LEAD-${(await db.lead.count({ where: { organizationId: form.organizationId } })).toString().padStart(5, "0")}`
      };
      const pdfBuffer = await generateFormResponsePdf(pdfData);
      const uploadsDir2 = path9.join(process.cwd(), "public", "uploads", "form-responses");
      if (!fs10.existsSync(uploadsDir2)) {
        fs10.mkdirSync(uploadsDir2, { recursive: true });
      }
      const pdfFileName = `formulaire-${slug}-${leadId.substring(0, 8)}-${Date.now()}.pdf`;
      const pdfPath = path9.join(uploadsDir2, pdfFileName);
      fs10.writeFileSync(pdfPath, pdfBuffer);
      pdfUrl = `/uploads/form-responses/${pdfFileName}`;
      await db.lead.update({
        where: { id: leadId },
        data: {
          data: {
            ...typeof (await db.lead.findUnique({ where: { id: leadId } }))?.data === "object" ? (await db.lead.findUnique({ where: { id: leadId } }))?.data : {},
            formPdfUrl: pdfUrl,
            formSlug: slug,
            formName: form.name
          }
        }
      });
      console.log("\u2705 [PublicForms] PDF generated and attached to Lead:", pdfUrl);
    } catch (pdfError) {
      console.error("\u26A0\uFE0F [PublicForms] PDF generation failed (non-blocking):", pdfError);
    }
    res.status(201).json({
      success: true,
      message: form.successMessage || "Merci pour votre demande !",
      title: form.successTitle || "Formulaire envoy\xE9",
      leadId,
      submissionId: tblSubmissionId,
      formSubmissionId: formSubmission.id,
      pdfUrl
    });
  } catch (error) {
    console.error("\u274C [PublicForms] Error submitting form:", error);
    try {
      const { slug } = req2.params;
      const form = await db.website_forms.findFirst({ where: { slug } });
      if (form) {
        await db.website_form_submissions.create({
          data: {
            formId: form.id,
            formData: req2.body?.formData || {},
            status: "error",
            errorMessage: error instanceof Error ? error.message : "Erreur inconnue",
            ipAddress: req2.ip
          }
        });
      }
    } catch (e) {
      console.error("\u274C [PublicForms] Failed to log error submission:", e);
    }
    res.status(500).json({
      error: "Erreur lors de la soumission du formulaire",
      message: error instanceof Error ? error.message : "Erreur inconnue"
    });
  }
});
router93.post("/:slug/partial", async (req2, res) => {
  try {
    const { slug } = req2.params;
    const { formData, currentStep, metadata } = req2.body;
    console.log("\u{1F4CB} [PublicForms] PARTIAL submit for form:", slug, "- Step:", currentStep);
    const form = await db.website_forms.findFirst({
      where: { slug }
    });
    if (!form) {
      return res.status(404).json({ error: "Formulaire non trouv\xE9" });
    }
    await db.website_form_submissions.create({
      data: {
        formId: form.id,
        formData: { ...formData, lastStep: currentStep },
        status: "partial",
        ipAddress: req2.ip,
        userAgent: req2.headers["user-agent"] || null,
        utmSource: metadata?.utmSource || null,
        utmMedium: metadata?.utmMedium || null,
        utmCampaign: metadata?.utmCampaign || null
      }
    });
    res.json({ success: true, message: "Progression sauvegard\xE9e" });
  } catch (error) {
    console.error("\u274C [PublicForms] Error saving partial:", error);
    res.status(500).json({ error: "Erreur" });
  }
});
var public_forms_default = router93;

// src/middleware/websiteDetection.ts
init_prisma();

// src/middleware/websiteRenderer.ts
function renderSection(section) {
  const content = section.content || {};
  const sectionType = section.sectionType;
  switch (sectionType) {
    case "header":
      return renderHeader(content);
    case "hero":
      return renderHero(content);
    case "services":
      return renderServices(content);
    case "about":
      return renderAbout(content);
    case "stats":
      return renderStats(content);
    case "cta":
      return renderCTA(content);
    case "testimonials":
      return renderTestimonials(content);
    case "faq":
      return renderFAQ(content);
    case "contact":
      return renderContact(content);
    case "footer":
      return renderFooter(content);
    default:
      return `<!-- Section inconnue: ${sectionType} -->`;
  }
}
function renderHeader(content) {
  const logo = content.logo || {};
  const menu = content.menu || {};
  const cta = content.cta || {};
  return `
    <header class="site-header" style="background-color: ${content.background?.color || "#ffffff"}; padding: ${content.spacing?.padding || "20px"} 0;">
      <div class="container" style="max-width: 1200px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center;">
        <div class="logo">
          ${logo.image?.url ? `<img src="${logo.image.url}" alt="${logo.text || "Logo"}" style="height: ${logo.size?.height || "40px"};">` : `<span style="font-size: ${logo.text?.fontSize || "24px"}; font-weight: bold; color: ${logo.text?.color || "#000000"};">${logo.text?.value || "Logo"}</span>`}
        </div>
        <nav class="menu" style="display: flex; gap: ${menu.spacing?.gap || "30px"};">
          ${(menu.items || []).map((item) => `
            <a href="${item.link || "#"}" style="color: ${menu.text?.color || "#333333"}; text-decoration: none; font-size: ${menu.text?.fontSize || "16px"};">
              ${item.label || "Menu"}
            </a>
          `).join("")}
        </nav>
        ${cta.text?.value ? `
          <a href="${cta.link || "#"}" class="cta-button" style="background-color: ${cta.background?.color || "#007bff"}; color: ${cta.text?.color || "#ffffff"}; padding: ${cta.spacing?.padding || "12px 24px"}; border-radius: ${cta.border?.radius || "4px"}; text-decoration: none; font-size: ${cta.text?.fontSize || "16px"};">
            ${cta.text.value}
          </a>
        ` : ""}
      </div>
    </header>
  `;
}
function renderHero(content) {
  const title = content.title || {};
  const subtitle = content.subtitle || {};
  const cta = content.cta || {};
  return `
    <section class="hero-section" style="background: ${content.background?.type === "image" && content.background?.image?.url ? `url('${content.background.image.url}') center/cover` : content.background?.color || "#f5f5f5"}; padding: ${content.spacing?.padding || "100px"} 0; text-align: ${content.layout?.alignment || "center"};">
      <div class="container" style="max-width: 1200px; margin: 0 auto;">
        <h1 style="font-size: ${title.fontSize || "48px"}; color: ${title.color || "#000000"}; margin-bottom: ${content.spacing?.gap || "20px"};">
          ${title.value || "Titre Principal"}
        </h1>
        ${subtitle.value ? `
          <p style="font-size: ${subtitle.fontSize || "20px"}; color: ${subtitle.color || "#666666"}; margin-bottom: ${content.spacing?.gap || "30px"};">
            ${subtitle.value}
          </p>
        ` : ""}
        ${cta.text?.value ? `
          <a href="${cta.link || "#"}" style="display: inline-block; background-color: ${cta.background?.color || "#007bff"}; color: ${cta.text?.color || "#ffffff"}; padding: ${cta.spacing?.padding || "16px 32px"}; border-radius: ${cta.border?.radius || "4px"}; text-decoration: none; font-size: ${cta.text?.fontSize || "18px"};">
            ${cta.text.value}
          </a>
        ` : ""}
      </div>
    </section>
  `;
}
function renderServices(content) {
  const title = content.title || {};
  const services = content.services || [];
  return `
    <section class="services-section" style="background-color: ${content.background?.color || "#ffffff"}; padding: ${content.spacing?.padding || "80px"} 0;">
      <div class="container" style="max-width: 1200px; margin: 0 auto;">
        ${title.value ? `
          <h2 style="font-size: ${title.fontSize || "36px"}; color: ${title.color || "#000000"}; text-align: center; margin-bottom: ${content.spacing?.gap || "50px"};">
            ${title.value}
          </h2>
        ` : ""}
        <div class="services-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: ${content.grid?.gap || "30px"};">
          ${services.map((service) => `
            <div class="service-card" style="background-color: ${service.background?.color || "#f9f9f9"}; padding: ${service.spacing?.padding || "30px"}; border-radius: ${service.border?.radius || "8px"}; text-align: center;">
              ${service.icon ? `<div class="service-icon" style="font-size: ${service.icon?.size || "48px"}; color: ${service.icon?.color || "#007bff"}; margin-bottom: 20px;">${service.icon.value || "\u{1F527}"}</div>` : ""}
              <h3 style="font-size: ${service.title?.fontSize || "24px"}; color: ${service.title?.color || "#000000"}; margin-bottom: 15px;">
                ${service.title?.value || "Service"}
              </h3>
              <p style="font-size: ${service.description?.fontSize || "16px"}; color: ${service.description?.color || "#666666"};">
                ${service.description?.value || "Description du service"}
              </p>
            </div>
          `).join("")}
        </div>
      </div>
    </section>
  `;
}
function renderAbout(_content) {
  return `<section class="about-section"><!-- Section About --></section>`;
}
function renderStats(_content) {
  return `<section class="stats-section"><!-- Section Stats --></section>`;
}
function renderCTA(_content) {
  return `<section class="cta-section"><!-- Section CTA --></section>`;
}
function renderTestimonials(_content) {
  return `<section class="testimonials-section"><!-- Section Testimonials --></section>`;
}
function renderFAQ(_content) {
  return `<section class="faq-section"><!-- Section FAQ --></section>`;
}
function renderContact(_content) {
  return `<section class="contact-section"><!-- Section Contact --></section>`;
}
function renderFooter(content) {
  const text = content.text || {};
  const social = content.social || [];
  return `
    <footer class="site-footer" style="background-color: ${content.background?.color || "#333333"}; color: ${text.color || "#ffffff"}; padding: ${content.spacing?.padding || "40px"} 0; text-align: center;">
      <div class="container" style="max-width: 1200px; margin: 0 auto;">
        ${text.value ? `
          <p style="font-size: ${text.fontSize || "14px"}; margin-bottom: ${content.spacing?.gap || "20px"};">
            ${text.value}
          </p>
        ` : ""}
        ${social.length > 0 ? `
          <div class="social-links" style="display: flex; justify-content: center; gap: ${content.social?.spacing || "20px"};">
            ${social.map((link) => `
              <a href="${link.url || "#"}" target="${link.openInNewTab !== false ? "_blank" : "_self"}" rel="${link.openInNewTab !== false ? "noopener noreferrer" : ""}" style="color: ${content.social?.color || "#ffffff"}; font-size: ${content.social?.size || "24px"};">
                ${link.icon || link.platform || "\u{1F517}"}
              </a>
            `).join("")}
          </div>
        ` : ""}
      </div>
    </footer>
  `;
}
async function renderWebsite(req2, res) {
  try {
    const website = req2.websiteData;
    console.log(`\u{1F3A8} [WEBSITE-RENDERER] Donn\xE9es re\xE7ues:`, {
      hasWebsite: !!website,
      name: website?.name,
      sectionsCount: website?.sections?.length
    });
    if (!website) {
      return res.status(404).send(`
        <!DOCTYPE html>
        <html lang="fr">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Site non trouv\xE9</title>
          </head>
          <body>
            <h1>Site non trouv\xE9</h1>
            <p>Aucun site n'est configur\xE9 pour ce domaine.</p>
          </body>
        </html>
      `);
    }
    const sectionsHTML = website.sections.map((section) => renderSection(section)).join("\n");
    const html = `
      <!DOCTYPE html>
      <html lang="fr">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
          <meta name="mobile-web-app-capable" content="yes">
          <meta name="apple-mobile-web-app-capable" content="yes">
          <title>${website.name}</title>
          <meta name="description" content="${website.config?.seo?.description || website.name}">
          <style>
            * {
              margin: 0;
              padding: 0;
              box-sizing: border-box;
            }
            body {
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
              line-height: 1.6;
            }
            .container {
              max-width: 1200px;
              margin: 0 auto;
              padding: 0 20px;
            }
            @media (max-width: 768px) {
              .site-header .container {
                flex-direction: column;
                gap: 20px;
              }
              .menu {
                flex-direction: column;
                text-align: center;
              }
              .services-grid {
                grid-template-columns: 1fr !important;
              }
            }
          </style>
        </head>
        <body>
          ${sectionsHTML}
          <script>
            console.log('\u2705 Site vitrine charg\xE9: ${website.name}');
            console.log('\u{1F4CD} Domaine: ${website.domain}');
          </script>
        </body>
      </html>
    `;
    res.send(html);
  } catch (error) {
    console.error("\u274C [WEBSITE-RENDERER] Erreur:", error);
    res.status(500).send("Erreur lors du chargement du site");
  }
}

// src/middleware/websiteDetection.ts
var websiteCache = /* @__PURE__ */ new Map();
var CACHE_TTL = 6e4;
var isProduction3 = process.env.NODE_ENV === "production";
var CRM_DOMAINS = [
  "app.2thier.be",
  "api.2thier.be",
  "crm.2thier.be",
  "localhost",
  "run.app",
  // Google Cloud Run
  "appspot.com"
  // Google App Engine
];
async function detectWebsite(req2, res, next) {
  try {
    const forwardedHost = req2.headers["x-forwarded-host"];
    const hostHeader = req2.headers.host;
    let hostname = forwardedHost || hostHeader || req2.hostname || "";
    hostname = hostname.split(":")[0];
    if (!isProduction3) {
      console.log(`\u{1F50D} [WEBSITE-DETECTION] Headers - X-Forwarded-Host: ${forwardedHost}, Host: ${hostHeader}, hostname: ${req2.hostname}`);
      console.log(`\u{1F50D} [WEBSITE-DETECTION] Domaine d\xE9tect\xE9: ${hostname}`);
    }
    if (CRM_DOMAINS.some((crm) => hostname.includes(crm))) {
      if (!isProduction3) {
        console.log(`\u{1F4F1} [WEBSITE-DETECTION] Domaine CRM d\xE9tect\xE9: ${hostname}`);
      }
      req2.isWebsiteRoute = false;
      return next();
    }
    const cleanDomain = hostname.replace(/^www\./, "");
    const cacheKey = cleanDomain;
    const cached = websiteCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
      if (cached.data) {
        req2.websiteData = cached.data;
        req2.isWebsiteRoute = true;
      } else {
        req2.isWebsiteRoute = false;
      }
      return next();
    }
    if (!isProduction3) {
      console.log(`\u{1F310} [WEBSITE-DETECTION] Recherche site pour: ${cleanDomain}`);
    }
    const website = await db.websites.findFirst({
      where: {
        OR: [
          { domain: cleanDomain },
          { domain: hostname },
          { domain: `www.${cleanDomain}` }
        ],
        isActive: true
      },
      include: {
        website_configs: true,
        website_sections: {
          where: { isActive: true },
          orderBy: { displayOrder: "asc" }
        }
      }
    });
    if (website) {
      if (!isProduction3) {
        console.log(`\u2705 [WEBSITE-DETECTION] Site trouv\xE9: ${website.siteName} (${website.slug})`);
      }
      const websiteData = {
        id: website.id,
        slug: website.slug,
        domain: website.domain || cleanDomain,
        name: website.siteName,
        // ‚Üê Correction: utiliser siteName au lieu de name
        config: website.website_configs,
        sections: website.website_sections
      };
      websiteCache.set(cacheKey, { data: websiteData, timestamp: Date.now() });
      req2.websiteData = websiteData;
      req2.isWebsiteRoute = true;
    } else {
      if (!isProduction3) {
        console.log(`\u26A0\uFE0F [WEBSITE-DETECTION] Aucun site trouv\xE9 pour: ${cleanDomain}`);
      }
      websiteCache.set(cacheKey, { data: null, timestamp: Date.now() });
      req2.isWebsiteRoute = false;
    }
    next();
  } catch (error) {
    console.error("\u274C [WEBSITE-DETECTION] Erreur:", error);
    req2.isWebsiteRoute = false;
    next();
  }
}
function websiteInterceptor(req2, res, next) {
  if (req2.url.startsWith("/api/") || req2.url.startsWith("/assets/") || req2.url.startsWith("/health")) {
    return next();
  }
  if (req2.isWebsiteRoute && req2.websiteData) {
    console.log(`\u{1F3A8} [WEBSITE-INTERCEPTOR] Interception pour site: ${req2.websiteData.name}`);
    return renderWebsite(req2, res);
  }
  next();
}

// src/security/securityMiddleware.ts
var import_express_rate_limit15 = __toESM(require("express-rate-limit"), 1);
var import_crypto24 = __toESM(require("crypto"), 1);
var isCodespaces = process.env.CODESPACES === "true" || typeof process.env.GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN === "string";
var isRateLimitEnabled = process.env.NODE_ENV === "production" && !isCodespaces;
var noopMiddleware = (_req, _res, next) => next();
var securityMonitoring = (req2, res, next) => {
  const startTime = Date.now();
  const requestId = import_crypto24.default.randomUUID();
  req2.requestId = requestId;
  const suspiciousPatterns = [
    /(\<script\>)/gi,
    // XSS basique
    /(union\s+select)/gi,
    // SQL injection
    /(\.\.\/)|(\.\.\\)/g,
    // Path traversal
    /(eval\(|function\s*\()/gi,
    // Code injection
    /(exec\(|system\()/gi
    // Command injection
  ];
  const userAgent = req2.headers["user-agent"] || "";
  const isSuspicious = suspiciousPatterns.some(
    (pattern) => pattern.test(req2.url) || pattern.test(JSON.stringify(req2.body || {})) || pattern.test(userAgent)
  );
  if (isSuspicious) {
    securityMetrics.suspiciousActivity++;
    logSecurityEvent("SUSPICIOUS_REQUEST", {
      requestId,
      ip: req2.ip,
      method: req2.method,
      url: req2.url,
      userAgent,
      body: req2.body,
      patterns: "detected"
    }, "warn");
  }
  res.on("finish", () => {
    const duration = Date.now() - startTime;
    securityMetrics.requestCount++;
    if (duration > 5e3) {
      logSecurityEvent("SLOW_REQUEST", {
        requestId,
        duration,
        method: req2.method,
        url: req2.url,
        ip: req2.ip
      }, "warn");
    }
  });
  next();
};
var timingAttackProtection = (req2, res, next) => {
  const randomDelay = Math.floor(Math.random() * 50);
  setTimeout(() => {
    next();
  }, randomDelay);
};
var authRateLimit = isRateLimitEnabled ? (0, import_express_rate_limit15.default)({
  windowMs: 15 * 60 * 1e3,
  max: 20,
  // 20 tentatives de login / registre / reset par IP / 15min
  standardHeaders: true,
  legacyHeaders: false,
  trustProxy: 1,
  // Sp√©cifique pour Cloud Run
  message: { error: "Trop de tentatives d'authentification, r\xE9essayez plus tard." },
  keyGenerator: (req2) => {
    const ipKey = (0, import_express_rate_limit15.ipKeyGenerator)(req2.ip ?? "");
    const identifier = req2.body && (req2.body.email || req2.body.username) || "anon";
    return `${ipKey}|${identifier}`;
  },
  handler: (req2, res) => {
    securityMetrics.blockedRequests++;
    logSecurityEvent("AUTH_RATE_LIMIT", { ip: req2.ip, url: req2.url, bodyKeys: Object.keys(req2.body || {}) }, "warn");
    res.status(429).json({ error: "Trop de tentatives", retryAfter: 900 });
  }
}) : noopMiddleware;
var advancedRateLimit = isRateLimitEnabled ? (0, import_express_rate_limit15.default)({
  windowMs: 15 * 60 * 1e3,
  trustProxy: 1,
  // Sp√©cifique pour Cloud Run
  max: (req2) => {
    const isDevEnv = process.env.NODE_ENV !== "production";
    const normalizeIp = (ip) => {
      if (!ip) return "";
      return ip.startsWith("::ffff:") ? ip.slice("::ffff:".length) : ip;
    };
    const isPrivateIp = (ip) => {
      if (ip === "127.0.0.1" || ip === "::1") return true;
      if (ip.startsWith("10.")) return true;
      if (ip.startsWith("192.168.")) return true;
      const m = ip.match(/^172\.(\d{1,3})\./);
      if (m) {
        const second = Number(m[1]);
        return second >= 16 && second <= 31;
      }
      return false;
    };
    if (req2.method === "OPTIONS") return 1e4;
    if (req2.path.startsWith("/assets/") || req2.path === "/manifest.webmanifest" || req2.path === "/registerSW.js" || req2.path === "/sw.js") return 1e4;
    const clientIp = normalizeIp(req2.ip);
    if (isDevEnv && isPrivateIp(clientIp)) {
      const envMax2 = Number(process.env.RATE_LIMIT_MAX_DEV || "20000");
      return Number.isFinite(envMax2) && envMax2 > 0 ? envMax2 : 2e4;
    }
    const cookieHeader = typeof req2.headers.cookie === "string" ? req2.headers.cookie : "";
    const hasSessionCookie = cookieHeader.includes("connect.sid=");
    const hasUserHeader = typeof req2.headers["x-user-id"] === "string" && req2.headers["x-user-id"].length > 0;
    const hasOrgHeader = typeof req2.headers["x-organization-id"] === "string" && req2.headers["x-organization-id"].length > 0;
    const hasAuth = hasSessionCookie || hasUserHeader || hasOrgHeader;
    if (hasAuth) {
      const envMax2 = Number(process.env.RATE_LIMIT_MAX_AUTH || "5000");
      return Number.isFinite(envMax2) && envMax2 > 0 ? envMax2 : 5e3;
    }
    const envMax = Number(process.env.RATE_LIMIT_MAX_ANON || "1000");
    return Number.isFinite(envMax) && envMax > 0 ? envMax : 1e3;
  },
  skip: (req2) => {
    return req2.method === "OPTIONS" || req2.path.startsWith("/assets/") || req2.path === "/manifest.webmanifest" || req2.path === "/registerSW.js" || req2.path === "/sw.js";
  },
  standardHeaders: true,
  legacyHeaders: false,
  message: { error: "Trop de requ\xEAtes, veuillez r\xE9essayer plus tard", retryAfter: "15 minutes" },
  handler: (req2, res) => {
    securityMetrics.blockedRequests++;
    logSecurityEvent("API_RATE_LIMIT", { ip: req2.ip, url: req2.url, method: req2.method }, "warn");
    res.status(429).json({ error: "Trop de requ\xEAtes", retryAfter: 900 });
  }
}) : noopMiddleware;
var requestHistory = /* @__PURE__ */ new Map();
var isDev = process.env.NODE_ENV !== "production";
var anomalyDetection = (req2, res, next) => {
  if (isDev) {
    return next();
  }
  const clientIP = req2.ip;
  const currentTime = Date.now();
  const endpoint = req2.path;
  if (!requestHistory.has(clientIP)) {
    requestHistory.set(clientIP, []);
  }
  const history = requestHistory.get(clientIP);
  const tenMinutesAgo = currentTime - 10 * 60 * 1e3;
  const recentHistory = history.filter((req3) => req3.timestamp > tenMinutesAgo);
  recentHistory.push({ timestamp: currentTime, endpoint });
  requestHistory.set(clientIP, recentHistory);
  const requestsInLastMinute = recentHistory.filter(
    (req3) => req3.timestamp > currentTime - 6e4
  ).length;
  const uniqueEndpoints = new Set(recentHistory.map((req3) => req3.endpoint)).size;
  const totalRequests = recentHistory.length;
  if (requestsInLastMinute > 200) {
    logSecurityEvent("ANOMALY_HIGH_FREQUENCY", {
      ip: clientIP,
      requestsPerMinute: requestsInLastMinute,
      userAgent: req2.headers["user-agent"]
    }, "warn");
  }
  if (uniqueEndpoints > 150 && totalRequests > 300) {
    const nonTblEndpoints = Array.from(new Set(recentHistory.map((r) => r.endpoint))).filter((ep) => !ep.includes("/treebranchleaf/") && !ep.includes("/tree-nodes/") && !ep.includes("/tbl/") && !ep.includes("/api/modules") && !ep.includes("/api/auth/") && !ep.includes("/assets/"));
    if (nonTblEndpoints.length > 50) {
      logSecurityEvent("ANOMALY_ENDPOINT_SCANNING", {
        ip: clientIP,
        uniqueEndpoints,
        totalRequests,
        suspiciousEndpoints: nonTblEndpoints.slice(0, 20)
        // Limiter la taille du log
      }, "warn");
    }
  }
  next();
};
var inputSanitization = (req2, res, next) => {
  const sanitizeObject = (obj) => {
    if (typeof obj !== "object" || obj === null) {
      if (typeof obj === "string") {
        return obj.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "").replace(/javascript:/gi, "").replace(/on\w+\s*=/gi, "").trim();
      }
      return obj;
    }
    if (Array.isArray(obj)) {
      return obj.map(sanitizeObject);
    }
    const sanitized2 = {};
    for (const [key2, value] of Object.entries(obj)) {
      sanitized2[key2] = sanitizeObject(value);
    }
    return sanitized2;
  };
  if (req2.body && typeof req2.body === "object") {
    try {
      req2.body = sanitizeObject(req2.body);
    } catch (e) {
      console.warn("Cannot sanitize req.body:", e);
    }
  }
  next();
};

// src/components/TreeBranchLeaf/treebranchleaf-new/api/sync-variable-hook.ts
init_database();
var prisma50 = db;
async function syncVariableSourceRefs() {
  try {
    const nodes = await prisma50.treeBranchLeafNode.findMany({
      where: {
        data_instances: { not: null }
      },
      include: {
        TreeBranchLeafNodeVariable: true
      }
    });
    let syncCount = 0;
    let skipCount = 0;
    for (const node of nodes) {
      if (!node.data_instances) continue;
      const dataInstances = node.data_instances;
      const firstInstanceKey = Object.keys(dataInstances)[0];
      if (!firstInstanceKey) continue;
      const firstInstance = dataInstances[firstInstanceKey];
      if (!firstInstance?.metadata?.sourceRef) continue;
      const jsonSourceRef = firstInstance.metadata.sourceRef;
      if (!node.TreeBranchLeafNodeVariable) {
        continue;
      }
      const dbSourceRef = node.TreeBranchLeafNodeVariable.sourceRef;
      if (dbSourceRef && (dbSourceRef.startsWith("@table.") || dbSourceRef.startsWith("@value."))) {
        if (jsonSourceRef.startsWith("node-formula:")) {
          skipCount++;
          continue;
        }
      }
      if (jsonSourceRef === dbSourceRef) {
        continue;
      }
      await prisma50.treeBranchLeafNodeVariable.update({
        where: { id: node.TreeBranchLeafNodeVariable.id },
        data: { sourceRef: jsonSourceRef }
      });
      syncCount++;
    }
    if (syncCount > 0) {
    }
    if (skipCount > 0) {
    }
    if (syncCount === 0 && skipCount === 0) {
    }
  } catch (error) {
    console.error("\xC3\xA2\xC2\x9D\xC5\u2019 [SYNC HOOK] Erreur:", error);
  }
}
async function initializeTreeBranchLeafSync() {
  try {
    await syncVariableSourceRefs();
  } catch (error) {
    console.error("\xC3\xA2\xC2\x9D\xC5\u2019 [INIT SYNC] Erreur:", error);
  } finally {
    await prisma50.$disconnect();
  }
}

// src/api-server-clean.ts
init_database();
import_dotenv.default.config();
console.log("\u{1F3AC} [BOOTSTRAP] api-server-clean.cjs loaded at", (/* @__PURE__ */ new Date()).toISOString());
console.log("\u{1F3AC} [BOOTSTRAP] PORT env:", process.env.PORT || "(not set, using 8080)");
console.log("\u{1F3AC} [BOOTSTRAP] NODE_ENV:", process.env.NODE_ENV || "development");
console.log("\u{1F680} [API-SERVER-CLEAN] D\xE9marrage du serveur CRM...");
logSecurityEvent("SERVER_STARTUP", {
  timestamp: (/* @__PURE__ */ new Date()).toISOString(),
  nodeVersion: process.version,
  environment: process.env.NODE_ENV || "development",
  securityLevel: "ENTERPRISE"
}, "info");
var app = (0, import_express97.default)();
app.set("trust proxy", 1);
var port = Number(process.env.PORT || 8080);
console.log("\u{1F3AF} [BOOTSTRAP] Server will listen on port:", port);
var BUILD_VERSION = process.env.BUILD_VERSION || "dev-local";
var GIT_SHA = process.env.GIT_SHA || "unknown";
app.use((req2, res, next) => {
  res.setHeader("X-App-Version", BUILD_VERSION);
  res.setHeader("X-Git-Sha", GIT_SHA);
  next();
});
var isDevelopment = process.env.NODE_ENV !== "production";
app.use(import_express_winston.default.logger({
  winstonInstance: securityLogger,
  meta: !isDevelopment,
  // Pas de meta en dev pour r√©duire la verbosit√©
  msg: "HTTP {{req.method}} {{req.url}} {{res.statusCode}} {{res.responseTime}}ms",
  expressFormat: false,
  colorize: false,
  requestWhitelist: ["method", "url", "ip"],
  responseWhitelist: ["statusCode"],
  skip: (req2, res) => {
    if (isDevelopment) {
      if (res.statusCode < 400) {
        const skipPatterns = [
          "/api/tree-nodes/",
          "/api/treebranchleaf/",
          "/api/tbl/",
          "/api/repeat/",
          "/api/health",
          "/health"
        ];
        if (skipPatterns.some((pattern) => req2.url.startsWith(pattern))) {
          return true;
        }
      }
    }
    return ["/api/health", "/health"].includes(req2.url) && res.statusCode < 400;
  }
}));
app.use(securityMonitoring);
app.use(timingAttackProtection);
app.use((0, import_helmet.default)({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "fonts.googleapis.com", "https:"],
      scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'", "maps.googleapis.com", "*.googleapis.com"],
      fontSrc: ["'self'", "fonts.gstatic.com", "data:"],
      imgSrc: ["'self'", "data:", "https:", "blob:", "maps.gstatic.com", "*.googleapis.com", "*.ggpht.com"],
      connectSrc: ["'self'", "https:", "wss:", "maps.googleapis.com", "*.googleapis.com"],
      frameSrc: ["'self'", "maps.google.com", "*.google.com"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      manifestSrc: ["'self'"],
      workerSrc: ["'self'", "blob:"]
    }
  },
  hsts: {
    maxAge: 31536e3,
    includeSubDomains: true,
    preload: true
  }
}));
app.use((0, import_compression.default)({
  level: 6,
  threshold: 1024,
  filter: (req2, res) => {
    if (req2.headers["x-no-compression"]) return false;
    return import_compression.default.filter(req2, res);
  }
}));
app.use(advancedRateLimit);
app.use(anomalyDetection);
var FRONTEND_URL = process.env.FRONTEND_URL;
var prodOrigins = [
  FRONTEND_URL || "https://app.2thier.be",
  "https://www.2thier.be",
  "https://crm.2thier.be",
  "http://localhost:4000",
  // Mode production local
  /\.run\.app$/,
  // Google Cloud Run
  /\.appspot\.com$/,
  // Google App Engine
  /^https:\/\/.*\.app\.github\.dev$/,
  // GitHub Codespaces (toutes URLs)
  /^https:\/\/.*-\d+\.app\.github\.dev$/
  // GitHub Codespaces avec port
];
var devOrigins = [
  FRONTEND_URL || "http://localhost:5173",
  "http://localhost:3000",
  "http://localhost:4000",
  // Mode production local
  /^https:\/\/.*\.app\.github\.dev$/,
  // GitHub Codespaces (toutes URLs)
  /^https:\/\/.*-\d+\.app\.github\.dev$/
  // GitHub Codespaces avec port
];
app.use((0, import_cors.default)({
  origin: (origin, callback) => {
    if (!origin) {
      return callback(null, true);
    }
    const allowedOrigins = process.env.NODE_ENV === "production" ? prodOrigins : devOrigins;
    const isAllowed = allowedOrigins.some((allowed) => {
      if (typeof allowed === "string") {
        return origin === allowed;
      }
      if (allowed instanceof RegExp) {
        return allowed.test(origin);
      }
      return false;
    });
    if (isAllowed) {
      callback(null, true);
    } else {
      console.warn(`\u{1F6AB} [CORS] Origin bloqu\xE9: ${origin}`);
      callback(null, false);
    }
  },
  credentials: true,
  methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization", "X-Requested-With", "x-organization-id"],
  exposedHeaders: ["X-Total-Count", "X-Rate-Limit-Remaining", "x-organization-id"]
}));
app.use(inputSanitization);
app.use(import_express97.default.json({
  limit: "50mb",
  verify: (req2, res, buf) => {
    try {
      JSON.parse(buf.toString());
    } catch (e) {
      logSecurityEvent("INVALID_JSON", {
        ip: req2.ip,
        userAgent: req2.headers["user-agent"],
        error: e.message
      }, "warn");
    }
  }
}));
app.use(import_express97.default.urlencoded({ extended: true, limit: "50mb" }));
app.use((0, import_cookie_parser.default)());
app.use((0, import_express_session.default)({
  secret: process.env.SESSION_SECRET || "crm-dev-secret-2024",
  resave: false,
  saveUninitialized: false,
  name: "CRM_SESSION_ID",
  cookie: {
    secure: process.env.NODE_ENV === "production",
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1e3,
    // 24 heures
    sameSite: process.env.NODE_ENV === "production" ? "none" : "lax",
    path: "/"
  },
  store: void 0
  // TODO: Ajouter un store persistant en production
}));
console.log("\u2705 [ENTERPRISE-SECURITY] Configuration s\xE9curit\xE9 niveau Enterprise activ\xE9e");
var uploadsDir = import_path8.default.resolve(process.cwd(), "public", "uploads");
app.use("/uploads", (req2, res, next) => {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "GET, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type");
  res.setHeader("Cross-Origin-Resource-Policy", "cross-origin");
  next();
}, import_express97.default.static(uploadsDir, {
  maxAge: "1h",
  // Cache 1 heure
  etag: true,
  lastModified: true
}));
console.log("\u{1F4F8} [UPLOADS] Dossier uploads configur\xE9 avec CORS:", uploadsDir);
console.log("\u{1F527} [API-SERVER-CLEAN] Configuration Passport...");
app.use(import_passport.default.initialize());
app.use(import_passport.default.session());
console.log("\u2705 [API-SERVER-CLEAN] Passport configur\xE9");
console.log("\u{1F527} [API-SERVER-CLEAN] Configuration des routes...");
app.use("/api/auth", authRateLimit);
app.use("/api", routes_default);
app.use("/api", websites_default);
app.use("/api", website_services_default);
app.use("/api", website_projects_default);
app.use("/api", website_testimonials_default);
app.use("/api", website_sections_default);
app.use("/api/website-themes", website_themes_default);
app.use("/api/ai-content", ai_content_default);
app.use("/api", cloud_run_domains_default);
app.use("/api/ai", ai_field_generator_default);
app.use("/api/ai", ai_default2);
app.use("/api", contact_form_default);
app.use("/api/image-upload", image_upload_default);
app.use("/api/documents", documents_default);
app.use("/api/measurement-reference", measurement_reference_default);
app.use("/api/tbl", tbl_routes_default);
app.use("/api/treebranchleaf", ia_config_routes_default);
app.use("/api/tbl", tbl_submission_evaluator_default);
app.use("/api/tbl/batch", tbl_batch_routes_default);
app.use("/api/batch", batch_routes_default);
app.use("/api/tree-nodes", calculatedValueController_default);
app.use("/api/user/favorites", userFavoritesRoutes_default);
app.use("/api/website-forms", website_forms_default);
app.use("/api/public/forms", public_forms_default);
var repeatRouter = createRepeatRouter(db);
app.use("/api/treebranchleaf/repeat", repeatRouter);
app.use("/api/repeat", repeatRouter);
console.log("\u2705 [API-SERVER-CLEAN] Routes configur\xE9es");
app.get("/health", (_req, res) => {
  res.json({
    status: "OK",
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  });
});
app.get("/api/health/db", async (_req, res) => {
  try {
    await db.$queryRaw`SELECT 1`;
    res.json({ db: "OK", timestamp: (/* @__PURE__ */ new Date()).toISOString() });
  } catch (e) {
    const message = e?.message || "Unknown error";
    res.status(503).json({ db: "DOWN", error: message, timestamp: (/* @__PURE__ */ new Date()).toISOString() });
  }
});
app.use(detectWebsite);
app.use(websiteInterceptor);
if (process.env.NODE_ENV === "production") {
  const distDir = import_path8.default.resolve(process.cwd(), "dist");
  const indexHtml = import_path8.default.join(distDir, "index.html");
  if (import_fs8.default.existsSync(indexHtml)) {
    console.log("\u{1F5C2}\uFE0F [STATIC] Distribution front d\xE9tect\xE9e, activation du serveur statique");
    const assetsDir = import_path8.default.join(distDir, "assets");
    app.use("/assets", import_express97.default.static(assetsDir, {
      setHeaders: (res) => {
        res.setHeader("Cache-Control", "public, max-age=31536000, immutable");
      }
    }));
    app.get(/^\/[^/]+\.(png|jpg|jpeg|gif|svg|ico|webp|js|css|woff|woff2|ttf|eot|json|webmanifest|html|txt|xml)$/i, (req2, res, next) => {
      const filePath = import_path8.default.join(distDir, req2.path);
      if (import_fs8.default.existsSync(filePath)) {
        const ext = import_path8.default.extname(req2.path).toLowerCase();
        const mimeTypes = {
          ".png": "image/png",
          ".jpg": "image/jpeg",
          ".jpeg": "image/jpeg",
          ".gif": "image/gif",
          ".svg": "image/svg+xml",
          ".ico": "image/x-icon",
          ".webp": "image/webp",
          ".js": "application/javascript",
          ".css": "text/css",
          ".woff": "font/woff",
          ".woff2": "font/woff2",
          ".ttf": "font/ttf",
          ".eot": "application/vnd.ms-fontobject",
          ".json": "application/json",
          ".webmanifest": "application/manifest+json",
          ".html": "text/html",
          ".txt": "text/plain",
          ".xml": "application/xml"
        };
        if (mimeTypes[ext]) {
          res.setHeader("Content-Type", mimeTypes[ext]);
        }
        res.setHeader("Cache-Control", "public, max-age=86400");
        console.log(`\u{1F4C1} [STATIC] Serving: ${req2.path}`);
        return res.sendFile(filePath);
      }
      next();
    });
    app.get(/^\/pwa-.*/, (req2, res) => {
      const filePath = import_path8.default.join(distDir, req2.path);
      if (import_fs8.default.existsSync(filePath)) {
        res.sendFile(filePath);
      } else {
        res.status(404).end();
      }
    });
    app.get("/favicon.ico", (req2, res) => res.sendFile(import_path8.default.join(distDir, "favicon.ico")));
    app.get("/manifest.json", (req2, res) => res.sendFile(import_path8.default.join(distDir, "manifest.json")));
    app.get("/manifest.webmanifest", (req2, res) => res.sendFile(import_path8.default.join(distDir, "manifest.webmanifest")));
    app.get("/registerSW.js", (req2, res) => {
      const swPath = import_path8.default.join(distDir, "registerSW.js");
      if (import_fs8.default.existsSync(swPath)) {
        res.setHeader("Content-Type", "application/javascript");
        res.sendFile(swPath);
      } else {
        res.status(404).end();
      }
    });
    app.get("/sw.js", (req2, res) => {
      const swPath = import_path8.default.join(distDir, "sw.js");
      if (import_fs8.default.existsSync(swPath)) {
        res.setHeader("Content-Type", "application/javascript");
        res.sendFile(swPath);
      } else {
        res.status(404).end();
      }
    });
    app.get(/^\/workbox-.*\.js$/, (req2, res) => {
      const filePath = import_path8.default.join(distDir, req2.path);
      if (import_fs8.default.existsSync(filePath)) {
        res.setHeader("Content-Type", "application/javascript");
        res.sendFile(filePath);
      } else {
        res.status(404).end();
      }
    });
    app.get("/env-config.js", (req2, res) => {
      const envPath = import_path8.default.join(distDir, "env-config.js");
      if (import_fs8.default.existsSync(envPath)) {
        res.setHeader("Content-Type", "application/javascript");
        res.sendFile(envPath);
      } else {
        res.status(404).end();
      }
    });
    app.get(/^(?!\/api\/|\/assets\/).*/, (req2, res, _next) => {
      if (req2.isWebsiteRoute === true && req2.websiteData) {
        console.log(`\u{1F3A8} [WEBSITE-RENDER] Rendu SSR pour: ${req2.websiteData.name} (${req2.hostname})`);
        return renderWebsite(req2, res);
      }
      console.log(`\u{1F4F1} [CRM-SPA] Serving React app for: ${req2.hostname}${req2.url}`);
      res.sendFile(indexHtml);
    });
  } else {
    console.warn("\u26A0\uFE0F [STATIC] Aucun build front trouv\xE9 (dist/index.html manquant)");
  }
}
app.use(import_express_winston.default.errorLogger({
  winstonInstance: securityLogger,
  meta: true,
  msg: "ERROR {{err.message}} {{req.method}} {{req.url}}",
  requestWhitelist: ["method", "url", "ip", "body"],
  blacklistedMetaFields: ["password", "token", "secret"]
}));
app.get("/api/root-info", (_req, res) => {
  res.json({
    status: "CRM API Server Online - ENTERPRISE SECURITY",
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    securityLevel: "100%",
    endpoints: {
      health: "/api/health",
      notifications: "/api/notifications",
      modules: "/api/modules/all",
      blocks: "/api/blocks",
      auth: "/api/auto-google-auth/connect"
    }
  });
});
app.get("/api/debug/static-status", (_req, res) => {
  const distDir = import_path8.default.resolve(process.cwd(), "dist");
  const indexHtml = import_path8.default.join(distDir, "index.html");
  res.json({
    env: process.env.NODE_ENV,
    distExists: import_fs8.default.existsSync(distDir),
    indexExists: import_fs8.default.existsSync(indexHtml),
    served: process.env.NODE_ENV === "production" && import_fs8.default.existsSync(indexHtml)
  });
});
var errorHandler = (err, req2, res, next) => {
  logSecurityEvent("SERVER_ERROR", {
    error: err.message,
    stack: err.stack,
    method: req2?.method || "UNKNOWN",
    url: req2?.url || "UNKNOWN",
    ip: req2?.ip || "UNKNOWN",
    userAgent: req2?.headers?.["user-agent"] || "UNKNOWN"
  }, "error");
  const errorResponse = process.env.NODE_ENV === "production" ? { error: "Une erreur interne s'est produite" } : { error: err.message, stack: err.stack };
  const status = typeof err.status === "number" ? err.status : 500;
  if (res.headersSent) {
    return next(err);
  }
  res.status(status).json(errorResponse);
};
app.use(errorHandler);
async function startServer() {
  try {
    console.log("\u{1F50C} [STARTUP] Connexion \xE0 la base de donn\xE9es...");
    await connectDatabase();
    console.log("\u2705 [STARTUP] Base de donn\xE9es connect\xE9e");
    const server = app.listen(port, "0.0.0.0", () => {
      logSecurityEvent("SERVER_READY", {
        port,
        securityLevel: "ENTERPRISE",
        features: [
          "Advanced Rate Limiting",
          "Anomaly Detection",
          "Input Sanitization",
          "Security Monitoring",
          "Comprehensive Logging",
          "Helmet Protection",
          "Timing Attack Protection"
        ]
      }, "info");
      console.log(`\u{1F389} [API-SERVER-CLEAN] Serveur CRM d\xE9marr\xE9 avec succ\xE8s sur http://0.0.0.0:${port}`);
      console.log(`\u{1F6E1}\uFE0F [ENTERPRISE-SECURITY] S\xE9curit\xE9 niveau 100% activ\xE9e`);
      if (process.env.NODE_ENV !== "production") {
        console.log("\u{1F504} [TREEBRANCHLEAF] Synchronisation des sourceRef...");
        initializeTreeBranchLeafSync().catch((err) => {
          console.error("\u26A0\uFE0F  [TREEBRANCHLEAF] Erreur lors de la synchronisation:", err);
        });
      } else {
        console.log("\u23ED\uFE0F [TREEBRANCHLEAF] Synchronisation d\xE9sactiv\xE9e en production (optimisation m\xE9moire)");
      }
      console.log(`\u{1F4CB} [API-SERVER-CLEAN] Endpoints disponibles:`);
      console.log(`   - Health: http://localhost:${port}/api/health`);
      console.log(`   - Auth Me: http://localhost:${port}/api/auth/me`);
      console.log(`   - Auth Login: http://localhost:${port}/api/auth/login`);
      console.log(`   - Notifications: http://localhost:${port}/api/notifications`);
      console.log(`   - Modules: http://localhost:${port}/api/modules/all`);
      console.log(`   - Blocks: http://localhost:${port}/api/blocks`);
      console.log(`   - Auto Google Auth (POST): http://localhost:${port}/api/auto-google-auth/connect`);
      console.log(`   - Auto Google Status (GET): http://localhost:${port}/api/auto-google-auth/status`);
    });
    return server;
  } catch (error) {
    console.error("\u274C [STARTUP] Erreur fatale au d\xE9marrage:", error);
    process.exit(1);
  }
}
startServer().catch((err) => {
  console.error("\u274C [FATAL] Impossible de d\xE9marrer le serveur:", err);
  process.exit(1);
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  app
});
//# sourceMappingURL=api-server-clean.cjs.map
